import process from 'node:process';globalThis._importMeta_={url:import.meta.url,env:process.env};import http$4, { Server as Server$3 } from 'node:http';
import https$2, { Server as Server$2 } from 'node:https';
import nodeCrypto, { createHash as createHash$4 } from 'node:crypto';
import * as require$$0$2$1 from 'stream';
import require$$0$2__default from 'stream';
import * as require$$0$3$1 from 'events';
import require$$0$3__default from 'events';
import * as require$$2$4 from 'http';
import require$$2__default from 'http';
import * as require$$1$7 from 'crypto';
import require$$1__default from 'crypto';
import * as require$$0$1$1 from 'buffer';
import require$$0$1__default from 'buffer';
import * as require$$0$8 from 'zlib';
import require$$0__default from 'zlib';
import * as require$$1$1$1 from 'https';
import require$$1$1__default from 'https';
import * as require$$3$4 from 'net';
import require$$3__default from 'net';
import * as require$$4$2 from 'tls';
import require$$4__default from 'tls';
import * as require$$7$3 from 'url';
import require$$7__default from 'url';
import { escapeHtml } from '@vue/shared';
import { mkdir, writeFile as writeFile$1 } from 'fs/promises';
import * as path$1 from 'path';
import { join as join$1 } from 'path';
import * as fs from 'fs';
import { existsSync as existsSync$1 } from 'fs';
import { createRenderer, getRequestDependencies, getPreloadLinks, getPrefetchLinks } from 'vue-bundle-renderer/runtime';
import { renderToString, ssrRenderTeleport, ssrRenderClass, ssrRenderVNode, ssrInterpolate, ssrRenderAttr, ssrRenderComponent, ssrRenderAttrs, ssrRenderSuspense, ssrRenderList, ssrIncludeBooleanAttr, ssrRenderStyle, ssrLooseContain, ssrLooseEqual, ssrRenderSlot } from 'vue/server-renderer';
import { createHead as createHead$1, propsToString, renderSSRHead } from 'unhead/server';
import { stringify as stringify$1, uneval } from 'devalue';
import { toValue, isRef, hasInjectionContext, inject, ref, watchEffect, getCurrentInstance, onBeforeUnmount, onDeactivated, onActivated, readonly, toRef, computed, defineComponent, createElementBlock, shallowRef, provide, cloneVNode, h as h$1, defineAsyncComponent, unref, shallowReactive, Suspense, Fragment, useSSRContext, createApp as createApp$1, watch as watch$1, createVNode, resolveDynamicComponent, withCtx, mergeProps, onErrorCaptured, onServerPrefetch, reactive, effectScope, isReadonly, isShallow, isReactive, toRaw, nextTick, getCurrentScope, markRaw, resolveComponent, createTextVNode, createBlock, createCommentVNode, openBlock, toDisplayString, withAsyncContext } from 'vue';
import { parseISO, formatDistanceToNow, isSameDay, format as format$4, startOfWeek, startOfMonth, addDays, endOfWeek, endOfMonth, eachDayOfInterval, isSameMonth, isToday } from 'date-fns';
import { th } from 'date-fns/locale';
import { walkResolver } from 'unhead/utils';
import { InformationCircleIcon, ExclamationTriangleIcon, ExclamationCircleIcon, NewspaperIcon, ChatBubbleLeftRightIcon, MegaphoneIcon, CalendarIcon, AcademicCapIcon, Cog6ToothIcon, EnvelopeIcon, CogIcon, ChartBarIcon, TagIcon, CurrencyDollarIcon, ClipboardDocumentCheckIcon, BookOpenIcon, BuildingOfficeIcon, ShieldCheckIcon, UserCircleIcon, UserIcon, UserGroupIcon, UsersIcon, HomeIcon } from '@heroicons/vue/24/outline';
import { useEditor, EditorContent } from '@tiptap/vue-3';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image';
import Link from '@tiptap/extension-link';
import TextAlign from '@tiptap/extension-text-align';
import { EventEmitter as EventEmitter$a } from 'node:events';
import { Buffer as Buffer$8 } from 'node:buffer';
import { promises, existsSync } from 'node:fs';
import { resolve as resolve$1, dirname as dirname$1, join } from 'node:path';
import * as querystring from 'querystring';
import * as timers from 'timers';
import * as util$5 from 'util';
import * as process$5 from 'process';
import * as string_decoder from 'string_decoder';
import { fileURLToPath } from 'node:url';
import { useRoute as useRoute$1, RouterView, createMemoryHistory, createRouter as createRouter$2, START_LOCATION } from 'vue-router';

nodeCrypto.webcrypto?.subtle || {};
const randomUUID = () => {
  return nodeCrypto.randomUUID();
};

const kNodeInspect = /* @__PURE__ */ Symbol.for(
  "nodejs.util.inspect.custom"
);
function toBufferLike(val) {
  if (val === void 0 || val === null) {
    return "";
  }
  const type = typeof val;
  if (type === "string") {
    return val;
  }
  if (type === "number" || type === "boolean" || type === "bigint") {
    return val.toString();
  }
  if (type === "function" || type === "symbol") {
    return "{}";
  }
  if (val instanceof Uint8Array || val instanceof ArrayBuffer) {
    return val;
  }
  if (isPlainObject$3(val)) {
    return JSON.stringify(val);
  }
  return val;
}
function isPlainObject$3(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

class Message {
  /** Access to the original [message event](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/message_event) if available. */
  event;
  /** Access to the Peer that emitted the message. */
  peer;
  /** Raw message data (can be of any type). */
  rawData;
  #id;
  #uint8Array;
  #arrayBuffer;
  #blob;
  #text;
  #json;
  constructor(rawData, peer, event) {
    this.rawData = rawData || "";
    this.peer = peer;
    this.event = event;
  }
  /**
   * Unique random [uuid v4](https://developer.mozilla.org/en-US/docs/Glossary/UUID) identifier for the message.
   */
  get id() {
    if (!this.#id) {
      this.#id = randomUUID();
    }
    return this.#id;
  }
  // --- data views ---
  /**
   * Get data as [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) value.
   *
   * If raw data is in any other format or string, it will be automatically converted and encoded.
   */
  uint8Array() {
    const _uint8Array = this.#uint8Array;
    if (_uint8Array) {
      return _uint8Array;
    }
    const rawData = this.rawData;
    if (rawData instanceof Uint8Array) {
      return this.#uint8Array = rawData;
    }
    if (rawData instanceof ArrayBuffer || rawData instanceof SharedArrayBuffer) {
      this.#arrayBuffer = rawData;
      return this.#uint8Array = new Uint8Array(rawData);
    }
    if (typeof rawData === "string") {
      this.#text = rawData;
      return this.#uint8Array = new TextEncoder().encode(this.#text);
    }
    if (Symbol.iterator in rawData) {
      return this.#uint8Array = new Uint8Array(rawData);
    }
    if (typeof rawData?.length === "number") {
      return this.#uint8Array = new Uint8Array(rawData);
    }
    if (rawData instanceof DataView) {
      return this.#uint8Array = new Uint8Array(
        rawData.buffer,
        rawData.byteOffset,
        rawData.byteLength
      );
    }
    throw new TypeError(
      `Unsupported message type: ${Object.prototype.toString.call(rawData)}`
    );
  }
  /**
   * Get data as [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) or [SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) value.
   *
   * If raw data is in any other format or string, it will be automatically converted and encoded.
   */
  arrayBuffer() {
    const _arrayBuffer = this.#arrayBuffer;
    if (_arrayBuffer) {
      return _arrayBuffer;
    }
    const rawData = this.rawData;
    if (rawData instanceof ArrayBuffer || rawData instanceof SharedArrayBuffer) {
      return this.#arrayBuffer = rawData;
    }
    return this.#arrayBuffer = this.uint8Array().buffer;
  }
  /**
   * Get data as [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) value.
   *
   * If raw data is in any other format or string, it will be automatically converted and encoded. */
  blob() {
    const _blob = this.#blob;
    if (_blob) {
      return _blob;
    }
    const rawData = this.rawData;
    if (rawData instanceof Blob) {
      return this.#blob = rawData;
    }
    return this.#blob = new Blob([this.uint8Array()]);
  }
  /**
   * Get stringified text version of the message.
   *
   * If raw data is in any other format, it will be automatically converted and decoded.
   */
  text() {
    const _text = this.#text;
    if (_text) {
      return _text;
    }
    const rawData = this.rawData;
    if (typeof rawData === "string") {
      return this.#text = rawData;
    }
    return this.#text = new TextDecoder().decode(this.uint8Array());
  }
  /**
   * Get parsed version of the message text with [`JSON.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse).
   */
  json() {
    const _json = this.#json;
    if (_json) {
      return _json;
    }
    return this.#json = JSON.parse(this.text());
  }
  /**
   * Message data (value varies based on `peer.websocket.binaryType`).
   */
  get data() {
    switch (this.peer?.websocket?.binaryType) {
      case "arraybuffer": {
        return this.arrayBuffer();
      }
      case "blob": {
        return this.blob();
      }
      case "nodebuffer": {
        return globalThis.Buffer ? Buffer.from(this.uint8Array()) : this.uint8Array();
      }
      case "uint8array": {
        return this.uint8Array();
      }
      case "text": {
        return this.text();
      }
      default: {
        return this.rawData;
      }
    }
  }
  // --- inspect ---
  toString() {
    return this.text();
  }
  [Symbol.toPrimitive]() {
    return this.text();
  }
  [kNodeInspect]() {
    return { data: this.rawData };
  }
}

class Peer {
  _internal;
  _topics;
  _id;
  #ws;
  constructor(internal) {
    this._topics = /* @__PURE__ */ new Set();
    this._internal = internal;
  }
  get context() {
    return this._internal.context ??= {};
  }
  /**
   * Unique random [uuid v4](https://developer.mozilla.org/en-US/docs/Glossary/UUID) identifier for the peer.
   */
  get id() {
    if (!this._id) {
      this._id = randomUUID();
    }
    return this._id;
  }
  /** IP address of the peer */
  get remoteAddress() {
    return void 0;
  }
  /** upgrade request */
  get request() {
    return this._internal.request;
  }
  /**
   * Get the [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) instance.
   *
   * **Note:** crossws adds polyfill for the following properties if native values are not available:
   * - `protocol`: Extracted from the `sec-websocket-protocol` header.
   * - `extensions`: Extracted from the `sec-websocket-extensions` header.
   * - `url`: Extracted from the request URL (http -> ws).
   * */
  get websocket() {
    if (!this.#ws) {
      const _ws = this._internal.ws;
      const _request = this._internal.request;
      this.#ws = _request ? createWsProxy(_ws, _request) : _ws;
    }
    return this.#ws;
  }
  /** All connected peers to the server */
  get peers() {
    return this._internal.peers || /* @__PURE__ */ new Set();
  }
  /** All topics, this peer has been subscribed to. */
  get topics() {
    return this._topics;
  }
  /** Abruptly close the connection */
  terminate() {
    this.close();
  }
  /** Subscribe to a topic */
  subscribe(topic) {
    this._topics.add(topic);
  }
  /** Unsubscribe from a topic */
  unsubscribe(topic) {
    this._topics.delete(topic);
  }
  // --- inspect ---
  toString() {
    return this.id;
  }
  [Symbol.toPrimitive]() {
    return this.id;
  }
  [Symbol.toStringTag]() {
    return "WebSocket";
  }
  [kNodeInspect]() {
    return Object.fromEntries(
      [
        ["id", this.id],
        ["remoteAddress", this.remoteAddress],
        ["peers", this.peers],
        ["webSocket", this.websocket]
      ].filter((p) => p[1])
    );
  }
}
function createWsProxy(ws, request) {
  return new Proxy(ws, {
    get: (target, prop) => {
      const value = Reflect.get(target, prop);
      if (!value) {
        switch (prop) {
          case "protocol": {
            return request?.headers?.get("sec-websocket-protocol") || "";
          }
          case "extensions": {
            return request?.headers?.get("sec-websocket-extensions") || "";
          }
          case "url": {
            return request?.url?.replace(/^http/, "ws") || void 0;
          }
        }
      }
      return value;
    }
  });
}

class AdapterHookable {
  options;
  constructor(options) {
    this.options = options || {};
  }
  callHook(name, arg1, arg2) {
    const globalHook = this.options.hooks?.[name];
    const globalPromise = globalHook?.(arg1, arg2);
    const resolveHooksPromise = this.options.resolve?.(arg1);
    if (!resolveHooksPromise) {
      return globalPromise;
    }
    const resolvePromise = resolveHooksPromise instanceof Promise ? resolveHooksPromise.then((hooks) => hooks?.[name]) : resolveHooksPromise?.[name];
    return Promise.all([globalPromise, resolvePromise]).then(
      ([globalRes, hook]) => {
        const hookResPromise = hook?.(arg1, arg2);
        return hookResPromise instanceof Promise ? hookResPromise.then((hookRes) => hookRes || globalRes) : hookResPromise || globalRes;
      }
    );
  }
  async upgrade(request) {
    let context = request.context;
    if (!context) {
      context = {};
      Object.defineProperty(request, "context", {
        enumerable: true,
        value: context
      });
    }
    try {
      const res = await this.callHook(
        "upgrade",
        request
      );
      if (!res) {
        return { context };
      }
      if (res.ok === false) {
        return { context, endResponse: res };
      }
      if (res.headers) {
        return {
          context,
          upgradeHeaders: res.headers
        };
      }
    } catch (error) {
      const errResponse = error.response || error;
      if (errResponse instanceof Response) {
        return {
          context,
          endResponse: errResponse
        };
      }
      throw error;
    }
    return { context };
  }
}

function adapterUtils(peers) {
  return {
    peers,
    publish(topic, message, options) {
      let firstPeerWithTopic;
      for (const peer of peers) {
        if (peer.topics.has(topic)) {
          firstPeerWithTopic = peer;
          break;
        }
      }
      if (firstPeerWithTopic) {
        firstPeerWithTopic.send(message, options);
        firstPeerWithTopic.publish(topic, message, options);
      }
    }
  };
}

class WSError extends Error {
  constructor(...args) {
    super(...args);
    this.name = "WSError";
  }
}

function getDefaultExportFromCjs$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var bufferUtil$4 = {exports: {}};

var constants$4;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants$4;
	hasRequiredConstants = 1;

	const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
	const hasBlob = typeof Blob !== 'undefined';

	if (hasBlob) BINARY_TYPES.push('blob');

	constants$4 = {
	  BINARY_TYPES,
	  EMPTY_BUFFER: Buffer.alloc(0),
	  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
	  hasBlob,
	  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
	  kListener: Symbol('kListener'),
	  kStatusCode: Symbol('status-code'),
	  kWebSocket: Symbol('websocket'),
	  NOOP: () => {}
	};
	return constants$4;
}

var hasRequiredBufferUtil;

function requireBufferUtil () {
	if (hasRequiredBufferUtil) return bufferUtil$4.exports;
	hasRequiredBufferUtil = 1;

	const { EMPTY_BUFFER } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];

	/**
	 * Merges an array of buffers into a new buffer.
	 *
	 * @param {Buffer[]} list The array of buffers to concat
	 * @param {Number} totalLength The total length of buffers in the list
	 * @return {Buffer} The resulting buffer
	 * @public
	 */
	function concat(list, totalLength) {
	  if (list.length === 0) return EMPTY_BUFFER;
	  if (list.length === 1) return list[0];

	  const target = Buffer.allocUnsafe(totalLength);
	  let offset = 0;

	  for (let i = 0; i < list.length; i++) {
	    const buf = list[i];
	    target.set(buf, offset);
	    offset += buf.length;
	  }

	  if (offset < totalLength) {
	    return new FastBuffer(target.buffer, target.byteOffset, offset);
	  }

	  return target;
	}

	/**
	 * Masks a buffer using the given mask.
	 *
	 * @param {Buffer} source The buffer to mask
	 * @param {Buffer} mask The mask to use
	 * @param {Buffer} output The buffer where to store the result
	 * @param {Number} offset The offset at which to start writing
	 * @param {Number} length The number of bytes to mask.
	 * @public
	 */
	function _mask(source, mask, output, offset, length) {
	  for (let i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	}

	/**
	 * Unmasks a buffer using the given mask.
	 *
	 * @param {Buffer} buffer The buffer to unmask
	 * @param {Buffer} mask The mask to use
	 * @public
	 */
	function _unmask(buffer, mask) {
	  for (let i = 0; i < buffer.length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	}

	/**
	 * Converts a buffer to an `ArrayBuffer`.
	 *
	 * @param {Buffer} buf The buffer to convert
	 * @return {ArrayBuffer} Converted buffer
	 * @public
	 */
	function toArrayBuffer(buf) {
	  if (buf.length === buf.buffer.byteLength) {
	    return buf.buffer;
	  }

	  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}

	/**
	 * Converts `data` to a `Buffer`.
	 *
	 * @param {*} data The data to convert
	 * @return {Buffer} The buffer
	 * @throws {TypeError}
	 * @public
	 */
	function toBuffer(data) {
	  toBuffer.readOnly = true;

	  if (Buffer.isBuffer(data)) return data;

	  let buf;

	  if (data instanceof ArrayBuffer) {
	    buf = new FastBuffer(data);
	  } else if (ArrayBuffer.isView(data)) {
	    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
	  } else {
	    buf = Buffer.from(data);
	    toBuffer.readOnly = false;
	  }

	  return buf;
	}

	bufferUtil$4.exports = {
	  concat,
	  mask: _mask,
	  toArrayBuffer,
	  toBuffer,
	  unmask: _unmask
	};

	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) {
	  try {
	    const bufferUtil$1 = require('bufferutil');

	    bufferUtil$4.exports.mask = function (source, mask, output, offset, length) {
	      if (length < 48) _mask(source, mask, output, offset, length);
	      else bufferUtil$1.mask(source, mask, output, offset, length);
	    };

	    bufferUtil$4.exports.unmask = function (buffer, mask) {
	      if (buffer.length < 32) _unmask(buffer, mask);
	      else bufferUtil$1.unmask(buffer, mask);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return bufferUtil$4.exports;
}

var limiter$2;
var hasRequiredLimiter;

function requireLimiter () {
	if (hasRequiredLimiter) return limiter$2;
	hasRequiredLimiter = 1;

	const kDone = Symbol('kDone');
	const kRun = Symbol('kRun');

	/**
	 * A very simple job queue with adjustable concurrency. Adapted from
	 * https://github.com/STRML/async-limiter
	 */
	class Limiter {
	  /**
	   * Creates a new `Limiter`.
	   *
	   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
	   *     to run concurrently
	   */
	  constructor(concurrency) {
	    this[kDone] = () => {
	      this.pending--;
	      this[kRun]();
	    };
	    this.concurrency = concurrency || Infinity;
	    this.jobs = [];
	    this.pending = 0;
	  }

	  /**
	   * Adds a job to the queue.
	   *
	   * @param {Function} job The job to run
	   * @public
	   */
	  add(job) {
	    this.jobs.push(job);
	    this[kRun]();
	  }

	  /**
	   * Removes a job from the queue and runs it if possible.
	   *
	   * @private
	   */
	  [kRun]() {
	    if (this.pending === this.concurrency) return;

	    if (this.jobs.length) {
	      const job = this.jobs.shift();

	      this.pending++;
	      job(this[kDone]);
	    }
	  }
	}

	limiter$2 = Limiter;
	return limiter$2;
}

var permessageDeflate$2;
var hasRequiredPermessageDeflate;

function requirePermessageDeflate () {
	if (hasRequiredPermessageDeflate) return permessageDeflate$2;
	hasRequiredPermessageDeflate = 1;

	const zlib = require$$0__default;

	const bufferUtil = requireBufferUtil();
	const Limiter = requireLimiter();
	const { kStatusCode } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
	const kPerMessageDeflate = Symbol('permessage-deflate');
	const kTotalLength = Symbol('total-length');
	const kCallback = Symbol('callback');
	const kBuffers = Symbol('buffers');
	const kError = Symbol('error');

	//
	// We limit zlib concurrency, which prevents severe memory fragmentation
	// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
	// and https://github.com/websockets/ws/issues/1202
	//
	// Intentionally global; it's the global thread pool that's an issue.
	//
	let zlibLimiter;

	/**
	 * permessage-deflate implementation.
	 */
	class PerMessageDeflate {
	  /**
	   * Creates a PerMessageDeflate instance.
	   *
	   * @param {Object} [options] Configuration options
	   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
	   *     for, or request, a custom client window size
	   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
	   *     acknowledge disabling of client context takeover
	   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
	   *     calls to zlib
	   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
	   *     use of a custom server window size
	   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
	   *     disabling of server context takeover
	   * @param {Number} [options.threshold=1024] Size (in bytes) below which
	   *     messages should not be compressed if context takeover is disabled
	   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
	   *     deflate
	   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
	   *     inflate
	   * @param {Boolean} [isServer=false] Create the instance in either server or
	   *     client mode
	   * @param {Number} [maxPayload=0] The maximum allowed message length
	   */
	  constructor(options, isServer, maxPayload) {
	    this._maxPayload = maxPayload | 0;
	    this._options = options || {};
	    this._threshold =
	      this._options.threshold !== undefined ? this._options.threshold : 1024;
	    this._isServer = !!isServer;
	    this._deflate = null;
	    this._inflate = null;

	    this.params = null;

	    if (!zlibLimiter) {
	      const concurrency =
	        this._options.concurrencyLimit !== undefined
	          ? this._options.concurrencyLimit
	          : 10;
	      zlibLimiter = new Limiter(concurrency);
	    }
	  }

	  /**
	   * @type {String}
	   */
	  static get extensionName() {
	    return 'permessage-deflate';
	  }

	  /**
	   * Create an extension negotiation offer.
	   *
	   * @return {Object} Extension parameters
	   * @public
	   */
	  offer() {
	    const params = {};

	    if (this._options.serverNoContextTakeover) {
	      params.server_no_context_takeover = true;
	    }
	    if (this._options.clientNoContextTakeover) {
	      params.client_no_context_takeover = true;
	    }
	    if (this._options.serverMaxWindowBits) {
	      params.server_max_window_bits = this._options.serverMaxWindowBits;
	    }
	    if (this._options.clientMaxWindowBits) {
	      params.client_max_window_bits = this._options.clientMaxWindowBits;
	    } else if (this._options.clientMaxWindowBits == null) {
	      params.client_max_window_bits = true;
	    }

	    return params;
	  }

	  /**
	   * Accept an extension negotiation offer/response.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Object} Accepted configuration
	   * @public
	   */
	  accept(configurations) {
	    configurations = this.normalizeParams(configurations);

	    this.params = this._isServer
	      ? this.acceptAsServer(configurations)
	      : this.acceptAsClient(configurations);

	    return this.params;
	  }

	  /**
	   * Releases all resources used by the extension.
	   *
	   * @public
	   */
	  cleanup() {
	    if (this._inflate) {
	      this._inflate.close();
	      this._inflate = null;
	    }

	    if (this._deflate) {
	      const callback = this._deflate[kCallback];

	      this._deflate.close();
	      this._deflate = null;

	      if (callback) {
	        callback(
	          new Error(
	            'The deflate stream was closed while data was being processed'
	          )
	        );
	      }
	    }
	  }

	  /**
	   *  Accept an extension negotiation offer.
	   *
	   * @param {Array} offers The extension negotiation offers
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsServer(offers) {
	    const opts = this._options;
	    const accepted = offers.find((params) => {
	      if (
	        (opts.serverNoContextTakeover === false &&
	          params.server_no_context_takeover) ||
	        (params.server_max_window_bits &&
	          (opts.serverMaxWindowBits === false ||
	            (typeof opts.serverMaxWindowBits === 'number' &&
	              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
	        (typeof opts.clientMaxWindowBits === 'number' &&
	          !params.client_max_window_bits)
	      ) {
	        return false;
	      }

	      return true;
	    });

	    if (!accepted) {
	      throw new Error('None of the extension offers can be accepted');
	    }

	    if (opts.serverNoContextTakeover) {
	      accepted.server_no_context_takeover = true;
	    }
	    if (opts.clientNoContextTakeover) {
	      accepted.client_no_context_takeover = true;
	    }
	    if (typeof opts.serverMaxWindowBits === 'number') {
	      accepted.server_max_window_bits = opts.serverMaxWindowBits;
	    }
	    if (typeof opts.clientMaxWindowBits === 'number') {
	      accepted.client_max_window_bits = opts.clientMaxWindowBits;
	    } else if (
	      accepted.client_max_window_bits === true ||
	      opts.clientMaxWindowBits === false
	    ) {
	      delete accepted.client_max_window_bits;
	    }

	    return accepted;
	  }

	  /**
	   * Accept the extension negotiation response.
	   *
	   * @param {Array} response The extension negotiation response
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsClient(response) {
	    const params = response[0];

	    if (
	      this._options.clientNoContextTakeover === false &&
	      params.client_no_context_takeover
	    ) {
	      throw new Error('Unexpected parameter "client_no_context_takeover"');
	    }

	    if (!params.client_max_window_bits) {
	      if (typeof this._options.clientMaxWindowBits === 'number') {
	        params.client_max_window_bits = this._options.clientMaxWindowBits;
	      }
	    } else if (
	      this._options.clientMaxWindowBits === false ||
	      (typeof this._options.clientMaxWindowBits === 'number' &&
	        params.client_max_window_bits > this._options.clientMaxWindowBits)
	    ) {
	      throw new Error(
	        'Unexpected or invalid parameter "client_max_window_bits"'
	      );
	    }

	    return params;
	  }

	  /**
	   * Normalize parameters.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Array} The offers/response with normalized parameters
	   * @private
	   */
	  normalizeParams(configurations) {
	    configurations.forEach((params) => {
	      Object.keys(params).forEach((key) => {
	        let value = params[key];

	        if (value.length > 1) {
	          throw new Error(`Parameter "${key}" must have only a single value`);
	        }

	        value = value[0];

	        if (key === 'client_max_window_bits') {
	          if (value !== true) {
	            const num = +value;
	            if (!Number.isInteger(num) || num < 8 || num > 15) {
	              throw new TypeError(
	                `Invalid value for parameter "${key}": ${value}`
	              );
	            }
	            value = num;
	          } else if (!this._isServer) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else if (key === 'server_max_window_bits') {
	          const num = +value;
	          if (!Number.isInteger(num) || num < 8 || num > 15) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	          value = num;
	        } else if (
	          key === 'client_no_context_takeover' ||
	          key === 'server_no_context_takeover'
	        ) {
	          if (value !== true) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else {
	          throw new Error(`Unknown parameter "${key}"`);
	        }

	        params[key] = value;
	      });
	    });

	    return configurations;
	  }

	  /**
	   * Decompress data. Concurrency limited.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  decompress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._decompress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Compress data. Concurrency limited.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  compress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._compress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Decompress data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _decompress(data, fin, callback) {
	    const endpoint = this._isServer ? 'client' : 'server';

	    if (!this._inflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._inflate = zlib.createInflateRaw({
	        ...this._options.zlibInflateOptions,
	        windowBits
	      });
	      this._inflate[kPerMessageDeflate] = this;
	      this._inflate[kTotalLength] = 0;
	      this._inflate[kBuffers] = [];
	      this._inflate.on('error', inflateOnError);
	      this._inflate.on('data', inflateOnData);
	    }

	    this._inflate[kCallback] = callback;

	    this._inflate.write(data);
	    if (fin) this._inflate.write(TRAILER);

	    this._inflate.flush(() => {
	      const err = this._inflate[kError];

	      if (err) {
	        this._inflate.close();
	        this._inflate = null;
	        callback(err);
	        return;
	      }

	      const data = bufferUtil.concat(
	        this._inflate[kBuffers],
	        this._inflate[kTotalLength]
	      );

	      if (this._inflate._readableState.endEmitted) {
	        this._inflate.close();
	        this._inflate = null;
	      } else {
	        this._inflate[kTotalLength] = 0;
	        this._inflate[kBuffers] = [];

	        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	          this._inflate.reset();
	        }
	      }

	      callback(null, data);
	    });
	  }

	  /**
	   * Compress data.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _compress(data, fin, callback) {
	    const endpoint = this._isServer ? 'server' : 'client';

	    if (!this._deflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._deflate = zlib.createDeflateRaw({
	        ...this._options.zlibDeflateOptions,
	        windowBits
	      });

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      this._deflate.on('data', deflateOnData);
	    }

	    this._deflate[kCallback] = callback;

	    this._deflate.write(data);
	    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
	      if (!this._deflate) {
	        //
	        // The deflate stream was closed while data was being processed.
	        //
	        return;
	      }

	      let data = bufferUtil.concat(
	        this._deflate[kBuffers],
	        this._deflate[kTotalLength]
	      );

	      if (fin) {
	        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
	      }

	      //
	      // Ensure that the callback will not be called again in
	      // `PerMessageDeflate#cleanup()`.
	      //
	      this._deflate[kCallback] = null;

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	        this._deflate.reset();
	      }

	      callback(null, data);
	    });
	  }
	}

	permessageDeflate$2 = PerMessageDeflate;

	/**
	 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function deflateOnData(chunk) {
	  this[kBuffers].push(chunk);
	  this[kTotalLength] += chunk.length;
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function inflateOnData(chunk) {
	  this[kTotalLength] += chunk.length;

	  if (
	    this[kPerMessageDeflate]._maxPayload < 1 ||
	    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
	  ) {
	    this[kBuffers].push(chunk);
	    return;
	  }

	  this[kError] = new RangeError('Max payload size exceeded');
	  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
	  this[kError][kStatusCode] = 1009;
	  this.removeListener('data', inflateOnData);

	  //
	  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the
	  // fact that in Node.js versions prior to 13.10.0, the callback for
	  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing
	  // `zlib.reset()` ensures that either the callback is invoked or an error is
	  // emitted.
	  //
	  this.reset();
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'error'` event.
	 *
	 * @param {Error} err The emitted error
	 * @private
	 */
	function inflateOnError(err) {
	  //
	  // There is no need to call `Zlib#close()` as the handle is automatically
	  // closed when an error is emitted.
	  //
	  this[kPerMessageDeflate]._inflate = null;

	  if (this[kError]) {
	    this[kCallback](this[kError]);
	    return;
	  }

	  err[kStatusCode] = 1007;
	  this[kCallback](err);
	}
	return permessageDeflate$2;
}

var validation$2 = {exports: {}};

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation$2.exports;
	hasRequiredValidation = 1;

	const { isUtf8 } = require$$0$1__default;

	const { hasBlob } = requireConstants();

	//
	// Allowed token characters:
	//
	// '!', '#', '$', '%', '&', ''', '*', '+', '-',
	// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
	//
	// tokenChars[32] === 0 // ' '
	// tokenChars[33] === 1 // '!'
	// tokenChars[34] === 0 // '"'
	// ...
	//
	// prettier-ignore
	const tokenChars = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
	];

	/**
	 * Checks if a status code is allowed in a close frame.
	 *
	 * @param {Number} code The status code
	 * @return {Boolean} `true` if the status code is valid, else `false`
	 * @public
	 */
	function isValidStatusCode(code) {
	  return (
	    (code >= 1000 &&
	      code <= 1014 &&
	      code !== 1004 &&
	      code !== 1005 &&
	      code !== 1006) ||
	    (code >= 3000 && code <= 4999)
	  );
	}

	/**
	 * Checks if a given buffer contains only correct UTF-8.
	 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	 * Markus Kuhn.
	 *
	 * @param {Buffer} buf The buffer to check
	 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	 * @public
	 */
	function _isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;

	  while (i < len) {
	    if ((buf[i] & 0x80) === 0) {
	      // 0xxxxxxx
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {
	      // 110xxxxx 10xxxxxx
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0 // Overlong
	      ) {
	        return false;
	      }

	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {
	      // 1110xxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
	        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
	      ) {
	        return false;
	      }

	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {
	      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
	        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
	        buf[i] > 0xf4 // > U+10FFFF
	      ) {
	        return false;
	      }

	      i += 4;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Determines whether a value is a `Blob`.
	 *
	 * @param {*} value The value to be tested
	 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
	 * @private
	 */
	function isBlob(value) {
	  return (
	    hasBlob &&
	    typeof value === 'object' &&
	    typeof value.arrayBuffer === 'function' &&
	    typeof value.type === 'string' &&
	    typeof value.stream === 'function' &&
	    (value[Symbol.toStringTag] === 'Blob' ||
	      value[Symbol.toStringTag] === 'File')
	  );
	}

	validation$2.exports = {
	  isBlob,
	  isValidStatusCode,
	  isValidUTF8: _isValidUTF8,
	  tokenChars
	};

	if (isUtf8) {
	  validation$2.exports.isValidUTF8 = function (buf) {
	    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	  };
	} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
	  try {
	    const isValidUTF8 = require('utf-8-validate');

	    validation$2.exports.isValidUTF8 = function (buf) {
	      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return validation$2.exports;
}

var receiver$2;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver$2;
	hasRequiredReceiver = 1;

	const { Writable } = require$$0$2__default;

	const PerMessageDeflate = requirePermessageDeflate();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  kStatusCode,
	  kWebSocket
	} = requireConstants();
	const { concat, toArrayBuffer, unmask } = requireBufferUtil();
	const { isValidStatusCode, isValidUTF8 } = requireValidation();

	const FastBuffer = Buffer[Symbol.species];

	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;

	/**
	 * HyBi Receiver implementation.
	 *
	 * @extends Writable
	 */
	class Receiver extends Writable {
	  /**
	   * Creates a Receiver instance.
	   *
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {String} [options.binaryType=nodebuffer] The type for binary data
	   * @param {Object} [options.extensions] An object containing the negotiated
	   *     extensions
	   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
	   *     client or server mode
	   * @param {Number} [options.maxPayload=0] The maximum allowed message length
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   */
	  constructor(options = {}) {
	    super();

	    this._allowSynchronousEvents =
	      options.allowSynchronousEvents !== undefined
	        ? options.allowSynchronousEvents
	        : true;
	    this._binaryType = options.binaryType || BINARY_TYPES[0];
	    this._extensions = options.extensions || {};
	    this._isServer = !!options.isServer;
	    this._maxPayload = options.maxPayload | 0;
	    this._skipUTF8Validation = !!options.skipUTF8Validation;
	    this[kWebSocket] = undefined;

	    this._bufferedBytes = 0;
	    this._buffers = [];

	    this._compressed = false;
	    this._payloadLength = 0;
	    this._mask = undefined;
	    this._fragmented = 0;
	    this._masked = false;
	    this._fin = false;
	    this._opcode = 0;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragments = [];

	    this._errored = false;
	    this._loop = false;
	    this._state = GET_INFO;
	  }

	  /**
	   * Implements `Writable.prototype._write()`.
	   *
	   * @param {Buffer} chunk The chunk of data to write
	   * @param {String} encoding The character encoding of `chunk`
	   * @param {Function} cb Callback
	   * @private
	   */
	  _write(chunk, encoding, cb) {
	    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

	    this._bufferedBytes += chunk.length;
	    this._buffers.push(chunk);
	    this.startLoop(cb);
	  }

	  /**
	   * Consumes `n` bytes from the buffered data.
	   *
	   * @param {Number} n The number of bytes to consume
	   * @return {Buffer} The consumed bytes
	   * @private
	   */
	  consume(n) {
	    this._bufferedBytes -= n;

	    if (n === this._buffers[0].length) return this._buffers.shift();

	    if (n < this._buffers[0].length) {
	      const buf = this._buffers[0];
	      this._buffers[0] = new FastBuffer(
	        buf.buffer,
	        buf.byteOffset + n,
	        buf.length - n
	      );

	      return new FastBuffer(buf.buffer, buf.byteOffset, n);
	    }

	    const dst = Buffer.allocUnsafe(n);

	    do {
	      const buf = this._buffers[0];
	      const offset = dst.length - n;

	      if (n >= buf.length) {
	        dst.set(this._buffers.shift(), offset);
	      } else {
	        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
	        this._buffers[0] = new FastBuffer(
	          buf.buffer,
	          buf.byteOffset + n,
	          buf.length - n
	        );
	      }

	      n -= buf.length;
	    } while (n > 0);

	    return dst;
	  }

	  /**
	   * Starts the parsing loop.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  startLoop(cb) {
	    this._loop = true;

	    do {
	      switch (this._state) {
	        case GET_INFO:
	          this.getInfo(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_16:
	          this.getPayloadLength16(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_64:
	          this.getPayloadLength64(cb);
	          break;
	        case GET_MASK:
	          this.getMask();
	          break;
	        case GET_DATA:
	          this.getData(cb);
	          break;
	        case INFLATING:
	        case DEFER_EVENT:
	          this._loop = false;
	          return;
	      }
	    } while (this._loop);

	    if (!this._errored) cb();
	  }

	  /**
	   * Reads the first two bytes of a frame.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getInfo(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(2);

	    if ((buf[0] & 0x30) !== 0x00) {
	      const error = this.createError(
	        RangeError,
	        'RSV2 and RSV3 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_2_3'
	      );

	      cb(error);
	      return;
	    }

	    const compressed = (buf[0] & 0x40) === 0x40;

	    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
	      const error = this.createError(
	        RangeError,
	        'RSV1 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_1'
	      );

	      cb(error);
	      return;
	    }

	    this._fin = (buf[0] & 0x80) === 0x80;
	    this._opcode = buf[0] & 0x0f;
	    this._payloadLength = buf[1] & 0x7f;

	    if (this._opcode === 0x00) {
	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (!this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          'invalid opcode 0',
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._opcode = this._fragmented;
	    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
	      if (this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          `invalid opcode ${this._opcode}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._compressed = compressed;
	    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
	      if (!this._fin) {
	        const error = this.createError(
	          RangeError,
	          'FIN must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_FIN'
	        );

	        cb(error);
	        return;
	      }

	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (
	        this._payloadLength > 0x7d ||
	        (this._opcode === 0x08 && this._payloadLength === 1)
	      ) {
	        const error = this.createError(
	          RangeError,
	          `invalid payload length ${this._payloadLength}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    } else {
	      const error = this.createError(
	        RangeError,
	        `invalid opcode ${this._opcode}`,
	        true,
	        1002,
	        'WS_ERR_INVALID_OPCODE'
	      );

	      cb(error);
	      return;
	    }

	    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
	    this._masked = (buf[1] & 0x80) === 0x80;

	    if (this._isServer) {
	      if (!this._masked) {
	        const error = this.createError(
	          RangeError,
	          'MASK must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_MASK'
	        );

	        cb(error);
	        return;
	      }
	    } else if (this._masked) {
	      const error = this.createError(
	        RangeError,
	        'MASK must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_MASK'
	      );

	      cb(error);
	      return;
	    }

	    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
	    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
	    else this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+16).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength16(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    this._payloadLength = this.consume(2).readUInt16BE(0);
	    this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+64).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength64(cb) {
	    if (this._bufferedBytes < 8) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(8);
	    const num = buf.readUInt32BE(0);

	    //
	    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
	    // if payload length is greater than this number.
	    //
	    if (num > Math.pow(2, 53 - 32) - 1) {
	      const error = this.createError(
	        RangeError,
	        'Unsupported WebSocket frame: payload length > 2^53 - 1',
	        false,
	        1009,
	        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
	      );

	      cb(error);
	      return;
	    }

	    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
	    this.haveLength(cb);
	  }

	  /**
	   * Payload length has been read.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  haveLength(cb) {
	    if (this._payloadLength && this._opcode < 0x08) {
	      this._totalPayloadLength += this._payloadLength;
	      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
	        const error = this.createError(
	          RangeError,
	          'Max payload size exceeded',
	          false,
	          1009,
	          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    }

	    if (this._masked) this._state = GET_MASK;
	    else this._state = GET_DATA;
	  }

	  /**
	   * Reads mask bytes.
	   *
	   * @private
	   */
	  getMask() {
	    if (this._bufferedBytes < 4) {
	      this._loop = false;
	      return;
	    }

	    this._mask = this.consume(4);
	    this._state = GET_DATA;
	  }

	  /**
	   * Reads data bytes.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getData(cb) {
	    let data = EMPTY_BUFFER;

	    if (this._payloadLength) {
	      if (this._bufferedBytes < this._payloadLength) {
	        this._loop = false;
	        return;
	      }

	      data = this.consume(this._payloadLength);

	      if (
	        this._masked &&
	        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
	      ) {
	        unmask(data, this._mask);
	      }
	    }

	    if (this._opcode > 0x07) {
	      this.controlMessage(data, cb);
	      return;
	    }

	    if (this._compressed) {
	      this._state = INFLATING;
	      this.decompress(data, cb);
	      return;
	    }

	    if (data.length) {
	      //
	      // This message is not compressed so its length is the sum of the payload
	      // length of all fragments.
	      //
	      this._messageLength = this._totalPayloadLength;
	      this._fragments.push(data);
	    }

	    this.dataMessage(cb);
	  }

	  /**
	   * Decompresses data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Function} cb Callback
	   * @private
	   */
	  decompress(data, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
	      if (err) return cb(err);

	      if (buf.length) {
	        this._messageLength += buf.length;
	        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
	          const error = this.createError(
	            RangeError,
	            'Max payload size exceeded',
	            false,
	            1009,
	            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	          );

	          cb(error);
	          return;
	        }

	        this._fragments.push(buf);
	      }

	      this.dataMessage(cb);
	      if (this._state === GET_INFO) this.startLoop(cb);
	    });
	  }

	  /**
	   * Handles a data message.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  dataMessage(cb) {
	    if (!this._fin) {
	      this._state = GET_INFO;
	      return;
	    }

	    const messageLength = this._messageLength;
	    const fragments = this._fragments;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragmented = 0;
	    this._fragments = [];

	    if (this._opcode === 2) {
	      let data;

	      if (this._binaryType === 'nodebuffer') {
	        data = concat(fragments, messageLength);
	      } else if (this._binaryType === 'arraybuffer') {
	        data = toArrayBuffer(concat(fragments, messageLength));
	      } else if (this._binaryType === 'blob') {
	        data = new Blob(fragments);
	      } else {
	        data = fragments;
	      }

	      if (this._allowSynchronousEvents) {
	        this.emit('message', data, true);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', data, true);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    } else {
	      const buf = concat(fragments, messageLength);

	      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	        const error = this.createError(
	          Error,
	          'invalid UTF-8 sequence',
	          true,
	          1007,
	          'WS_ERR_INVALID_UTF8'
	        );

	        cb(error);
	        return;
	      }

	      if (this._state === INFLATING || this._allowSynchronousEvents) {
	        this.emit('message', buf, false);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', buf, false);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    }
	  }

	  /**
	   * Handles a control message.
	   *
	   * @param {Buffer} data Data to handle
	   * @return {(Error|RangeError|undefined)} A possible error
	   * @private
	   */
	  controlMessage(data, cb) {
	    if (this._opcode === 0x08) {
	      if (data.length === 0) {
	        this._loop = false;
	        this.emit('conclude', 1005, EMPTY_BUFFER);
	        this.end();
	      } else {
	        const code = data.readUInt16BE(0);

	        if (!isValidStatusCode(code)) {
	          const error = this.createError(
	            RangeError,
	            `invalid status code ${code}`,
	            true,
	            1002,
	            'WS_ERR_INVALID_CLOSE_CODE'
	          );

	          cb(error);
	          return;
	        }

	        const buf = new FastBuffer(
	          data.buffer,
	          data.byteOffset + 2,
	          data.length - 2
	        );

	        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	          const error = this.createError(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );

	          cb(error);
	          return;
	        }

	        this._loop = false;
	        this.emit('conclude', code, buf);
	        this.end();
	      }

	      this._state = GET_INFO;
	      return;
	    }

	    if (this._allowSynchronousEvents) {
	      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	      this._state = GET_INFO;
	    } else {
	      this._state = DEFER_EVENT;
	      setImmediate(() => {
	        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	        this._state = GET_INFO;
	        this.startLoop(cb);
	      });
	    }
	  }

	  /**
	   * Builds an error object.
	   *
	   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
	   * @param {String} message The error message
	   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
	   *     `message`
	   * @param {Number} statusCode The status code
	   * @param {String} errorCode The exposed error code
	   * @return {(Error|RangeError)} The error
	   * @private
	   */
	  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
	    this._loop = false;
	    this._errored = true;

	    const err = new ErrorCtor(
	      prefix ? `Invalid WebSocket frame: ${message}` : message
	    );

	    Error.captureStackTrace(err, this.createError);
	    err.code = errorCode;
	    err[kStatusCode] = statusCode;
	    return err;
	  }
	}

	receiver$2 = Receiver;
	return receiver$2;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

var sender$2;
var hasRequiredSender;

function requireSender () {
	if (hasRequiredSender) return sender$2;
	hasRequiredSender = 1;

	const { Duplex } = require$$0$2__default;
	const { randomFillSync } = require$$1__default;

	const PerMessageDeflate = requirePermessageDeflate();
	const { EMPTY_BUFFER, kWebSocket, NOOP } = requireConstants();
	const { isBlob, isValidStatusCode } = requireValidation();
	const { mask: applyMask, toBuffer } = requireBufferUtil();

	const kByteLength = Symbol('kByteLength');
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;

	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;

	/**
	 * HyBi Sender implementation.
	 */
	class Sender {
	  /**
	   * Creates a Sender instance.
	   *
	   * @param {Duplex} socket The connection socket
	   * @param {Object} [extensions] An object containing the negotiated extensions
	   * @param {Function} [generateMask] The function used to generate the masking
	   *     key
	   */
	  constructor(socket, extensions, generateMask) {
	    this._extensions = extensions || {};

	    if (generateMask) {
	      this._generateMask = generateMask;
	      this._maskBuffer = Buffer.alloc(4);
	    }

	    this._socket = socket;

	    this._firstFragment = true;
	    this._compress = false;

	    this._bufferedBytes = 0;
	    this._queue = [];
	    this._state = DEFAULT;
	    this.onerror = NOOP;
	    this[kWebSocket] = undefined;
	  }

	  /**
	   * Frames a piece of data according to the HyBi WebSocket protocol.
	   *
	   * @param {(Buffer|String)} data The data to frame
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @return {(Buffer|String)[]} The framed data
	   * @public
	   */
	  static frame(data, options) {
	    let mask;
	    let merge = false;
	    let offset = 2;
	    let skipMasking = false;

	    if (options.mask) {
	      mask = options.maskBuffer || maskBuffer;

	      if (options.generateMask) {
	        options.generateMask(mask);
	      } else {
	        if (randomPoolPointer === RANDOM_POOL_SIZE) {
	          /* istanbul ignore else  */
	          if (randomPool === undefined) {
	            //
	            // This is lazily initialized because server-sent frames must not
	            // be masked so it may never be used.
	            //
	            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
	          }

	          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
	          randomPoolPointer = 0;
	        }

	        mask[0] = randomPool[randomPoolPointer++];
	        mask[1] = randomPool[randomPoolPointer++];
	        mask[2] = randomPool[randomPoolPointer++];
	        mask[3] = randomPool[randomPoolPointer++];
	      }

	      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
	      offset = 6;
	    }

	    let dataLength;

	    if (typeof data === 'string') {
	      if (
	        (!options.mask || skipMasking) &&
	        options[kByteLength] !== undefined
	      ) {
	        dataLength = options[kByteLength];
	      } else {
	        data = Buffer.from(data);
	        dataLength = data.length;
	      }
	    } else {
	      dataLength = data.length;
	      merge = options.mask && options.readOnly && !skipMasking;
	    }

	    let payloadLength = dataLength;

	    if (dataLength >= 65536) {
	      offset += 8;
	      payloadLength = 127;
	    } else if (dataLength > 125) {
	      offset += 2;
	      payloadLength = 126;
	    }

	    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

	    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
	    if (options.rsv1) target[0] |= 0x40;

	    target[1] = payloadLength;

	    if (payloadLength === 126) {
	      target.writeUInt16BE(dataLength, 2);
	    } else if (payloadLength === 127) {
	      target[2] = target[3] = 0;
	      target.writeUIntBE(dataLength, 4, 6);
	    }

	    if (!options.mask) return [target, data];

	    target[1] |= 0x80;
	    target[offset - 4] = mask[0];
	    target[offset - 3] = mask[1];
	    target[offset - 2] = mask[2];
	    target[offset - 1] = mask[3];

	    if (skipMasking) return [target, data];

	    if (merge) {
	      applyMask(data, mask, target, offset, dataLength);
	      return [target];
	    }

	    applyMask(data, mask, data, 0, dataLength);
	    return [target, data];
	  }

	  /**
	   * Sends a close message to the other peer.
	   *
	   * @param {Number} [code] The status code component of the body
	   * @param {(String|Buffer)} [data] The message component of the body
	   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  close(code, data, mask, cb) {
	    let buf;

	    if (code === undefined) {
	      buf = EMPTY_BUFFER;
	    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
	      throw new TypeError('First argument must be a valid error code number');
	    } else if (data === undefined || !data.length) {
	      buf = Buffer.allocUnsafe(2);
	      buf.writeUInt16BE(code, 0);
	    } else {
	      const length = Buffer.byteLength(data);

	      if (length > 123) {
	        throw new RangeError('The message must not be greater than 123 bytes');
	      }

	      buf = Buffer.allocUnsafe(2 + length);
	      buf.writeUInt16BE(code, 0);

	      if (typeof data === 'string') {
	        buf.write(data, 2);
	      } else {
	        buf.set(data, 2);
	      }
	    }

	    const options = {
	      [kByteLength]: buf.length,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x08,
	      readOnly: false,
	      rsv1: false
	    };

	    if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, buf, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(buf, options), cb);
	    }
	  }

	  /**
	   * Sends a ping message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  ping(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x09,
	      readOnly,
	      rsv1: false
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, false, options, cb]);
	      } else {
	        this.getBlobData(data, false, options, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a pong message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  pong(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x0a,
	      readOnly,
	      rsv1: false
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, false, options, cb]);
	      } else {
	        this.getBlobData(data, false, options, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a data message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Object} options Options object
	   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
	   *     or text
	   * @param {Boolean} [options.compress=false] Specifies whether or not to
	   *     compress `data`
	   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  send(data, options, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    let opcode = options.binary ? 2 : 1;
	    let rsv1 = options.compress;

	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (this._firstFragment) {
	      this._firstFragment = false;
	      if (
	        rsv1 &&
	        perMessageDeflate &&
	        perMessageDeflate.params[
	          perMessageDeflate._isServer
	            ? 'server_no_context_takeover'
	            : 'client_no_context_takeover'
	        ]
	      ) {
	        rsv1 = byteLength >= perMessageDeflate._threshold;
	      }
	      this._compress = rsv1;
	    } else {
	      rsv1 = false;
	      opcode = 0;
	    }

	    if (options.fin) this._firstFragment = true;

	    const opts = {
	      [kByteLength]: byteLength,
	      fin: options.fin,
	      generateMask: this._generateMask,
	      mask: options.mask,
	      maskBuffer: this._maskBuffer,
	      opcode,
	      readOnly,
	      rsv1
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
	      } else {
	        this.getBlobData(data, this._compress, opts, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
	    } else {
	      this.dispatch(data, this._compress, opts, cb);
	    }
	  }

	  /**
	   * Gets the contents of a blob as binary data.
	   *
	   * @param {Blob} blob The blob
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     the data
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  getBlobData(blob, compress, options, cb) {
	    this._bufferedBytes += options[kByteLength];
	    this._state = GET_BLOB_DATA;

	    blob
	      .arrayBuffer()
	      .then((arrayBuffer) => {
	        if (this._socket.destroyed) {
	          const err = new Error(
	            'The socket was closed while the blob was being read'
	          );

	          //
	          // `callCallbacks` is called in the next tick to ensure that errors
	          // that might be thrown in the callbacks behave like errors thrown
	          // outside the promise chain.
	          //
	          process.nextTick(callCallbacks, this, err, cb);
	          return;
	        }

	        this._bufferedBytes -= options[kByteLength];
	        const data = toBuffer(arrayBuffer);

	        if (!compress) {
	          this._state = DEFAULT;
	          this.sendFrame(Sender.frame(data, options), cb);
	          this.dequeue();
	        } else {
	          this.dispatch(data, compress, options, cb);
	        }
	      })
	      .catch((err) => {
	        //
	        // `onError` is called in the next tick for the same reason that
	        // `callCallbacks` above is.
	        //
	        process.nextTick(onError, this, err, cb);
	      });
	  }

	  /**
	   * Dispatches a message.
	   *
	   * @param {(Buffer|String)} data The message to send
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     `data`
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  dispatch(data, compress, options, cb) {
	    if (!compress) {
	      this.sendFrame(Sender.frame(data, options), cb);
	      return;
	    }

	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    this._bufferedBytes += options[kByteLength];
	    this._state = DEFLATING;
	    perMessageDeflate.compress(data, options.fin, (_, buf) => {
	      if (this._socket.destroyed) {
	        const err = new Error(
	          'The socket was closed while data was being compressed'
	        );

	        callCallbacks(this, err, cb);
	        return;
	      }

	      this._bufferedBytes -= options[kByteLength];
	      this._state = DEFAULT;
	      options.readOnly = false;
	      this.sendFrame(Sender.frame(buf, options), cb);
	      this.dequeue();
	    });
	  }

	  /**
	   * Executes queued send operations.
	   *
	   * @private
	   */
	  dequeue() {
	    while (this._state === DEFAULT && this._queue.length) {
	      const params = this._queue.shift();

	      this._bufferedBytes -= params[3][kByteLength];
	      Reflect.apply(params[0], this, params.slice(1));
	    }
	  }

	  /**
	   * Enqueues a send operation.
	   *
	   * @param {Array} params Send operation parameters.
	   * @private
	   */
	  enqueue(params) {
	    this._bufferedBytes += params[3][kByteLength];
	    this._queue.push(params);
	  }

	  /**
	   * Sends a frame.
	   *
	   * @param {(Buffer | String)[]} list The frame to send
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  sendFrame(list, cb) {
	    if (list.length === 2) {
	      this._socket.cork();
	      this._socket.write(list[0]);
	      this._socket.write(list[1], cb);
	      this._socket.uncork();
	    } else {
	      this._socket.write(list[0], cb);
	    }
	  }
	}

	sender$2 = Sender;

	/**
	 * Calls queued callbacks with an error.
	 *
	 * @param {Sender} sender The `Sender` instance
	 * @param {Error} err The error to call the callbacks with
	 * @param {Function} [cb] The first callback
	 * @private
	 */
	function callCallbacks(sender, err, cb) {
	  if (typeof cb === 'function') cb(err);

	  for (let i = 0; i < sender._queue.length; i++) {
	    const params = sender._queue[i];
	    const callback = params[params.length - 1];

	    if (typeof callback === 'function') callback(err);
	  }
	}

	/**
	 * Handles a `Sender` error.
	 *
	 * @param {Sender} sender The `Sender` instance
	 * @param {Error} err The error
	 * @param {Function} [cb] The first pending callback
	 * @private
	 */
	function onError(sender, err, cb) {
	  callCallbacks(sender, err, cb);
	  sender.onerror(err);
	}
	return sender$2;
}

var eventTarget$2;
var hasRequiredEventTarget;

function requireEventTarget () {
	if (hasRequiredEventTarget) return eventTarget$2;
	hasRequiredEventTarget = 1;

	const { kForOnEventAttribute, kListener } = requireConstants();

	const kCode = Symbol('kCode');
	const kData = Symbol('kData');
	const kError = Symbol('kError');
	const kMessage = Symbol('kMessage');
	const kReason = Symbol('kReason');
	const kTarget = Symbol('kTarget');
	const kType = Symbol('kType');
	const kWasClean = Symbol('kWasClean');

	/**
	 * Class representing an event.
	 */
	class Event {
	  /**
	   * Create a new `Event`.
	   *
	   * @param {String} type The name of the event
	   * @throws {TypeError} If the `type` argument is not specified
	   */
	  constructor(type) {
	    this[kTarget] = null;
	    this[kType] = type;
	  }

	  /**
	   * @type {*}
	   */
	  get target() {
	    return this[kTarget];
	  }

	  /**
	   * @type {String}
	   */
	  get type() {
	    return this[kType];
	  }
	}

	Object.defineProperty(Event.prototype, 'target', { enumerable: true });
	Object.defineProperty(Event.prototype, 'type', { enumerable: true });

	/**
	 * Class representing a close event.
	 *
	 * @extends Event
	 */
	class CloseEvent extends Event {
	  /**
	   * Create a new `CloseEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {Number} [options.code=0] The status code explaining why the
	   *     connection was closed
	   * @param {String} [options.reason=''] A human-readable string explaining why
	   *     the connection was closed
	   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
	   *     connection was cleanly closed
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kCode] = options.code === undefined ? 0 : options.code;
	    this[kReason] = options.reason === undefined ? '' : options.reason;
	    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
	  }

	  /**
	   * @type {Number}
	   */
	  get code() {
	    return this[kCode];
	  }

	  /**
	   * @type {String}
	   */
	  get reason() {
	    return this[kReason];
	  }

	  /**
	   * @type {Boolean}
	   */
	  get wasClean() {
	    return this[kWasClean];
	  }
	}

	Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

	/**
	 * Class representing an error event.
	 *
	 * @extends Event
	 */
	class ErrorEvent extends Event {
	  /**
	   * Create a new `ErrorEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.error=null] The error that generated this event
	   * @param {String} [options.message=''] The error message
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kError] = options.error === undefined ? null : options.error;
	    this[kMessage] = options.message === undefined ? '' : options.message;
	  }

	  /**
	   * @type {*}
	   */
	  get error() {
	    return this[kError];
	  }

	  /**
	   * @type {String}
	   */
	  get message() {
	    return this[kMessage];
	  }
	}

	Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

	/**
	 * Class representing a message event.
	 *
	 * @extends Event
	 */
	class MessageEvent extends Event {
	  /**
	   * Create a new `MessageEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.data=null] The message content
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kData] = options.data === undefined ? null : options.data;
	  }

	  /**
	   * @type {*}
	   */
	  get data() {
	    return this[kData];
	  }
	}

	Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

	/**
	 * This provides methods for emulating the `EventTarget` interface. It's not
	 * meant to be used directly.
	 *
	 * @mixin
	 */
	const EventTarget = {
	  /**
	   * Register an event listener.
	   *
	   * @param {String} type A string representing the event type to listen for
	   * @param {(Function|Object)} handler The listener to add
	   * @param {Object} [options] An options object specifies characteristics about
	   *     the event listener
	   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
	   *     listener should be invoked at most once after being added. If `true`,
	   *     the listener would be automatically removed when invoked.
	   * @public
	   */
	  addEventListener(type, handler, options = {}) {
	    for (const listener of this.listeners(type)) {
	      if (
	        !options[kForOnEventAttribute] &&
	        listener[kListener] === handler &&
	        !listener[kForOnEventAttribute]
	      ) {
	        return;
	      }
	    }

	    let wrapper;

	    if (type === 'message') {
	      wrapper = function onMessage(data, isBinary) {
	        const event = new MessageEvent('message', {
	          data: isBinary ? data : data.toString()
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'close') {
	      wrapper = function onClose(code, message) {
	        const event = new CloseEvent('close', {
	          code,
	          reason: message.toString(),
	          wasClean: this._closeFrameReceived && this._closeFrameSent
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'error') {
	      wrapper = function onError(error) {
	        const event = new ErrorEvent('error', {
	          error,
	          message: error.message
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'open') {
	      wrapper = function onOpen() {
	        const event = new Event('open');

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else {
	      return;
	    }

	    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
	    wrapper[kListener] = handler;

	    if (options.once) {
	      this.once(type, wrapper);
	    } else {
	      this.on(type, wrapper);
	    }
	  },

	  /**
	   * Remove an event listener.
	   *
	   * @param {String} type A string representing the event type to remove
	   * @param {(Function|Object)} handler The listener to remove
	   * @public
	   */
	  removeEventListener(type, handler) {
	    for (const listener of this.listeners(type)) {
	      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
	        this.removeListener(type, listener);
	        break;
	      }
	    }
	  }
	};

	eventTarget$2 = {
	  CloseEvent,
	  ErrorEvent,
	  Event,
	  EventTarget,
	  MessageEvent
	};

	/**
	 * Call an event listener
	 *
	 * @param {(Function|Object)} listener The listener to call
	 * @param {*} thisArg The value to use as `this`` when calling the listener
	 * @param {Event} event The event to pass to the listener
	 * @private
	 */
	function callListener(listener, thisArg, event) {
	  if (typeof listener === 'object' && listener.handleEvent) {
	    listener.handleEvent.call(listener, event);
	  } else {
	    listener.call(thisArg, event);
	  }
	}
	return eventTarget$2;
}

var extension$4;
var hasRequiredExtension;

function requireExtension () {
	if (hasRequiredExtension) return extension$4;
	hasRequiredExtension = 1;

	const { tokenChars } = requireValidation();

	/**
	 * Adds an offer to the map of extension offers or a parameter to the map of
	 * parameters.
	 *
	 * @param {Object} dest The map of extension offers or parameters
	 * @param {String} name The extension or parameter name
	 * @param {(Object|Boolean|String)} elem The extension parameters or the
	 *     parameter value
	 * @private
	 */
	function push(dest, name, elem) {
	  if (dest[name] === undefined) dest[name] = [elem];
	  else dest[name].push(elem);
	}

	/**
	 * Parses the `Sec-WebSocket-Extensions` header into an object.
	 *
	 * @param {String} header The field value of the header
	 * @return {Object} The parsed object
	 * @public
	 */
	function parse(header) {
	  const offers = Object.create(null);
	  let params = Object.create(null);
	  let mustUnescape = false;
	  let isEscaping = false;
	  let inQuotes = false;
	  let extensionName;
	  let paramName;
	  let start = -1;
	  let code = -1;
	  let end = -1;
	  let i = 0;

	  for (; i < header.length; i++) {
	    code = header.charCodeAt(i);

	    if (extensionName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (
	        i !== 0 &&
	        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	      ) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        const name = header.slice(start, end);
	        if (code === 0x2c) {
	          push(offers, name, params);
	          params = Object.create(null);
	        } else {
	          extensionName = name;
	        }

	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else if (paramName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 || code === 0x09) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        push(params, header.slice(start, end), true);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        start = end = -1;
	      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
	        paramName = header.slice(start, i);
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else {
	      //
	      // The value of a quoted-string after unescaping must conform to the
	      // token ABNF, so only token characters are valid.
	      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
	      //
	      if (isEscaping) {
	        if (tokenChars[code] !== 1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (start === -1) start = i;
	        else if (!mustUnescape) mustUnescape = true;
	        isEscaping = false;
	      } else if (inQuotes) {
	        if (tokenChars[code] === 1) {
	          if (start === -1) start = i;
	        } else if (code === 0x22 /* '"' */ && start !== -1) {
	          inQuotes = false;
	          end = i;
	        } else if (code === 0x5c /* '\' */) {
	          isEscaping = true;
	        } else {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
	        inQuotes = true;
	      } else if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
	        if (end === -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        let value = header.slice(start, end);
	        if (mustUnescape) {
	          value = value.replace(/\\/g, '');
	          mustUnescape = false;
	        }
	        push(params, paramName, value);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        paramName = undefined;
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    }
	  }

	  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  if (end === -1) end = i;
	  const token = header.slice(start, end);
	  if (extensionName === undefined) {
	    push(offers, token, params);
	  } else {
	    if (paramName === undefined) {
	      push(params, token, true);
	    } else if (mustUnescape) {
	      push(params, paramName, token.replace(/\\/g, ''));
	    } else {
	      push(params, paramName, token);
	    }
	    push(offers, extensionName, params);
	  }

	  return offers;
	}

	/**
	 * Builds the `Sec-WebSocket-Extensions` header field value.
	 *
	 * @param {Object} extensions The map of extensions and parameters to format
	 * @return {String} A string representing the given object
	 * @public
	 */
	function format(extensions) {
	  return Object.keys(extensions)
	    .map((extension) => {
	      let configurations = extensions[extension];
	      if (!Array.isArray(configurations)) configurations = [configurations];
	      return configurations
	        .map((params) => {
	          return [extension]
	            .concat(
	              Object.keys(params).map((k) => {
	                let values = params[k];
	                if (!Array.isArray(values)) values = [values];
	                return values
	                  .map((v) => (v === true ? k : `${k}=${v}`))
	                  .join('; ');
	              })
	            )
	            .join('; ');
	        })
	        .join(', ');
	    })
	    .join(', ');
	}

	extension$4 = { format, parse };
	return extension$4;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

var websocket$4;
var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket$4;
	hasRequiredWebsocket = 1;

	const EventEmitter = require$$0$3__default;
	const https = require$$1$1__default;
	const http = require$$2__default;
	const net = require$$3__default;
	const tls = require$$4__default;
	const { randomBytes, createHash } = require$$1__default;
	const { Duplex, Readable } = require$$0$2__default;
	const { URL } = require$$7__default;

	const PerMessageDeflate = requirePermessageDeflate();
	const Receiver = requireReceiver();
	const Sender = requireSender();
	const { isBlob } = requireValidation();

	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  GUID,
	  kForOnEventAttribute,
	  kListener,
	  kStatusCode,
	  kWebSocket,
	  NOOP
	} = requireConstants();
	const {
	  EventTarget: { addEventListener, removeEventListener }
	} = requireEventTarget();
	const { format, parse } = requireExtension();
	const { toBuffer } = requireBufferUtil();

	const closeTimeout = 30 * 1000;
	const kAborted = Symbol('kAborted');
	const protocolVersions = [8, 13];
	const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

	/**
	 * Class representing a WebSocket.
	 *
	 * @extends EventEmitter
	 */
	class WebSocket extends EventEmitter {
	  /**
	   * Create a new `WebSocket`.
	   *
	   * @param {(String|URL)} address The URL to which to connect
	   * @param {(String|String[])} [protocols] The subprotocols
	   * @param {Object} [options] Connection options
	   */
	  constructor(address, protocols, options) {
	    super();

	    this._binaryType = BINARY_TYPES[0];
	    this._closeCode = 1006;
	    this._closeFrameReceived = false;
	    this._closeFrameSent = false;
	    this._closeMessage = EMPTY_BUFFER;
	    this._closeTimer = null;
	    this._errorEmitted = false;
	    this._extensions = {};
	    this._paused = false;
	    this._protocol = '';
	    this._readyState = WebSocket.CONNECTING;
	    this._receiver = null;
	    this._sender = null;
	    this._socket = null;

	    if (address !== null) {
	      this._bufferedAmount = 0;
	      this._isServer = false;
	      this._redirects = 0;

	      if (protocols === undefined) {
	        protocols = [];
	      } else if (!Array.isArray(protocols)) {
	        if (typeof protocols === 'object' && protocols !== null) {
	          options = protocols;
	          protocols = [];
	        } else {
	          protocols = [protocols];
	        }
	      }

	      initAsClient(this, address, protocols, options);
	    } else {
	      this._autoPong = options.autoPong;
	      this._isServer = true;
	    }
	  }

	  /**
	   * For historical reasons, the custom "nodebuffer" type is used by the default
	   * instead of "blob".
	   *
	   * @type {String}
	   */
	  get binaryType() {
	    return this._binaryType;
	  }

	  set binaryType(type) {
	    if (!BINARY_TYPES.includes(type)) return;

	    this._binaryType = type;

	    //
	    // Allow to change `binaryType` on the fly.
	    //
	    if (this._receiver) this._receiver._binaryType = type;
	  }

	  /**
	   * @type {Number}
	   */
	  get bufferedAmount() {
	    if (!this._socket) return this._bufferedAmount;

	    return this._socket._writableState.length + this._sender._bufferedBytes;
	  }

	  /**
	   * @type {String}
	   */
	  get extensions() {
	    return Object.keys(this._extensions).join();
	  }

	  /**
	   * @type {Boolean}
	   */
	  get isPaused() {
	    return this._paused;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onclose() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onerror() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onopen() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onmessage() {
	    return null;
	  }

	  /**
	   * @type {String}
	   */
	  get protocol() {
	    return this._protocol;
	  }

	  /**
	   * @type {Number}
	   */
	  get readyState() {
	    return this._readyState;
	  }

	  /**
	   * @type {String}
	   */
	  get url() {
	    return this._url;
	  }

	  /**
	   * Set up the socket and the internal resources.
	   *
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Object} options Options object
	   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Number} [options.maxPayload=0] The maximum allowed message size
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @private
	   */
	  setSocket(socket, head, options) {
	    const receiver = new Receiver({
	      allowSynchronousEvents: options.allowSynchronousEvents,
	      binaryType: this.binaryType,
	      extensions: this._extensions,
	      isServer: this._isServer,
	      maxPayload: options.maxPayload,
	      skipUTF8Validation: options.skipUTF8Validation
	    });

	    const sender = new Sender(socket, this._extensions, options.generateMask);

	    this._receiver = receiver;
	    this._sender = sender;
	    this._socket = socket;

	    receiver[kWebSocket] = this;
	    sender[kWebSocket] = this;
	    socket[kWebSocket] = this;

	    receiver.on('conclude', receiverOnConclude);
	    receiver.on('drain', receiverOnDrain);
	    receiver.on('error', receiverOnError);
	    receiver.on('message', receiverOnMessage);
	    receiver.on('ping', receiverOnPing);
	    receiver.on('pong', receiverOnPong);

	    sender.onerror = senderOnError;

	    //
	    // These methods may not be available if `socket` is just a `Duplex`.
	    //
	    if (socket.setTimeout) socket.setTimeout(0);
	    if (socket.setNoDelay) socket.setNoDelay();

	    if (head.length > 0) socket.unshift(head);

	    socket.on('close', socketOnClose);
	    socket.on('data', socketOnData);
	    socket.on('end', socketOnEnd);
	    socket.on('error', socketOnError);

	    this._readyState = WebSocket.OPEN;
	    this.emit('open');
	  }

	  /**
	   * Emit the `'close'` event.
	   *
	   * @private
	   */
	  emitClose() {
	    if (!this._socket) {
	      this._readyState = WebSocket.CLOSED;
	      this.emit('close', this._closeCode, this._closeMessage);
	      return;
	    }

	    if (this._extensions[PerMessageDeflate.extensionName]) {
	      this._extensions[PerMessageDeflate.extensionName].cleanup();
	    }

	    this._receiver.removeAllListeners();
	    this._readyState = WebSocket.CLOSED;
	    this.emit('close', this._closeCode, this._closeMessage);
	  }

	  /**
	   * Start a closing handshake.
	   *
	   *          +----------+   +-----------+   +----------+
	   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
	   *    |     +----------+   +-----------+   +----------+     |
	   *          +----------+   +-----------+         |
	   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
	   *          +----------+   +-----------+   |
	   *    |           |                        |   +---+        |
	   *                +------------------------+-->|fin| - - - -
	   *    |         +---+                      |   +---+
	   *     - - - - -|fin|<---------------------+
	   *              +---+
	   *
	   * @param {Number} [code] Status code explaining why the connection is closing
	   * @param {(String|Buffer)} [data] The reason why the connection is
	   *     closing
	   * @public
	   */
	  close(code, data) {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this.readyState === WebSocket.CLOSING) {
	      if (
	        this._closeFrameSent &&
	        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
	      ) {
	        this._socket.end();
	      }

	      return;
	    }

	    this._readyState = WebSocket.CLOSING;
	    this._sender.close(code, data, !this._isServer, (err) => {
	      //
	      // This error is handled by the `'error'` listener on the socket. We only
	      // want to know if the close frame has been sent here.
	      //
	      if (err) return;

	      this._closeFrameSent = true;

	      if (
	        this._closeFrameReceived ||
	        this._receiver._writableState.errorEmitted
	      ) {
	        this._socket.end();
	      }
	    });

	    setCloseTimer(this);
	  }

	  /**
	   * Pause the socket.
	   *
	   * @public
	   */
	  pause() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = true;
	    this._socket.pause();
	  }

	  /**
	   * Send a ping.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the ping is sent
	   * @public
	   */
	  ping(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Send a pong.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the pong is sent
	   * @public
	   */
	  pong(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Resume the socket.
	   *
	   * @public
	   */
	  resume() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = false;
	    if (!this._receiver._writableState.needDrain) this._socket.resume();
	  }

	  /**
	   * Send a data message.
	   *
	   * @param {*} data The message to send
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
	   *     text
	   * @param {Boolean} [options.compress] Specifies whether or not to compress
	   *     `data`
	   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when data is written out
	   * @public
	   */
	  send(data, options, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof options === 'function') {
	      cb = options;
	      options = {};
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    const opts = {
	      binary: typeof data !== 'string',
	      mask: !this._isServer,
	      compress: true,
	      fin: true,
	      ...options
	    };

	    if (!this._extensions[PerMessageDeflate.extensionName]) {
	      opts.compress = false;
	    }

	    this._sender.send(data || EMPTY_BUFFER, opts, cb);
	  }

	  /**
	   * Forcibly close the connection.
	   *
	   * @public
	   */
	  terminate() {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this._socket) {
	      this._readyState = WebSocket.CLOSING;
	      this._socket.destroy();
	    }
	  }
	}

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	[
	  'binaryType',
	  'bufferedAmount',
	  'extensions',
	  'isPaused',
	  'protocol',
	  'readyState',
	  'url'
	].forEach((property) => {
	  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});

	//
	// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
	// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
	//
	['open', 'error', 'close', 'message'].forEach((method) => {
	  Object.defineProperty(WebSocket.prototype, `on${method}`, {
	    enumerable: true,
	    get() {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) return listener[kListener];
	      }

	      return null;
	    },
	    set(handler) {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) {
	          this.removeListener(method, listener);
	          break;
	        }
	      }

	      if (typeof handler !== 'function') return;

	      this.addEventListener(method, handler, {
	        [kForOnEventAttribute]: true
	      });
	    }
	  });
	});

	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;

	websocket$4 = WebSocket;

	/**
	 * Initialize a WebSocket client.
	 *
	 * @param {WebSocket} websocket The client to initialize
	 * @param {(String|URL)} address The URL to which to connect
	 * @param {Array} protocols The subprotocols
	 * @param {Object} [options] Connection options
	 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	 *     times in the same tick
	 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	 *     automatically send a pong in response to a ping
	 * @param {Function} [options.finishRequest] A function which can be used to
	 *     customize the headers of each http request before it is sent
	 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
	 *     redirects
	 * @param {Function} [options.generateMask] The function used to generate the
	 *     masking key
	 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	 *     handshake request
	 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	 *     size
	 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
	 *     allowed
	 * @param {String} [options.origin] Value of the `Origin` or
	 *     `Sec-WebSocket-Origin` header
	 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	 *     permessage-deflate
	 * @param {Number} [options.protocolVersion=13] Value of the
	 *     `Sec-WebSocket-Version` header
	 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	 *     not to skip UTF-8 validation for text and close messages
	 * @private
	 */
	function initAsClient(websocket, address, protocols, options) {
	  const opts = {
	    allowSynchronousEvents: true,
	    autoPong: true,
	    protocolVersion: protocolVersions[1],
	    maxPayload: 100 * 1024 * 1024,
	    skipUTF8Validation: false,
	    perMessageDeflate: true,
	    followRedirects: false,
	    maxRedirects: 10,
	    ...options,
	    socketPath: undefined,
	    hostname: undefined,
	    protocol: undefined,
	    timeout: undefined,
	    method: 'GET',
	    host: undefined,
	    path: undefined,
	    port: undefined
	  };

	  websocket._autoPong = opts.autoPong;

	  if (!protocolVersions.includes(opts.protocolVersion)) {
	    throw new RangeError(
	      `Unsupported protocol version: ${opts.protocolVersion} ` +
	        `(supported versions: ${protocolVersions.join(', ')})`
	    );
	  }

	  let parsedUrl;

	  if (address instanceof URL) {
	    parsedUrl = address;
	  } else {
	    try {
	      parsedUrl = new URL(address);
	    } catch (e) {
	      throw new SyntaxError(`Invalid URL: ${address}`);
	    }
	  }

	  if (parsedUrl.protocol === 'http:') {
	    parsedUrl.protocol = 'ws:';
	  } else if (parsedUrl.protocol === 'https:') {
	    parsedUrl.protocol = 'wss:';
	  }

	  websocket._url = parsedUrl.href;

	  const isSecure = parsedUrl.protocol === 'wss:';
	  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
	  let invalidUrlMessage;

	  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
	    invalidUrlMessage =
	      'The URL\'s protocol must be one of "ws:", "wss:", ' +
	      '"http:", "https:", or "ws+unix:"';
	  } else if (isIpcUrl && !parsedUrl.pathname) {
	    invalidUrlMessage = "The URL's pathname is empty";
	  } else if (parsedUrl.hash) {
	    invalidUrlMessage = 'The URL contains a fragment identifier';
	  }

	  if (invalidUrlMessage) {
	    const err = new SyntaxError(invalidUrlMessage);

	    if (websocket._redirects === 0) {
	      throw err;
	    } else {
	      emitErrorAndClose(websocket, err);
	      return;
	    }
	  }

	  const defaultPort = isSecure ? 443 : 80;
	  const key = randomBytes(16).toString('base64');
	  const request = isSecure ? https.request : http.request;
	  const protocolSet = new Set();
	  let perMessageDeflate;

	  opts.createConnection =
	    opts.createConnection || (isSecure ? tlsConnect : netConnect);
	  opts.defaultPort = opts.defaultPort || defaultPort;
	  opts.port = parsedUrl.port || defaultPort;
	  opts.host = parsedUrl.hostname.startsWith('[')
	    ? parsedUrl.hostname.slice(1, -1)
	    : parsedUrl.hostname;
	  opts.headers = {
	    ...opts.headers,
	    'Sec-WebSocket-Version': opts.protocolVersion,
	    'Sec-WebSocket-Key': key,
	    Connection: 'Upgrade',
	    Upgrade: 'websocket'
	  };
	  opts.path = parsedUrl.pathname + parsedUrl.search;
	  opts.timeout = opts.handshakeTimeout;

	  if (opts.perMessageDeflate) {
	    perMessageDeflate = new PerMessageDeflate(
	      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
	      false,
	      opts.maxPayload
	    );
	    opts.headers['Sec-WebSocket-Extensions'] = format({
	      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
	    });
	  }
	  if (protocols.length) {
	    for (const protocol of protocols) {
	      if (
	        typeof protocol !== 'string' ||
	        !subprotocolRegex.test(protocol) ||
	        protocolSet.has(protocol)
	      ) {
	        throw new SyntaxError(
	          'An invalid or duplicated subprotocol was specified'
	        );
	      }

	      protocolSet.add(protocol);
	    }

	    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
	  }
	  if (opts.origin) {
	    if (opts.protocolVersion < 13) {
	      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
	    } else {
	      opts.headers.Origin = opts.origin;
	    }
	  }
	  if (parsedUrl.username || parsedUrl.password) {
	    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
	  }

	  if (isIpcUrl) {
	    const parts = opts.path.split(':');

	    opts.socketPath = parts[0];
	    opts.path = parts[1];
	  }

	  let req;

	  if (opts.followRedirects) {
	    if (websocket._redirects === 0) {
	      websocket._originalIpc = isIpcUrl;
	      websocket._originalSecure = isSecure;
	      websocket._originalHostOrSocketPath = isIpcUrl
	        ? opts.socketPath
	        : parsedUrl.host;

	      const headers = options && options.headers;

	      //
	      // Shallow copy the user provided options so that headers can be changed
	      // without mutating the original object.
	      //
	      options = { ...options, headers: {} };

	      if (headers) {
	        for (const [key, value] of Object.entries(headers)) {
	          options.headers[key.toLowerCase()] = value;
	        }
	      }
	    } else if (websocket.listenerCount('redirect') === 0) {
	      const isSameHost = isIpcUrl
	        ? websocket._originalIpc
	          ? opts.socketPath === websocket._originalHostOrSocketPath
	          : false
	        : websocket._originalIpc
	          ? false
	          : parsedUrl.host === websocket._originalHostOrSocketPath;

	      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
	        //
	        // Match curl 7.77.0 behavior and drop the following headers. These
	        // headers are also dropped when following a redirect to a subdomain.
	        //
	        delete opts.headers.authorization;
	        delete opts.headers.cookie;

	        if (!isSameHost) delete opts.headers.host;

	        opts.auth = undefined;
	      }
	    }

	    //
	    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
	    // If the `Authorization` header is set, then there is nothing to do as it
	    // will take precedence.
	    //
	    if (opts.auth && !options.headers.authorization) {
	      options.headers.authorization =
	        'Basic ' + Buffer.from(opts.auth).toString('base64');
	    }

	    req = websocket._req = request(opts);

	    if (websocket._redirects) {
	      //
	      // Unlike what is done for the `'upgrade'` event, no early exit is
	      // triggered here if the user calls `websocket.close()` or
	      // `websocket.terminate()` from a listener of the `'redirect'` event. This
	      // is because the user can also call `request.destroy()` with an error
	      // before calling `websocket.close()` or `websocket.terminate()` and this
	      // would result in an error being emitted on the `request` object with no
	      // `'error'` event listeners attached.
	      //
	      websocket.emit('redirect', websocket.url, req);
	    }
	  } else {
	    req = websocket._req = request(opts);
	  }

	  if (opts.timeout) {
	    req.on('timeout', () => {
	      abortHandshake(websocket, req, 'Opening handshake has timed out');
	    });
	  }

	  req.on('error', (err) => {
	    if (req === null || req[kAborted]) return;

	    req = websocket._req = null;
	    emitErrorAndClose(websocket, err);
	  });

	  req.on('response', (res) => {
	    const location = res.headers.location;
	    const statusCode = res.statusCode;

	    if (
	      location &&
	      opts.followRedirects &&
	      statusCode >= 300 &&
	      statusCode < 400
	    ) {
	      if (++websocket._redirects > opts.maxRedirects) {
	        abortHandshake(websocket, req, 'Maximum redirects exceeded');
	        return;
	      }

	      req.abort();

	      let addr;

	      try {
	        addr = new URL(location, address);
	      } catch (e) {
	        const err = new SyntaxError(`Invalid URL: ${location}`);
	        emitErrorAndClose(websocket, err);
	        return;
	      }

	      initAsClient(websocket, addr, protocols, options);
	    } else if (!websocket.emit('unexpected-response', req, res)) {
	      abortHandshake(
	        websocket,
	        req,
	        `Unexpected server response: ${res.statusCode}`
	      );
	    }
	  });

	  req.on('upgrade', (res, socket, head) => {
	    websocket.emit('upgrade', res);

	    //
	    // The user may have closed the connection from a listener of the
	    // `'upgrade'` event.
	    //
	    if (websocket.readyState !== WebSocket.CONNECTING) return;

	    req = websocket._req = null;

	    const upgrade = res.headers.upgrade;

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      abortHandshake(websocket, socket, 'Invalid Upgrade header');
	      return;
	    }

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    if (res.headers['sec-websocket-accept'] !== digest) {
	      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
	      return;
	    }

	    const serverProt = res.headers['sec-websocket-protocol'];
	    let protError;

	    if (serverProt !== undefined) {
	      if (!protocolSet.size) {
	        protError = 'Server sent a subprotocol but none was requested';
	      } else if (!protocolSet.has(serverProt)) {
	        protError = 'Server sent an invalid subprotocol';
	      }
	    } else if (protocolSet.size) {
	      protError = 'Server sent no subprotocol';
	    }

	    if (protError) {
	      abortHandshake(websocket, socket, protError);
	      return;
	    }

	    if (serverProt) websocket._protocol = serverProt;

	    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

	    if (secWebSocketExtensions !== undefined) {
	      if (!perMessageDeflate) {
	        const message =
	          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
	          'was requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      let extensions;

	      try {
	        extensions = parse(secWebSocketExtensions);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      const extensionNames = Object.keys(extensions);

	      if (
	        extensionNames.length !== 1 ||
	        extensionNames[0] !== PerMessageDeflate.extensionName
	      ) {
	        const message = 'Server indicated an extension that was not requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      try {
	        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      websocket._extensions[PerMessageDeflate.extensionName] =
	        perMessageDeflate;
	    }

	    websocket.setSocket(socket, head, {
	      allowSynchronousEvents: opts.allowSynchronousEvents,
	      generateMask: opts.generateMask,
	      maxPayload: opts.maxPayload,
	      skipUTF8Validation: opts.skipUTF8Validation
	    });
	  });

	  if (opts.finishRequest) {
	    opts.finishRequest(req, websocket);
	  } else {
	    req.end();
	  }
	}

	/**
	 * Emit the `'error'` and `'close'` events.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {Error} The error to emit
	 * @private
	 */
	function emitErrorAndClose(websocket, err) {
	  websocket._readyState = WebSocket.CLOSING;
	  //
	  // The following assignment is practically useless and is done only for
	  // consistency.
	  //
	  websocket._errorEmitted = true;
	  websocket.emit('error', err);
	  websocket.emitClose();
	}

	/**
	 * Create a `net.Socket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {net.Socket} The newly created socket used to start the connection
	 * @private
	 */
	function netConnect(options) {
	  options.path = options.socketPath;
	  return net.connect(options);
	}

	/**
	 * Create a `tls.TLSSocket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {tls.TLSSocket} The newly created socket used to start the connection
	 * @private
	 */
	function tlsConnect(options) {
	  options.path = undefined;

	  if (!options.servername && options.servername !== '') {
	    options.servername = net.isIP(options.host) ? '' : options.host;
	  }

	  return tls.connect(options);
	}

	/**
	 * Abort the handshake and emit an error.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	 *     abort or the socket to destroy
	 * @param {String} message The error message
	 * @private
	 */
	function abortHandshake(websocket, stream, message) {
	  websocket._readyState = WebSocket.CLOSING;

	  const err = new Error(message);
	  Error.captureStackTrace(err, abortHandshake);

	  if (stream.setHeader) {
	    stream[kAborted] = true;
	    stream.abort();

	    if (stream.socket && !stream.socket.destroyed) {
	      //
	      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
	      // called after the request completed. See
	      // https://github.com/websockets/ws/issues/1869.
	      //
	      stream.socket.destroy();
	    }

	    process.nextTick(emitErrorAndClose, websocket, err);
	  } else {
	    stream.destroy(err);
	    stream.once('error', websocket.emit.bind(websocket, 'error'));
	    stream.once('close', websocket.emitClose.bind(websocket));
	  }
	}

	/**
	 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {*} [data] The data to send
	 * @param {Function} [cb] Callback
	 * @private
	 */
	function sendAfterClose(websocket, data, cb) {
	  if (data) {
	    const length = isBlob(data) ? data.size : toBuffer(data).length;

	    //
	    // The `_bufferedAmount` property is used only when the peer is a client and
	    // the opening handshake fails. Under these circumstances, in fact, the
	    // `setSocket()` method is not called, so the `_socket` and `_sender`
	    // properties are set to `null`.
	    //
	    if (websocket._socket) websocket._sender._bufferedBytes += length;
	    else websocket._bufferedAmount += length;
	  }

	  if (cb) {
	    const err = new Error(
	      `WebSocket is not open: readyState ${websocket.readyState} ` +
	        `(${readyStates[websocket.readyState]})`
	    );
	    process.nextTick(cb, err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'conclude'` event.
	 *
	 * @param {Number} code The status code
	 * @param {Buffer} reason The reason for closing
	 * @private
	 */
	function receiverOnConclude(code, reason) {
	  const websocket = this[kWebSocket];

	  websocket._closeFrameReceived = true;
	  websocket._closeMessage = reason;
	  websocket._closeCode = code;

	  if (websocket._socket[kWebSocket] === undefined) return;

	  websocket._socket.removeListener('data', socketOnData);
	  process.nextTick(resume, websocket._socket);

	  if (code === 1005) websocket.close();
	  else websocket.close(code, reason);
	}

	/**
	 * The listener of the `Receiver` `'drain'` event.
	 *
	 * @private
	 */
	function receiverOnDrain() {
	  const websocket = this[kWebSocket];

	  if (!websocket.isPaused) websocket._socket.resume();
	}

	/**
	 * The listener of the `Receiver` `'error'` event.
	 *
	 * @param {(RangeError|Error)} err The emitted error
	 * @private
	 */
	function receiverOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket._socket[kWebSocket] !== undefined) {
	    websocket._socket.removeListener('data', socketOnData);

	    //
	    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
	    // https://github.com/websockets/ws/issues/1940.
	    //
	    process.nextTick(resume, websocket._socket);

	    websocket.close(err[kStatusCode]);
	  }

	  if (!websocket._errorEmitted) {
	    websocket._errorEmitted = true;
	    websocket.emit('error', err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'finish'` event.
	 *
	 * @private
	 */
	function receiverOnFinish() {
	  this[kWebSocket].emitClose();
	}

	/**
	 * The listener of the `Receiver` `'message'` event.
	 *
	 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
	 * @param {Boolean} isBinary Specifies whether the message is binary or not
	 * @private
	 */
	function receiverOnMessage(data, isBinary) {
	  this[kWebSocket].emit('message', data, isBinary);
	}

	/**
	 * The listener of the `Receiver` `'ping'` event.
	 *
	 * @param {Buffer} data The data included in the ping frame
	 * @private
	 */
	function receiverOnPing(data) {
	  const websocket = this[kWebSocket];

	  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
	  websocket.emit('ping', data);
	}

	/**
	 * The listener of the `Receiver` `'pong'` event.
	 *
	 * @param {Buffer} data The data included in the pong frame
	 * @private
	 */
	function receiverOnPong(data) {
	  this[kWebSocket].emit('pong', data);
	}

	/**
	 * Resume a readable stream
	 *
	 * @param {Readable} stream The readable stream
	 * @private
	 */
	function resume(stream) {
	  stream.resume();
	}

	/**
	 * The `Sender` error event handler.
	 *
	 * @param {Error} The error
	 * @private
	 */
	function senderOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket.readyState === WebSocket.CLOSED) return;
	  if (websocket.readyState === WebSocket.OPEN) {
	    websocket._readyState = WebSocket.CLOSING;
	    setCloseTimer(websocket);
	  }

	  //
	  // `socket.end()` is used instead of `socket.destroy()` to allow the other
	  // peer to finish sending queued data. There is no need to set a timer here
	  // because `CLOSING` means that it is already set or not needed.
	  //
	  this._socket.end();

	  if (!websocket._errorEmitted) {
	    websocket._errorEmitted = true;
	    websocket.emit('error', err);
	  }
	}

	/**
	 * Set a timer to destroy the underlying raw socket of a WebSocket.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @private
	 */
	function setCloseTimer(websocket) {
	  websocket._closeTimer = setTimeout(
	    websocket._socket.destroy.bind(websocket._socket),
	    closeTimeout
	  );
	}

	/**
	 * The listener of the socket `'close'` event.
	 *
	 * @private
	 */
	function socketOnClose() {
	  const websocket = this[kWebSocket];

	  this.removeListener('close', socketOnClose);
	  this.removeListener('data', socketOnData);
	  this.removeListener('end', socketOnEnd);

	  websocket._readyState = WebSocket.CLOSING;

	  let chunk;

	  //
	  // The close frame might not have been received or the `'end'` event emitted,
	  // for example, if the socket was destroyed due to an error. Ensure that the
	  // `receiver` stream is closed after writing any remaining buffered data to
	  // it. If the readable side of the socket is in flowing mode then there is no
	  // buffered data as everything has been already written and `readable.read()`
	  // will return `null`. If instead, the socket is paused, any possible buffered
	  // data will be read as a single chunk.
	  //
	  if (
	    !this._readableState.endEmitted &&
	    !websocket._closeFrameReceived &&
	    !websocket._receiver._writableState.errorEmitted &&
	    (chunk = websocket._socket.read()) !== null
	  ) {
	    websocket._receiver.write(chunk);
	  }

	  websocket._receiver.end();

	  this[kWebSocket] = undefined;

	  clearTimeout(websocket._closeTimer);

	  if (
	    websocket._receiver._writableState.finished ||
	    websocket._receiver._writableState.errorEmitted
	  ) {
	    websocket.emitClose();
	  } else {
	    websocket._receiver.on('error', receiverOnFinish);
	    websocket._receiver.on('finish', receiverOnFinish);
	  }
	}

	/**
	 * The listener of the socket `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function socketOnData(chunk) {
	  if (!this[kWebSocket]._receiver.write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * The listener of the socket `'end'` event.
	 *
	 * @private
	 */
	function socketOnEnd() {
	  const websocket = this[kWebSocket];

	  websocket._readyState = WebSocket.CLOSING;
	  websocket._receiver.end();
	  this.end();
	}

	/**
	 * The listener of the socket `'error'` event.
	 *
	 * @private
	 */
	function socketOnError() {
	  const websocket = this[kWebSocket];

	  this.removeListener('error', socketOnError);
	  this.on('error', NOOP);

	  if (websocket) {
	    websocket._readyState = WebSocket.CLOSING;
	    this.destroy();
	  }
	}
	return websocket$4;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^WebSocket$" }] */

var stream$2;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream$2;
	hasRequiredStream = 1;

	requireWebsocket();
	const { Duplex } = require$$0$2__default;

	/**
	 * Emits the `'close'` event on a stream.
	 *
	 * @param {Duplex} stream The stream.
	 * @private
	 */
	function emitClose(stream) {
	  stream.emit('close');
	}

	/**
	 * The listener of the `'end'` event.
	 *
	 * @private
	 */
	function duplexOnEnd() {
	  if (!this.destroyed && this._writableState.finished) {
	    this.destroy();
	  }
	}

	/**
	 * The listener of the `'error'` event.
	 *
	 * @param {Error} err The error
	 * @private
	 */
	function duplexOnError(err) {
	  this.removeListener('error', duplexOnError);
	  this.destroy();
	  if (this.listenerCount('error') === 0) {
	    // Do not suppress the throwing behavior.
	    this.emit('error', err);
	  }
	}

	/**
	 * Wraps a `WebSocket` in a duplex stream.
	 *
	 * @param {WebSocket} ws The `WebSocket` to wrap
	 * @param {Object} [options] The options for the `Duplex` constructor
	 * @return {Duplex} The duplex stream
	 * @public
	 */
	function createWebSocketStream(ws, options) {
	  let terminateOnDestroy = true;

	  const duplex = new Duplex({
	    ...options,
	    autoDestroy: false,
	    emitClose: false,
	    objectMode: false,
	    writableObjectMode: false
	  });

	  ws.on('message', function message(msg, isBinary) {
	    const data =
	      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

	    if (!duplex.push(data)) ws.pause();
	  });

	  ws.once('error', function error(err) {
	    if (duplex.destroyed) return;

	    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
	    //
	    // - If the `'error'` event is emitted before the `'open'` event, then
	    //   `ws.terminate()` is a noop as no socket is assigned.
	    // - Otherwise, the error is re-emitted by the listener of the `'error'`
	    //   event of the `Receiver` object. The listener already closes the
	    //   connection by calling `ws.close()`. This allows a close frame to be
	    //   sent to the other peer. If `ws.terminate()` is called right after this,
	    //   then the close frame might not be sent.
	    terminateOnDestroy = false;
	    duplex.destroy(err);
	  });

	  ws.once('close', function close() {
	    if (duplex.destroyed) return;

	    duplex.push(null);
	  });

	  duplex._destroy = function (err, callback) {
	    if (ws.readyState === ws.CLOSED) {
	      callback(err);
	      process.nextTick(emitClose, duplex);
	      return;
	    }

	    let called = false;

	    ws.once('error', function error(err) {
	      called = true;
	      callback(err);
	    });

	    ws.once('close', function close() {
	      if (!called) callback(err);
	      process.nextTick(emitClose, duplex);
	    });

	    if (terminateOnDestroy) ws.terminate();
	  };

	  duplex._final = function (callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._final(callback);
	      });
	      return;
	    }

	    // If the value of the `_socket` property is `null` it means that `ws` is a
	    // client websocket and the handshake failed. In fact, when this happens, a
	    // socket is never assigned to the websocket. Wait for the `'error'` event
	    // that will be emitted by the websocket.
	    if (ws._socket === null) return;

	    if (ws._socket._writableState.finished) {
	      callback();
	      if (duplex._readableState.endEmitted) duplex.destroy();
	    } else {
	      ws._socket.once('finish', function finish() {
	        // `duplex` is not destroyed here because the `'end'` event will be
	        // emitted on `duplex` after this `'finish'` event. The EOF signaling
	        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
	        callback();
	      });
	      ws.close();
	    }
	  };

	  duplex._read = function () {
	    if (ws.isPaused) ws.resume();
	  };

	  duplex._write = function (chunk, encoding, callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._write(chunk, encoding, callback);
	      });
	      return;
	    }

	    ws.send(chunk, callback);
	  };

	  duplex.on('end', duplexOnEnd);
	  duplex.on('error', duplexOnError);
	  return duplex;
	}

	stream$2 = createWebSocketStream;
	return stream$2;
}

requireStream();

requireReceiver();

requireSender();

requireWebsocket();

var subprotocol$4;
var hasRequiredSubprotocol;

function requireSubprotocol () {
	if (hasRequiredSubprotocol) return subprotocol$4;
	hasRequiredSubprotocol = 1;

	const { tokenChars } = requireValidation();

	/**
	 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	 *
	 * @param {String} header The field value of the header
	 * @return {Set} The subprotocol names
	 * @public
	 */
	function parse(header) {
	  const protocols = new Set();
	  let start = -1;
	  let end = -1;
	  let i = 0;

	  for (i; i < header.length; i++) {
	    const code = header.charCodeAt(i);

	    if (end === -1 && tokenChars[code] === 1) {
	      if (start === -1) start = i;
	    } else if (
	      i !== 0 &&
	      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	    ) {
	      if (end === -1 && start !== -1) end = i;
	    } else if (code === 0x2c /* ',' */) {
	      if (start === -1) {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }

	      if (end === -1) end = i;

	      const protocol = header.slice(start, end);

	      if (protocols.has(protocol)) {
	        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	      }

	      protocols.add(protocol);
	      start = end = -1;
	    } else {
	      throw new SyntaxError(`Unexpected character at index ${i}`);
	    }
	  }

	  if (start === -1 || end !== -1) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  const protocol = header.slice(start, i);

	  if (protocols.has(protocol)) {
	    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	  }

	  protocols.add(protocol);
	  return protocols;
	}

	subprotocol$4 = { parse };
	return subprotocol$4;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

var websocketServer$2;
var hasRequiredWebsocketServer;

function requireWebsocketServer () {
	if (hasRequiredWebsocketServer) return websocketServer$2;
	hasRequiredWebsocketServer = 1;

	const EventEmitter = require$$0$3__default;
	const http = require$$2__default;
	const { Duplex } = require$$0$2__default;
	const { createHash } = require$$1__default;

	const extension = requireExtension();
	const PerMessageDeflate = requirePermessageDeflate();
	const subprotocol = requireSubprotocol();
	const WebSocket = requireWebsocket();
	const { GUID, kWebSocket } = requireConstants();

	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;

	/**
	 * Class representing a WebSocket server.
	 *
	 * @extends EventEmitter
	 */
	class WebSocketServer extends EventEmitter {
	  /**
	   * Create a `WebSocketServer` instance.
	   *
	   * @param {Object} options Configuration options
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	   *     automatically send a pong in response to a ping
	   * @param {Number} [options.backlog=511] The maximum length of the queue of
	   *     pending connections
	   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
	   *     track clients
	   * @param {Function} [options.handleProtocols] A hook to handle protocols
	   * @param {String} [options.host] The hostname where to bind the server
	   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	   *     size
	   * @param {Boolean} [options.noServer=false] Enable no server mode
	   * @param {String} [options.path] Accept only connections matching this path
	   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
	   *     permessage-deflate
	   * @param {Number} [options.port] The port where to bind the server
	   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
	   *     server to use
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @param {Function} [options.verifyClient] A hook to reject connections
	   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
	   *     class to use. It must be the `WebSocket` class or class that extends it
	   * @param {Function} [callback] A listener for the `listening` event
	   */
	  constructor(options, callback) {
	    super();

	    options = {
	      allowSynchronousEvents: true,
	      autoPong: true,
	      maxPayload: 100 * 1024 * 1024,
	      skipUTF8Validation: false,
	      perMessageDeflate: false,
	      handleProtocols: null,
	      clientTracking: true,
	      verifyClient: null,
	      noServer: false,
	      backlog: null, // use default (511 as implemented in net.js)
	      server: null,
	      host: null,
	      path: null,
	      port: null,
	      WebSocket,
	      ...options
	    };

	    if (
	      (options.port == null && !options.server && !options.noServer) ||
	      (options.port != null && (options.server || options.noServer)) ||
	      (options.server && options.noServer)
	    ) {
	      throw new TypeError(
	        'One and only one of the "port", "server", or "noServer" options ' +
	          'must be specified'
	      );
	    }

	    if (options.port != null) {
	      this._server = http.createServer((req, res) => {
	        const body = http.STATUS_CODES[426];

	        res.writeHead(426, {
	          'Content-Length': body.length,
	          'Content-Type': 'text/plain'
	        });
	        res.end(body);
	      });
	      this._server.listen(
	        options.port,
	        options.host,
	        options.backlog,
	        callback
	      );
	    } else if (options.server) {
	      this._server = options.server;
	    }

	    if (this._server) {
	      const emitConnection = this.emit.bind(this, 'connection');

	      this._removeListeners = addListeners(this._server, {
	        listening: this.emit.bind(this, 'listening'),
	        error: this.emit.bind(this, 'error'),
	        upgrade: (req, socket, head) => {
	          this.handleUpgrade(req, socket, head, emitConnection);
	        }
	      });
	    }

	    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
	    if (options.clientTracking) {
	      this.clients = new Set();
	      this._shouldEmitClose = false;
	    }

	    this.options = options;
	    this._state = RUNNING;
	  }

	  /**
	   * Returns the bound address, the address family name, and port of the server
	   * as reported by the operating system if listening on an IP socket.
	   * If the server is listening on a pipe or UNIX domain socket, the name is
	   * returned as a string.
	   *
	   * @return {(Object|String|null)} The address of the server
	   * @public
	   */
	  address() {
	    if (this.options.noServer) {
	      throw new Error('The server is operating in "noServer" mode');
	    }

	    if (!this._server) return null;
	    return this._server.address();
	  }

	  /**
	   * Stop the server from accepting new connections and emit the `'close'` event
	   * when all existing connections are closed.
	   *
	   * @param {Function} [cb] A one-time listener for the `'close'` event
	   * @public
	   */
	  close(cb) {
	    if (this._state === CLOSED) {
	      if (cb) {
	        this.once('close', () => {
	          cb(new Error('The server is not running'));
	        });
	      }

	      process.nextTick(emitClose, this);
	      return;
	    }

	    if (cb) this.once('close', cb);

	    if (this._state === CLOSING) return;
	    this._state = CLOSING;

	    if (this.options.noServer || this.options.server) {
	      if (this._server) {
	        this._removeListeners();
	        this._removeListeners = this._server = null;
	      }

	      if (this.clients) {
	        if (!this.clients.size) {
	          process.nextTick(emitClose, this);
	        } else {
	          this._shouldEmitClose = true;
	        }
	      } else {
	        process.nextTick(emitClose, this);
	      }
	    } else {
	      const server = this._server;

	      this._removeListeners();
	      this._removeListeners = this._server = null;

	      //
	      // The HTTP/S server was created internally. Close it, and rely on its
	      // `'close'` event.
	      //
	      server.close(() => {
	        emitClose(this);
	      });
	    }
	  }

	  /**
	   * See if a given request should be handled by this server instance.
	   *
	   * @param {http.IncomingMessage} req Request object to inspect
	   * @return {Boolean} `true` if the request is valid, else `false`
	   * @public
	   */
	  shouldHandle(req) {
	    if (this.options.path) {
	      const index = req.url.indexOf('?');
	      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

	      if (pathname !== this.options.path) return false;
	    }

	    return true;
	  }

	  /**
	   * Handle a HTTP Upgrade request.
	   *
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @public
	   */
	  handleUpgrade(req, socket, head, cb) {
	    socket.on('error', socketOnError);

	    const key = req.headers['sec-websocket-key'];
	    const upgrade = req.headers.upgrade;
	    const version = +req.headers['sec-websocket-version'];

	    if (req.method !== 'GET') {
	      const message = 'Invalid HTTP method';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
	      return;
	    }

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      const message = 'Invalid Upgrade header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (key === undefined || !keyRegex.test(key)) {
	      const message = 'Missing or invalid Sec-WebSocket-Key header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (version !== 8 && version !== 13) {
	      const message = 'Missing or invalid Sec-WebSocket-Version header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (!this.shouldHandle(req)) {
	      abortHandshake(socket, 400);
	      return;
	    }

	    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
	    let protocols = new Set();

	    if (secWebSocketProtocol !== undefined) {
	      try {
	        protocols = subprotocol.parse(secWebSocketProtocol);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Protocol header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
	    const extensions = {};

	    if (
	      this.options.perMessageDeflate &&
	      secWebSocketExtensions !== undefined
	    ) {
	      const perMessageDeflate = new PerMessageDeflate(
	        this.options.perMessageDeflate,
	        true,
	        this.options.maxPayload
	      );

	      try {
	        const offers = extension.parse(secWebSocketExtensions);

	        if (offers[PerMessageDeflate.extensionName]) {
	          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
	          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
	        }
	      } catch (err) {
	        const message =
	          'Invalid or unacceptable Sec-WebSocket-Extensions header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    //
	    // Optionally call external client verification handler.
	    //
	    if (this.options.verifyClient) {
	      const info = {
	        origin:
	          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
	        secure: !!(req.socket.authorized || req.socket.encrypted),
	        req
	      };

	      if (this.options.verifyClient.length === 2) {
	        this.options.verifyClient(info, (verified, code, message, headers) => {
	          if (!verified) {
	            return abortHandshake(socket, code || 401, message, headers);
	          }

	          this.completeUpgrade(
	            extensions,
	            key,
	            protocols,
	            req,
	            socket,
	            head,
	            cb
	          );
	        });
	        return;
	      }

	      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
	    }

	    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
	  }

	  /**
	   * Upgrade the connection to WebSocket.
	   *
	   * @param {Object} extensions The accepted extensions
	   * @param {String} key The value of the `Sec-WebSocket-Key` header
	   * @param {Set} protocols The subprotocols
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @throws {Error} If called more than once with the same socket
	   * @private
	   */
	  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
	    //
	    // Destroy the socket if the client has already sent a FIN packet.
	    //
	    if (!socket.readable || !socket.writable) return socket.destroy();

	    if (socket[kWebSocket]) {
	      throw new Error(
	        'server.handleUpgrade() was called more than once with the same ' +
	          'socket, possibly due to a misconfiguration'
	      );
	    }

	    if (this._state > RUNNING) return abortHandshake(socket, 503);

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    const headers = [
	      'HTTP/1.1 101 Switching Protocols',
	      'Upgrade: websocket',
	      'Connection: Upgrade',
	      `Sec-WebSocket-Accept: ${digest}`
	    ];

	    const ws = new this.options.WebSocket(null, undefined, this.options);

	    if (protocols.size) {
	      //
	      // Optionally call external protocol selection handler.
	      //
	      const protocol = this.options.handleProtocols
	        ? this.options.handleProtocols(protocols, req)
	        : protocols.values().next().value;

	      if (protocol) {
	        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
	        ws._protocol = protocol;
	      }
	    }

	    if (extensions[PerMessageDeflate.extensionName]) {
	      const params = extensions[PerMessageDeflate.extensionName].params;
	      const value = extension.format({
	        [PerMessageDeflate.extensionName]: [params]
	      });
	      headers.push(`Sec-WebSocket-Extensions: ${value}`);
	      ws._extensions = extensions;
	    }

	    //
	    // Allow external modification/inspection of handshake headers.
	    //
	    this.emit('headers', headers, req);

	    socket.write(headers.concat('\r\n').join('\r\n'));
	    socket.removeListener('error', socketOnError);

	    ws.setSocket(socket, head, {
	      allowSynchronousEvents: this.options.allowSynchronousEvents,
	      maxPayload: this.options.maxPayload,
	      skipUTF8Validation: this.options.skipUTF8Validation
	    });

	    if (this.clients) {
	      this.clients.add(ws);
	      ws.on('close', () => {
	        this.clients.delete(ws);

	        if (this._shouldEmitClose && !this.clients.size) {
	          process.nextTick(emitClose, this);
	        }
	      });
	    }

	    cb(ws, req);
	  }
	}

	websocketServer$2 = WebSocketServer;

	/**
	 * Add event listeners on an `EventEmitter` using a map of <event, listener>
	 * pairs.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @param {Object.<String, Function>} map The listeners to add
	 * @return {Function} A function that will remove the added listeners when
	 *     called
	 * @private
	 */
	function addListeners(server, map) {
	  for (const event of Object.keys(map)) server.on(event, map[event]);

	  return function removeListeners() {
	    for (const event of Object.keys(map)) {
	      server.removeListener(event, map[event]);
	    }
	  };
	}

	/**
	 * Emit a `'close'` event on an `EventEmitter`.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @private
	 */
	function emitClose(server) {
	  server._state = CLOSED;
	  server.emit('close');
	}

	/**
	 * Handle socket errors.
	 *
	 * @private
	 */
	function socketOnError() {
	  this.destroy();
	}

	/**
	 * Close the connection when preconditions are not fulfilled.
	 *
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} [message] The HTTP response body
	 * @param {Object} [headers] Additional HTTP response headers
	 * @private
	 */
	function abortHandshake(socket, code, message, headers) {
	  //
	  // The socket is writable unless the user destroyed or ended it before calling
	  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
	  // error. Handling this does not make much sense as the worst that can happen
	  // is that some of the data written by the user might be discarded due to the
	  // call to `socket.end()` below, which triggers an `'error'` event that in
	  // turn causes the socket to be destroyed.
	  //
	  message = message || http.STATUS_CODES[code];
	  headers = {
	    Connection: 'close',
	    'Content-Type': 'text/html',
	    'Content-Length': Buffer.byteLength(message),
	    ...headers
	  };

	  socket.once('finish', socket.destroy);

	  socket.end(
	    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
	      Object.keys(headers)
	        .map((h) => `${h}: ${headers[h]}`)
	        .join('\r\n') +
	      '\r\n\r\n' +
	      message
	  );
	}

	/**
	 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	 * one listener for it, otherwise call `abortHandshake()`.
	 *
	 * @param {WebSocketServer} server The WebSocket server
	 * @param {http.IncomingMessage} req The request object
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} message The HTTP response body
	 * @private
	 */
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
	  if (server.listenerCount('wsClientError')) {
	    const err = new Error(message);
	    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

	    server.emit('wsClientError', err, socket, req);
	  } else {
	    abortHandshake(socket, code, message);
	  }
	}
	return websocketServer$2;
}

var websocketServerExports = requireWebsocketServer();
const _WebSocketServer = /*@__PURE__*/getDefaultExportFromCjs$1(websocketServerExports);

const nodeAdapter = (options = {}) => {
  const hooks = new AdapterHookable(options);
  const peers = /* @__PURE__ */ new Set();
  const wss = options.wss || new _WebSocketServer({
    noServer: true,
    ...options.serverOptions
  });
  wss.on("connection", (ws, nodeReq) => {
    const request = new NodeReqProxy(nodeReq);
    const peer = new NodePeer({ ws, request, peers, nodeReq });
    peers.add(peer);
    hooks.callHook("open", peer);
    ws.on("message", (data) => {
      if (Array.isArray(data)) {
        data = Buffer.concat(data);
      }
      hooks.callHook("message", peer, new Message(data, peer));
    });
    ws.on("error", (error) => {
      peers.delete(peer);
      hooks.callHook("error", peer, new WSError(error));
    });
    ws.on("close", (code, reason) => {
      peers.delete(peer);
      hooks.callHook("close", peer, {
        code,
        reason: reason?.toString()
      });
    });
  });
  wss.on("headers", (outgoingHeaders, req) => {
    const upgradeHeaders = req._upgradeHeaders;
    if (upgradeHeaders) {
      for (const [key, value] of new Headers(upgradeHeaders)) {
        outgoingHeaders.push(`${key}: ${value}`);
      }
    }
  });
  return {
    ...adapterUtils(peers),
    handleUpgrade: async (nodeReq, socket, head) => {
      const request = new NodeReqProxy(nodeReq);
      const { upgradeHeaders, endResponse, context } = await hooks.upgrade(request);
      if (endResponse) {
        return sendResponse(socket, endResponse);
      }
      nodeReq._request = request;
      nodeReq._upgradeHeaders = upgradeHeaders;
      nodeReq._context = context;
      wss.handleUpgrade(nodeReq, socket, head, (ws) => {
        wss.emit("connection", ws, nodeReq);
      });
    },
    closeAll: (code, data, force) => {
      for (const client of wss.clients) {
        if (force) {
          client.terminate();
        } else {
          client.close(code, data);
        }
      }
    }
  };
};
class NodePeer extends Peer {
  get remoteAddress() {
    return this._internal.nodeReq.socket?.remoteAddress;
  }
  get context() {
    return this._internal.nodeReq._context;
  }
  send(data, options) {
    const dataBuff = toBufferLike(data);
    const isBinary = typeof dataBuff !== "string";
    this._internal.ws.send(dataBuff, {
      compress: options?.compress,
      binary: isBinary,
      ...options
    });
    return 0;
  }
  publish(topic, data, options) {
    const dataBuff = toBufferLike(data);
    const isBinary = typeof data !== "string";
    const sendOptions = {
      compress: options?.compress,
      binary: isBinary,
      ...options
    };
    for (const peer of this._internal.peers) {
      if (peer !== this && peer._topics.has(topic)) {
        peer._internal.ws.send(dataBuff, sendOptions);
      }
    }
  }
  close(code, data) {
    this._internal.ws.close(code, data);
  }
  terminate() {
    this._internal.ws.terminate();
  }
}
class NodeReqProxy {
  _req;
  _headers;
  _url;
  constructor(req) {
    this._req = req;
  }
  get url() {
    if (!this._url) {
      const req = this._req;
      const host = req.headers["host"] || "localhost";
      const isSecure = req.socket?.encrypted ?? req.headers["x-forwarded-proto"] === "https";
      this._url = `${isSecure ? "https" : "http"}://${host}${req.url}`;
    }
    return this._url;
  }
  get headers() {
    if (!this._headers) {
      this._headers = new Headers(this._req.headers);
    }
    return this._headers;
  }
}
async function sendResponse(socket, res) {
  const head = [
    `HTTP/1.1 ${res.status || 200} ${res.statusText || ""}`,
    ...[...res.headers.entries()].map(
      ([key, value]) => `${encodeURIComponent(key)}: ${encodeURIComponent(value)}`
    )
  ];
  socket.write(head.join("\r\n") + "\r\n\r\n");
  if (res.body) {
    for await (const chunk of res.body) {
      socket.write(chunk);
    }
  }
  return new Promise((resolve) => {
    socket.end(() => {
      socket.destroy();
      resolve();
    });
  });
}

const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const PLUS_RE = /\+/g;
const ENC_CARET_RE = /%5e/gi;
const ENC_BACKTICK_RE = /%60/gi;
const ENC_PIPE_RE = /%7c/gi;
const ENC_SPACE_RE = /%20/gi;
const ENC_SLASH_RE = /%2f/gi;
function encode$1(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode$1(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function decode$6(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodePath(text) {
  return decode$6(text.replace(ENC_SLASH_RE, "%252F"));
}
function decodeQueryKey(text) {
  return decode$6(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode$6(text.replace(PLUS_RE, " "));
}

function parseQuery(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}

const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
const PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
const PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i;
const TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
const JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function isScriptProtocol(protocol) {
  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
  }
  const [s0, ...s] = path.split("?");
  const cleanPath = s0.endsWith("/") ? s0.slice(0, -1) : s0;
  return (cleanPath || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s0, ...s] = path.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function hasLeadingSlash(input = "") {
  return input.startsWith("/");
}
function withLeadingSlash(input = "") {
  return hasLeadingSlash(input) ? input : "/" + input;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withoutBase(input, base) {
  if (isEmptyURL(base)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (!input.startsWith(_base)) {
    return input;
  }
  const trimmed = input.slice(_base.length);
  return trimmed[0] === "/" ? trimmed : "/" + trimmed;
}
function withQuery(input, query) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function getQuery$1(input) {
  return parseQuery(parseURL(input).search);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
function joinRelativeURL(..._input) {
  const JOIN_SEGMENT_SPLIT_RE = /\/(?!\/)/;
  const input = _input.filter(Boolean);
  const segments = [];
  let segmentsDepth = 0;
  for (const i of input) {
    if (!i || i === "/") {
      continue;
    }
    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {
      if (!s || s === ".") {
        continue;
      }
      if (s === "..") {
        if (segments.length === 1 && hasProtocol(segments[0])) {
          continue;
        }
        segments.pop();
        segmentsDepth--;
        continue;
      }
      if (sindex === 1 && segments[segments.length - 1]?.endsWith(":/")) {
        segments[segments.length - 1] += "/" + s;
        continue;
      }
      segments.push(s);
      segmentsDepth++;
    }
  }
  let url = segments.join("/");
  if (segmentsDepth >= 0) {
    if (input[0]?.startsWith("/") && !url.startsWith("/")) {
      url = "/" + url;
    } else if (input[0]?.startsWith("./") && !url.startsWith("./")) {
      url = "./" + url;
    }
  } else {
    url = "../".repeat(-1 * segmentsDepth) + url;
  }
  if (input[input.length - 1]?.endsWith("/") && !url.endsWith("/")) {
    url += "/";
  }
  return url;
}

const protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}

function parse$i(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  const obj = {};
  const opt = {};
  const dec = opt.decode || decode$5;
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if (opt?.filter && !opt?.filter(key)) {
      index = endIdx + 1;
      continue;
    }
    if (void 0 === obj[key]) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.codePointAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode$2(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
}
function decode$5(str) {
  return str.includes("%") ? decodeURIComponent(str) : str;
}
function tryDecode$2(str, decode2) {
  try {
    return decode2(str);
  } catch {
    return str;
  }
}

const fieldContentRegExp = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
function serialize$3(name, value, options) {
  const opt = options || {};
  const enc = opt.encode || encodeURIComponent;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  const encodedValue = enc(value);
  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {
    throw new TypeError("argument val is invalid");
  }
  let str = name + "=" + encodedValue;
  if (void 0 !== opt.maxAge && opt.maxAge !== null) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge) || !Number.isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (!isDate$1(opt.expires) || Number.isNaN(opt.expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    const priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low": {
        str += "; Priority=Low";
        break;
      }
      case "medium": {
        str += "; Priority=Medium";
        break;
      }
      case "high": {
        str += "; Priority=High";
        break;
      }
      default: {
        throw new TypeError("option priority is invalid");
      }
    }
  }
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true: {
        str += "; SameSite=Strict";
        break;
      }
      case "lax": {
        str += "; SameSite=Lax";
        break;
      }
      case "strict": {
        str += "; SameSite=Strict";
        break;
      }
      case "none": {
        str += "; SameSite=None";
        break;
      }
      default: {
        throw new TypeError("option sameSite is invalid");
      }
    }
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  return str;
}
function isDate$1(val) {
  return Object.prototype.toString.call(val) === "[object Date]" || val instanceof Date;
}

function parseSetCookie(setCookieValue, options) {
  const parts = (setCookieValue || "").split(";").filter((str) => typeof str === "string" && !!str.trim());
  const nameValuePairStr = parts.shift() || "";
  const parsed = _parseNameValuePair(nameValuePairStr);
  const name = parsed.name;
  let value = parsed.value;
  try {
    value = options?.decode === false ? value : (options?.decode || decodeURIComponent)(value);
  } catch {
  }
  const cookie = {
    name,
    value
  };
  for (const part of parts) {
    const sides = part.split("=");
    const partKey = (sides.shift() || "").trimStart().toLowerCase();
    const partValue = sides.join("=");
    switch (partKey) {
      case "expires": {
        cookie.expires = new Date(partValue);
        break;
      }
      case "max-age": {
        cookie.maxAge = Number.parseInt(partValue, 10);
        break;
      }
      case "secure": {
        cookie.secure = true;
        break;
      }
      case "httponly": {
        cookie.httpOnly = true;
        break;
      }
      case "samesite": {
        cookie.sameSite = partValue;
        break;
      }
      default: {
        cookie[partKey] = partValue;
      }
    }
  }
  return cookie;
}
function _parseNameValuePair(nameValuePairStr) {
  let name = "";
  let value = "";
  const nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("=");
  } else {
    value = nameValuePairStr;
  }
  return { name, value };
}

const NODE_TYPES = {
  NORMAL: 0,
  WILDCARD: 1,
  PLACEHOLDER: 2
};

function createRouter$1(options = {}) {
  const ctx = {
    options,
    rootNode: createRadixNode(),
    staticRoutesMap: {}
  };
  const normalizeTrailingSlash = (p) => options.strictTrailingSlash ? p : p.replace(/\/$/, "") || "/";
  if (options.routes) {
    for (const path in options.routes) {
      insert(ctx, normalizeTrailingSlash(path), options.routes[path]);
    }
  }
  return {
    ctx,
    lookup: (path) => lookup(ctx, normalizeTrailingSlash(path)),
    insert: (path, data) => insert(ctx, normalizeTrailingSlash(path), data),
    remove: (path) => remove(ctx, normalizeTrailingSlash(path))
  };
}
function lookup(ctx, path) {
  const staticPathNode = ctx.staticRoutesMap[path];
  if (staticPathNode) {
    return staticPathNode.data;
  }
  const sections = path.split("/");
  const params = {};
  let paramsFound = false;
  let wildcardNode = null;
  let node = ctx.rootNode;
  let wildCardParam = null;
  for (let i = 0; i < sections.length; i++) {
    const section = sections[i];
    if (node.wildcardChildNode !== null) {
      wildcardNode = node.wildcardChildNode;
      wildCardParam = sections.slice(i).join("/");
    }
    const nextNode = node.children.get(section);
    if (nextNode === void 0) {
      if (node && node.placeholderChildren.length > 1) {
        const remaining = sections.length - i;
        node = node.placeholderChildren.find((c) => c.maxDepth === remaining) || null;
      } else {
        node = node.placeholderChildren[0] || null;
      }
      if (!node) {
        break;
      }
      if (node.paramName) {
        params[node.paramName] = section;
      }
      paramsFound = true;
    } else {
      node = nextNode;
    }
  }
  if ((node === null || node.data === null) && wildcardNode !== null) {
    node = wildcardNode;
    params[node.paramName || "_"] = wildCardParam;
    paramsFound = true;
  }
  if (!node) {
    return null;
  }
  if (paramsFound) {
    return {
      ...node.data,
      params: paramsFound ? params : void 0
    };
  }
  return node.data;
}
function insert(ctx, path, data) {
  let isStaticRoute = true;
  const sections = path.split("/");
  let node = ctx.rootNode;
  let _unnamedPlaceholderCtr = 0;
  const matchedNodes = [node];
  for (const section of sections) {
    let childNode;
    if (childNode = node.children.get(section)) {
      node = childNode;
    } else {
      const type = getNodeType(section);
      childNode = createRadixNode({ type, parent: node });
      node.children.set(section, childNode);
      if (type === NODE_TYPES.PLACEHOLDER) {
        childNode.paramName = section === "*" ? `_${_unnamedPlaceholderCtr++}` : section.slice(1);
        node.placeholderChildren.push(childNode);
        isStaticRoute = false;
      } else if (type === NODE_TYPES.WILDCARD) {
        node.wildcardChildNode = childNode;
        childNode.paramName = section.slice(
          3
          /* "**:" */
        ) || "_";
        isStaticRoute = false;
      }
      matchedNodes.push(childNode);
      node = childNode;
    }
  }
  for (const [depth, node2] of matchedNodes.entries()) {
    node2.maxDepth = Math.max(matchedNodes.length - depth, node2.maxDepth || 0);
  }
  node.data = data;
  if (isStaticRoute === true) {
    ctx.staticRoutesMap[path] = node;
  }
  return node;
}
function remove(ctx, path) {
  let success = false;
  const sections = path.split("/");
  let node = ctx.rootNode;
  for (const section of sections) {
    node = node.children.get(section);
    if (!node) {
      return success;
    }
  }
  if (node.data) {
    const lastSection = sections.at(-1) || "";
    node.data = null;
    if (Object.keys(node.children).length === 0 && node.parent) {
      node.parent.children.delete(lastSection);
      node.parent.wildcardChildNode = null;
      node.parent.placeholderChildren = [];
    }
    success = true;
  }
  return success;
}
function createRadixNode(options = {}) {
  return {
    type: options.type || NODE_TYPES.NORMAL,
    maxDepth: 0,
    parent: options.parent || null,
    children: /* @__PURE__ */ new Map(),
    data: options.data || null,
    paramName: options.paramName || null,
    wildcardChildNode: null,
    placeholderChildren: []
  };
}
function getNodeType(str) {
  if (str.startsWith("**")) {
    return NODE_TYPES.WILDCARD;
  }
  if (str[0] === ":" || str === "*") {
    return NODE_TYPES.PLACEHOLDER;
  }
  return NODE_TYPES.NORMAL;
}

function toRouteMatcher(router) {
  const table = _routerNodeToTable("", router.ctx.rootNode);
  return _createMatcher(table, router.ctx.options.strictTrailingSlash);
}
function _createMatcher(table, strictTrailingSlash) {
  return {
    ctx: { table },
    matchAll: (path) => _matchRoutes(path, table, strictTrailingSlash)
  };
}
function _createRouteTable() {
  return {
    static: /* @__PURE__ */ new Map(),
    wildcard: /* @__PURE__ */ new Map(),
    dynamic: /* @__PURE__ */ new Map()
  };
}
function _matchRoutes(path, table, strictTrailingSlash) {
  if (strictTrailingSlash !== true && path.endsWith("/")) {
    path = path.slice(0, -1) || "/";
  }
  const matches = [];
  for (const [key, value] of _sortRoutesMap(table.wildcard)) {
    if (path === key || path.startsWith(key + "/")) {
      matches.push(value);
    }
  }
  for (const [key, value] of _sortRoutesMap(table.dynamic)) {
    if (path.startsWith(key + "/")) {
      const subPath = "/" + path.slice(key.length).split("/").splice(2).join("/");
      matches.push(..._matchRoutes(subPath, value));
    }
  }
  const staticMatch = table.static.get(path);
  if (staticMatch) {
    matches.push(staticMatch);
  }
  return matches.filter(Boolean);
}
function _sortRoutesMap(m) {
  return [...m.entries()].sort((a, b) => a[0].length - b[0].length);
}
function _routerNodeToTable(initialPath, initialNode) {
  const table = _createRouteTable();
  function _addNode(path, node) {
    if (path) {
      if (node.type === NODE_TYPES.NORMAL && !(path.includes("*") || path.includes(":"))) {
        if (node.data) {
          table.static.set(path, node.data);
        }
      } else if (node.type === NODE_TYPES.WILDCARD) {
        table.wildcard.set(path.replace("/**", ""), node.data);
      } else if (node.type === NODE_TYPES.PLACEHOLDER) {
        const subTable = _routerNodeToTable("", node);
        if (node.data) {
          subTable.static.set("/", node.data);
        }
        table.dynamic.set(path.replace(/\/\*|\/:\w+/, ""), subTable);
        return;
      }
    }
    for (const [childPath, child] of node.children.entries()) {
      _addNode(`${path}/${childPath}`.replace("//", "/"), child);
    }
  }
  _addNode(initialPath, initialNode);
  return table;
}

function isPlainObject$2(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject$2(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject$2(value) && isPlainObject$2(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();
const defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

function o(n){throw new Error(`${n} is not implemented yet!`)}let i$3 = class i extends EventEmitter$a{__unenv__={};readableEncoding=null;readableEnded=true;readableFlowing=false;readableHighWaterMark=0;readableLength=0;readableObjectMode=false;readableAborted=false;readableDidRead=false;closed=false;errored=null;readable=false;destroyed=false;static from(e,t){return new i(t)}constructor(e){super();}_read(e){}read(e){}setEncoding(e){return this}pause(){return this}resume(){return this}isPaused(){return  true}unpipe(e){return this}unshift(e,t){}wrap(e){return this}push(e,t){return  false}_destroy(e,t){this.removeAllListeners();}destroy(e){return this.destroyed=true,this._destroy(e),this}pipe(e,t){return {}}compose(e,t){throw new Error("Method not implemented.")}[Symbol.asyncDispose](){return this.destroy(),Promise.resolve()}async*[Symbol.asyncIterator](){throw o("Readable.asyncIterator")}iterator(e){throw o("Readable.iterator")}map(e,t){throw o("Readable.map")}filter(e,t){throw o("Readable.filter")}forEach(e,t){throw o("Readable.forEach")}reduce(e,t,r){throw o("Readable.reduce")}find(e,t){throw o("Readable.find")}findIndex(e,t){throw o("Readable.findIndex")}some(e,t){throw o("Readable.some")}toArray(e){throw o("Readable.toArray")}every(e,t){throw o("Readable.every")}flatMap(e,t){throw o("Readable.flatMap")}drop(e,t){throw o("Readable.drop")}take(e,t){throw o("Readable.take")}asIndexedPairs(e){throw o("Readable.asIndexedPairs")}};let l$1 = class l extends EventEmitter$a{__unenv__={};writable=true;writableEnded=false;writableFinished=false;writableHighWaterMark=0;writableLength=0;writableObjectMode=false;writableCorked=0;closed=false;errored=null;writableNeedDrain=false;writableAborted=false;destroyed=false;_data;_encoding="utf8";constructor(e){super();}pipe(e,t){return {}}_write(e,t,r){if(this.writableEnded){r&&r();return}if(this._data===void 0)this._data=e;else {const s=typeof this._data=="string"?Buffer$8.from(this._data,this._encoding||t||"utf8"):this._data,a=typeof e=="string"?Buffer$8.from(e,t||this._encoding||"utf8"):e;this._data=Buffer$8.concat([s,a]);}this._encoding=t,r&&r();}_writev(e,t){}_destroy(e,t){}_final(e){}write(e,t,r){const s=typeof t=="string"?this._encoding:"utf8",a=typeof t=="function"?t:typeof r=="function"?r:void 0;return this._write(e,s,a),true}setDefaultEncoding(e){return this}end(e,t,r){const s=typeof e=="function"?e:typeof t=="function"?t:typeof r=="function"?r:void 0;if(this.writableEnded)return s&&s(),this;const a=e===s?void 0:e;if(a){const u=t===s?void 0:t;this.write(a,u,s);}return this.writableEnded=true,this.writableFinished=true,this.emit("close"),this.emit("finish"),this}cork(){}uncork(){}destroy(e){return this.destroyed=true,delete this._data,this.removeAllListeners(),this}compose(e,t){throw new Error("Method not implemented.")}[Symbol.asyncDispose](){return Promise.resolve()}};const c$1=class c{allowHalfOpen=true;_destroy;constructor(e=new i$3,t=new l$1){Object.assign(this,e),Object.assign(this,t),this._destroy=m$1(e._destroy,t._destroy);}};function _(){return Object.assign(c$1.prototype,i$3.prototype),Object.assign(c$1.prototype,l$1.prototype),c$1}function m$1(...n){return function(...e){for(const t of n)t(...e);}}const g=_();class A extends g{__unenv__={};bufferSize=0;bytesRead=0;bytesWritten=0;connecting=false;destroyed=false;pending=false;localAddress="";localPort=0;remoteAddress="";remoteFamily="";remotePort=0;autoSelectFamilyAttemptedAddresses=[];readyState="readOnly";constructor(e){super();}write(e,t,r){return  false}connect(e,t,r){return this}end(e,t,r){return this}setEncoding(e){return this}pause(){return this}resume(){return this}setTimeout(e,t){return this}setNoDelay(e){return this}setKeepAlive(e,t){return this}address(){return {}}unref(){return this}ref(){return this}destroySoon(){this.destroy();}resetAndDestroy(){const e=new Error("ERR_SOCKET_CLOSED");return e.code="ERR_SOCKET_CLOSED",this.destroy(e),this}}let y$1 = class y extends i$3{aborted=false;httpVersion="1.1";httpVersionMajor=1;httpVersionMinor=1;complete=true;connection;socket;headers={};trailers={};method="GET";url="/";statusCode=200;statusMessage="";closed=false;errored=null;readable=false;constructor(e){super(),this.socket=this.connection=e||new A;}get rawHeaders(){const e=this.headers,t=[];for(const r in e)if(Array.isArray(e[r]))for(const s of e[r])t.push(r,s);else t.push(r,e[r]);return t}get rawTrailers(){return []}setTimeout(e,t){return this}get headersDistinct(){return p(this.headers)}get trailersDistinct(){return p(this.trailers)}};function p(n){const e={};for(const[t,r]of Object.entries(n))t&&(e[t]=(Array.isArray(r)?r:[r]).filter(Boolean));return e}let w$1 = class w extends l$1{statusCode=200;statusMessage="";upgrading=false;chunkedEncoding=false;shouldKeepAlive=false;useChunkedEncodingByDefault=false;sendDate=false;finished=false;headersSent=false;strictContentLength=false;connection=null;socket=null;req;_headers={};constructor(e){super(),this.req=e;}assignSocket(e){e._httpMessage=this,this.socket=e,this.connection=e,this.emit("socket",e),this._flush();}_flush(){this.flushHeaders();}detachSocket(e){}writeContinue(e){}writeHead(e,t,r){e&&(this.statusCode=e),typeof t=="string"&&(this.statusMessage=t,t=void 0);const s=r||t;if(s&&!Array.isArray(s))for(const a in s)this.setHeader(a,s[a]);return this.headersSent=true,this}writeProcessing(){}setTimeout(e,t){return this}appendHeader(e,t){e=e.toLowerCase();const r=this._headers[e],s=[...Array.isArray(r)?r:[r],...Array.isArray(t)?t:[t]].filter(Boolean);return this._headers[e]=s.length>1?s:s[0],this}setHeader(e,t){return this._headers[e.toLowerCase()]=t,this}setHeaders(e){for(const[t,r]of Object.entries(e))this.setHeader(t,r);return this}getHeader(e){return this._headers[e.toLowerCase()]}getHeaders(){return this._headers}getHeaderNames(){return Object.keys(this._headers)}hasHeader(e){return e.toLowerCase()in this._headers}removeHeader(e){delete this._headers[e.toLowerCase()];}addTrailers(e){}flushHeaders(){}writeEarlyHints(e,t){typeof t=="function"&&t();}};const E=(()=>{const n=function(){};return n.prototype=Object.create(null),n})();function R(n={}){const e=new E,t=Array.isArray(n)||H(n)?n:Object.entries(n);for(const[r,s]of t)if(s){if(e[r]===void 0){e[r]=s;continue}e[r]=[...Array.isArray(e[r])?e[r]:[e[r]],...Array.isArray(s)?s:[s]];}return e}function H(n){return typeof n?.entries=="function"}function v(n={}){if(n instanceof Headers)return n;const e=new Headers;for(const[t,r]of Object.entries(n))if(r!==void 0){if(Array.isArray(r)){for(const s of r)e.append(t,String(s));continue}e.set(t,String(r));}return e}const S=new Set([101,204,205,304]);async function b(n,e){const t=new y$1,r=new w$1(t);t.url=e.url?.toString()||"/";let s;if(!t.url.startsWith("/")){const d=new URL(t.url);s=d.host,t.url=d.pathname+d.search+d.hash;}t.method=e.method||"GET",t.headers=R(e.headers||{}),t.headers.host||(t.headers.host=e.host||s||"localhost"),t.connection.encrypted=t.connection.encrypted||e.protocol==="https",t.body=e.body||null,t.__unenv__=e.context,await n(t,r);let a=r._data;(S.has(r.statusCode)||t.method.toUpperCase()==="HEAD")&&(a=null,delete r._headers["content-length"]);const u={status:r.statusCode,statusText:r.statusMessage,headers:r._headers,body:a};return t.destroy(),r.destroy(),u}async function C(n,e,t={}){try{const r=await b(n,{url:e,...t});return new Response(r.body,{status:r.status,statusText:r.statusText,headers:v(r.headers)})}catch(r){return new Response(r.toString(),{status:Number.parseInt(r.statusCode||r.code)||500,statusText:r.statusText})}}

function hasProp(obj, prop) {
  try {
    return prop in obj;
  } catch {
    return false;
  }
}

class H3Error extends Error {
  static __h3_error__ = true;
  statusCode = 500;
  fatal = false;
  unhandled = false;
  statusMessage;
  data;
  cause;
  constructor(message, opts = {}) {
    super(message, opts);
    if (opts.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
  toJSON() {
    const obj = {
      message: this.message,
      statusCode: sanitizeStatusCode(this.statusCode, 500)
    };
    if (this.statusMessage) {
      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);
    }
    if (this.data !== void 0) {
      obj.data = this.data;
    }
    return obj;
  }
}
function createError$2(input) {
  if (typeof input === "string") {
    return new H3Error(input);
  }
  if (isError(input)) {
    return input;
  }
  const err = new H3Error(input.message ?? input.statusMessage ?? "", {
    cause: input.cause || input
  });
  if (hasProp(input, "stack")) {
    try {
      Object.defineProperty(err, "stack", {
        get() {
          return input.stack;
        }
      });
    } catch {
      try {
        err.stack = input.stack;
      } catch {
      }
    }
  }
  if (input.data) {
    err.data = input.data;
  }
  if (input.statusCode) {
    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);
  } else if (input.status) {
    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);
  }
  if (input.statusMessage) {
    err.statusMessage = input.statusMessage;
  } else if (input.statusText) {
    err.statusMessage = input.statusText;
  }
  if (err.statusMessage) {
    const originalMessage = err.statusMessage;
    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);
    if (sanitizedMessage !== originalMessage) {
      console.warn(
        "[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default."
      );
    }
  }
  if (input.fatal !== void 0) {
    err.fatal = input.fatal;
  }
  if (input.unhandled !== void 0) {
    err.unhandled = input.unhandled;
  }
  return err;
}
function sendError(event, error, debug) {
  if (event.handled) {
    return;
  }
  const h3Error = isError(error) ? error : createError$2(error);
  const responseBody = {
    statusCode: h3Error.statusCode,
    statusMessage: h3Error.statusMessage,
    stack: [],
    data: h3Error.data
  };
  if (debug) {
    responseBody.stack = (h3Error.stack || "").split("\n").map((l) => l.trim());
  }
  if (event.handled) {
    return;
  }
  const _code = Number.parseInt(h3Error.statusCode);
  setResponseStatus(event, _code, h3Error.statusMessage);
  event.node.res.setHeader("content-type", MIMES.json);
  event.node.res.end(JSON.stringify(responseBody, void 0, 2));
}
function isError(input) {
  return input?.constructor?.__h3_error__ === true;
}

function parse$h(multipartBodyBuffer, boundary) {
  let lastline = "";
  let state = 0 /* INIT */;
  let buffer = [];
  const allParts = [];
  let currentPartHeaders = [];
  for (let i = 0; i < multipartBodyBuffer.length; i++) {
    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;
    const currByte = multipartBodyBuffer[i];
    const newLineChar = currByte === 10 || currByte === 13;
    if (!newLineChar) {
      lastline += String.fromCodePoint(currByte);
    }
    const newLineDetected = currByte === 10 && prevByte === 13;
    if (0 /* INIT */ === state && newLineDetected) {
      if ("--" + boundary === lastline) {
        state = 1 /* READING_HEADERS */;
      }
      lastline = "";
    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {
      if (lastline.length > 0) {
        const i2 = lastline.indexOf(":");
        if (i2 > 0) {
          const name = lastline.slice(0, i2).toLowerCase();
          const value = lastline.slice(i2 + 1).trim();
          currentPartHeaders.push([name, value]);
        }
      } else {
        state = 2 /* READING_DATA */;
        buffer = [];
      }
      lastline = "";
    } else if (2 /* READING_DATA */ === state) {
      if (lastline.length > boundary.length + 4) {
        lastline = "";
      }
      if ("--" + boundary === lastline) {
        const j = buffer.length - lastline.length;
        const part = buffer.slice(0, j - 1);
        allParts.push(process$4(part, currentPartHeaders));
        buffer = [];
        currentPartHeaders = [];
        lastline = "";
        state = 3 /* READING_PART_SEPARATOR */;
      } else {
        buffer.push(currByte);
      }
      if (newLineDetected) {
        lastline = "";
      }
    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {
      state = 1 /* READING_HEADERS */;
    }
  }
  return allParts;
}
function process$4(data, headers) {
  const dataObj = {};
  const contentDispositionHeader = headers.find((h) => h[0] === "content-disposition")?.[1] || "";
  for (const i of contentDispositionHeader.split(";")) {
    const s = i.split("=");
    if (s.length !== 2) {
      continue;
    }
    const key = (s[0] || "").trim();
    if (key === "name" || key === "filename") {
      const _value = (s[1] || "").trim().replace(/"/g, "");
      dataObj[key] = Buffer.from(_value, "latin1").toString("utf8");
    }
  }
  const contentType = headers.find((h) => h[0] === "content-type")?.[1] || "";
  if (contentType) {
    dataObj.type = contentType;
  }
  dataObj.data = Buffer.from(data);
  return dataObj;
}

function getQuery(event) {
  return getQuery$1(event.path || "");
}
function getRouterParams(event, opts = {}) {
  let params = event.context.params || {};
  if (opts.decode) {
    params = { ...params };
    for (const key in params) {
      params[key] = decode$6(params[key]);
    }
  }
  return params;
}
function getRouterParam(event, name, opts = {}) {
  const params = getRouterParams(event, opts);
  return params[name];
}
function isMethod(event, expected, allowHead) {
  if (typeof expected === "string") {
    if (event.method === expected) {
      return true;
    }
  } else if (expected.includes(event.method)) {
    return true;
  }
  return false;
}
function assertMethod(event, expected, allowHead) {
  if (!isMethod(event, expected)) {
    throw createError$2({
      statusCode: 405,
      statusMessage: "HTTP method is not allowed."
    });
  }
}
function getRequestHeaders(event) {
  const _headers = {};
  for (const key in event.node.req.headers) {
    const val = event.node.req.headers[key];
    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(", ") : val;
  }
  return _headers;
}
function getRequestHeader(event, name) {
  const headers = getRequestHeaders(event);
  const value = headers[name.toLowerCase()];
  return value;
}
const getHeader = getRequestHeader;
function getRequestHost(event, opts = {}) {
  if (opts.xForwardedHost) {
    const _header = event.node.req.headers["x-forwarded-host"];
    const xForwardedHost = (_header || "").split(",").shift()?.trim();
    if (xForwardedHost) {
      return xForwardedHost;
    }
  }
  return event.node.req.headers.host || "localhost";
}
function getRequestProtocol(event, opts = {}) {
  if (opts.xForwardedProto !== false && event.node.req.headers["x-forwarded-proto"] === "https") {
    return "https";
  }
  return event.node.req.connection?.encrypted ? "https" : "http";
}
function getRequestURL(event, opts = {}) {
  const host = getRequestHost(event, opts);
  const protocol = getRequestProtocol(event, opts);
  const path = (event.node.req.originalUrl || event.path).replace(
    /^[/\\]+/g,
    "/"
  );
  return new URL(path, `${protocol}://${host}`);
}

const RawBodySymbol = Symbol.for("h3RawBody");
const ParsedBodySymbol = Symbol.for("h3ParsedBody");
const PayloadMethods$1 = ["PATCH", "POST", "PUT", "DELETE"];
function readRawBody(event, encoding = "utf8") {
  assertMethod(event, PayloadMethods$1);
  const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.rawBody || event.node.req.body;
  if (_rawBody) {
    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {
      if (Buffer.isBuffer(_resolved)) {
        return _resolved;
      }
      if (typeof _resolved.pipeTo === "function") {
        return new Promise((resolve, reject) => {
          const chunks = [];
          _resolved.pipeTo(
            new WritableStream({
              write(chunk) {
                chunks.push(chunk);
              },
              close() {
                resolve(Buffer.concat(chunks));
              },
              abort(reason) {
                reject(reason);
              }
            })
          ).catch(reject);
        });
      } else if (typeof _resolved.pipe === "function") {
        return new Promise((resolve, reject) => {
          const chunks = [];
          _resolved.on("data", (chunk) => {
            chunks.push(chunk);
          }).on("end", () => {
            resolve(Buffer.concat(chunks));
          }).on("error", reject);
        });
      }
      if (_resolved.constructor === Object) {
        return Buffer.from(JSON.stringify(_resolved));
      }
      if (_resolved instanceof URLSearchParams) {
        return Buffer.from(_resolved.toString());
      }
      if (_resolved instanceof FormData) {
        return new Response(_resolved).bytes().then((uint8arr) => Buffer.from(uint8arr));
      }
      return Buffer.from(_resolved);
    });
    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;
  }
  if (!Number.parseInt(event.node.req.headers["content-length"] || "") && !String(event.node.req.headers["transfer-encoding"] ?? "").split(",").map((e) => e.trim()).filter(Boolean).includes("chunked")) {
    return Promise.resolve(void 0);
  }
  const promise = event.node.req[RawBodySymbol] = new Promise(
    (resolve, reject) => {
      const bodyData = [];
      event.node.req.on("error", (err) => {
        reject(err);
      }).on("data", (chunk) => {
        bodyData.push(chunk);
      }).on("end", () => {
        resolve(Buffer.concat(bodyData));
      });
    }
  );
  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;
  return result;
}
async function readBody(event, options = {}) {
  const request = event.node.req;
  if (hasProp(request, ParsedBodySymbol)) {
    return request[ParsedBodySymbol];
  }
  const contentType = request.headers["content-type"] || "";
  const body = await readRawBody(event);
  let parsed;
  if (contentType === "application/json") {
    parsed = _parseJSON(body, options.strict ?? true);
  } else if (contentType.startsWith("application/x-www-form-urlencoded")) {
    parsed = _parseURLEncodedBody(body);
  } else if (contentType.startsWith("text/")) {
    parsed = body;
  } else {
    parsed = _parseJSON(body, options.strict ?? false);
  }
  request[ParsedBodySymbol] = parsed;
  return parsed;
}
async function readMultipartFormData(event) {
  const contentType = getRequestHeader(event, "content-type");
  if (!contentType || !contentType.startsWith("multipart/form-data")) {
    return;
  }
  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];
  if (!boundary) {
    return;
  }
  const body = await readRawBody(event, false);
  if (!body) {
    return;
  }
  return parse$h(body, boundary);
}
function getRequestWebStream(event) {
  if (!PayloadMethods$1.includes(event.method)) {
    return;
  }
  const bodyStream = event.web?.request?.body || event._requestBody;
  if (bodyStream) {
    return bodyStream;
  }
  const _hasRawBody = RawBodySymbol in event.node.req || "rawBody" in event.node.req || "body" in event.node.req || "__unenv__" in event.node.req;
  if (_hasRawBody) {
    return new ReadableStream({
      async start(controller) {
        const _rawBody = await readRawBody(event, false);
        if (_rawBody) {
          controller.enqueue(_rawBody);
        }
        controller.close();
      }
    });
  }
  return new ReadableStream({
    start: (controller) => {
      event.node.req.on("data", (chunk) => {
        controller.enqueue(chunk);
      });
      event.node.req.on("end", () => {
        controller.close();
      });
      event.node.req.on("error", (err) => {
        controller.error(err);
      });
    }
  });
}
function _parseJSON(body = "", strict) {
  if (!body) {
    return void 0;
  }
  try {
    return destr(body, { strict });
  } catch {
    throw createError$2({
      statusCode: 400,
      statusMessage: "Bad Request",
      message: "Invalid JSON body"
    });
  }
}
function _parseURLEncodedBody(body) {
  const form = new URLSearchParams(body);
  const parsedForm = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of form.entries()) {
    if (hasProp(parsedForm, key)) {
      if (!Array.isArray(parsedForm[key])) {
        parsedForm[key] = [parsedForm[key]];
      }
      parsedForm[key].push(value);
    } else {
      parsedForm[key] = value;
    }
  }
  return parsedForm;
}

function handleCacheHeaders(event, opts) {
  const cacheControls = ["public", ...opts.cacheControls || []];
  let cacheMatched = false;
  if (opts.maxAge !== void 0) {
    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);
  }
  if (opts.modifiedTime) {
    const modifiedTime = new Date(opts.modifiedTime);
    const ifModifiedSince = event.node.req.headers["if-modified-since"];
    event.node.res.setHeader("last-modified", modifiedTime.toUTCString());
    if (ifModifiedSince && new Date(ifModifiedSince) >= modifiedTime) {
      cacheMatched = true;
    }
  }
  if (opts.etag) {
    event.node.res.setHeader("etag", opts.etag);
    const ifNonMatch = event.node.req.headers["if-none-match"];
    if (ifNonMatch === opts.etag) {
      cacheMatched = true;
    }
  }
  event.node.res.setHeader("cache-control", cacheControls.join(", "));
  if (cacheMatched) {
    event.node.res.statusCode = 304;
    if (!event.handled) {
      event.node.res.end();
    }
    return true;
  }
  return false;
}

const MIMES = {
  html: "text/html",
  json: "application/json"
};

const DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;
function sanitizeStatusMessage(statusMessage = "") {
  return statusMessage.replace(DISALLOWED_STATUS_CHARS, "");
}
function sanitizeStatusCode(statusCode, defaultStatusCode = 200) {
  if (!statusCode) {
    return defaultStatusCode;
  }
  if (typeof statusCode === "string") {
    statusCode = Number.parseInt(statusCode, 10);
  }
  if (statusCode < 100 || statusCode > 999) {
    return defaultStatusCode;
  }
  return statusCode;
}

function getDistinctCookieKey(name, opts) {
  return [name, opts.domain || "", opts.path || "/"].join(";");
}

function parseCookies(event) {
  return parse$i(event.node.req.headers.cookie || "");
}
function getCookie(event, name) {
  return parseCookies(event)[name];
}
function setCookie(event, name, value, serializeOptions = {}) {
  if (!serializeOptions.path) {
    serializeOptions = { path: "/", ...serializeOptions };
  }
  const newCookie = serialize$3(name, value, serializeOptions);
  const currentCookies = splitCookiesString(
    event.node.res.getHeader("set-cookie")
  );
  if (currentCookies.length === 0) {
    event.node.res.setHeader("set-cookie", newCookie);
    return;
  }
  const newCookieKey = getDistinctCookieKey(name, serializeOptions);
  event.node.res.removeHeader("set-cookie");
  for (const cookie of currentCookies) {
    const parsed = parseSetCookie(cookie);
    const key = getDistinctCookieKey(parsed.name, parsed);
    if (key === newCookieKey) {
      continue;
    }
    event.node.res.appendHeader("set-cookie", cookie);
  }
  event.node.res.appendHeader("set-cookie", newCookie);
}
function deleteCookie(event, name, serializeOptions) {
  setCookie(event, name, "", {
    ...serializeOptions,
    maxAge: 0
  });
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString.flatMap((c) => splitCookiesString(c));
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  const cookiesStrings = [];
  let pos = 0;
  let start;
  let ch;
  let lastComma;
  let nextStart;
  let cookiesSeparatorFound;
  const skipWhitespace = () => {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  };
  const notSpecialChar = () => {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  };
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.slice(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.slice(start));
    }
  }
  return cookiesStrings;
}

const defer = typeof setImmediate === "undefined" ? (fn) => fn() : setImmediate;
function send(event, data, type) {
  if (type) {
    defaultContentType(event, type);
  }
  return new Promise((resolve) => {
    defer(() => {
      if (!event.handled) {
        event.node.res.end(data);
      }
      resolve();
    });
  });
}
function sendNoContent(event, code) {
  if (event.handled) {
    return;
  }
  if (!code && event.node.res.statusCode !== 200) {
    code = event.node.res.statusCode;
  }
  const _code = sanitizeStatusCode(code, 204);
  if (_code === 204) {
    event.node.res.removeHeader("content-length");
  }
  event.node.res.writeHead(_code);
  event.node.res.end();
}
function setResponseStatus(event, code, text) {
  if (code) {
    event.node.res.statusCode = sanitizeStatusCode(
      code,
      event.node.res.statusCode
    );
  }
  if (text) {
    event.node.res.statusMessage = sanitizeStatusMessage(text);
  }
}
function getResponseStatus(event) {
  return event.node.res.statusCode;
}
function getResponseStatusText(event) {
  return event.node.res.statusMessage;
}
function defaultContentType(event, type) {
  if (type && event.node.res.statusCode !== 304 && !event.node.res.getHeader("content-type")) {
    event.node.res.setHeader("content-type", type);
  }
}
function sendRedirect(event, location, code = 302) {
  event.node.res.statusCode = sanitizeStatusCode(
    code,
    event.node.res.statusCode
  );
  event.node.res.setHeader("location", location);
  const encodedLoc = location.replace(/"/g, "%22");
  const html = `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`;
  return send(event, html, MIMES.html);
}
function getResponseHeader(event, name) {
  return event.node.res.getHeader(name);
}
function setResponseHeaders(event, headers) {
  for (const [name, value] of Object.entries(headers)) {
    event.node.res.setHeader(
      name,
      value
    );
  }
}
const setHeaders = setResponseHeaders;
function setResponseHeader(event, name, value) {
  event.node.res.setHeader(name, value);
}
const setHeader = setResponseHeader;
function appendResponseHeader(event, name, value) {
  let current = event.node.res.getHeader(name);
  if (!current) {
    event.node.res.setHeader(name, value);
    return;
  }
  if (!Array.isArray(current)) {
    current = [current.toString()];
  }
  event.node.res.setHeader(name, [...current, value]);
}
function removeResponseHeader(event, name) {
  return event.node.res.removeHeader(name);
}
function isStream(data) {
  if (!data || typeof data !== "object") {
    return false;
  }
  if (typeof data.pipe === "function") {
    if (typeof data._read === "function") {
      return true;
    }
    if (typeof data.abort === "function") {
      return true;
    }
  }
  if (typeof data.pipeTo === "function") {
    return true;
  }
  return false;
}
function isWebResponse(data) {
  return typeof Response !== "undefined" && data instanceof Response;
}
function sendStream(event, stream) {
  if (!stream || typeof stream !== "object") {
    throw new Error("[h3] Invalid stream provided.");
  }
  event.node.res._data = stream;
  if (!event.node.res.socket) {
    event._handled = true;
    return Promise.resolve();
  }
  if (hasProp(stream, "pipeTo") && typeof stream.pipeTo === "function") {
    return stream.pipeTo(
      new WritableStream({
        write(chunk) {
          event.node.res.write(chunk);
        }
      })
    ).then(() => {
      event.node.res.end();
    });
  }
  if (hasProp(stream, "pipe") && typeof stream.pipe === "function") {
    return new Promise((resolve, reject) => {
      stream.pipe(event.node.res);
      if (stream.on) {
        stream.on("end", () => {
          event.node.res.end();
          resolve();
        });
        stream.on("error", (error) => {
          reject(error);
        });
      }
      event.node.res.on("close", () => {
        if (stream.abort) {
          stream.abort();
        }
      });
    });
  }
  throw new Error("[h3] Invalid or incompatible stream provided.");
}
function sendWebResponse(event, response) {
  for (const [key, value] of response.headers) {
    if (key === "set-cookie") {
      event.node.res.appendHeader(key, splitCookiesString(value));
    } else {
      event.node.res.setHeader(key, value);
    }
  }
  if (response.status) {
    event.node.res.statusCode = sanitizeStatusCode(
      response.status,
      event.node.res.statusCode
    );
  }
  if (response.statusText) {
    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
  }
  if (response.redirected) {
    event.node.res.setHeader("location", response.url);
  }
  if (!response.body) {
    event.node.res.end();
    return;
  }
  return sendStream(event, response.body);
}

const PayloadMethods = /* @__PURE__ */ new Set(["PATCH", "POST", "PUT", "DELETE"]);
const ignoredHeaders = /* @__PURE__ */ new Set([
  "transfer-encoding",
  "accept-encoding",
  "connection",
  "keep-alive",
  "upgrade",
  "expect",
  "host",
  "accept"
]);
async function proxyRequest(event, target, opts = {}) {
  let body;
  let duplex;
  if (PayloadMethods.has(event.method)) {
    if (opts.streamRequest) {
      body = getRequestWebStream(event);
      duplex = "half";
    } else {
      body = await readRawBody(event, false).catch(() => void 0);
    }
  }
  const method = opts.fetchOptions?.method || event.method;
  const fetchHeaders = mergeHeaders$1(
    getProxyRequestHeaders(event, { host: target.startsWith("/") }),
    opts.fetchOptions?.headers,
    opts.headers
  );
  return sendProxy(event, target, {
    ...opts,
    fetchOptions: {
      method,
      body,
      duplex,
      ...opts.fetchOptions,
      headers: fetchHeaders
    }
  });
}
async function sendProxy(event, target, opts = {}) {
  let response;
  try {
    response = await _getFetch(opts.fetch)(target, {
      headers: opts.headers,
      ignoreResponseError: true,
      // make $ofetch.raw transparent
      ...opts.fetchOptions
    });
  } catch (error) {
    throw createError$2({
      status: 502,
      statusMessage: "Bad Gateway",
      cause: error
    });
  }
  event.node.res.statusCode = sanitizeStatusCode(
    response.status,
    event.node.res.statusCode
  );
  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
  const cookies = [];
  for (const [key, value] of response.headers.entries()) {
    if (key === "content-encoding") {
      continue;
    }
    if (key === "content-length") {
      continue;
    }
    if (key === "set-cookie") {
      cookies.push(...splitCookiesString(value));
      continue;
    }
    event.node.res.setHeader(key, value);
  }
  if (cookies.length > 0) {
    event.node.res.setHeader(
      "set-cookie",
      cookies.map((cookie) => {
        if (opts.cookieDomainRewrite) {
          cookie = rewriteCookieProperty(
            cookie,
            opts.cookieDomainRewrite,
            "domain"
          );
        }
        if (opts.cookiePathRewrite) {
          cookie = rewriteCookieProperty(
            cookie,
            opts.cookiePathRewrite,
            "path"
          );
        }
        return cookie;
      })
    );
  }
  if (opts.onResponse) {
    await opts.onResponse(event, response);
  }
  if (response._data !== void 0) {
    return response._data;
  }
  if (event.handled) {
    return;
  }
  if (opts.sendStream === false) {
    const data = new Uint8Array(await response.arrayBuffer());
    return event.node.res.end(data);
  }
  if (response.body) {
    for await (const chunk of response.body) {
      event.node.res.write(chunk);
    }
  }
  return event.node.res.end();
}
function getProxyRequestHeaders(event, opts) {
  const headers = /* @__PURE__ */ Object.create(null);
  const reqHeaders = getRequestHeaders(event);
  for (const name in reqHeaders) {
    if (!ignoredHeaders.has(name) || name === "host" && opts?.host) {
      headers[name] = reqHeaders[name];
    }
  }
  return headers;
}
function fetchWithEvent(event, req, init, options) {
  return _getFetch(options?.fetch)(req, {
    ...init,
    context: init?.context || event.context,
    headers: {
      ...getProxyRequestHeaders(event, {
        host: typeof req === "string" && req.startsWith("/")
      }),
      ...init?.headers
    }
  });
}
function _getFetch(_fetch) {
  if (_fetch) {
    return _fetch;
  }
  if (globalThis.fetch) {
    return globalThis.fetch;
  }
  throw new Error(
    "fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js."
  );
}
function rewriteCookieProperty(header, map, property) {
  const _map = typeof map === "string" ? { "*": map } : map;
  return header.replace(
    new RegExp(`(;\\s*${property}=)([^;]+)`, "gi"),
    (match, prefix, previousValue) => {
      let newValue;
      if (previousValue in _map) {
        newValue = _map[previousValue];
      } else if ("*" in _map) {
        newValue = _map["*"];
      } else {
        return match;
      }
      return newValue ? prefix + newValue : "";
    }
  );
}
function mergeHeaders$1(defaults, ...inputs) {
  const _inputs = inputs.filter(Boolean);
  if (_inputs.length === 0) {
    return defaults;
  }
  const merged = new Headers(defaults);
  for (const input of _inputs) {
    const entries = Array.isArray(input) ? input : typeof input.entries === "function" ? input.entries() : Object.entries(input);
    for (const [key, value] of entries) {
      if (value !== void 0) {
        merged.set(key, value);
      }
    }
  }
  return merged;
}

class H3Event {
  "__is_event__" = true;
  // Context
  node;
  // Node
  web;
  // Web
  context = {};
  // Shared
  // Request
  _method;
  _path;
  _headers;
  _requestBody;
  // Response
  _handled = false;
  // Hooks
  _onBeforeResponseCalled;
  _onAfterResponseCalled;
  constructor(req, res) {
    this.node = { req, res };
  }
  // --- Request ---
  get method() {
    if (!this._method) {
      this._method = (this.node.req.method || "GET").toUpperCase();
    }
    return this._method;
  }
  get path() {
    return this._path || this.node.req.url || "/";
  }
  get headers() {
    if (!this._headers) {
      this._headers = _normalizeNodeHeaders(this.node.req.headers);
    }
    return this._headers;
  }
  // --- Respoonse ---
  get handled() {
    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;
  }
  respondWith(response) {
    return Promise.resolve(response).then(
      (_response) => sendWebResponse(this, _response)
    );
  }
  // --- Utils ---
  toString() {
    return `[${this.method}] ${this.path}`;
  }
  toJSON() {
    return this.toString();
  }
  // --- Deprecated ---
  /** @deprecated Please use `event.node.req` instead. */
  get req() {
    return this.node.req;
  }
  /** @deprecated Please use `event.node.res` instead. */
  get res() {
    return this.node.res;
  }
}
function isEvent(input) {
  return hasProp(input, "__is_event__");
}
function createEvent(req, res) {
  return new H3Event(req, res);
}
function _normalizeNodeHeaders(nodeHeaders) {
  const headers = new Headers();
  for (const [name, value] of Object.entries(nodeHeaders)) {
    if (Array.isArray(value)) {
      for (const item of value) {
        headers.append(name, item);
      }
    } else if (value) {
      headers.set(name, value);
    }
  }
  return headers;
}

function defineEventHandler(handler) {
  if (typeof handler === "function") {
    handler.__is_handler__ = true;
    return handler;
  }
  const _hooks = {
    onRequest: _normalizeArray(handler.onRequest),
    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)
  };
  const _handler = (event) => {
    return _callHandler(event, handler.handler, _hooks);
  };
  _handler.__is_handler__ = true;
  _handler.__resolve__ = handler.handler.__resolve__;
  _handler.__websocket__ = handler.websocket;
  return _handler;
}
function _normalizeArray(input) {
  return input ? Array.isArray(input) ? input : [input] : void 0;
}
async function _callHandler(event, handler, hooks) {
  if (hooks.onRequest) {
    for (const hook of hooks.onRequest) {
      await hook(event);
      if (event.handled) {
        return;
      }
    }
  }
  const body = await handler(event);
  const response = { body };
  if (hooks.onBeforeResponse) {
    for (const hook of hooks.onBeforeResponse) {
      await hook(event, response);
    }
  }
  return response.body;
}
const eventHandler = defineEventHandler;
function isEventHandler(input) {
  return hasProp(input, "__is_handler__");
}
function toEventHandler(input, _, _route) {
  if (!isEventHandler(input)) {
    console.warn(
      "[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.",
      _route && _route !== "/" ? `
     Route: ${_route}` : "",
      `
     Handler: ${input}`
    );
  }
  return input;
}
function defineLazyEventHandler(factory) {
  let _promise;
  let _resolved;
  const resolveHandler = () => {
    if (_resolved) {
      return Promise.resolve(_resolved);
    }
    if (!_promise) {
      _promise = Promise.resolve(factory()).then((r) => {
        const handler2 = r.default || r;
        if (typeof handler2 !== "function") {
          throw new TypeError(
            "Invalid lazy handler result. It should be a function:",
            handler2
          );
        }
        _resolved = { handler: toEventHandler(r.default || r) };
        return _resolved;
      });
    }
    return _promise;
  };
  const handler = eventHandler((event) => {
    if (_resolved) {
      return _resolved.handler(event);
    }
    return resolveHandler().then((r) => r.handler(event));
  });
  handler.__resolve__ = resolveHandler;
  return handler;
}
const lazyEventHandler = defineLazyEventHandler;

function createApp(options = {}) {
  const stack = [];
  const handler = createAppEventHandler(stack, options);
  const resolve = createResolver(stack);
  handler.__resolve__ = resolve;
  const getWebsocket = cachedFn(() => websocketOptions(resolve, options));
  const app = {
    // @ts-expect-error
    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),
    resolve,
    handler,
    stack,
    options,
    get websocket() {
      return getWebsocket();
    }
  };
  return app;
}
function use(app, arg1, arg2, arg3) {
  if (Array.isArray(arg1)) {
    for (const i of arg1) {
      use(app, i, arg2, arg3);
    }
  } else if (Array.isArray(arg2)) {
    for (const i of arg2) {
      use(app, arg1, i, arg3);
    }
  } else if (typeof arg1 === "string") {
    app.stack.push(
      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })
    );
  } else if (typeof arg1 === "function") {
    app.stack.push(normalizeLayer({ ...arg2, handler: arg1 }));
  } else {
    app.stack.push(normalizeLayer({ ...arg1 }));
  }
  return app;
}
function createAppEventHandler(stack, options) {
  const spacing = options.debug ? 2 : void 0;
  return eventHandler(async (event) => {
    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || "/";
    const _reqPath = event._path || event.node.req.url || "/";
    let _layerPath;
    if (options.onRequest) {
      await options.onRequest(event);
    }
    for (const layer of stack) {
      if (layer.route.length > 1) {
        if (!_reqPath.startsWith(layer.route)) {
          continue;
        }
        _layerPath = _reqPath.slice(layer.route.length) || "/";
      } else {
        _layerPath = _reqPath;
      }
      if (layer.match && !layer.match(_layerPath, event)) {
        continue;
      }
      event._path = _layerPath;
      event.node.req.url = _layerPath;
      const val = await layer.handler(event);
      const _body = val === void 0 ? void 0 : await val;
      if (_body !== void 0) {
        const _response = { body: _body };
        if (options.onBeforeResponse) {
          event._onBeforeResponseCalled = true;
          await options.onBeforeResponse(event, _response);
        }
        await handleHandlerResponse(event, _response.body, spacing);
        if (options.onAfterResponse) {
          event._onAfterResponseCalled = true;
          await options.onAfterResponse(event, _response);
        }
        return;
      }
      if (event.handled) {
        if (options.onAfterResponse) {
          event._onAfterResponseCalled = true;
          await options.onAfterResponse(event, void 0);
        }
        return;
      }
    }
    if (!event.handled) {
      throw createError$2({
        statusCode: 404,
        statusMessage: `Cannot find any path matching ${event.path || "/"}.`
      });
    }
    if (options.onAfterResponse) {
      event._onAfterResponseCalled = true;
      await options.onAfterResponse(event, void 0);
    }
  });
}
function createResolver(stack) {
  return async (path) => {
    let _layerPath;
    for (const layer of stack) {
      if (layer.route === "/" && !layer.handler.__resolve__) {
        continue;
      }
      if (!path.startsWith(layer.route)) {
        continue;
      }
      _layerPath = path.slice(layer.route.length) || "/";
      if (layer.match && !layer.match(_layerPath, void 0)) {
        continue;
      }
      let res = { route: layer.route, handler: layer.handler };
      if (res.handler.__resolve__) {
        const _res = await res.handler.__resolve__(_layerPath);
        if (!_res) {
          continue;
        }
        res = {
          ...res,
          ..._res,
          route: joinURL(res.route || "/", _res.route || "/")
        };
      }
      return res;
    }
  };
}
function normalizeLayer(input) {
  let handler = input.handler;
  if (handler.handler) {
    handler = handler.handler;
  }
  if (input.lazy) {
    handler = lazyEventHandler(handler);
  } else if (!isEventHandler(handler)) {
    handler = toEventHandler(handler, void 0, input.route);
  }
  return {
    route: withoutTrailingSlash(input.route),
    match: input.match,
    handler
  };
}
function handleHandlerResponse(event, val, jsonSpace) {
  if (val === null) {
    return sendNoContent(event);
  }
  if (val) {
    if (isWebResponse(val)) {
      return sendWebResponse(event, val);
    }
    if (isStream(val)) {
      return sendStream(event, val);
    }
    if (val.buffer) {
      return send(event, val);
    }
    if (val.arrayBuffer && typeof val.arrayBuffer === "function") {
      return val.arrayBuffer().then((arrayBuffer) => {
        return send(event, Buffer.from(arrayBuffer), val.type);
      });
    }
    if (val instanceof Error) {
      throw createError$2(val);
    }
    if (typeof val.end === "function") {
      return true;
    }
  }
  const valType = typeof val;
  if (valType === "string") {
    return send(event, val, MIMES.html);
  }
  if (valType === "object" || valType === "boolean" || valType === "number") {
    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);
  }
  if (valType === "bigint") {
    return send(event, val.toString(), MIMES.json);
  }
  throw createError$2({
    statusCode: 500,
    statusMessage: `[h3] Cannot send ${valType} as response.`
  });
}
function cachedFn(fn) {
  let cache;
  return () => {
    if (!cache) {
      cache = fn();
    }
    return cache;
  };
}
function websocketOptions(evResolver, appOptions) {
  return {
    ...appOptions.websocket,
    async resolve(info) {
      const url = info.request?.url || info.url || "/";
      const { pathname } = typeof url === "string" ? parseURL(url) : url;
      const resolved = await evResolver(pathname);
      return resolved?.handler?.__websocket__ || {};
    }
  };
}

const RouterMethods = [
  "connect",
  "delete",
  "get",
  "head",
  "options",
  "post",
  "put",
  "trace",
  "patch"
];
function createRouter(opts = {}) {
  const _router = createRouter$1({});
  const routes = {};
  let _matcher;
  const router = {};
  const addRoute = (path, handler, method) => {
    let route = routes[path];
    if (!route) {
      routes[path] = route = { path, handlers: {} };
      _router.insert(path, route);
    }
    if (Array.isArray(method)) {
      for (const m of method) {
        addRoute(path, handler, m);
      }
    } else {
      route.handlers[method] = toEventHandler(handler, void 0, path);
    }
    return router;
  };
  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || "all");
  for (const method of RouterMethods) {
    router[method] = (path, handle) => router.add(path, handle, method);
  }
  const matchHandler = (path = "/", method = "get") => {
    const qIndex = path.indexOf("?");
    if (qIndex !== -1) {
      path = path.slice(0, Math.max(0, qIndex));
    }
    const matched = _router.lookup(path);
    if (!matched || !matched.handlers) {
      return {
        error: createError$2({
          statusCode: 404,
          name: "Not Found",
          statusMessage: `Cannot find any route matching ${path || "/"}.`
        })
      };
    }
    let handler = matched.handlers[method] || matched.handlers.all;
    if (!handler) {
      if (!_matcher) {
        _matcher = toRouteMatcher(_router);
      }
      const _matches = _matcher.matchAll(path).reverse();
      for (const _match of _matches) {
        if (_match.handlers[method]) {
          handler = _match.handlers[method];
          matched.handlers[method] = matched.handlers[method] || handler;
          break;
        }
        if (_match.handlers.all) {
          handler = _match.handlers.all;
          matched.handlers.all = matched.handlers.all || handler;
          break;
        }
      }
    }
    if (!handler) {
      return {
        error: createError$2({
          statusCode: 405,
          name: "Method Not Allowed",
          statusMessage: `Method ${method} is not allowed on this route.`
        })
      };
    }
    return { matched, handler };
  };
  const isPreemptive = opts.preemptive || opts.preemtive;
  router.handler = eventHandler((event) => {
    const match = matchHandler(
      event.path,
      event.method.toLowerCase()
    );
    if ("error" in match) {
      if (isPreemptive) {
        throw match.error;
      } else {
        return;
      }
    }
    event.context.matchedRoute = match.matched;
    const params = match.matched.params || {};
    event.context.params = params;
    return Promise.resolve(match.handler(event)).then((res) => {
      if (res === void 0 && isPreemptive) {
        return null;
      }
      return res;
    });
  });
  router.handler.__resolve__ = async (path) => {
    path = withLeadingSlash(path);
    const match = matchHandler(path);
    if ("error" in match) {
      return;
    }
    let res = {
      route: match.matched.path,
      handler: match.handler
    };
    if (match.handler.__resolve__) {
      const _res = await match.handler.__resolve__(path);
      if (!_res) {
        return;
      }
      res = { ...res, ..._res };
    }
    return res;
  };
  return router;
}
function toNodeListener(app) {
  const toNodeHandle = async function(req, res) {
    const event = createEvent(req, res);
    try {
      await app.handler(event);
    } catch (_error) {
      const error = createError$2(_error);
      if (!isError(_error)) {
        error.unhandled = true;
      }
      setResponseStatus(event, error.statusCode, error.statusMessage);
      if (app.options.onError) {
        await app.options.onError(error, event);
      }
      if (event.handled) {
        return;
      }
      if (error.unhandled || error.fatal) {
        console.error("[h3]", error.fatal ? "[fatal]" : "[unhandled]", error);
      }
      if (app.options.onBeforeResponse && !event._onBeforeResponseCalled) {
        await app.options.onBeforeResponse(event, { body: error });
      }
      await sendError(event, error, !!app.options.debug);
      if (app.options.onAfterResponse && !event._onAfterResponseCalled) {
        await app.options.onAfterResponse(event, { body: error });
      }
    }
  };
  return toNodeHandle;
}

function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
const defaultTask = { run: (function_) => function_() };
const _createTask = () => defaultTask;
const createTask = typeof console.createTask !== "undefined" ? console.createTask : _createTask;
function serialTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return hooks.reduce(
    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),
    Promise.resolve()
  );
}
function parallelTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));
}
function callEachWith(callbacks, arg0) {
  for (const callback of [...callbacks]) {
    callback(arg0);
  }
}

class Hookable {
  constructor() {
    this._hooks = {};
    this._before = void 0;
    this._after = void 0;
    this._deprecatedMessages = void 0;
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, function_, options = {}) {
    if (!name || typeof function_ !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let dep;
    while (this._deprecatedHooks[name]) {
      dep = this._deprecatedHooks[name];
      name = dep.to;
    }
    if (dep && !options.allowDeprecated) {
      let message = dep.message;
      if (!message) {
        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : "");
      }
      if (!this._deprecatedMessages) {
        this._deprecatedMessages = /* @__PURE__ */ new Set();
      }
      if (!this._deprecatedMessages.has(message)) {
        console.warn(message);
        this._deprecatedMessages.add(message);
      }
    }
    if (!function_.name) {
      try {
        Object.defineProperty(function_, "name", {
          get: () => "_" + name.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(function_);
    return () => {
      if (function_) {
        this.removeHook(name, function_);
        function_ = void 0;
      }
    };
  }
  hookOnce(name, function_) {
    let _unreg;
    let _function = (...arguments_) => {
      if (typeof _unreg === "function") {
        _unreg();
      }
      _unreg = void 0;
      _function = void 0;
      return function_(...arguments_);
    };
    _unreg = this.hook(name, _function);
    return _unreg;
  }
  removeHook(name, function_) {
    if (this._hooks[name]) {
      const index = this._hooks[name].indexOf(function_);
      if (index !== -1) {
        this._hooks[name].splice(index, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = typeof deprecated === "string" ? { to: deprecated } : deprecated;
    const _hooks = this._hooks[name] || [];
    delete this._hooks[name];
    for (const hook of _hooks) {
      this.hook(name, hook);
    }
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
    for (const name in deprecatedHooks) {
      this.deprecateHook(name, deprecatedHooks[name]);
    }
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map(
      (key) => this.hook(key, hooks[key])
    );
    return () => {
      for (const unreg of removeFns.splice(0, removeFns.length)) {
        unreg();
      }
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  removeAllHooks() {
    for (const key in this._hooks) {
      delete this._hooks[key];
    }
  }
  callHook(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(serialTaskCaller, name, ...arguments_);
  }
  callHookParallel(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(parallelTaskCaller, name, ...arguments_);
  }
  callHookWith(caller, name, ...arguments_) {
    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;
    if (this._before) {
      callEachWith(this._before, event);
    }
    const result = caller(
      name in this._hooks ? [...this._hooks[name]] : [],
      arguments_
    );
    if (result instanceof Promise) {
      return result.finally(() => {
        if (this._after && event) {
          callEachWith(this._after, event);
        }
      });
    }
    if (this._after && event) {
      callEachWith(this._after, event);
    }
    return result;
  }
  beforeEach(function_) {
    this._before = this._before || [];
    this._before.push(function_);
    return () => {
      if (this._before !== void 0) {
        const index = this._before.indexOf(function_);
        if (index !== -1) {
          this._before.splice(index, 1);
        }
      }
    };
  }
  afterEach(function_) {
    this._after = this._after || [];
    this._after.push(function_);
    return () => {
      if (this._after !== void 0) {
        const index = this._after.indexOf(function_);
        if (index !== -1) {
          this._after.splice(index, 1);
        }
      }
    };
  }
}
function createHooks() {
  return new Hookable();
}

const s$2=globalThis.Headers,i$2=globalThis.AbortController,l=globalThis.fetch||(()=>{throw new Error("[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!")});

class FetchError extends Error {
  constructor(message, opts) {
    super(message, opts);
    this.name = "FetchError";
    if (opts?.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
}
function createFetchError(ctx) {
  const errorMessage = ctx.error?.message || ctx.error?.toString() || "";
  const method = ctx.request?.method || ctx.options?.method || "GET";
  const url = ctx.request?.url || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}

const payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  if (value instanceof FormData || value instanceof URLSearchParams) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
const textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
const JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (contentType === "text/event-stream") {
    return "stream";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function resolveFetchOptions(request, input, defaults, Headers) {
  const headers = mergeHeaders(
    input?.headers ?? request?.headers,
    defaults?.headers,
    Headers
  );
  let query;
  if (defaults?.query || defaults?.params || input?.params || input?.query) {
    query = {
      ...defaults?.params,
      ...defaults?.query,
      ...input?.params,
      ...input?.query
    };
  }
  return {
    ...defaults,
    ...input,
    query,
    params: query,
    headers
  };
}
function mergeHeaders(input, defaults, Headers) {
  if (!defaults) {
    return new Headers(input);
  }
  const headers = new Headers(defaults);
  if (input) {
    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers(input)) {
      headers.set(key, value);
    }
  }
  return headers;
}
async function callHooks(context, hooks) {
  if (hooks) {
    if (Array.isArray(hooks)) {
      for (const hook of hooks) {
        await hook(context);
      }
    } else {
      await hooks(context);
    }
  }
}

const retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early (Experimental)
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
]);
const nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch = globalThis.fetch,
    Headers = globalThis.Headers,
    AbortController = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = typeof context.options.retryDelay === "function" ? context.options.retryDelay(context) : context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: resolveFetchOptions(
        _request,
        _options,
        globalOptions.defaults,
        Headers
      ),
      response: void 0,
      error: void 0
    };
    if (context.options.method) {
      context.options.method = context.options.method.toUpperCase();
    }
    if (context.options.onRequest) {
      await callHooks(context, context.options.onRequest);
      if (!(context.options.headers instanceof Headers)) {
        context.options.headers = new Headers(
          context.options.headers || {}
          /* compat */
        );
      }
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = withBase(context.request, context.options.baseURL);
      }
      if (context.options.query) {
        context.request = withQuery(context.request, context.options.query);
        delete context.options.query;
      }
      if ("query" in context.options) {
        delete context.options.query;
      }
      if ("params" in context.options) {
        delete context.options.params;
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        const contentType = context.options.headers.get("content-type");
        if (typeof context.options.body !== "string") {
          context.options.body = contentType === "application/x-www-form-urlencoded" ? new URLSearchParams(
            context.options.body
          ).toString() : JSON.stringify(context.options.body);
        }
        if (!contentType) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    let abortTimeout;
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController();
      abortTimeout = setTimeout(() => {
        const error = new Error(
          "[TimeoutError]: The operation was aborted due to timeout"
        );
        error.name = "TimeoutError";
        error.code = 23;
        controller.abort(error);
      }, context.options.timeout);
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await callHooks(
          context,
          context.options.onRequestError
        );
      }
      return await onError(context);
    } finally {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324
    // https://github.com/unjs/ofetch/issues/294
    // https://github.com/JakeChampion/fetch/issues/1454
    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body || context.response._bodyInit;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await callHooks(
        context,
        context.options.onResponse
      );
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await callHooks(
          context,
          context.options.onResponseError
        );
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch = async function $fetch2(request, options) {
    const r = await $fetchRaw(request, options);
    return r._data;
  };
  $fetch.raw = $fetchRaw;
  $fetch.native = (...args) => fetch(...args);
  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({
    ...globalOptions,
    ...customGlobalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...customGlobalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch;
}

function createNodeFetch() {
  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || "false");
  if (!useKeepAlive) {
    return l;
  }
  const agentOptions = { keepAlive: true };
  const httpAgent = new http$4.Agent(agentOptions);
  const httpsAgent = new https$2.Agent(agentOptions);
  const nodeFetchOptions = {
    agent(parsedURL) {
      return parsedURL.protocol === "http:" ? httpAgent : httpsAgent;
    }
  };
  return function nodeFetchWithKeepAlive(input, init) {
    return l(input, { ...nodeFetchOptions, ...init });
  };
}
const fetch = globalThis.fetch ? (...args) => globalThis.fetch(...args) : createNodeFetch();
const Headers$1 = globalThis.Headers || s$2;
const AbortController = globalThis.AbortController || i$2;
const ofetch = createFetch({ fetch, Headers: Headers$1, AbortController });
const $fetch$1 = ofetch;

function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c) => c.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}

const storageKeyProperties = [
  "has",
  "hasItem",
  "get",
  "getItem",
  "getItemRaw",
  "set",
  "setItem",
  "setItemRaw",
  "del",
  "remove",
  "removeItem",
  "getMeta",
  "setMeta",
  "removeMeta",
  "getKeys",
  "clear",
  "mount",
  "unmount"
];
function prefixStorage(storage, base) {
  base = normalizeBaseKey(base);
  if (!base) {
    return storage;
  }
  const nsStorage = { ...storage };
  for (const property of storageKeyProperties) {
    nsStorage[property] = (key = "", ...args) => (
      // @ts-ignore
      storage[property](base + key, ...args)
    );
  }
  nsStorage.getKeys = (key = "", ...arguments_) => storage.getKeys(base + key, ...arguments_).then((keys) => keys.map((key2) => key2.slice(base.length)));
  nsStorage.keys = nsStorage.getKeys;
  nsStorage.getItems = async (items, commonOptions) => {
    const prefixedItems = items.map(
      (item) => typeof item === "string" ? base + item : { ...item, key: base + item.key }
    );
    const results = await storage.getItems(prefixedItems, commonOptions);
    return results.map((entry) => ({
      key: entry.key.slice(base.length),
      value: entry.value
    }));
  };
  nsStorage.setItems = async (items, commonOptions) => {
    const prefixedItems = items.map((item) => ({
      key: base + item.key,
      value: item.value,
      options: item.options
    }));
    return storage.setItems(prefixedItems, commonOptions);
  };
  return nsStorage;
}
function normalizeKey$1(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function joinKeys(...keys) {
  return normalizeKey$1(keys.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey$1(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

function defineDriver$1(factory) {
  return factory;
}

const DRIVER_NAME$1 = "memory";
const memory = defineDriver$1(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME$1,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});

function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey$1(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey$1(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r) => r.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r) => r.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey$1(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!mount.driver.flags?.maxDepth) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey$1(key);
          if (!maskedMounts.some((p) => fullKey.startsWith(p))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m) => {
          if (m.driver.clear) {
            return asyncCall(m.driver.clear, m.relativeBase, opts);
          }
          if (m.driver.removeItem) {
            const keys = await m.driver.getKeys(m.relativeBase || "", opts);
            return Promise.all(
              keys.map((key) => m.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a, b) => b.length - a.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]?.();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey$1(key) + ":";
      const m = getMount(key);
      return {
        driver: m.driver,
        base: m.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey$1(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m) => ({
        driver: m.driver,
        base: m.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

const _assets = {

};

const normalizeKey = function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
};

const assets$1 = {
  getKeys() {
    return Promise.resolve(Object.keys(_assets))
  },
  hasItem (id) {
    id = normalizeKey(id);
    return Promise.resolve(id in _assets)
  },
  getItem (id) {
    id = normalizeKey(id);
    return Promise.resolve(_assets[id] ? _assets[id].import() : null)
  },
  getMeta (id) {
    id = normalizeKey(id);
    return Promise.resolve(_assets[id] ? _assets[id].meta : {})
  }
};

function defineDriver(factory) {
  return factory;
}
function createError$1(driver, message, opts) {
  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, createError$1);
  }
  return err;
}
function createRequiredError(driver, name) {
  if (Array.isArray(name)) {
    return createError$1(
      driver,
      `Missing some of the required options ${name.map((n) => "`" + n + "`").join(", ")}`
    );
  }
  return createError$1(driver, `Missing required option \`${name}\`.`);
}

function ignoreNotfound(err) {
  return err.code === "ENOENT" || err.code === "EISDIR" ? null : err;
}
function ignoreExists(err) {
  return err.code === "EEXIST" ? null : err;
}
async function writeFile(path, data, encoding) {
  await ensuredir(dirname$1(path));
  return promises.writeFile(path, data, encoding);
}
function readFile(path, encoding) {
  return promises.readFile(path, encoding).catch(ignoreNotfound);
}
function unlink(path) {
  return promises.unlink(path).catch(ignoreNotfound);
}
function readdir(dir) {
  return promises.readdir(dir, { withFileTypes: true }).catch(ignoreNotfound).then((r) => r || []);
}
async function ensuredir(dir) {
  if (existsSync(dir)) {
    return;
  }
  await ensuredir(dirname$1(dir)).catch(ignoreExists);
  await promises.mkdir(dir).catch(ignoreExists);
}
async function readdirRecursive(dir, ignore, maxDepth) {
  if (ignore && ignore(dir)) {
    return [];
  }
  const entries = await readdir(dir);
  const files = [];
  await Promise.all(
    entries.map(async (entry) => {
      const entryPath = resolve$1(dir, entry.name);
      if (entry.isDirectory()) {
        if (maxDepth === void 0 || maxDepth > 0) {
          const dirFiles = await readdirRecursive(
            entryPath,
            ignore,
            maxDepth === void 0 ? void 0 : maxDepth - 1
          );
          files.push(...dirFiles.map((f) => entry.name + "/" + f));
        }
      } else {
        if (!(ignore && ignore(entry.name))) {
          files.push(entry.name);
        }
      }
    })
  );
  return files;
}
async function rmRecursive(dir) {
  const entries = await readdir(dir);
  await Promise.all(
    entries.map((entry) => {
      const entryPath = resolve$1(dir, entry.name);
      if (entry.isDirectory()) {
        return rmRecursive(entryPath).then(() => promises.rmdir(entryPath));
      } else {
        return promises.unlink(entryPath);
      }
    })
  );
}

const PATH_TRAVERSE_RE = /\.\.:|\.\.$/;
const DRIVER_NAME = "fs-lite";
const unstorage_47drivers_47fs_45lite = defineDriver((opts = {}) => {
  if (!opts.base) {
    throw createRequiredError(DRIVER_NAME, "base");
  }
  opts.base = resolve$1(opts.base);
  const r = (key) => {
    if (PATH_TRAVERSE_RE.test(key)) {
      throw createError$1(
        DRIVER_NAME,
        `Invalid key: ${JSON.stringify(key)}. It should not contain .. segments`
      );
    }
    const resolved = join(opts.base, key.replace(/:/g, "/"));
    return resolved;
  };
  return {
    name: DRIVER_NAME,
    options: opts,
    flags: {
      maxDepth: true
    },
    hasItem(key) {
      return existsSync(r(key));
    },
    getItem(key) {
      return readFile(r(key), "utf8");
    },
    getItemRaw(key) {
      return readFile(r(key));
    },
    async getMeta(key) {
      const { atime, mtime, size, birthtime, ctime } = await promises.stat(r(key)).catch(() => ({}));
      return { atime, mtime, size, birthtime, ctime };
    },
    setItem(key, value) {
      if (opts.readOnly) {
        return;
      }
      return writeFile(r(key), value, "utf8");
    },
    setItemRaw(key, value) {
      if (opts.readOnly) {
        return;
      }
      return writeFile(r(key), value);
    },
    removeItem(key) {
      if (opts.readOnly) {
        return;
      }
      return unlink(r(key));
    },
    getKeys(_base, topts) {
      return readdirRecursive(r("."), opts.ignore, topts?.maxDepth);
    },
    async clear() {
      if (opts.readOnly || opts.noClear) {
        return;
      }
      await rmRecursive(r("."));
    }
  };
});

const storage = createStorage({});

storage.mount('/assets', assets$1);

storage.mount('data', unstorage_47drivers_47fs_45lite({"driver":"fsLite","base":"./.data/kv"}));

function useStorage(base = "") {
  return base ? prefixStorage(storage, base) : storage;
}

function serialize$2(o){return typeof o=="string"?`'${o}'`:new c().serialize(o)}const c=/*@__PURE__*/function(){class o{#t=new Map;compare(t,r){const e=typeof t,n=typeof r;return e==="string"&&n==="string"?t.localeCompare(r):e==="number"&&n==="number"?t-r:String.prototype.localeCompare.call(this.serialize(t,true),this.serialize(r,true))}serialize(t,r){if(t===null)return "null";switch(typeof t){case "string":return r?t:`'${t}'`;case "bigint":return `${t}n`;case "object":return this.$object(t);case "function":return this.$function(t)}return String(t)}serializeObject(t){const r=Object.prototype.toString.call(t);if(r!=="[object Object]")return this.serializeBuiltInType(r.length<10?`unknown:${r}`:r.slice(8,-1),t);const e=t.constructor,n=e===Object||e===void 0?"":e.name;if(n!==""&&globalThis[n]===e)return this.serializeBuiltInType(n,t);if(typeof t.toJSON=="function"){const i=t.toJSON();return n+(i!==null&&typeof i=="object"?this.$object(i):`(${this.serialize(i)})`)}return this.serializeObjectEntries(n,Object.entries(t))}serializeBuiltInType(t,r){const e=this["$"+t];if(e)return e.call(this,r);if(typeof r?.entries=="function")return this.serializeObjectEntries(t,r.entries());throw new Error(`Cannot serialize ${t}`)}serializeObjectEntries(t,r){const e=Array.from(r).sort((i,a)=>this.compare(i[0],a[0]));let n=`${t}{`;for(let i=0;i<e.length;i++){const[a,l]=e[i];n+=`${this.serialize(a,true)}:${this.serialize(l)}`,i<e.length-1&&(n+=",");}return n+"}"}$object(t){let r=this.#t.get(t);return r===void 0&&(this.#t.set(t,`#${this.#t.size}`),r=this.serializeObject(t),this.#t.set(t,r)),r}$function(t){const r=Function.prototype.toString.call(t);return r.slice(-15)==="[native code] }"?`${t.name||""}()[native]`:`${t.name}(${t.length})${r.replace(/\s*\n\s*/g,"")}`}$Array(t){let r="[";for(let e=0;e<t.length;e++)r+=this.serialize(t[e]),e<t.length-1&&(r+=",");return r+"]"}$Date(t){try{return `Date(${t.toISOString()})`}catch{return "Date(null)"}}$ArrayBuffer(t){return `ArrayBuffer[${new Uint8Array(t).join(",")}]`}$Set(t){return `Set${this.$Array(Array.from(t).sort((r,e)=>this.compare(r,e)))}`}$Map(t){return this.serializeObjectEntries("Map",t.entries())}}for(const s of ["Error","RegExp","URL"])o.prototype["$"+s]=function(t){return `${s}(${t})`};for(const s of ["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"])o.prototype["$"+s]=function(t){return `${s}[${t.join(",")}]`};for(const s of ["BigInt64Array","BigUint64Array"])o.prototype["$"+s]=function(t){return `${s}[${t.join("n,")}${t.length>0?"n":""}]`};return o}();

function isEqual(object1, object2) {
  if (object1 === object2) {
    return true;
  }
  if (serialize$2(object1) === serialize$2(object2)) {
    return true;
  }
  return false;
}

const e=globalThis.process?.getBuiltinModule?.("crypto")?.hash,r="sha256",s$1="base64url";function digest(t){if(e)return e(r,t,s$1);const o=createHash$4(r).update(t);return globalThis.process?.versions?.webcontainer?o.digest().toString(s$1):o.digest(s$1)}

const Hasher = /* @__PURE__ */ (() => {
  class Hasher2 {
    buff = "";
    #context = /* @__PURE__ */ new Map();
    write(str) {
      this.buff += str;
    }
    dispatch(value) {
      const type = value === null ? "null" : typeof value;
      return this[type](value);
    }
    object(object) {
      if (object && typeof object.toJSON === "function") {
        return this.object(object.toJSON());
      }
      const objString = Object.prototype.toString.call(object);
      let objType = "";
      const objectLength = objString.length;
      objType = objectLength < 10 ? "unknown:[" + objString + "]" : objString.slice(8, objectLength - 1);
      objType = objType.toLowerCase();
      let objectNumber = null;
      if ((objectNumber = this.#context.get(object)) === void 0) {
        this.#context.set(object, this.#context.size);
      } else {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
        this.write("buffer:");
        return this.write(object.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this[objType]) {
          this[objType](object);
        } else {
          this.unknown(object, objType);
        }
      } else {
        const keys = Object.keys(object).sort();
        const extraKeys = [];
        this.write("object:" + (keys.length + extraKeys.length) + ":");
        const dispatchForKey = (key) => {
          this.dispatch(key);
          this.write(":");
          this.dispatch(object[key]);
          this.write(",");
        };
        for (const key of keys) {
          dispatchForKey(key);
        }
        for (const key of extraKeys) {
          dispatchForKey(key);
        }
      }
    }
    array(arr, unordered) {
      unordered = unordered === void 0 ? false : unordered;
      this.write("array:" + arr.length + ":");
      if (!unordered || arr.length <= 1) {
        for (const entry of arr) {
          this.dispatch(entry);
        }
        return;
      }
      const contextAdditions = /* @__PURE__ */ new Map();
      const entries = arr.map((entry) => {
        const hasher = new Hasher2();
        hasher.dispatch(entry);
        for (const [key, value] of hasher.#context) {
          contextAdditions.set(key, value);
        }
        return hasher.toString();
      });
      this.#context = contextAdditions;
      entries.sort();
      return this.array(entries, false);
    }
    date(date) {
      return this.write("date:" + date.toJSON());
    }
    symbol(sym) {
      return this.write("symbol:" + sym.toString());
    }
    unknown(value, type) {
      this.write(type);
      if (!value) {
        return;
      }
      this.write(":");
      if (value && typeof value.entries === "function") {
        return this.array(
          [...value.entries()],
          true
          /* ordered */
        );
      }
    }
    error(err) {
      return this.write("error:" + err.toString());
    }
    boolean(bool) {
      return this.write("bool:" + bool);
    }
    string(string) {
      this.write("string:" + string.length + ":");
      this.write(string);
    }
    function(fn) {
      this.write("fn:");
      if (isNativeFunction(fn)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn.toString());
      }
    }
    number(number) {
      return this.write("number:" + number);
    }
    null() {
      return this.write("Null");
    }
    undefined() {
      return this.write("Undefined");
    }
    regexp(regex) {
      return this.write("regex:" + regex.toString());
    }
    arraybuffer(arr) {
      this.write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr));
    }
    url(url) {
      return this.write("url:" + url.toString());
    }
    map(map) {
      this.write("map:");
      const arr = [...map];
      return this.array(arr, false);
    }
    set(set) {
      this.write("set:");
      const arr = [...set];
      return this.array(arr, false);
    }
    bigint(number) {
      return this.write("bigint:" + number.toString());
    }
  }
  for (const type of [
    "uint8array",
    "uint8clampedarray",
    "unt8array",
    "uint16array",
    "unt16array",
    "uint32array",
    "unt32array",
    "float32array",
    "float64array"
  ]) {
    Hasher2.prototype[type] = function(arr) {
      this.write(type + ":");
      return this.array([...arr], false);
    };
  }
  function isNativeFunction(f) {
    if (typeof f !== "function") {
      return false;
    }
    return Function.prototype.toString.call(f).slice(
      -15
      /* "[native code] }".length */
    ) === "[native code] }";
  }
  return Hasher2;
})();
function serialize$1(object) {
  const hasher = new Hasher();
  hasher.dispatch(object);
  return hasher.buff;
}
function hash(value) {
  return digest(typeof value === "string" ? value : serialize$1(value)).replace(/[-_]/g, "").slice(0, 10);
}

function defaultCacheOptions() {
  return {
    name: "_",
    base: "/cache",
    swr: true,
    maxAge: 1
  };
}
function defineCachedFunction(fn, opts = {}) {
  opts = { ...defaultCacheOptions(), ...opts };
  const pending = {};
  const group = opts.group || "nitro/functions";
  const name = opts.name || fn.name || "_";
  const integrity = opts.integrity || hash([fn, opts]);
  const validate = opts.validate || ((entry) => entry.value !== void 0);
  async function get(key, resolver, shouldInvalidateCache, event) {
    const cacheKey = [opts.base, group, name, key + ".json"].filter(Boolean).join(":").replace(/:\/$/, ":index");
    let entry = await useStorage().getItem(cacheKey).catch((error) => {
      console.error(`[cache] Cache read error.`, error);
      useNitroApp().captureError(error, { event, tags: ["cache"] });
    }) || {};
    if (typeof entry !== "object") {
      entry = {};
      const error = new Error("Malformed data read from cache.");
      console.error("[cache]", error);
      useNitroApp().captureError(error, { event, tags: ["cache"] });
    }
    const ttl = (opts.maxAge ?? 0) * 1e3;
    if (ttl) {
      entry.expires = Date.now() + ttl;
    }
    const expired = shouldInvalidateCache || entry.integrity !== integrity || ttl && Date.now() - (entry.mtime || 0) > ttl || validate(entry) === false;
    const _resolve = async () => {
      const isPending = pending[key];
      if (!isPending) {
        if (entry.value !== void 0 && (opts.staleMaxAge || 0) >= 0 && opts.swr === false) {
          entry.value = void 0;
          entry.integrity = void 0;
          entry.mtime = void 0;
          entry.expires = void 0;
        }
        pending[key] = Promise.resolve(resolver());
      }
      try {
        entry.value = await pending[key];
      } catch (error) {
        if (!isPending) {
          delete pending[key];
        }
        throw error;
      }
      if (!isPending) {
        entry.mtime = Date.now();
        entry.integrity = integrity;
        delete pending[key];
        if (validate(entry) !== false) {
          let setOpts;
          if (opts.maxAge && !opts.swr) {
            setOpts = { ttl: opts.maxAge };
          }
          const promise = useStorage().setItem(cacheKey, entry, setOpts).catch((error) => {
            console.error(`[cache] Cache write error.`, error);
            useNitroApp().captureError(error, { event, tags: ["cache"] });
          });
          if (event?.waitUntil) {
            event.waitUntil(promise);
          }
        }
      }
    };
    const _resolvePromise = expired ? _resolve() : Promise.resolve();
    if (entry.value === void 0) {
      await _resolvePromise;
    } else if (expired && event && event.waitUntil) {
      event.waitUntil(_resolvePromise);
    }
    if (opts.swr && validate(entry) !== false) {
      _resolvePromise.catch((error) => {
        console.error(`[cache] SWR handler error.`, error);
        useNitroApp().captureError(error, { event, tags: ["cache"] });
      });
      return entry;
    }
    return _resolvePromise.then(() => entry);
  }
  return async (...args) => {
    const shouldBypassCache = await opts.shouldBypassCache?.(...args);
    if (shouldBypassCache) {
      return fn(...args);
    }
    const key = await (opts.getKey || getKey)(...args);
    const shouldInvalidateCache = await opts.shouldInvalidateCache?.(...args);
    const entry = await get(
      key,
      () => fn(...args),
      shouldInvalidateCache,
      args[0] && isEvent(args[0]) ? args[0] : void 0
    );
    let value = entry.value;
    if (opts.transform) {
      value = await opts.transform(entry, ...args) || value;
    }
    return value;
  };
}
function cachedFunction(fn, opts = {}) {
  return defineCachedFunction(fn, opts);
}
function getKey(...args) {
  return args.length > 0 ? hash(args) : "";
}
function escapeKey(key) {
  return String(key).replace(/\W/g, "");
}
function defineCachedEventHandler(handler, opts = defaultCacheOptions()) {
  const variableHeaderNames = (opts.varies || []).filter(Boolean).map((h) => h.toLowerCase()).sort();
  const _opts = {
    ...opts,
    getKey: async (event) => {
      const customKey = await opts.getKey?.(event);
      if (customKey) {
        return escapeKey(customKey);
      }
      const _path = event.node.req.originalUrl || event.node.req.url || event.path;
      let _pathname;
      try {
        _pathname = escapeKey(decodeURI(parseURL(_path).pathname)).slice(0, 16) || "index";
      } catch {
        _pathname = "-";
      }
      const _hashedPath = `${_pathname}.${hash(_path)}`;
      const _headers = variableHeaderNames.map((header) => [header, event.node.req.headers[header]]).map(([name, value]) => `${escapeKey(name)}.${hash(value)}`);
      return [_hashedPath, ..._headers].join(":");
    },
    validate: (entry) => {
      if (!entry.value) {
        return false;
      }
      if (entry.value.code >= 400) {
        return false;
      }
      if (entry.value.body === void 0) {
        return false;
      }
      if (entry.value.headers.etag === "undefined" || entry.value.headers["last-modified"] === "undefined") {
        return false;
      }
      return true;
    },
    group: opts.group || "nitro/handlers",
    integrity: opts.integrity || hash([handler, opts])
  };
  const _cachedHandler = cachedFunction(
    async (incomingEvent) => {
      const variableHeaders = {};
      for (const header of variableHeaderNames) {
        const value = incomingEvent.node.req.headers[header];
        if (value !== void 0) {
          variableHeaders[header] = value;
        }
      }
      const reqProxy = cloneWithProxy(incomingEvent.node.req, {
        headers: variableHeaders
      });
      const resHeaders = {};
      let _resSendBody;
      const resProxy = cloneWithProxy(incomingEvent.node.res, {
        statusCode: 200,
        writableEnded: false,
        writableFinished: false,
        headersSent: false,
        closed: false,
        getHeader(name) {
          return resHeaders[name];
        },
        setHeader(name, value) {
          resHeaders[name] = value;
          return this;
        },
        getHeaderNames() {
          return Object.keys(resHeaders);
        },
        hasHeader(name) {
          return name in resHeaders;
        },
        removeHeader(name) {
          delete resHeaders[name];
        },
        getHeaders() {
          return resHeaders;
        },
        end(chunk, arg2, arg3) {
          if (typeof chunk === "string") {
            _resSendBody = chunk;
          }
          if (typeof arg2 === "function") {
            arg2();
          }
          if (typeof arg3 === "function") {
            arg3();
          }
          return this;
        },
        write(chunk, arg2, arg3) {
          if (typeof chunk === "string") {
            _resSendBody = chunk;
          }
          if (typeof arg2 === "function") {
            arg2(void 0);
          }
          if (typeof arg3 === "function") {
            arg3();
          }
          return true;
        },
        writeHead(statusCode, headers2) {
          this.statusCode = statusCode;
          if (headers2) {
            if (Array.isArray(headers2) || typeof headers2 === "string") {
              throw new TypeError("Raw headers  is not supported.");
            }
            for (const header in headers2) {
              const value = headers2[header];
              if (value !== void 0) {
                this.setHeader(
                  header,
                  value
                );
              }
            }
          }
          return this;
        }
      });
      const event = createEvent(reqProxy, resProxy);
      event.fetch = (url, fetchOptions) => fetchWithEvent(event, url, fetchOptions, {
        fetch: useNitroApp().localFetch
      });
      event.$fetch = (url, fetchOptions) => fetchWithEvent(event, url, fetchOptions, {
        fetch: globalThis.$fetch
      });
      event.waitUntil = incomingEvent.waitUntil;
      event.context = incomingEvent.context;
      event.context.cache = {
        options: _opts
      };
      const body = await handler(event) || _resSendBody;
      const headers = event.node.res.getHeaders();
      headers.etag = String(
        headers.Etag || headers.etag || `W/"${hash(body)}"`
      );
      headers["last-modified"] = String(
        headers["Last-Modified"] || headers["last-modified"] || (/* @__PURE__ */ new Date()).toUTCString()
      );
      const cacheControl = [];
      if (opts.swr) {
        if (opts.maxAge) {
          cacheControl.push(`s-maxage=${opts.maxAge}`);
        }
        if (opts.staleMaxAge) {
          cacheControl.push(`stale-while-revalidate=${opts.staleMaxAge}`);
        } else {
          cacheControl.push("stale-while-revalidate");
        }
      } else if (opts.maxAge) {
        cacheControl.push(`max-age=${opts.maxAge}`);
      }
      if (cacheControl.length > 0) {
        headers["cache-control"] = cacheControl.join(", ");
      }
      const cacheEntry = {
        code: event.node.res.statusCode,
        headers,
        body
      };
      return cacheEntry;
    },
    _opts
  );
  return defineEventHandler(async (event) => {
    if (opts.headersOnly) {
      if (handleCacheHeaders(event, { maxAge: opts.maxAge })) {
        return;
      }
      return handler(event);
    }
    const response = await _cachedHandler(
      event
    );
    if (event.node.res.headersSent || event.node.res.writableEnded) {
      return response.body;
    }
    if (handleCacheHeaders(event, {
      modifiedTime: new Date(response.headers["last-modified"]),
      etag: response.headers.etag,
      maxAge: opts.maxAge
    })) {
      return;
    }
    event.node.res.statusCode = response.code;
    for (const name in response.headers) {
      const value = response.headers[name];
      if (name === "set-cookie") {
        event.node.res.appendHeader(
          name,
          splitCookiesString(value)
        );
      } else {
        if (value !== void 0) {
          event.node.res.setHeader(name, value);
        }
      }
    }
    return response.body;
  });
}
function cloneWithProxy(obj, overrides) {
  return new Proxy(obj, {
    get(target, property, receiver) {
      if (property in overrides) {
        return overrides[property];
      }
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      if (property in overrides) {
        overrides[property] = value;
        return true;
      }
      return Reflect.set(target, property, value, receiver);
    }
  });
}
const cachedEventHandler = defineCachedEventHandler;

function klona(x) {
	if (typeof x !== 'object') return x;

	var k, tmp, str=Object.prototype.toString.call(x);

	if (str === '[object Object]') {
		if (x.constructor !== Object && typeof x.constructor === 'function') {
			tmp = new x.constructor();
			for (k in x) {
				if (x.hasOwnProperty(k) && tmp[k] !== x[k]) {
					tmp[k] = klona(x[k]);
				}
			}
		} else {
			tmp = {}; // null
			for (k in x) {
				if (k === '__proto__') {
					Object.defineProperty(tmp, k, {
						value: klona(x[k]),
						configurable: true,
						enumerable: true,
						writable: true,
					});
				} else {
					tmp[k] = klona(x[k]);
				}
			}
		}
		return tmp;
	}

	if (str === '[object Array]') {
		k = x.length;
		for (tmp=Array(k); k--;) {
			tmp[k] = klona(x[k]);
		}
		return tmp;
	}

	if (str === '[object Set]') {
		tmp = new Set;
		x.forEach(function (val) {
			tmp.add(klona(val));
		});
		return tmp;
	}

	if (str === '[object Map]') {
		tmp = new Map;
		x.forEach(function (val, key) {
			tmp.set(klona(key), klona(val));
		});
		return tmp;
	}

	if (str === '[object Date]') {
		return new Date(+x);
	}

	if (str === '[object RegExp]') {
		tmp = new RegExp(x.source, x.flags);
		tmp.lastIndex = x.lastIndex;
		return tmp;
	}

	if (str === '[object DataView]') {
		return new x.constructor( klona(x.buffer) );
	}

	if (str === '[object ArrayBuffer]') {
		return x.slice(0);
	}

	// ArrayBuffer.isView(x)
	// ~> `new` bcuz `Buffer.slice` => ref
	if (str.slice(-6) === 'Array]') {
		return new x.constructor(x);
	}

	return x;
}

const defineAppConfig = (config) => config;

const appConfig0 = defineAppConfig({
  name: "KDC Tutor School",
  version: "1.0.0",
  theme: {
    primary: "#2563eb",
    secondary: "#10b981",
    accent: "#f97316"
  }
});

const inlineAppConfig = {
  "nuxt": {}
};

const appConfig = defuFn(appConfig0, inlineAppConfig);

const NUMBER_CHAR_RE = /\d/;
const STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char)) {
    return void 0;
  }
  return char !== char.toLowerCase();
}
function splitByCase(str, separators) {
  const splitters = STR_SPLITTERS;
  const parts = [];
  if (!str || typeof str !== "string") {
    return parts;
  }
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = splitters.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function kebabCase(str, joiner) {
  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => p.toLowerCase()).join(joiner) : "";
}
function snakeCase(str) {
  return kebabCase(str || "", "_");
}

function getEnv(key, opts) {
  const envKey = snakeCase(key).toUpperCase();
  return destr(
    process.env[opts.prefix + envKey] ?? process.env[opts.altPrefix + envKey]
  );
}
function _isObject(input) {
  return typeof input === "object" && !Array.isArray(input);
}
function applyEnv(obj, opts, parentKey = "") {
  for (const key in obj) {
    const subKey = parentKey ? `${parentKey}_${key}` : key;
    const envValue = getEnv(subKey, opts);
    if (_isObject(obj[key])) {
      if (_isObject(envValue)) {
        obj[key] = { ...obj[key], ...envValue };
        applyEnv(obj[key], opts, subKey);
      } else if (envValue === void 0) {
        applyEnv(obj[key], opts, subKey);
      } else {
        obj[key] = envValue ?? obj[key];
      }
    } else {
      obj[key] = envValue ?? obj[key];
    }
    if (opts.envExpansion && typeof obj[key] === "string") {
      obj[key] = _expandFromEnv(obj[key]);
    }
  }
  return obj;
}
const envExpandRx = /\{\{([^{}]*)\}\}/g;
function _expandFromEnv(value) {
  return value.replace(envExpandRx, (match, key) => {
    return process.env[key] || match;
  });
}

const _inlineRuntimeConfig = {
  "app": {
    "baseURL": "/",
    "buildId": "c56e8ffe-2a3b-4e5e-bffa-d3756b0e67a8",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  },
  "nitro": {
    "envPrefix": "NUXT_",
    "routeRules": {
      "/__nuxt_error": {
        "cache": false
      },
      "/_nuxt/builds/meta/**": {
        "headers": {
          "cache-control": "public, max-age=31536000, immutable"
        }
      },
      "/_nuxt/builds/**": {
        "headers": {
          "cache-control": "public, max-age=1, immutable"
        }
      },
      "/_nuxt/**": {
        "headers": {
          "cache-control": "public, max-age=31536000, immutable"
        }
      }
    }
  },
  "public": {
    "apiBase": "/api",
    "appName": "KDC Tutor School",
    "appVersion": "1.0.0",
    "i18n": {
      "configLocales": [],
      "defaultLocale": "th",
      "strategy": "prefix_except_default",
      "differentDomains": false,
      "multiDomainLocales": [],
      "skipSettingLocaleOnNavigate": false,
      "routesNameSeparator": "___",
      "defaultLocaleRouteNameSuffix": "default",
      "defaultDirection": "ltr",
      "experimental": {
        "switchLocalePathLinkSSR": false
      }
    }
  },
  "dbHost": "localhost",
  "dbPort": 3306,
  "dbName": "tutordb",
  "dbUser": "root",
  "dbPassword": "",
  "jwtSecret": "t5sW0QA+fA8vkUS6bbtdIdLBfAcA6qtKWGNTuWswCQE=",
  "jwtRefreshSecret": "aJ2YfuWgoLv44yXtI/4W38pZA379nSRQ5J5s0MwQZlo=",
  "jwtExpiresIn": "15m",
  "jwtRefreshExpiresIn": "7d",
  "redisHost": "localhost",
  "redisPort": 6379,
  "redisPassword": "",
  "redisDb": 0
};
const envOptions = {
  prefix: "NITRO_",
  altPrefix: _inlineRuntimeConfig.nitro.envPrefix ?? process.env.NITRO_ENV_PREFIX ?? "_",
  envExpansion: _inlineRuntimeConfig.nitro.envExpansion ?? process.env.NITRO_ENV_EXPANSION ?? false
};
const _sharedRuntimeConfig = _deepFreeze(
  applyEnv(klona(_inlineRuntimeConfig), envOptions)
);
function useRuntimeConfig$1(event) {
  if (!event) {
    return _sharedRuntimeConfig;
  }
  if (event.context.nitro.runtimeConfig) {
    return event.context.nitro.runtimeConfig;
  }
  const runtimeConfig = klona(_inlineRuntimeConfig);
  applyEnv(runtimeConfig, envOptions);
  event.context.nitro.runtimeConfig = runtimeConfig;
  return runtimeConfig;
}
_deepFreeze(klona(appConfig));
function _deepFreeze(object) {
  const propNames = Object.getOwnPropertyNames(object);
  for (const name of propNames) {
    const value = object[name];
    if (value && typeof value === "object") {
      _deepFreeze(value);
    }
  }
  return Object.freeze(object);
}
new Proxy(/* @__PURE__ */ Object.create(null), {
  get: (_, prop) => {
    console.warn(
      "Please use `useRuntimeConfig()` instead of accessing config directly."
    );
    const runtimeConfig = useRuntimeConfig$1();
    if (prop in runtimeConfig) {
      return runtimeConfig[prop];
    }
    return void 0;
  }
});

function createContext(opts = {}) {
  let currentInstance;
  let isSingleton = false;
  const checkConflict = (instance) => {
    if (currentInstance && currentInstance !== instance) {
      throw new Error("Context conflict");
    }
  };
  let als;
  if (opts.asyncContext) {
    const _AsyncLocalStorage = opts.AsyncLocalStorage || globalThis.AsyncLocalStorage;
    if (_AsyncLocalStorage) {
      als = new _AsyncLocalStorage();
    } else {
      console.warn("[unctx] `AsyncLocalStorage` is not provided.");
    }
  }
  const _getCurrentInstance = () => {
    if (als) {
      const instance = als.getStore();
      if (instance !== void 0) {
        return instance;
      }
    }
    return currentInstance;
  };
  return {
    use: () => {
      const _instance = _getCurrentInstance();
      if (_instance === void 0) {
        throw new Error("Context is not available");
      }
      return _instance;
    },
    tryUse: () => {
      return _getCurrentInstance();
    },
    set: (instance, replace) => {
      if (!replace) {
        checkConflict(instance);
      }
      currentInstance = instance;
      isSingleton = true;
    },
    unset: () => {
      currentInstance = void 0;
      isSingleton = false;
    },
    call: (instance, callback) => {
      checkConflict(instance);
      currentInstance = instance;
      try {
        return als ? als.run(instance, callback) : callback();
      } finally {
        if (!isSingleton) {
          currentInstance = void 0;
        }
      }
    },
    async callAsync(instance, callback) {
      currentInstance = instance;
      const onRestore = () => {
        currentInstance = instance;
      };
      const onLeave = () => currentInstance === instance ? onRestore : void 0;
      asyncHandlers.add(onLeave);
      try {
        const r = als ? als.run(instance, callback) : callback();
        if (!isSingleton) {
          currentInstance = void 0;
        }
        return await r;
      } finally {
        asyncHandlers.delete(onLeave);
      }
    }
  };
}
function createNamespace(defaultOpts = {}) {
  const contexts = {};
  return {
    get(key, opts = {}) {
      if (!contexts[key]) {
        contexts[key] = createContext({ ...defaultOpts, ...opts });
      }
      return contexts[key];
    }
  };
}
const _globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : {};
const globalKey = "__unctx__";
const defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());
const getContext = (key, opts = {}) => defaultNamespace.get(key, opts);
const asyncHandlersKey = "__unctx_async_handlers__";
const asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());
function executeAsync(function_) {
  const restores = [];
  for (const leaveHandler of asyncHandlers) {
    const restore2 = leaveHandler();
    if (restore2) {
      restores.push(restore2);
    }
  }
  const restore = () => {
    for (const restore2 of restores) {
      restore2();
    }
  };
  let awaitable = function_();
  if (awaitable && typeof awaitable === "object" && "catch" in awaitable) {
    awaitable = awaitable.catch((error) => {
      restore();
      throw error;
    });
  }
  return [awaitable, restore];
}

getContext("nitro-app", {
  asyncContext: false,
  AsyncLocalStorage: void 0
});

const config$1 = useRuntimeConfig$1();
const _routeRulesMatcher = toRouteMatcher(
  createRouter$1({ routes: config$1.nitro.routeRules })
);
function createRouteRulesHandler(ctx) {
  return eventHandler((event) => {
    const routeRules = getRouteRules$1(event);
    if (routeRules.headers) {
      setHeaders(event, routeRules.headers);
    }
    if (routeRules.redirect) {
      let target = routeRules.redirect.to;
      if (target.endsWith("/**")) {
        let targetPath = event.path;
        const strpBase = routeRules.redirect._redirectStripBase;
        if (strpBase) {
          targetPath = withoutBase(targetPath, strpBase);
        }
        target = joinURL(target.slice(0, -3), targetPath);
      } else if (event.path.includes("?")) {
        const query = getQuery$1(event.path);
        target = withQuery(target, query);
      }
      return sendRedirect(event, target, routeRules.redirect.statusCode);
    }
    if (routeRules.proxy) {
      let target = routeRules.proxy.to;
      if (target.endsWith("/**")) {
        let targetPath = event.path;
        const strpBase = routeRules.proxy._proxyStripBase;
        if (strpBase) {
          targetPath = withoutBase(targetPath, strpBase);
        }
        target = joinURL(target.slice(0, -3), targetPath);
      } else if (event.path.includes("?")) {
        const query = getQuery$1(event.path);
        target = withQuery(target, query);
      }
      return proxyRequest(event, target, {
        fetch: ctx.localFetch,
        ...routeRules.proxy
      });
    }
  });
}
function getRouteRules$1(event) {
  event.context._nitro = event.context._nitro || {};
  if (!event.context._nitro.routeRules) {
    event.context._nitro.routeRules = getRouteRulesForPath(
      withoutBase(event.path.split("?")[0], useRuntimeConfig$1().app.baseURL)
    );
  }
  return event.context._nitro.routeRules;
}
function getRouteRulesForPath(path) {
  return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());
}

function _captureError(error, type) {
  console.error(`[${type}]`, error);
  useNitroApp().captureError(error, { tags: [type] });
}
function trapUnhandledNodeErrors() {
  process.on(
    "unhandledRejection",
    (error) => _captureError(error, "unhandledRejection")
  );
  process.on(
    "uncaughtException",
    (error) => _captureError(error, "uncaughtException")
  );
}
function joinHeaders(value) {
  return Array.isArray(value) ? value.join(", ") : String(value);
}
function normalizeFetchResponse(response) {
  if (!response.headers.has("set-cookie")) {
    return response;
  }
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: normalizeCookieHeaders(response.headers)
  });
}
function normalizeCookieHeader(header = "") {
  return splitCookiesString(joinHeaders(header));
}
function normalizeCookieHeaders(headers) {
  const outgoingHeaders = new Headers();
  for (const [name, header] of headers) {
    if (name === "set-cookie") {
      for (const cookie of normalizeCookieHeader(header)) {
        outgoingHeaders.append("set-cookie", cookie);
      }
    } else {
      outgoingHeaders.set(name, joinHeaders(header));
    }
  }
  return outgoingHeaders;
}

function isJsonRequest(event) {
  if (hasReqHeader(event, "accept", "text/html")) {
    return false;
  }
  return hasReqHeader(event, "accept", "application/json") || hasReqHeader(event, "user-agent", "curl/") || hasReqHeader(event, "user-agent", "httpie/") || hasReqHeader(event, "sec-fetch-mode", "cors") || event.path.startsWith("/api/") || event.path.endsWith(".json");
}
function hasReqHeader(event, name, includes) {
  const value = getRequestHeader(event, name);
  return value && typeof value === "string" && value.toLowerCase().includes(includes);
}

const errorHandler$0 = (async function errorhandler(error, event, { defaultHandler }) {
  if (event.handled || isJsonRequest(event)) {
    return;
  }
  const defaultRes = await defaultHandler(error, event, { json: true });
  const statusCode = error.statusCode || 500;
  if (statusCode === 404 && defaultRes.status === 302) {
    setResponseHeaders(event, defaultRes.headers);
    setResponseStatus(event, defaultRes.status, defaultRes.statusText);
    return send(event, JSON.stringify(defaultRes.body, null, 2));
  }
  const errorObject = defaultRes.body;
  const url = new URL(errorObject.url);
  errorObject.url = withoutBase(url.pathname, useRuntimeConfig$1(event).app.baseURL) + url.search + url.hash;
  errorObject.message ||= "Server Error";
  errorObject.data ||= error.data;
  errorObject.statusMessage ||= error.statusMessage;
  delete defaultRes.headers["content-type"];
  delete defaultRes.headers["content-security-policy"];
  setResponseHeaders(event, defaultRes.headers);
  const reqHeaders = getRequestHeaders(event);
  const isRenderingError = event.path.startsWith("/__nuxt_error") || !!reqHeaders["x-nuxt-error"];
  const res = isRenderingError ? null : await useNitroApp().localFetch(
    withQuery(joinURL(useRuntimeConfig$1(event).app.baseURL, "/__nuxt_error"), errorObject),
    {
      headers: { ...reqHeaders, "x-nuxt-error": "true" },
      redirect: "manual"
    }
  ).catch(() => null);
  if (event.handled) {
    return;
  }
  if (!res) {
    const { template } = await Promise.resolve().then(function () { return error500; });
    setResponseHeader(event, "Content-Type", "text/html;charset=UTF-8");
    return send(event, template(errorObject));
  }
  const html = await res.text();
  for (const [header, value] of res.headers.entries()) {
    if (header === "set-cookie") {
      appendResponseHeader(event, header, value);
      continue;
    }
    setResponseHeader(event, header, value);
  }
  setResponseStatus(event, res.status && res.status !== 200 ? res.status : defaultRes.status, res.statusText || defaultRes.statusText);
  return send(event, html);
});

function defineNitroErrorHandler(handler) {
  return handler;
}

const errorHandler$1 = defineNitroErrorHandler(
  function defaultNitroErrorHandler(error, event) {
    const res = defaultHandler(error, event);
    setResponseHeaders(event, res.headers);
    setResponseStatus(event, res.status, res.statusText);
    return send(event, JSON.stringify(res.body, null, 2));
  }
);
function defaultHandler(error, event, opts) {
  const isSensitive = error.unhandled || error.fatal;
  const statusCode = error.statusCode || 500;
  const statusMessage = error.statusMessage || "Server Error";
  const url = getRequestURL(event, { xForwardedHost: true, xForwardedProto: true });
  if (statusCode === 404) {
    const baseURL = "/";
    if (/^\/[^/]/.test(baseURL) && !url.pathname.startsWith(baseURL)) {
      const redirectTo = `${baseURL}${url.pathname.slice(1)}${url.search}`;
      return {
        status: 302,
        statusText: "Found",
        headers: { location: redirectTo },
        body: `Redirecting...`
      };
    }
  }
  if (isSensitive && !opts?.silent) {
    const tags = [error.unhandled && "[unhandled]", error.fatal && "[fatal]"].filter(Boolean).join(" ");
    console.error(`[request error] ${tags} [${event.method}] ${url}
`, error);
  }
  const headers = {
    "content-type": "application/json",
    // Prevent browser from guessing the MIME types of resources.
    "x-content-type-options": "nosniff",
    // Prevent error page from being embedded in an iframe
    "x-frame-options": "DENY",
    // Prevent browsers from sending the Referer header
    "referrer-policy": "no-referrer",
    // Disable the execution of any js
    "content-security-policy": "script-src 'none'; frame-ancestors 'none';"
  };
  setResponseStatus(event, statusCode, statusMessage);
  if (statusCode === 404 || !getResponseHeader(event, "cache-control")) {
    headers["cache-control"] = "no-cache";
  }
  const body = {
    error: true,
    url: url.href,
    statusCode,
    statusMessage,
    message: isSensitive ? "Server Error" : error.message,
    data: isSensitive ? void 0 : error.data
  };
  return {
    status: statusCode,
    statusText: statusMessage,
    headers,
    body
  };
}

const errorHandlers = [errorHandler$0, errorHandler$1];

async function errorHandler(error, event) {
  for (const handler of errorHandlers) {
    try {
      await handler(error, event, { defaultHandler });
      if (event.handled) {
        return; // Response handled
      }
    } catch(error) {
      // Handler itself thrown, log and continue
      console.error(error);
    }
  }
  // H3 will handle fallback
}

function defineNitroPlugin(def) {
  return def;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

var engine_io = {};

const require$$1$6 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$2$4);

var server$2 = {};

const require$$0$7 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(querystring);

const require$$7$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$7$3);

var base64id$1 = {exports: {}};

const require$$3$3 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$1$7);

/*!
 * base64id v0.1.0
 */

(function (module, exports$1) {
	/**
	 * Module dependencies
	 */

	var crypto = require$$3$3;

	/**
	 * Constructor
	 */

	var Base64Id = function() { };

	/**
	 * Get random bytes
	 *
	 * Uses a buffer if available, falls back to crypto.randomBytes
	 */

	Base64Id.prototype.getRandomBytes = function(bytes) {

	  var BUFFER_SIZE = 4096;
	  var self = this;  
	  
	  bytes = bytes || 12;

	  if (bytes > BUFFER_SIZE) {
	    return crypto.randomBytes(bytes);
	  }
	  
	  var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);
	  var threshold = parseInt(bytesInBuffer*0.85);

	  if (!threshold) {
	    return crypto.randomBytes(bytes);
	  }

	  if (this.bytesBufferIndex == null) {
	     this.bytesBufferIndex = -1;
	  }

	  if (this.bytesBufferIndex == bytesInBuffer) {
	    this.bytesBuffer = null;
	    this.bytesBufferIndex = -1;
	  }

	  // No buffered bytes available or index above threshold
	  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
	     
	    if (!this.isGeneratingBytes) {
	      this.isGeneratingBytes = true;
	      crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {
	        self.bytesBuffer = bytes;
	        self.bytesBufferIndex = 0;
	        self.isGeneratingBytes = false;
	      }); 
	    }
	    
	    // Fall back to sync call when no buffered bytes are available
	    if (this.bytesBufferIndex == -1) {
	      return crypto.randomBytes(bytes);
	    }
	  }
	  
	  var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); 
	  this.bytesBufferIndex++; 
	  
	  return result;
	};

	/**
	 * Generates a base64 id
	 *
	 * (Original version from socket.io <http://socket.io>)
	 */

	Base64Id.prototype.generateId = function () {
	  var rand = Buffer.alloc(15); // multiple of 3 for base64
	  if (!rand.writeInt32BE) {
	    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()
	      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
	  }
	  this.sequenceNumber = (this.sequenceNumber + 1) | 0;
	  rand.writeInt32BE(this.sequenceNumber, 11);
	  if (crypto.randomBytes) {
	    this.getRandomBytes(12).copy(rand);
	  } else {
	    // not secure for node 0.4
	    [0, 4, 8].forEach(function(i) {
	      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
	    });
	  }
	  return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
	};

	/**
	 * Export
	 */

	module.exports = new Base64Id(); 
} (base64id$1));

var base64idExports = base64id$1.exports;

var transports = {};

var polling$2 = {};

var transport = {};

const require$$0$6 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$0$3$1);

const PACKET_TYPES = Object.create(null); // no Map = no polyfill
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };

const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
        return callback(supportsBinary ? data : "b" + toBuffer$6(data, true).toString("base64"));
    }
    // plain string
    return callback(PACKET_TYPES[type] + (data || ""));
};
const toBuffer$6 = (data, forceBufferConversion) => {
    if (Buffer.isBuffer(data) ||
        (data instanceof Uint8Array && !forceBufferConversion)) {
        return data;
    }
    else if (data instanceof ArrayBuffer) {
        return Buffer.from(data);
    }
    else {
        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    }
};
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return callback(toBuffer$6(packet.data, false));
    }
    encodePacket(packet, true, (encoded) => {
        if (!TEXT_ENCODER) {
            // lazily created for compatibility with Node.js 10
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}

const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType),
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        const buffer = Buffer.from(encodedPacket.substring(1), "base64");
        return {
            type: "message",
            data: mapBinary(buffer, binaryType),
        };
    }
    if (!PACKET_TYPES_REVERSE[type]) {
        return ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
        }
        : {
            type: PACKET_TYPES_REVERSE[type],
        };
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "arraybuffer":
            if (data instanceof ArrayBuffer) {
                // from WebSocket & binaryType "arraybuffer"
                return data;
            }
            else if (Buffer.isBuffer(data)) {
                // from HTTP long-polling
                return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
            }
            else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
        case "nodebuffer":
        default:
            if (Buffer.isBuffer(data)) {
                // from HTTP long-polling or WebSocket & binaryType "nodebuffer" (default)
                return data;
            }
            else {
                // from WebTransport (Uint8Array)
                return Buffer.from(data);
            }
    }
};

const SEPARATOR$1 = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        encodePacket(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR$1));
            }
        });
    });
};
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR$1);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = decodePacket(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
function createPacketEncoderStream() {
    return new TransformStream({
        transform(packet, controller) {
            encodePacketToBinary(packet, (encodedPacket) => {
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                }
                else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                }
                else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        },
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* State.READ_HEADER */;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            while (true) {
                if (state === 0 /* State.READ_HEADER */) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* State.READ_PAYLOAD */;
                    }
                    else if (expectedLength === 126) {
                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
                    }
                    else {
                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
                    }
                }
                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(ERROR_PACKET);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* State.READ_HEADER */;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(ERROR_PACKET);
                    break;
                }
            }
        },
    });
}
const protocol$1 = 4;

const esm = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  createPacketDecoderStream: createPacketDecoderStream,
  createPacketEncoderStream: createPacketEncoderStream,
  decodePacket: decodePacket,
  decodePayload: decodePayload,
  encodePacket: encodePacket,
  encodePayload: encodePayload,
  protocol: protocol$1
}, Symbol.toStringTag, { value: 'Module' }));

var parserV3 = {};

/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;
// Taken from https://mths.be/punycode
function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    var value;
    var extra;
    while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            // high surrogate, and there is a next character
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            }
            else {
                // unmatched surrogate; only append this code unit, in case the next
                // code unit is the high surrogate of a surrogate pair
                output.push(value);
                counter--;
            }
        }
        else {
            output.push(value);
        }
    }
    return output;
}
// Taken from https://mths.be/punycode
function ucs2encode(array) {
    var length = array.length;
    var index = -1;
    var value;
    var output = '';
    while (++index < length) {
        value = array[index];
        if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
        }
        output += stringFromCharCode(value);
    }
    return output;
}
function checkScalarValue(codePoint, strict) {
    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
        if (strict) {
            throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
                ' is not a scalar value');
        }
        return false;
    }
    return true;
}
/*--------------------------------------------------------------------------*/
function createByte(codePoint, shift) {
    return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}
function encodeCodePoint(codePoint, strict) {
    if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
        return stringFromCharCode(codePoint);
    }
    var symbol = '';
    if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
        symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
    }
    else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
        if (!checkScalarValue(codePoint, strict)) {
            codePoint = 0xFFFD;
        }
        symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
        symbol += createByte(codePoint, 6);
    }
    else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
        symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
        symbol += createByte(codePoint, 12);
        symbol += createByte(codePoint, 6);
    }
    symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
    return symbol;
}
function utf8encode(string, opts) {
    opts = opts || {};
    var strict = false !== opts.strict;
    var codePoints = ucs2decode(string);
    var length = codePoints.length;
    var index = -1;
    var codePoint;
    var byteString = '';
    while (++index < length) {
        codePoint = codePoints[index];
        byteString += encodeCodePoint(codePoint, strict);
    }
    return byteString;
}
/*--------------------------------------------------------------------------*/
function readContinuationByte() {
    if (byteIndex >= byteCount) {
        throw Error('Invalid byte index');
    }
    var continuationByte = byteArray[byteIndex] & 0xFF;
    byteIndex++;
    if ((continuationByte & 0xC0) == 0x80) {
        return continuationByte & 0x3F;
    }
    // If we end up here, its not a continuation byte
    throw Error('Invalid continuation byte');
}
function decodeSymbol(strict) {
    var byte1;
    var byte2;
    var byte3;
    var byte4;
    var codePoint;
    if (byteIndex > byteCount) {
        throw Error('Invalid byte index');
    }
    if (byteIndex == byteCount) {
        return false;
    }
    // Read first byte
    byte1 = byteArray[byteIndex] & 0xFF;
    byteIndex++;
    // 1-byte sequence (no continuation bytes)
    if ((byte1 & 0x80) == 0) {
        return byte1;
    }
    // 2-byte sequence
    if ((byte1 & 0xE0) == 0xC0) {
        byte2 = readContinuationByte();
        codePoint = ((byte1 & 0x1F) << 6) | byte2;
        if (codePoint >= 0x80) {
            return codePoint;
        }
        else {
            throw Error('Invalid continuation byte');
        }
    }
    // 3-byte sequence (may include unpaired surrogates)
    if ((byte1 & 0xF0) == 0xE0) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
        if (codePoint >= 0x0800) {
            return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
        }
        else {
            throw Error('Invalid continuation byte');
        }
    }
    // 4-byte sequence
    if ((byte1 & 0xF8) == 0xF0) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        byte4 = readContinuationByte();
        codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
            (byte3 << 0x06) | byte4;
        if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
            return codePoint;
        }
    }
    throw Error('Invalid UTF-8 detected');
}
var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
    opts = opts || {};
    var strict = false !== opts.strict;
    byteArray = ucs2decode(byteString);
    byteCount = byteArray.length;
    byteIndex = 0;
    var codePoints = [];
    var tmp;
    while ((tmp = decodeSymbol(strict)) !== false) {
        codePoints.push(tmp);
    }
    return ucs2encode(codePoints);
}
var utf8 = {
    version: '2.1.2',
    encode: utf8encode,
    decode: utf8decode
};

(function (exports$1) {
	// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x
	Object.defineProperty(exports$1, "__esModule", { value: true });
	exports$1.packets = exports$1.protocol = void 0;
	exports$1.encodePacket = encodePacket;
	exports$1.encodeBase64Packet = encodeBase64Packet;
	exports$1.decodePacket = decodePacket;
	exports$1.decodeBase64Packet = decodeBase64Packet;
	exports$1.encodePayload = encodePayload;
	exports$1.decodePayload = decodePayload;
	exports$1.encodePayloadAsBinary = encodePayloadAsBinary;
	exports$1.decodePayloadAsBinary = decodePayloadAsBinary;
	/**
	 * Module dependencies.
	 */
	var utf8$1 = utf8;
	/**
	 * Current protocol version.
	 */
	exports$1.protocol = 3;
	const hasBinary = (packets) => {
	    for (const packet of packets) {
	        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
	            return true;
	        }
	    }
	    return false;
	};
	/**
	 * Packet types.
	 */
	exports$1.packets = {
	    open: 0 // non-ws
	    ,
	    close: 1 // non-ws
	    ,
	    ping: 2,
	    pong: 3,
	    message: 4,
	    upgrade: 5,
	    noop: 6
	};
	var packetslist = Object.keys(exports$1.packets);
	/**
	 * Premade error packet.
	 */
	var err = { type: 'error', data: 'parser error' };
	const EMPTY_BUFFER = Buffer.concat([]);
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	function encodePacket(packet, supportsBinary, utf8encode, callback) {
	    if (typeof supportsBinary === 'function') {
	        callback = supportsBinary;
	        supportsBinary = null;
	    }
	    if (typeof utf8encode === 'function') {
	        callback = utf8encode;
	        utf8encode = null;
	    }
	    if (Buffer.isBuffer(packet.data)) {
	        return encodeBuffer(packet, supportsBinary, callback);
	    }
	    else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
	        return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
	    }
	    // Sending data as a utf-8 string
	    var encoded = exports$1.packets[packet.type];
	    // data fragment is optional
	    if (undefined !== packet.data) {
	        encoded += utf8encode ? utf8$1.encode(String(packet.data), { strict: false }) : String(packet.data);
	    }
	    return callback('' + encoded);
	}
	/**
	 * Encode Buffer data
	 */
	function encodeBuffer(packet, supportsBinary, callback) {
	    if (!supportsBinary) {
	        return encodeBase64Packet(packet, callback);
	    }
	    var data = packet.data;
	    var typeBuffer = Buffer.allocUnsafe(1);
	    typeBuffer[0] = exports$1.packets[packet.type];
	    return callback(Buffer.concat([typeBuffer, data]));
	}
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	function encodeBase64Packet(packet, callback) {
	    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
	    var message = 'b' + exports$1.packets[packet.type];
	    message += data.toString('base64');
	    return callback(message);
	}
	/**
	 * Decodes a packet. Data also available as an ArrayBuffer if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	function decodePacket(data, binaryType, utf8decode) {
	    if (data === undefined) {
	        return err;
	    }
	    var type;
	    // String data
	    if (typeof data === 'string') {
	        type = data.charAt(0);
	        if (type === 'b') {
	            return decodeBase64Packet(data.slice(1), binaryType);
	        }
	        if (utf8decode) {
	            data = tryDecode(data);
	            if (data === false) {
	                return err;
	            }
	        }
	        if (Number(type) != type || !packetslist[type]) {
	            return err;
	        }
	        if (data.length > 1) {
	            return { type: packetslist[type], data: data.slice(1) };
	        }
	        else {
	            return { type: packetslist[type] };
	        }
	    }
	    // Binary data
	    if (binaryType === 'arraybuffer') {
	        // wrap Buffer/ArrayBuffer data into an Uint8Array
	        var intArray = new Uint8Array(data);
	        type = intArray[0];
	        return { type: packetslist[type], data: intArray.buffer.slice(1) };
	    }
	    if (data instanceof ArrayBuffer) {
	        data = arrayBufferToBuffer(data);
	    }
	    type = data[0];
	    return { type: packetslist[type], data: data.slice(1) };
	}
	function tryDecode(data) {
	    try {
	        data = utf8$1.decode(data, { strict: false });
	    }
	    catch (e) {
	        return false;
	    }
	    return data;
	}
	/**
	 * Decodes a packet encoded in a base64 string.
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	function decodeBase64Packet(msg, binaryType) {
	    var type = packetslist[msg.charAt(0)];
	    var data = Buffer.from(msg.slice(1), 'base64');
	    if (binaryType === 'arraybuffer') {
	        var abv = new Uint8Array(data.length);
	        for (var i = 0; i < abv.length; i++) {
	            abv[i] = data[i];
	        }
	        // @ts-ignore
	        data = abv.buffer;
	    }
	    return { type: type, data: data };
	}
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	function encodePayload(packets, supportsBinary, callback) {
	    if (typeof supportsBinary === 'function') {
	        callback = supportsBinary;
	        supportsBinary = null;
	    }
	    if (supportsBinary && hasBinary(packets)) {
	        return encodePayloadAsBinary(packets, callback);
	    }
	    if (!packets.length) {
	        return callback('0:');
	    }
	    function encodeOne(packet, doneCallback) {
	        encodePacket(packet, supportsBinary, false, function (message) {
	            doneCallback(null, setLengthHeader(message));
	        });
	    }
	    map(packets, encodeOne, function (err, results) {
	        return callback(results.join(''));
	    });
	}
	function setLengthHeader(message) {
	    return message.length + ':' + message;
	}
	/**
	 * Async array map using after
	 */
	function map(ary, each, done) {
	    const results = new Array(ary.length);
	    let count = 0;
	    for (let i = 0; i < ary.length; i++) {
	        each(ary[i], (error, msg) => {
	            results[i] = msg;
	            if (++count === ary.length) {
	                done(null, results);
	            }
	        });
	    }
	}
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	function decodePayload(data, binaryType, callback) {
	    if (typeof data !== 'string') {
	        return decodePayloadAsBinary(data, binaryType, callback);
	    }
	    if (typeof binaryType === 'function') {
	        callback = binaryType;
	        binaryType = null;
	    }
	    if (data === '') {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	    }
	    var length = '', n, msg, packet;
	    for (var i = 0, l = data.length; i < l; i++) {
	        var chr = data.charAt(i);
	        if (chr !== ':') {
	            length += chr;
	            continue;
	        }
	        // @ts-ignore
	        if (length === '' || (length != (n = Number(length)))) {
	            // parser error - ignoring payload
	            return callback(err, 0, 1);
	        }
	        msg = data.slice(i + 1, i + 1 + n);
	        if (length != msg.length) {
	            // parser error - ignoring payload
	            return callback(err, 0, 1);
	        }
	        if (msg.length) {
	            packet = decodePacket(msg, binaryType, false);
	            if (err.type === packet.type && err.data === packet.data) {
	                // parser error in individual packet - ignoring payload
	                return callback(err, 0, 1);
	            }
	            var more = callback(packet, i + n, l);
	            if (false === more)
	                return;
	        }
	        // advance cursor
	        i += n;
	        length = '';
	    }
	    if (length !== '') {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	    }
	}
	/**
	 *
	 * Converts a buffer to a utf8.js encoded string
	 *
	 * @api private
	 */
	function bufferToString(buffer) {
	    var str = '';
	    for (var i = 0, l = buffer.length; i < l; i++) {
	        str += String.fromCharCode(buffer[i]);
	    }
	    return str;
	}
	/**
	 *
	 * Converts a utf8.js encoded string to a buffer
	 *
	 * @api private
	 */
	function stringToBuffer(string) {
	    var buf = Buffer.allocUnsafe(string.length);
	    for (var i = 0, l = string.length; i < l; i++) {
	        buf.writeUInt8(string.charCodeAt(i), i);
	    }
	    return buf;
	}
	/**
	 *
	 * Converts an ArrayBuffer to a Buffer
	 *
	 * @api private
	 */
	function arrayBufferToBuffer(data) {
	    // data is either an ArrayBuffer or ArrayBufferView.
	    var length = data.byteLength || data.length;
	    var offset = data.byteOffset || 0;
	    return Buffer.from(data.buffer || data, offset, length);
	}
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {Buffer} encoded payload
	 * @api private
	 */
	function encodePayloadAsBinary(packets, callback) {
	    if (!packets.length) {
	        return callback(EMPTY_BUFFER);
	    }
	    map(packets, encodeOneBinaryPacket, function (err, results) {
	        return callback(Buffer.concat(results));
	    });
	}
	function encodeOneBinaryPacket(p, doneCallback) {
	    function onBinaryPacketEncode(packet) {
	        var encodingLength = '' + packet.length;
	        var sizeBuffer;
	        if (typeof packet === 'string') {
	            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
	            sizeBuffer[0] = 0; // is a string (not true binary = 0)
	            for (var i = 0; i < encodingLength.length; i++) {
	                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
	            }
	            sizeBuffer[sizeBuffer.length - 1] = 255;
	            return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
	        }
	        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
	        sizeBuffer[0] = 1; // is binary (true binary = 1)
	        for (var i = 0; i < encodingLength.length; i++) {
	            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
	        }
	        sizeBuffer[sizeBuffer.length - 1] = 255;
	        doneCallback(null, Buffer.concat([sizeBuffer, packet]));
	    }
	    encodePacket(p, true, true, onBinaryPacketEncode);
	}
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary

	 * @param {Buffer} data, callback method
	 * @api public
	 */
	function decodePayloadAsBinary(data, binaryType, callback) {
	    if (typeof binaryType === 'function') {
	        callback = binaryType;
	        binaryType = null;
	    }
	    var bufferTail = data;
	    var buffers = [];
	    var i;
	    while (bufferTail.length > 0) {
	        var strLen = '';
	        var isString = bufferTail[0] === 0;
	        for (i = 1;; i++) {
	            if (bufferTail[i] === 255)
	                break;
	            // 310 = char length of Number.MAX_VALUE
	            if (strLen.length > 310) {
	                return callback(err, 0, 1);
	            }
	            strLen += '' + bufferTail[i];
	        }
	        bufferTail = bufferTail.slice(strLen.length + 1);
	        var msgLength = parseInt(strLen, 10);
	        var msg = bufferTail.slice(1, msgLength + 1);
	        if (isString)
	            msg = bufferToString(msg);
	        buffers.push(msg);
	        bufferTail = bufferTail.slice(msgLength + 1);
	    }
	    var total = buffers.length;
	    for (i = 0; i < total; i++) {
	        var buffer = buffers[i];
	        callback(decodePacket(buffer, binaryType, true), i, total);
	    }
	}
} (parserV3));

function createDebug(namespace) {
	return Object.assign((...args) => {
		const env = globalThis.process?.env.DEBUG;
		if (!env || env !== "*" && !env.startsWith(namespace)) return;
		console.debug(...args);
	}, {
		color: "#000000",
		diff: 0,
		enabled: true,
		log: console.debug.bind(console),
		namespace,
		destroy: () => false,
		extend: (ns, _del) => createDebug(namespace + ns)
	});
}
const debug$h = Object.assign(createDebug, {
	coerce: (val) => val,
	disable: () => "",
	enable: (_namespaces) => {},
	enabled: (_namespaces) => true,
	formatArgs(args) {
		args[0] = `${this.namespace} ${args[0]}`;
	},
	log: console.debug.bind(console),
	selectColor: (_namespace) => 0,
	humanize: (num) => `${num}ms`,
	inspectOpts: {},
	names: [],
	skips: [],
	formatters: {}
});
const coerce$2 = debug$h.coerce;
const disable = debug$h.disable;
const enable = debug$h.enable;
const enabled = debug$h.enabled;
const formatArgs = debug$h.formatArgs;
const log = debug$h.log;
const selectColor = debug$h.selectColor;
const humanize = debug$h.humanize;
const names = debug$h.names;
const skips = debug$h.skips;
const formatters = debug$h.formatters;

const debug$i = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  coerce: coerce$2,
  default: debug$h,
  disable: disable,
  enable: enable,
  enabled: enabled,
  formatArgs: formatArgs,
  formatters: formatters,
  humanize: humanize,
  log: log,
  names: names,
  selectColor: selectColor,
  skips: skips
}, Symbol.toStringTag, { value: 'Module' }));

const require$$13 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(debug$i);

Object.defineProperty(transport, "__esModule", { value: true });
transport.Transport = void 0;
const events_1$4 = require$$0$6;
const parser_v4 = esm;
const parser_v3 = parserV3;
const debug_1$c = require$$13;
const debug$g = (0, debug_1$c.default)("engine:transport");
function noop$1() { }
class Transport extends events_1$4.EventEmitter {
    get readyState() {
        return this._readyState;
    }
    set readyState(state) {
        debug$g("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
        this._readyState = state;
    }
    /**
     * Transport constructor.
     *
     * @param {EngineRequest} req
     */
    constructor(req) {
        super();
        /**
         * Whether the transport is currently ready to send packets.
         */
        this.writable = false;
        /**
         * The current state of the transport.
         * @protected
         */
        this._readyState = "open";
        /**
         * Whether the transport is discarded and can be safely closed (used during upgrade).
         * @protected
         */
        this.discarded = false;
        this.protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default
        this.parser = this.protocol === 4 ? parser_v4 : parser_v3;
        this.supportsBinary = !(req._query && req._query.b64);
    }
    /**
     * Flags the transport as discarded.
     *
     * @package
     */
    discard() {
        this.discarded = true;
    }
    /**
     * Called with an incoming HTTP request.
     *
     * @param req
     * @package
     */
    onRequest(req) { }
    /**
     * Closes the transport.
     *
     * @package
     */
    close(fn) {
        if ("closed" === this.readyState || "closing" === this.readyState)
            return;
        this.readyState = "closing";
        this.doClose(fn || noop$1);
    }
    /**
     * Called with a transport error.
     *
     * @param {String} msg - message error
     * @param {Object} desc - error description
     * @protected
     */
    onError(msg, desc) {
        if (this.listeners("error").length) {
            const err = new Error(msg);
            // @ts-ignore
            err.type = "TransportError";
            // @ts-ignore
            err.description = desc;
            this.emit("error", err);
        }
        else {
            debug$g("ignored transport error %s (%s)", msg, desc);
        }
    }
    /**
     * Called with parsed out a packets from the data stream.
     *
     * @param {Object} packet
     * @protected
     */
    onPacket(packet) {
        this.emit("packet", packet);
    }
    /**
     * Called with the encoded packet data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
        this.onPacket(this.parser.decodePacket(data));
    }
    /**
     * Called upon transport close.
     *
     * @protected
     */
    onClose() {
        this.readyState = "closed";
        this.emit("close");
    }
}
transport.Transport = Transport;

const require$$0$5 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$0$8);

var negotiator = {exports: {}};

var charset = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

charset.exports = preferredCharsets$1;
charset.exports.preferredCharsets = preferredCharsets$1;

/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */

function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;

  var charset = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a charset.
 * @private
 */

function getCharsetPriority(charset, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$3(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the charset.
 * @private
 */

function specify$3(charset, spec, index) {
  var s = 0;
  if(spec.charset.toLowerCase() === charset.toLowerCase()){
    s |= 1;
  } else if (spec.charset !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}

/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */

function preferredCharsets$1(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts
      .filter(isQuality$3)
      .sort(compareSpecs$3)
      .map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  });

  // sorted list of accepted charsets
  return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs$3(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full charset string.
 * @private
 */

function getFullCharset(spec) {
  return spec.charset;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality$3(spec) {
  return spec.q > 0;
}

var charsetExports = charset.exports;

var encoding = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

encoding.exports = preferredEncodings$1;
encoding.exports.preferredEncodings = preferredEncodings$1;

/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify$2('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}

/**
 * Get the priority of an encoding.
 * @private
 */

function getEncodingPriority(encoding, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$2(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the encoding.
 * @private
 */

function specify$2(encoding, spec, index) {
  var s = 0;
  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
    s |= 1;
  } else if (spec.encoding !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}
/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings$1(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts
      .filter(isQuality$2)
      .sort(compareSpecs$2)
      .map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  });

  // sorted list of accepted encodings
  return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs$2(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full encoding string.
 * @private
 */

function getFullEncoding(spec) {
  return spec.encoding;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality$2(spec) {
  return spec.q > 0;
}

var encodingExports = encoding.exports;

var language = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

language.exports = preferredLanguages$1;
language.exports.preferredLanguages = preferredLanguages$1;

/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 */

function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  var prefix = match[1];
  var suffix = match[2];
  var full = prefix;

  if (suffix) full += "-" + suffix;

  var q = 1;
  if (match[3]) {
    var params = match[3].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}

/**
 * Get the priority of a language.
 * @private
 */

function getLanguagePriority(language, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$1(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 */

function specify$1(language, spec, index) {
  var p = parseLanguage(language);
  if (!p) return null;
  var s = 0;
  if(spec.full.toLowerCase() === p.full.toLowerCase()){
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}
/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages$1(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts
      .filter(isQuality$1)
      .sort(compareSpecs$1)
      .map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  });

  // sorted list of accepted languages
  return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs$1(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full language string.
 * @private
 */

function getFullLanguage(spec) {
  return spec.full;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality$1(spec) {
  return spec.q > 0;
}

var languageExports = language.exports;

var mediaType = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

mediaType.exports = preferredMediaTypes$1;
mediaType.exports.preferredMediaTypes = preferredMediaTypes$1;

/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a media type from the Accept header.
 * @private
 */

function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;

  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];

      // get the value, unwrapping quotes
      var value = val && val[0] === '"' && val[val.length - 1] === '"'
        ? val.substr(1, val.length - 2)
        : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      }

      // store parameter
      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a media type.
 * @private
 */

function getMediaTypePriority(type, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the media type.
 * @private
 */

function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4;
  } else if(spec.type != '*') {
    return null;
  }

  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2;
  } else if(spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1;
    } else {
      return null
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s,
  }
}

/**
 * Get the preferred media types from an Accept header.
 * @public
 */

function preferredMediaTypes$1(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  });

  // sorted list of accepted types
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full type string.
 * @private
 */

function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}

/**
 * Count the number of quotes in a string.
 * @private
 */

function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}

/**
 * Split a key value pair.
 * @private
 */

function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}

/**
 * Split an Accept header into media types.
 * @private
 */

function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  }

  // trim accepts
  accepts.length = j + 1;

  return accepts;
}

/**
 * Split a string of parameters.
 * @private
 */

function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  }

  // trim parameters
  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}

var mediaTypeExports = mediaType.exports;

/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var preferredCharsets = charsetExports;
var preferredEncodings = encodingExports;
var preferredLanguages = languageExports;
var preferredMediaTypes = mediaTypeExports;

/**
 * Module exports.
 * @public
 */

negotiator.exports = Negotiator$1;
negotiator.exports.Negotiator = Negotiator$1;

/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator$1(request) {
  if (!(this instanceof Negotiator$1)) {
    return new Negotiator$1(request);
  }

  this.request = request;
}

Negotiator$1.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator$1.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator$1.prototype.encoding = function encoding(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator$1.prototype.encodings = function encodings(available) {
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator$1.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator$1.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator$1.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator$1.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};

// Backwards compatibility
Negotiator$1.prototype.preferredCharset = Negotiator$1.prototype.charset;
Negotiator$1.prototype.preferredCharsets = Negotiator$1.prototype.charsets;
Negotiator$1.prototype.preferredEncoding = Negotiator$1.prototype.encoding;
Negotiator$1.prototype.preferredEncodings = Negotiator$1.prototype.encodings;
Negotiator$1.prototype.preferredLanguage = Negotiator$1.prototype.language;
Negotiator$1.prototype.preferredLanguages = Negotiator$1.prototype.languages;
Negotiator$1.prototype.preferredMediaType = Negotiator$1.prototype.mediaType;
Negotiator$1.prototype.preferredMediaTypes = Negotiator$1.prototype.mediaTypes;

var negotiatorExports = negotiator.exports;

var mimeTypes = {};

const require$$0$4 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

var mimeDb = require$$0$4;

const require$$5$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(path$1);

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

(function (exports$1) {

	/**
	 * Module dependencies.
	 * @private
	 */

	var db = mimeDb;
	var extname = require$$5$1.extname;

	/**
	 * Module variables.
	 * @private
	 */

	var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	var TEXT_TYPE_REGEXP = /^text\//i;

	/**
	 * Module exports.
	 * @public
	 */

	exports$1.charset = charset;
	exports$1.charsets = { lookup: charset };
	exports$1.contentType = contentType;
	exports$1.extension = extension;
	exports$1.extensions = Object.create(null);
	exports$1.lookup = lookup;
	exports$1.types = Object.create(null);

	// Populate the extensions/types maps
	populateMaps(exports$1.extensions, exports$1.types);

	/**
	 * Get the default charset for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */

	function charset (type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }

	  // TODO: use media-typer
	  var match = EXTRACT_TYPE_REGEXP.exec(type);
	  var mime = match && db[match[1].toLowerCase()];

	  if (mime && mime.charset) {
	    return mime.charset
	  }

	  // default text/* to utf-8
	  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
	    return 'UTF-8'
	  }

	  return false
	}

	/**
	 * Create a full Content-Type header given a MIME type or extension.
	 *
	 * @param {string} str
	 * @return {boolean|string}
	 */

	function contentType (str) {
	  // TODO: should this even be in this module?
	  if (!str || typeof str !== 'string') {
	    return false
	  }

	  var mime = str.indexOf('/') === -1
	    ? exports$1.lookup(str)
	    : str;

	  if (!mime) {
	    return false
	  }

	  // TODO: use content-type or other module
	  if (mime.indexOf('charset') === -1) {
	    var charset = exports$1.charset(mime);
	    if (charset) mime += '; charset=' + charset.toLowerCase();
	  }

	  return mime
	}

	/**
	 * Get the default extension for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */

	function extension (type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }

	  // TODO: use media-typer
	  var match = EXTRACT_TYPE_REGEXP.exec(type);

	  // get extensions
	  var exts = match && exports$1.extensions[match[1].toLowerCase()];

	  if (!exts || !exts.length) {
	    return false
	  }

	  return exts[0]
	}

	/**
	 * Lookup the MIME type for a file path/extension.
	 *
	 * @param {string} path
	 * @return {boolean|string}
	 */

	function lookup (path) {
	  if (!path || typeof path !== 'string') {
	    return false
	  }

	  // get the extension ("ext" or ".ext" or full path)
	  var extension = extname('x.' + path)
	    .toLowerCase()
	    .substr(1);

	  if (!extension) {
	    return false
	  }

	  return exports$1.types[extension] || false
	}

	/**
	 * Populate the extensions and types maps.
	 * @private
	 */

	function populateMaps (extensions, types) {
	  // source preference (least -> most)
	  var preference = ['nginx', 'apache', undefined, 'iana'];

	  Object.keys(db).forEach(function forEachMimeType (type) {
	    var mime = db[type];
	    var exts = mime.extensions;

	    if (!exts || !exts.length) {
	      return
	    }

	    // mime -> extensions
	    extensions[type] = exts;

	    // extension -> mime
	    for (var i = 0; i < exts.length; i++) {
	      var extension = exts[i];

	      if (types[extension]) {
	        var from = preference.indexOf(db[types[extension]].source);
	        var to = preference.indexOf(mime.source);

	        if (types[extension] !== 'application/octet-stream' &&
	          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
	          // skip the remapping
	          continue
	        }
	      }

	      // set the extension -> mime
	      types[extension] = type;
	    }
	  });
	} 
} (mimeTypes));

/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var Negotiator = negotiatorExports;
var mime = mimeTypes;

/**
 * Module exports.
 * @public
 */

var accepts$2 = Accepts;

/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts (req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req)
  }

  this.headers = req.headers;
  this.negotiator = new Negotiator(req);
}

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */

Accepts.prototype.type =
Accepts.prototype.types = function (types_) {
  var types = types_;

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length);
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i];
    }
  }

  // no types, return all requested types
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes()
  }

  // no accept header, return first given type
  if (!this.headers.accept) {
    return types[0]
  }

  var mimes = types.map(extToMime);
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first = accepts[0];

  return first
    ? types[mimes.indexOf(first)]
    : false
};

/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.encoding =
Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_;

  // support flattened arguments
  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length);
    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i];
    }
  }

  // no encodings, return all requested encodings
  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings()
  }

  return this.negotiator.encodings(encodings)[0] || false
};

/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.charset =
Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_;

  // support flattened arguments
  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length);
    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i];
    }
  }

  // no charsets, return all requested charsets
  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets()
  }

  return this.negotiator.charsets(charsets)[0] || false
};

/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */

Accepts.prototype.lang =
Accepts.prototype.langs =
Accepts.prototype.language =
Accepts.prototype.languages = function (languages_) {
  var languages = languages_;

  // support flattened arguments
  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length);
    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i];
    }
  }

  // no languages, return all requested languages
  if (!languages || languages.length === 0) {
    return this.negotiator.languages()
  }

  return this.negotiator.languages(languages)[0] || false
};

/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function extToMime (type) {
  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function validMime (type) {
  return typeof type === 'string'
}

Object.defineProperty(polling$2, "__esModule", { value: true });
polling$2.Polling = void 0;
const transport_1$4 = transport;
const zlib_1$1 = require$$0$5;
const accepts$1 = accepts$2;
const debug_1$b = require$$13;
const debug$f = (0, debug_1$b.default)("engine:polling");
const compressionMethods$1 = {
    gzip: zlib_1$1.createGzip,
    deflate: zlib_1$1.createDeflate,
};
let Polling$1 = class Polling extends transport_1$4.Transport {
    /**
     * HTTP polling constructor.
     */
    constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1000;
    }
    /**
     * Transport name
     */
    get name() {
        return "polling";
    }
    /**
     * Overrides onRequest.
     *
     * @param {EngineRequest} req
     * @package
     */
    onRequest(req) {
        const res = req.res;
        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)
        req.res = null;
        if ("GET" === req.method) {
            this.onPollRequest(req, res);
        }
        else if ("POST" === req.method) {
            this.onDataRequest(req, res);
        }
        else {
            res.writeHead(500);
            res.end();
        }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @private
     */
    onPollRequest(req, res) {
        if (this.req) {
            debug$f("request overlap");
            // assert: this.res, '.req and .res should be (un)set together'
            this.onError("overlap from client");
            res.writeHead(400);
            res.end();
            return;
        }
        debug$f("setting request");
        this.req = req;
        this.res = res;
        const onClose = () => {
            this.onError("poll connection closed prematurely");
        };
        const cleanup = () => {
            req.removeListener("close", onClose);
            this.req = this.res = null;
        };
        req.cleanup = cleanup;
        req.on("close", onClose);
        this.writable = true;
        this.emit("ready");
        // if we're still writable but had a pending close, trigger an empty send
        if (this.writable && this.shouldClose) {
            debug$f("triggering empty send to append close packet");
            this.send([{ type: "noop" }]);
        }
    }
    /**
     * The client sends a request with data.
     *
     * @private
     */
    onDataRequest(req, res) {
        if (this.dataReq) {
            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
            this.onError("data request overlap from client");
            res.writeHead(400);
            res.end();
            return;
        }
        const isBinary = "application/octet-stream" === req.headers["content-type"];
        if (isBinary && this.protocol === 4) {
            return this.onError("invalid content");
        }
        this.dataReq = req;
        this.dataRes = res;
        let chunks = isBinary ? Buffer.concat([]) : "";
        const cleanup = () => {
            req.removeListener("data", onData);
            req.removeListener("end", onEnd);
            req.removeListener("close", onClose);
            this.dataReq = this.dataRes = chunks = null;
        };
        const onClose = () => {
            cleanup();
            this.onError("data request connection closed prematurely");
        };
        const onData = (data) => {
            let contentLength;
            if (isBinary) {
                chunks = Buffer.concat([chunks, data]);
                contentLength = chunks.length;
            }
            else {
                chunks += data;
                contentLength = Buffer.byteLength(chunks);
            }
            if (contentLength > this.maxHttpBufferSize) {
                res.writeHead(413).end();
                cleanup();
            }
        };
        const onEnd = () => {
            this.onData(chunks);
            const headers = {
                // text/html is required instead of text/plain to avoid an
                // unwanted download dialog on certain user-agents (GH-43)
                "Content-Type": "text/html",
                "Content-Length": "2",
            };
            res.writeHead(200, this.headers(req, headers));
            res.end("ok");
            cleanup();
        };
        req.on("close", onClose);
        if (!isBinary)
            req.setEncoding("utf8");
        req.on("data", onData);
        req.on("end", onEnd);
    }
    /**
     * Processes the incoming data payload.
     *
     * @param data - encoded payload
     * @protected
     */
    onData(data) {
        debug$f('received "%s"', data);
        const callback = (packet) => {
            if ("close" === packet.type) {
                debug$f("got xhr close packet");
                this.onClose();
                return false;
            }
            this.onPacket(packet);
        };
        if (this.protocol === 3) {
            this.parser.decodePayload(data, callback);
        }
        else {
            this.parser.decodePayload(data).forEach(callback);
        }
    }
    /**
     * Overrides onClose.
     *
     * @private
     */
    onClose() {
        if (this.writable) {
            // close pending poll request
            this.send([{ type: "noop" }]);
        }
        super.onClose();
    }
    send(packets) {
        this.writable = false;
        if (this.shouldClose) {
            debug$f("appending close packet to payload");
            packets.push({ type: "close" });
            this.shouldClose();
            this.shouldClose = null;
        }
        const doWrite = (data) => {
            const compress = packets.some((packet) => {
                return packet.options && packet.options.compress;
            });
            this.write(data, { compress });
        };
        if (this.protocol === 3) {
            this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        }
        else {
            this.parser.encodePayload(packets, doWrite);
        }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @private
     */
    write(data, options) {
        debug$f('writing "%s"', data);
        this.doWrite(data, options, () => {
            this.req.cleanup();
            this.emit("drain");
        });
    }
    /**
     * Performs the write.
     *
     * @protected
     */
    doWrite(data, options, callback) {
        // explicit UTF-8 is required for pages not served under utf
        const isString = typeof data === "string";
        const contentType = isString
            ? "text/plain; charset=UTF-8"
            : "application/octet-stream";
        const headers = {
            "Content-Type": contentType,
        };
        const respond = (data) => {
            headers["Content-Length"] =
                "string" === typeof data ? Buffer.byteLength(data) : data.length;
            this.res.writeHead(200, this.headers(this.req, headers));
            this.res.end(data);
            callback();
        };
        if (!this.httpCompression || !options.compress) {
            respond(data);
            return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len < this.httpCompression.threshold) {
            respond(data);
            return;
        }
        const encoding = accepts$1(this.req).encodings(["gzip", "deflate"]);
        if (!encoding) {
            respond(data);
            return;
        }
        this.compress(data, encoding, (err, data) => {
            if (err) {
                this.res.writeHead(500);
                this.res.end();
                callback(err);
                return;
            }
            headers["Content-Encoding"] = encoding;
            respond(data);
        });
    }
    /**
     * Compresses data.
     *
     * @private
     */
    compress(data, encoding, callback) {
        debug$f("compressing");
        const buffers = [];
        let nread = 0;
        compressionMethods$1[encoding](this.httpCompression)
            .on("error", callback)
            .on("data", function (chunk) {
            buffers.push(chunk);
            nread += chunk.length;
        })
            .on("end", function () {
            callback(null, Buffer.concat(buffers, nread));
        })
            .end(data);
    }
    /**
     * Closes the transport.
     *
     * @private
     */
    doClose(fn) {
        debug$f("closing");
        let closeTimeoutTimer;
        if (this.dataReq) {
            debug$f("aborting ongoing data request");
            this.dataReq.destroy();
        }
        const onClose = () => {
            clearTimeout(closeTimeoutTimer);
            fn();
            this.onClose();
        };
        if (this.writable) {
            debug$f("transport writable - closing right away");
            this.send([{ type: "close" }]);
            onClose();
        }
        else if (this.discarded) {
            debug$f("transport discarded - closing right away");
            onClose();
        }
        else {
            debug$f("transport not writable - buffering orderly close");
            this.shouldClose = onClose;
            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
    }
    /**
     * Returns headers for a response.
     *
     * @param {http.IncomingMessage} req
     * @param {Object} headers - extra headers
     * @private
     */
    headers(req, headers = {}) {
        // prevent XSS warnings on IE
        // https://github.com/LearnBoost/socket.io/pull/1333
        const ua = req.headers["user-agent"];
        if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
            headers["X-XSS-Protection"] = "0";
        }
        headers["cache-control"] = "no-store";
        this.emit("headers", headers, req);
        return headers;
    }
};
polling$2.Polling = Polling$1;

var pollingJsonp = {};

Object.defineProperty(pollingJsonp, "__esModule", { value: true });
pollingJsonp.JSONP = void 0;
const polling_1$2 = polling$2;
const qs$1 = require$$0$7;
const rDoubleSlashes = /\\\\n/g;
const rSlashes = /(\\)?\\n/g;
class JSONP extends polling_1$2.Polling {
    /**
     * JSON-P polling transport.
     */
    constructor(req) {
        super(req);
        this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
        this.foot = ");";
    }
    onData(data) {
        // we leverage the qs module so that we get built-in DoS protection
        // and the fast alternative to decodeURIComponent
        data = qs$1.parse(data).d;
        if ("string" === typeof data) {
            // client will send already escaped newlines as \\\\n and newlines as \\n
            // \\n must be replaced with \n and \\\\n with \\n
            data = data.replace(rSlashes, function (match, slashes) {
                return slashes ? match : "\n";
            });
            super.onData(data.replace(rDoubleSlashes, "\\n"));
        }
    }
    doWrite(data, options, callback) {
        // we must output valid javascript, not valid json
        // see: http://timelessrepo.com/json-isnt-a-javascript-subset
        const js = JSON.stringify(data)
            .replace(/\u2028/g, "\\u2028")
            .replace(/\u2029/g, "\\u2029");
        // prepare response
        data = this.head + js + this.foot;
        super.doWrite(data, options, callback);
    }
}
pollingJsonp.JSONP = JSONP;

var websocket$3 = {};

Object.defineProperty(websocket$3, "__esModule", { value: true });
websocket$3.WebSocket = void 0;
const transport_1$3 = transport;
const debug_1$a = require$$13;
const debug$e = (0, debug_1$a.default)("engine:ws");
let WebSocket$8 = class WebSocket extends transport_1$3.Transport {
    /**
     * WebSocket transport
     *
     * @param {EngineRequest} req
     */
    constructor(req) {
        super(req);
        this._doSend = (data) => {
            this.socket.send(data, this._onSent);
        };
        this._doSendLast = (data) => {
            this.socket.send(data, this._onSentLast);
        };
        this._onSent = (err) => {
            if (err) {
                this.onError("write error", err.stack);
            }
        };
        this._onSentLast = (err) => {
            if (err) {
                this.onError("write error", err.stack);
            }
            else {
                this.emit("drain");
                this.writable = true;
                this.emit("ready");
            }
        };
        this.socket = req.websocket;
        this.socket.on("message", (data, isBinary) => {
            const message = isBinary ? data : data.toString();
            debug$e('received "%s"', message);
            super.onData(message);
        });
        this.socket.once("close", this.onClose.bind(this));
        this.socket.on("error", this.onError.bind(this));
        this.writable = true;
        this.perMessageDeflate = null;
    }
    /**
     * Transport name
     */
    get name() {
        return "websocket";
    }
    /**
     * Advertise upgrade support.
     */
    get handlesUpgrades() {
        return true;
    }
    send(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const isLast = i + 1 === packets.length;
            if (this._canSendPreEncodedFrame(packet)) {
                // the WebSocket frame was computed with WebSocket.Sender.frame()
                // see https://github.com/websockets/ws/issues/617#issuecomment-283002469
                this.socket._sender.sendFrame(
                // @ts-ignore
                packet.options.wsPreEncodedFrame, isLast ? this._onSentLast : this._onSent);
            }
            else {
                this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);
            }
        }
    }
    /**
     * Whether the encoding of the WebSocket frame can be skipped.
     * @param packet
     * @private
     */
    _canSendPreEncodedFrame(packet) {
        var _a, _b, _c;
        return (!this.perMessageDeflate &&
            typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === "function" &&
            // @ts-ignore
            ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined);
    }
    doClose(fn) {
        debug$e("closing");
        this.socket.close();
        fn && fn();
    }
};
websocket$3.WebSocket = WebSocket$8;

var webtransport = {};

Object.defineProperty(webtransport, "__esModule", { value: true });
webtransport.WebTransport = void 0;
const transport_1$2 = transport;
const debug_1$9 = require$$13;
const engine_io_parser_1$1 = esm;
const debug$d = (0, debug_1$9.default)("engine:webtransport");
/**
 * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API
 */
class WebTransport extends transport_1$2.Transport {
    constructor(session, stream, reader) {
        super({ _query: { EIO: "4" } });
        this.session = session;
        const transformStream = (0, engine_io_parser_1$1.createPacketEncoderStream)();
        transformStream.readable.pipeTo(stream.writable).catch(() => {
            debug$d("the stream was closed");
        });
        this.writer = transformStream.writable.getWriter();
        (async () => {
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        debug$d("session is closed");
                        break;
                    }
                    debug$d("received chunk: %o", value);
                    this.onPacket(value);
                }
            }
            catch (e) {
                debug$d("error while reading: %s", e.message);
            }
        })();
        session.closed.then(() => this.onClose());
        this.writable = true;
    }
    get name() {
        return "webtransport";
    }
    async send(packets) {
        this.writable = false;
        try {
            for (let i = 0; i < packets.length; i++) {
                const packet = packets[i];
                await this.writer.write(packet);
            }
        }
        catch (e) {
            debug$d("error while writing: %s", e.message);
        }
        this.emit("drain");
        this.writable = true;
        this.emit("ready");
    }
    doClose(fn) {
        debug$d("closing WebTransport session");
        this.session.close();
        fn && fn();
    }
}
webtransport.WebTransport = WebTransport;

Object.defineProperty(transports, "__esModule", { value: true });
const polling_1$1 = polling$2;
const polling_jsonp_1 = pollingJsonp;
const websocket_1$1 = websocket$3;
const webtransport_1$1 = webtransport;
transports.default = {
    polling: polling$1,
    websocket: websocket_1$1.WebSocket,
    webtransport: webtransport_1$1.WebTransport,
};
/**
 * Polling polymorphic constructor.
 */
function polling$1(req) {
    if ("string" === typeof req._query.j) {
        return new polling_jsonp_1.JSONP(req);
    }
    else {
        return new polling_1$1.Polling(req);
    }
}
polling$1.upgradesTo = ["websocket", "webtransport"];

var socket$1 = {};

const require$$2$3 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(timers);

Object.defineProperty(socket$1, "__esModule", { value: true });
socket$1.Socket = void 0;
const events_1$3 = require$$0$6;
const debug_1$8 = require$$13;
const timers_1 = require$$2$3;
const debug$c = (0, debug_1$8.default)("engine:socket");
let Socket$2 = class Socket extends events_1$3.EventEmitter {
    get readyState() {
        return this._readyState;
    }
    set readyState(state) {
        debug$c("readyState updated from %s to %s", this._readyState, state);
        this._readyState = state;
    }
    constructor(id, server, transport, req, protocol) {
        super();
        /**
         * The current state of the socket.
         */
        this._readyState = "opening";
        /* private */ this.upgrading = false;
        /* private */ this.upgraded = false;
        this.writeBuffer = [];
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.cleanupFn = [];
        this.id = id;
        this.server = server;
        this.request = req;
        this.protocol = protocol;
        // Cache IP since it might not be in the req later
        if (req) {
            if (req.websocket && req.websocket._socket) {
                this.remoteAddress = req.websocket._socket.remoteAddress;
            }
            else {
                this.remoteAddress = req.connection.remoteAddress;
            }
        }
        this.pingTimeoutTimer = null;
        this.pingIntervalTimer = null;
        this.setTransport(transport);
        this.onOpen();
    }
    /**
     * Called upon transport considered open.
     *
     * @private
     */
    onOpen() {
        this.readyState = "open";
        // sends an `open` packet
        this.transport.sid = this.id;
        this.sendPacket("open", JSON.stringify({
            sid: this.id,
            upgrades: this.getAvailableUpgrades(),
            pingInterval: this.server.opts.pingInterval,
            pingTimeout: this.server.opts.pingTimeout,
            maxPayload: this.server.opts.maxHttpBufferSize,
        }));
        if (this.server.opts.initialPacket) {
            this.sendPacket("message", this.server.opts.initialPacket);
        }
        this.emit("open");
        if (this.protocol === 3) {
            // in protocol v3, the client sends a ping, and the server answers with a pong
            this.resetPingTimeout();
        }
        else {
            // in protocol v4, the server sends a ping, and the client answers with a pong
            this.schedulePing();
        }
    }
    /**
     * Called upon transport packet.
     *
     * @param {Object} packet
     * @private
     */
    onPacket(packet) {
        if ("open" !== this.readyState) {
            return debug$c("packet received with closed socket");
        }
        // export packet event
        debug$c(`received packet ${packet.type}`);
        this.emit("packet", packet);
        switch (packet.type) {
            case "ping":
                if (this.transport.protocol !== 3) {
                    this.onError(new Error("invalid heartbeat direction"));
                    return;
                }
                debug$c("got ping");
                this.pingTimeoutTimer.refresh();
                this.sendPacket("pong");
                this.emit("heartbeat");
                break;
            case "pong":
                if (this.transport.protocol === 3) {
                    this.onError(new Error("invalid heartbeat direction"));
                    return;
                }
                debug$c("got pong");
                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
                this.pingIntervalTimer.refresh();
                this.emit("heartbeat");
                break;
            case "error":
                this.onClose("parse error");
                break;
            case "message":
                this.emit("data", packet.data);
                this.emit("message", packet.data);
                break;
        }
    }
    /**
     * Called upon transport error.
     *
     * @param {Error} err - error object
     * @private
     */
    onError(err) {
        debug$c("transport error");
        this.onClose("transport error", err);
    }
    /**
     * Pings client every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @private
     */
    schedulePing() {
        this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {
            debug$c("writing ping packet - expecting pong within %sms", this.server.opts.pingTimeout);
            this.sendPacket("ping");
            this.resetPingTimeout();
        }, this.server.opts.pingInterval);
    }
    /**
     * Resets ping timeout.
     *
     * @private
     */
    resetPingTimeout() {
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {
            if (this.readyState === "closed")
                return;
            this.onClose("ping timeout");
        }, this.protocol === 3
            ? this.server.opts.pingInterval + this.server.opts.pingTimeout
            : this.server.opts.pingTimeout);
    }
    /**
     * Attaches handlers for the given transport.
     *
     * @param {Transport} transport
     * @private
     */
    setTransport(transport) {
        const onError = this.onError.bind(this);
        const onReady = () => this.flush();
        const onPacket = this.onPacket.bind(this);
        const onDrain = this.onDrain.bind(this);
        const onClose = this.onClose.bind(this, "transport close");
        this.transport = transport;
        this.transport.once("error", onError);
        this.transport.on("ready", onReady);
        this.transport.on("packet", onPacket);
        this.transport.on("drain", onDrain);
        this.transport.once("close", onClose);
        this.cleanupFn.push(function () {
            transport.removeListener("error", onError);
            transport.removeListener("ready", onReady);
            transport.removeListener("packet", onPacket);
            transport.removeListener("drain", onDrain);
            transport.removeListener("close", onClose);
        });
    }
    /**
     * Upon transport "drain" event
     *
     * @private
     */
    onDrain() {
        if (this.sentCallbackFn.length > 0) {
            debug$c("executing batch send callback");
            const seqFn = this.sentCallbackFn.shift();
            if (seqFn) {
                for (let i = 0; i < seqFn.length; i++) {
                    seqFn[i](this.transport);
                }
            }
        }
    }
    /**
     * Upgrades socket to the given transport
     *
     * @param {Transport} transport
     * @private
     */
    /* private */ _maybeUpgrade(transport) {
        debug$c('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
        this.upgrading = true;
        // set transport upgrade timer
        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {
            debug$c("client did not complete upgrade - closing transport");
            cleanup();
            if ("open" === transport.readyState) {
                transport.close();
            }
        }, this.server.opts.upgradeTimeout);
        let checkIntervalTimer;
        const onPacket = (packet) => {
            if ("ping" === packet.type && "probe" === packet.data) {
                debug$c("got probe ping packet, sending pong");
                transport.send([{ type: "pong", data: "probe" }]);
                this.emit("upgrading", transport);
                clearInterval(checkIntervalTimer);
                checkIntervalTimer = setInterval(check, 100);
            }
            else if ("upgrade" === packet.type && this.readyState !== "closed") {
                debug$c("got upgrade packet - upgrading");
                cleanup();
                this.transport.discard();
                this.upgraded = true;
                this.clearTransport();
                this.setTransport(transport);
                this.emit("upgrade", transport);
                this.flush();
                if (this.readyState === "closing") {
                    transport.close(() => {
                        this.onClose("forced close");
                    });
                }
            }
            else {
                cleanup();
                transport.close();
            }
        };
        // we force a polling cycle to ensure a fast upgrade
        const check = () => {
            if ("polling" === this.transport.name && this.transport.writable) {
                debug$c("writing a noop packet to polling for fast upgrade");
                this.transport.send([{ type: "noop" }]);
            }
        };
        const cleanup = () => {
            this.upgrading = false;
            clearInterval(checkIntervalTimer);
            (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
            transport.removeListener("packet", onPacket);
            transport.removeListener("close", onTransportClose);
            transport.removeListener("error", onError);
            this.removeListener("close", onClose);
        };
        const onError = (err) => {
            debug$c("client did not complete upgrade - %s", err);
            cleanup();
            transport.close();
            transport = null;
        };
        const onTransportClose = () => {
            onError("transport closed");
        };
        const onClose = () => {
            onError("socket closed");
        };
        transport.on("packet", onPacket);
        transport.once("close", onTransportClose);
        transport.once("error", onError);
        this.once("close", onClose);
    }
    /**
     * Clears listeners and timers associated with current transport.
     *
     * @private
     */
    clearTransport() {
        let cleanup;
        const toCleanUp = this.cleanupFn.length;
        for (let i = 0; i < toCleanUp; i++) {
            cleanup = this.cleanupFn.shift();
            cleanup();
        }
        // silence further transport errors and prevent uncaught exceptions
        this.transport.on("error", function () {
            debug$c("error triggered by discarded transport");
        });
        // ensure transport won't stay open
        this.transport.close();
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    }
    /**
     * Called upon transport considered closed.
     * Possible reasons: `ping timeout`, `client error`, `parse error`,
     * `transport error`, `server close`, `transport close`
     */
    onClose(reason, description) {
        if ("closed" !== this.readyState) {
            this.readyState = "closed";
            // clear timers
            (0, timers_1.clearTimeout)(this.pingIntervalTimer);
            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
            // clean writeBuffer in next tick, so developers can still
            // grab the writeBuffer on 'close' event
            process.nextTick(() => {
                this.writeBuffer = [];
            });
            this.packetsFn = [];
            this.sentCallbackFn = [];
            this.clearTransport();
            this.emit("close", reason, description);
        }
    }
    /**
     * Sends a message packet.
     *
     * @param {Object} data
     * @param {Object} options
     * @param {Function} callback
     * @return {Socket} for chaining
     */
    send(data, options, callback) {
        this.sendPacket("message", data, options, callback);
        return this;
    }
    /**
     * Alias of {@link send}.
     *
     * @param data
     * @param options
     * @param callback
     */
    write(data, options, callback) {
        this.sendPacket("message", data, options, callback);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type - packet type
     * @param {String} data
     * @param {Object} options
     * @param {Function} callback
     *
     * @private
     */
    sendPacket(type, data, options = {}, callback) {
        if ("function" === typeof options) {
            callback = options;
            options = {};
        }
        if ("closing" !== this.readyState && "closed" !== this.readyState) {
            debug$c('sending packet "%s" (%s)', type, data);
            // compression is enabled by default
            options.compress = options.compress !== false;
            const packet = {
                type,
                options: options,
            };
            if (data)
                packet.data = data;
            // exports packetCreate event
            this.emit("packetCreate", packet);
            this.writeBuffer.push(packet);
            // add send callback to object, if defined
            if ("function" === typeof callback)
                this.packetsFn.push(callback);
            this.flush();
        }
    }
    /**
     * Attempts to flush the packets buffer.
     *
     * @private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            this.writeBuffer.length) {
            debug$c("flushing buffer to transport");
            this.emit("flush", this.writeBuffer);
            this.server.emit("flush", this, this.writeBuffer);
            const wbuf = this.writeBuffer;
            this.writeBuffer = [];
            if (this.packetsFn.length) {
                this.sentCallbackFn.push(this.packetsFn);
                this.packetsFn = [];
            }
            else {
                this.sentCallbackFn.push(null);
            }
            this.transport.send(wbuf);
            this.emit("drain");
            this.server.emit("drain", this);
        }
    }
    /**
     * Get available upgrades for this socket.
     *
     * @private
     */
    getAvailableUpgrades() {
        const availableUpgrades = [];
        const allUpgrades = this.server.upgrades(this.transport.name);
        for (let i = 0; i < allUpgrades.length; ++i) {
            const upg = allUpgrades[i];
            if (this.server.opts.transports.indexOf(upg) !== -1) {
                availableUpgrades.push(upg);
            }
        }
        return availableUpgrades;
    }
    /**
     * Closes the socket and underlying transport.
     *
     * @param {Boolean} discard - optional, discard the transport
     * @return {Socket} for chaining
     */
    close(discard) {
        if (discard &&
            (this.readyState === "open" || this.readyState === "closing")) {
            return this.closeTransport(discard);
        }
        if ("open" !== this.readyState)
            return;
        this.readyState = "closing";
        if (this.writeBuffer.length) {
            debug$c("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
            this.once("drain", () => {
                debug$c("all packets have been sent, closing the transport");
                this.closeTransport(discard);
            });
            return;
        }
        debug$c("the buffer is empty, closing the transport right away");
        this.closeTransport(discard);
    }
    /**
     * Closes the underlying transport.
     *
     * @param {Boolean} discard
     * @private
     */
    closeTransport(discard) {
        debug$c("closing the transport (discard? %s)", !!discard);
        if (discard)
            this.transport.discard();
        this.transport.close(this.onClose.bind(this, "forced close"));
    }
};
socket$1.Socket = Socket$2;

var cookie = {};

/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

cookie.parse = parse$g;
cookie.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString;
var __hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */

var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 */

var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */

var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */

var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [opt]
 * @return {object}
 * @public
 */

function parse$g(str, opt) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var len = str.length;
  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
  if (len < 2) return obj;

  var dec = (opt && opt.decode) || decode$4;
  var index = 0;
  var eqIdx = 0;
  var endIdx = 0;

  do {
    eqIdx = str.indexOf('=', index);
    if (eqIdx === -1) break; // No more cookie pairs.

    endIdx = str.indexOf(';', index);

    if (endIdx === -1) {
      endIdx = len;
    } else if (eqIdx > endIdx) {
      // backtrack on prior semicolon
      index = str.lastIndexOf(';', eqIdx - 1) + 1;
      continue;
    }

    var keyStartIdx = startIndex(str, index, eqIdx);
    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
    var key = str.slice(keyStartIdx, keyEndIdx);

    // only assign once
    if (!__hasOwnProperty.call(obj, key)) {
      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
      var valEndIdx = endIndex(str, endIdx, valStartIdx);

      if (str.charCodeAt(valStartIdx) === 0x22 /* " */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */) {
        valStartIdx++;
        valEndIdx--;
      }

      var val = str.slice(valStartIdx, valEndIdx);
      obj[key] = tryDecode$1(val, dec);
    }

    index = endIdx + 1;
  } while (index < len);

  return obj;
}

function startIndex(str, index, max) {
  do {
    var code = str.charCodeAt(index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
  } while (++index < max);
  return max;
}

function endIndex(str, index, min) {
  while (index > min) {
    var code = str.charCodeAt(--index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
  }
  return min;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [opt]
 * @return {string}
 * @public
 */

function serialize(name, val, opt) {
  var enc = (opt && opt.encode) || encodeURIComponent;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!cookieNameRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (!cookieValueRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;
  if (!opt) return str;

  if (null != opt.maxAge) {
    var maxAge = Math.floor(opt.maxAge);

    if (!isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid')
    }

    str += '; Max-Age=' + maxAge;
  }

  if (opt.domain) {
    if (!domainValueRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!pathValueRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    var expires = opt.expires;

    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.partitioned) {
    str += '; Partitioned';
  }

  if (opt.priority) {
    var priority = typeof opt.priority === 'string'
      ? opt.priority.toLowerCase() : opt.priority;

    switch (priority) {
      case 'low':
        str += '; Priority=Low';
        break
      case 'medium':
        str += '; Priority=Medium';
        break
      case 'high':
        str += '; Priority=High';
        break
      default:
        throw new TypeError('option priority is invalid')
    }
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */

function decode$4 (str) {
  return str.indexOf('%') !== -1
    ? decodeURIComponent(str)
    : str
}

/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */

function isDate (val) {
  return __toString.call(val) === '[object Date]';
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode$1(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}

const require$$2$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$0$2$1);

const { Duplex: Duplex$7 } = require$$2$2;

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose$3(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd$1() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError$1(err) {
  this.removeListener('error', duplexOnError$1);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream$1(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex$7({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose$3, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose$3, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd$1);
  duplex.on('error', duplexOnError$1);
  return duplex;
}

var stream$1 = createWebSocketStream$1;

const stream_default$1 = /*@__PURE__*/getDefaultExportFromCjs(stream$1);

var bufferUtil$3 = {exports: {}};

var constants$3 = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};

const _bufferutil = {};

const _bufferutil$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _bufferutil
}, Symbol.toStringTag, { value: 'Module' }));

const require$$1$5 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(_bufferutil$1);

var unmask$3;
var mask$1;

const { EMPTY_BUFFER: EMPTY_BUFFER$7 } = constants$3;

const FastBuffer$5 = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat$3(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER$7;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer$5(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask$1(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask$1(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer$4(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer$5(data) {
  toBuffer$5.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer$5(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer$5(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer$5.readOnly = false;
  }

  return buf;
}

bufferUtil$3.exports = {
  concat: concat$3,
  mask: _mask$1,
  toArrayBuffer: toArrayBuffer$4,
  toBuffer: toBuffer$5,
  unmask: _unmask$1
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = require$$1$5;

    mask$1 = bufferUtil$3.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask$1(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    unmask$3 = bufferUtil$3.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask$1(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}

var bufferUtilExports$1 = bufferUtil$3.exports;

const kDone$1 = Symbol('kDone');
const kRun$1 = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
let Limiter$3 = class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone$1] = () => {
      this.pending--;
      this[kRun$1]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun$1]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun$1]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone$1]);
    }
  }
};

var limiter$1 = Limiter$3;

const zlib$1 = require$$0$5;

const bufferUtil$2 = bufferUtilExports$1;
const Limiter$2 = limiter$1;
const { kStatusCode: kStatusCode$5 } = constants$3;

const FastBuffer$4 = Buffer[Symbol.species];
const TRAILER$1 = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate$1 = Symbol('permessage-deflate');
const kTotalLength$1 = Symbol('total-length');
const kCallback$1 = Symbol('callback');
const kBuffers$1 = Symbol('buffers');
const kError$3 = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter$1;

/**
 * permessage-deflate implementation.
 */
let PerMessageDeflate$9 = class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter$1) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter$1 = new Limiter$2(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback$1];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter$1.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter$1.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib$1.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib$1.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate$1] = this;
      this._inflate[kTotalLength$1] = 0;
      this._inflate[kBuffers$1] = [];
      this._inflate.on('error', inflateOnError$1);
      this._inflate.on('data', inflateOnData$1);
    }

    this._inflate[kCallback$1] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER$1);

    this._inflate.flush(() => {
      const err = this._inflate[kError$3];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil$2.concat(
        this._inflate[kBuffers$1],
        this._inflate[kTotalLength$1]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength$1] = 0;
        this._inflate[kBuffers$1] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib$1.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib$1.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength$1] = 0;
      this._deflate[kBuffers$1] = [];

      this._deflate.on('data', deflateOnData$1);
    }

    this._deflate[kCallback$1] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib$1.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil$2.concat(
        this._deflate[kBuffers$1],
        this._deflate[kTotalLength$1]
      );

      if (fin) {
        data = new FastBuffer$4(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback$1] = null;

      this._deflate[kTotalLength$1] = 0;
      this._deflate[kBuffers$1] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
};

var permessageDeflate$1 = PerMessageDeflate$9;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData$1(chunk) {
  this[kBuffers$1].push(chunk);
  this[kTotalLength$1] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData$1(chunk) {
  this[kTotalLength$1] += chunk.length;

  if (
    this[kPerMessageDeflate$1]._maxPayload < 1 ||
    this[kTotalLength$1] <= this[kPerMessageDeflate$1]._maxPayload
  ) {
    this[kBuffers$1].push(chunk);
    return;
  }

  this[kError$3] = new RangeError('Max payload size exceeded');
  this[kError$3].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError$3][kStatusCode$5] = 1009;
  this.removeListener('data', inflateOnData$1);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError$1(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate$1]._inflate = null;
  err[kStatusCode$5] = 1007;
  this[kCallback$1](err);
}

var validation$1 = {exports: {}};

const require$$0$3 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$0$1$1);

const _utf8Validate = {};

const _utf8Validate$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _utf8Validate
}, Symbol.toStringTag, { value: 'Module' }));

const require$$1$4 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(_utf8Validate$1);

var isValidUTF8_1$1;

const { isUtf8: isUtf8$1 } = require$$0$3;

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars$5 = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode$5(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8$1(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

validation$1.exports = {
  isValidStatusCode: isValidStatusCode$5,
  isValidUTF8: _isValidUTF8$1,
  tokenChars: tokenChars$5
};

if (isUtf8$1) {
  isValidUTF8_1$1 = validation$1.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8$1(buf) : isUtf8$1(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = require$$1$4;

    isValidUTF8_1$1 = validation$1.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8$1(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}

var validationExports$1 = validation$1.exports;

const { Writable: Writable$1 } = require$$2$2;

const PerMessageDeflate$8 = permessageDeflate$1;
const {
  BINARY_TYPES: BINARY_TYPES$3,
  EMPTY_BUFFER: EMPTY_BUFFER$6,
  kStatusCode: kStatusCode$4,
  kWebSocket: kWebSocket$5
} = constants$3;
const { concat: concat$2, toArrayBuffer: toArrayBuffer$3, unmask: unmask$2 } = bufferUtilExports$1;
const { isValidStatusCode: isValidStatusCode$4, isValidUTF8: isValidUTF8$1 } = validationExports$1;

const FastBuffer$3 = Buffer[Symbol.species];

const GET_INFO$1 = 0;
const GET_PAYLOAD_LENGTH_16$1 = 1;
const GET_PAYLOAD_LENGTH_64$1 = 2;
const GET_MASK$1 = 3;
const GET_DATA$1 = 4;
const INFLATING$1 = 5;
const DEFER_EVENT$1 = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
let Receiver$3 = class Receiver extends Writable$1 {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES$3[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket$5] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO$1;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO$1) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer$3(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer$3(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer$3(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO$1:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16$1:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64$1:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK$1:
          this.getMask();
          break;
        case GET_DATA$1:
          this.getData(cb);
          break;
        case INFLATING$1:
        case DEFER_EVENT$1:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate$8.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16$1;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64$1;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK$1;
    else this._state = GET_DATA$1;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA$1;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER$6;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask$2(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING$1;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$8.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO$1) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO$1;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat$2(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer$3(concat$2(fragments, messageLength));
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO$1;
      } else {
        this._state = DEFER_EVENT$1;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO$1;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat$2(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8$1(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING$1 || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO$1;
      } else {
        this._state = DEFER_EVENT$1;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO$1;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER$6);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode$4(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer$3(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8$1(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO$1;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO$1;
    } else {
      this._state = DEFER_EVENT$1;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO$1;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode$4] = statusCode;
    return err;
  }
};

var receiver$1 = Receiver$3;

const receiver_default$1 = /*@__PURE__*/getDefaultExportFromCjs(receiver$1);

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

const { Duplex: Duplex$6 } = require$$2$2;
const { randomFillSync: randomFillSync$1 } = require$$3$3;

const PerMessageDeflate$7 = permessageDeflate$1;
const { EMPTY_BUFFER: EMPTY_BUFFER$5 } = constants$3;
const { isValidStatusCode: isValidStatusCode$3 } = validationExports$1;
const { mask: applyMask$1, toBuffer: toBuffer$4 } = bufferUtilExports$1;

const kByteLength$1 = Symbol('kByteLength');
const maskBuffer$1 = Buffer.alloc(4);
const RANDOM_POOL_SIZE$1 = 8 * 1024;
let randomPool$1;
let randomPoolPointer$1 = RANDOM_POOL_SIZE$1;

/**
 * HyBi Sender implementation.
 */
let Sender$3 = class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer$1;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer$1 === RANDOM_POOL_SIZE$1) {
          /* istanbul ignore else  */
          if (randomPool$1 === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool$1 = Buffer.alloc(RANDOM_POOL_SIZE$1);
          }

          randomFillSync$1(randomPool$1, 0, RANDOM_POOL_SIZE$1);
          randomPoolPointer$1 = 0;
        }

        mask[0] = randomPool$1[randomPoolPointer$1++];
        mask[1] = randomPool$1[randomPoolPointer$1++];
        mask[2] = randomPool$1[randomPoolPointer$1++];
        mask[3] = randomPool$1[randomPoolPointer$1++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength$1] !== undefined
      ) {
        dataLength = options[kByteLength$1];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask$1(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask$1(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER$5;
    } else if (typeof code !== 'number' || !isValidStatusCode$3(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength$1]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$4(data);
      byteLength = data.length;
      readOnly = toBuffer$4.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength$1]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$4(data);
      byteLength = data.length;
      readOnly = toBuffer$4.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength$1]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$7.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$4(data);
      byteLength = data.length;
      readOnly = toBuffer$4.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        [kByteLength$1]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          [kByteLength$1]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate$7.extensionName];

    this._bufferedBytes += options[kByteLength$1];
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const params = this._queue[i];
          const callback = params[params.length - 1];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= options[kByteLength$1];
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength$1];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength$1];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
};

var sender$1 = Sender$3;

const sender_default$1 = /*@__PURE__*/getDefaultExportFromCjs(sender$1);

const require$$1$3 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$1$1$1);

const require$$3$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$3$4);

const require$$4$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(require$$4$2);

const { kForOnEventAttribute: kForOnEventAttribute$3, kListener: kListener$3 } = constants$3;

const kCode$1 = Symbol('kCode');
const kData$1 = Symbol('kData');
const kError$2 = Symbol('kError');
const kMessage$1 = Symbol('kMessage');
const kReason$1 = Symbol('kReason');
const kTarget$1 = Symbol('kTarget');
const kType$1 = Symbol('kType');
const kWasClean$1 = Symbol('kWasClean');

/**
 * Class representing an event.
 */
let Event$1 = class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget$1] = null;
    this[kType$1] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget$1];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType$1];
  }
};

Object.defineProperty(Event$1.prototype, 'target', { enumerable: true });
Object.defineProperty(Event$1.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
let CloseEvent$1 = class CloseEvent extends Event$1 {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode$1] = options.code === undefined ? 0 : options.code;
    this[kReason$1] = options.reason === undefined ? '' : options.reason;
    this[kWasClean$1] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode$1];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason$1];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean$1];
  }
};

Object.defineProperty(CloseEvent$1.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent$1.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent$1.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
let ErrorEvent$1 = class ErrorEvent extends Event$1 {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError$2] = options.error === undefined ? null : options.error;
    this[kMessage$1] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError$2];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage$1];
  }
};

Object.defineProperty(ErrorEvent$1.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent$1.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
let MessageEvent$1 = class MessageEvent extends Event$1 {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData$1] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData$1];
  }
};

Object.defineProperty(MessageEvent$1.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget$1 = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute$3] &&
        listener[kListener$3] === handler &&
        !listener[kForOnEventAttribute$3]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent$1('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget$1] = this;
        callListener$1(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent$1('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget$1] = this;
        callListener$1(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent$1('error', {
          error,
          message: error.message
        });

        event[kTarget$1] = this;
        callListener$1(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event$1('open');

        event[kTarget$1] = this;
        callListener$1(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute$3] = !!options[kForOnEventAttribute$3];
    wrapper[kListener$3] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener$3] === handler && !listener[kForOnEventAttribute$3]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

var eventTarget$1 = {
  EventTarget: EventTarget$1};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener$1(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}

const { tokenChars: tokenChars$4 } = validationExports$1;

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push$1(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse$f(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars$4[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push$1(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars$4[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push$1(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push$1(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars$4[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$4[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$4[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push$1(params, paramName, value);
        if (code === 0x2c) {
          push$1(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push$1(offers, token, params);
  } else {
    if (paramName === undefined) {
      push$1(params, token, true);
    } else if (mustUnescape) {
      push$1(params, paramName, token.replace(/\\/g, ''));
    } else {
      push$1(params, paramName, token);
    }
    push$1(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format$3(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

var extension$3 = { format: format$3, parse: parse$f };

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

const EventEmitter$9 = require$$0$6;
const https$1 = require$$1$3;
const http$3 = require$$1$6;
const net$1 = require$$3$2;
const tls$1 = require$$4$1;
const { randomBytes: randomBytes$1, createHash: createHash$3 } = require$$3$3;
const { Duplex: Duplex$5, Readable: Readable$3 } = require$$2$2;
const { URL: URL$3 } = require$$7$2;

const PerMessageDeflate$6 = permessageDeflate$1;
const Receiver$2 = receiver$1;
const Sender$2 = sender$1;
const {
  BINARY_TYPES: BINARY_TYPES$2,
  EMPTY_BUFFER: EMPTY_BUFFER$4,
  GUID: GUID$3,
  kForOnEventAttribute: kForOnEventAttribute$2,
  kListener: kListener$2,
  kStatusCode: kStatusCode$3,
  kWebSocket: kWebSocket$4,
  NOOP: NOOP$1
} = constants$3;
const {
  EventTarget: { addEventListener: addEventListener$1, removeEventListener: removeEventListener$1 }
} = eventTarget$1;
const { format: format$2, parse: parse$e } = extension$3;
const { toBuffer: toBuffer$3 } = bufferUtilExports$1;

const closeTimeout$1 = 30 * 1000;
const kAborted$1 = Symbol('kAborted');
const protocolVersions$1 = [8, 13];
const readyStates$1 = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex$1 = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
let WebSocket$6 = class WebSocket extends EventEmitter$9 {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES$2[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER$4;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient$1(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES$2.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver$2({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    this._sender = new Sender$2(socket, this._extensions, options.generateMask);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket$4] = this;
    socket[kWebSocket$4] = this;

    receiver.on('conclude', receiverOnConclude$1);
    receiver.on('drain', receiverOnDrain$1);
    receiver.on('error', receiverOnError$1);
    receiver.on('message', receiverOnMessage$1);
    receiver.on('ping', receiverOnPing$1);
    receiver.on('pong', receiverOnPong$1);

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose$1);
    socket.on('data', socketOnData$1);
    socket.on('end', socketOnEnd$1);
    socket.on('error', socketOnError$3);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate$6.extensionName]) {
      this._extensions[PerMessageDeflate$6.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake$3(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout$1
    );
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose$1(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER$4, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose$1(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER$4, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose$1(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate$6.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER$4, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake$3(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
};

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$6, 'CONNECTING', {
  enumerable: true,
  value: readyStates$1.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$6.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates$1.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$6, 'OPEN', {
  enumerable: true,
  value: readyStates$1.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$6.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates$1.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$6, 'CLOSING', {
  enumerable: true,
  value: readyStates$1.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$6.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates$1.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$6, 'CLOSED', {
  enumerable: true,
  value: readyStates$1.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$6.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates$1.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket$6.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket$6.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute$2]) return listener[kListener$2];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute$2]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute$2]: true
      });
    }
  });
});

WebSocket$6.prototype.addEventListener = addEventListener$1;
WebSocket$6.prototype.removeEventListener = removeEventListener$1;

var websocket$2 = WebSocket$6;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient$1(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions$1[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions$1.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions$1.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL$3) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL$3(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose$1(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes$1(16).toString('base64');
  const request = isSecure ? https$1.request : http$3.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect$1 : netConnect$1);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$6(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format$2({
      [PerMessageDeflate$6.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex$1.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake$3(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted$1]) return;

    req = websocket._req = null;
    emitErrorAndClose$1(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake$3(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL$3(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose$1(websocket, err);
        return;
      }

      initAsClient$1(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake$3(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket$6.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake$3(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash$3('sha1')
      .update(key + GUID$3)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake$3(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake$3(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake$3(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse$e(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake$3(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate$6.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake$3(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate$6.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake$3(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate$6.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose$1(websocket, err) {
  websocket._readyState = WebSocket$6.CLOSING;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect$1(options) {
  options.path = options.socketPath;
  return net$1.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect$1(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net$1.isIP(options.host) ? '' : options.host;
  }

  return tls$1.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake$3(websocket, stream, message) {
  websocket._readyState = WebSocket$6.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake$3);

  if (stream.setHeader) {
    stream[kAborted$1] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose$1, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose$1(websocket, data, cb) {
  if (data) {
    const length = toBuffer$3(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates$1[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude$1(code, reason) {
  const websocket = this[kWebSocket$4];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket$4] === undefined) return;

  websocket._socket.removeListener('data', socketOnData$1);
  process.nextTick(resume$1, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain$1() {
  const websocket = this[kWebSocket$4];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError$1(err) {
  const websocket = this[kWebSocket$4];

  if (websocket._socket[kWebSocket$4] !== undefined) {
    websocket._socket.removeListener('data', socketOnData$1);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume$1, websocket._socket);

    websocket.close(err[kStatusCode$3]);
  }

  websocket.emit('error', err);
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish$1() {
  this[kWebSocket$4].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage$1(data, isBinary) {
  this[kWebSocket$4].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing$1(data) {
  const websocket = this[kWebSocket$4];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP$1);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong$1(data) {
  this[kWebSocket$4].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume$1(stream) {
  stream.resume();
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose$1() {
  const websocket = this[kWebSocket$4];

  this.removeListener('close', socketOnClose$1);
  this.removeListener('data', socketOnData$1);
  this.removeListener('end', socketOnEnd$1);

  websocket._readyState = WebSocket$6.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket$4] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish$1);
    websocket._receiver.on('finish', receiverOnFinish$1);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData$1(chunk) {
  if (!this[kWebSocket$4]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd$1() {
  const websocket = this[kWebSocket$4];

  websocket._readyState = WebSocket$6.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError$3() {
  const websocket = this[kWebSocket$4];

  this.removeListener('error', socketOnError$3);
  this.on('error', NOOP$1);

  if (websocket) {
    websocket._readyState = WebSocket$6.CLOSING;
    this.destroy();
  }
}

const WebSocket$7 = /*@__PURE__*/getDefaultExportFromCjs(websocket$2);

const { tokenChars: tokenChars$3 } = validationExports$1;

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse$d(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars$3[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

var subprotocol$3 = { parse: parse$d };

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

const EventEmitter$8 = require$$0$6;
const http$2 = require$$1$6;
const { Duplex: Duplex$4 } = require$$2$2;
const { createHash: createHash$2 } = require$$3$3;

const extension$2 = extension$3;
const PerMessageDeflate$5 = permessageDeflate$1;
const subprotocol$2 = subprotocol$3;
const WebSocket$5 = websocket$2;
const { GUID: GUID$2, kWebSocket: kWebSocket$3 } = constants$3;

const keyRegex$1 = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING$1 = 0;
const CLOSING$1 = 1;
const CLOSED$1 = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
let WebSocketServer$1 = class WebSocketServer extends EventEmitter$8 {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket: WebSocket$5,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http$2.createServer((req, res) => {
        const body = http$2.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners$1(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING$1;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED$1) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose$2, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING$1) return;
    this._state = CLOSING$1;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose$2, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose$2, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose$2(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError$2);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError$1(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError$1(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex$1.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError$1(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError$1(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake$2(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol$2.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError$1(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate$5(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension$2.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate$5.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate$5.extensionName]);
          extensions[PerMessageDeflate$5.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError$1(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake$2(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake$2(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket$3]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING$1) return abortHandshake$2(socket, 503);

    const digest = createHash$2('sha1')
      .update(key + GUID$2)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate$5.extensionName]) {
      const params = extensions[PerMessageDeflate$5.extensionName].params;
      const value = extension$2.format({
        [PerMessageDeflate$5.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError$2);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose$2, this);
        }
      });
    }

    cb(ws, req);
  }
};

var websocketServer$1 = WebSocketServer$1;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners$1(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose$2(server) {
  server._state = CLOSED$1;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError$2() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake$2(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http$2.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError$1(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError$1);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake$2(socket, code, message);
  }
}

const websocketServer_default$1 = /*@__PURE__*/getDefaultExportFromCjs(websocketServer$1);

const wrapper$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Receiver: receiver_default$1,
  Sender: sender_default$1,
  WebSocket: WebSocket$7,
  WebSocketServer: websocketServer_default$1,
  createWebSocketStream: stream_default$1,
  default: WebSocket$7
}, Symbol.toStringTag, { value: 'Module' }));

const require$$8 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(wrapper$2);

var lib$4 = {exports: {}};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty$2.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

var vary$1 = {exports: {}};

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

vary$1.exports = vary;
vary$1.exports.append = append;

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse$c(String(field))
    : field;

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header;
  var vals = parse$c(header.toLowerCase());

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val
        ? val + ', ' + fields[i]
        : fields[i];
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse$c (header) {
  var end = 0;
  var list = [];
  var start = 0;

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1;
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end));
        start = end = i + 1;
        break
      default:
        end = i + 1;
        break
    }
  }

  // final token
  list.push(header.substring(start, end));

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || '';
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val);

  // set new header
  if ((val = append(header, field))) {
    res.setHeader('Vary', val);
  }
}

var varyExports = vary$1.exports;

(function () {

  var assign = objectAssign;
  var vary = varyExports;

  var defaults = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204
  };

  function isString(s) {
    return typeof s === 'string' || s instanceof String;
  }

  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (isString(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }

  function configureOrigin(options, req) {
    var requestOrigin = req.headers.origin,
      headers = [],
      isAllowed;

    if (!options.origin || options.origin === '*') {
      // allow any origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: '*'
      }]);
    } else if (isString(options.origin)) {
      // fixed origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: options.origin
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options.origin);
      // reflect origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    }

    return headers;
  }

  function configureMethods(options) {
    var methods = options.methods;
    if (methods.join) {
      methods = options.methods.join(','); // .methods is an array, so turn it into a string
    }
    return {
      key: 'Access-Control-Allow-Methods',
      value: methods
    };
  }

  function configureCredentials(options) {
    if (options.credentials === true) {
      return {
        key: 'Access-Control-Allow-Credentials',
        value: 'true'
      };
    }
    return null;
  }

  function configureAllowedHeaders(options, req) {
    var allowedHeaders = options.allowedHeaders || options.headers;
    var headers = [];

    if (!allowedHeaders) {
      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
      headers.push([{
        key: 'Vary',
        value: 'Access-Control-Request-Headers'
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: 'Access-Control-Allow-Headers',
        value: allowedHeaders
      }]);
    }

    return headers;
  }

  function configureExposedHeaders(options) {
    var headers = options.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(','); // .headers is an array, so turn it into a string
    }
    if (headers && headers.length) {
      return {
        key: 'Access-Control-Expose-Headers',
        value: headers
      };
    }
    return null;
  }

  function configureMaxAge(options) {
    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();
    if (maxAge && maxAge.length) {
      return {
        key: 'Access-Control-Max-Age',
        value: maxAge
      };
    }
    return null;
  }

  function applyHeaders(headers, res) {
    for (var i = 0, n = headers.length; i < n; i++) {
      var header = headers[i];
      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === 'Vary' && header.value) {
          vary(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }

  function cors(options, req, res, next) {
    var headers = [],
      method = req.method && req.method.toUpperCase && req.method.toUpperCase();

    if (method === 'OPTIONS') {
      // preflight
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options));
      headers.push(configureMethods(options));
      headers.push(configureAllowedHeaders(options, req));
      headers.push(configureMaxAge(options));
      headers.push(configureExposedHeaders(options));
      applyHeaders(headers, res);

      if (options.preflightContinue) {
        next();
      } else {
        // Safari (and potentially other browsers) need content-length 0,
        //   for 204 or they just hang waiting for a body
        res.statusCode = options.optionsSuccessStatus;
        res.setHeader('Content-Length', '0');
        res.end();
      }
    } else {
      // actual response
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options));
      headers.push(configureExposedHeaders(options));
      applyHeaders(headers, res);
      next();
    }
  }

  function middlewareWrapper(o) {
    // if options are static (either via defaults or custom options passed in), wrap in a function
    var optionsCallback = null;
    if (typeof o === 'function') {
      optionsCallback = o;
    } else {
      optionsCallback = function (req, cb) {
        cb(null, o);
      };
    }

    return function corsMiddleware(req, res, next) {
      optionsCallback(req, function (err, options) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function (origin, cb) {
              cb(null, corsOptions.origin);
            };
          }

          if (originCallback) {
            originCallback(req.headers.origin, function (err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }

  // can pass either an options hash, an options delegate, or nothing
  lib$4.exports = middlewareWrapper;

}());

var libExports$1 = lib$4.exports;

Object.defineProperty(server$2, "__esModule", { value: true });
server$2.Server = server$2.BaseServer = void 0;
const qs = require$$0$7;
const url_1 = require$$7$2;
const base64id = base64idExports;
const transports_1 = transports;
const events_1$2 = require$$0$6;
const socket_1 = socket$1;
const debug_1$7 = require$$13;
const cookie_1 = cookie;
const ws_1 = require$$8;
const webtransport_1 = webtransport;
const engine_io_parser_1 = esm;
const debug$b = (0, debug_1$7.default)("engine");
const kResponseHeaders = Symbol("responseHeaders");
function parseSessionId(data) {
    try {
        const parsed = JSON.parse(data);
        if (typeof parsed.sid === "string") {
            return parsed.sid;
        }
    }
    catch (e) { }
}
class BaseServer extends events_1$2.EventEmitter {
    /**
     * Server constructor.
     *
     * @param {Object} opts - options
     */
    constructor(opts = {}) {
        super();
        this.middlewares = [];
        this.clients = {};
        this.clientsCount = 0;
        this.opts = Object.assign({
            wsEngine: ws_1.Server,
            pingTimeout: 20000,
            pingInterval: 25000,
            upgradeTimeout: 10000,
            maxHttpBufferSize: 1e6,
            transports: ["polling", "websocket"], // WebTransport is disabled by default
            allowUpgrades: true,
            httpCompression: {
                threshold: 1024,
            },
            cors: false,
            allowEIO3: false,
        }, opts);
        if (opts.cookie) {
            this.opts.cookie = Object.assign({
                name: "io",
                path: "/",
                // @ts-ignore
                httpOnly: opts.cookie.path !== false,
                sameSite: "lax",
            }, opts.cookie);
        }
        if (this.opts.cors) {
            this.use(libExports$1(this.opts.cors));
        }
        if (opts.perMessageDeflate) {
            this.opts.perMessageDeflate = Object.assign({
                threshold: 1024,
            }, opts.perMessageDeflate);
        }
        this.init();
    }
    /**
     * Compute the pathname of the requests that are handled by the server
     * @param options
     * @protected
     */
    _computePath(options) {
        let path = (options.path || "/engine.io").replace(/\/$/, "");
        if (options.addTrailingSlash !== false) {
            // normalize path
            path += "/";
        }
        return path;
    }
    /**
     * Returns a list of available transports for upgrade given a certain transport.
     *
     * @return {Array}
     */
    upgrades(transport) {
        if (!this.opts.allowUpgrades)
            return [];
        return transports_1.default[transport].upgradesTo || [];
    }
    /**
     * Verifies a request.
     *
     * @param {EngineRequest} req
     * @param upgrade - whether it's an upgrade request
     * @param fn
     * @protected
     */
    verify(req, upgrade, fn) {
        // transport check
        const transport = req._query.transport;
        // WebTransport does not go through the verify() method, see the onWebTransportSession() method
        if (!~this.opts.transports.indexOf(transport) ||
            transport === "webtransport") {
            debug$b('unknown transport "%s"', transport);
            return fn(Server$1.errors.UNKNOWN_TRANSPORT, { transport });
        }
        // 'Origin' header check
        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
        if (isOriginInvalid) {
            const origin = req.headers.origin;
            req.headers.origin = null;
            debug$b("origin header invalid");
            return fn(Server$1.errors.BAD_REQUEST, {
                name: "INVALID_ORIGIN",
                origin,
            });
        }
        // sid check
        const sid = req._query.sid;
        if (sid) {
            if (!this.clients.hasOwnProperty(sid)) {
                debug$b('unknown sid "%s"', sid);
                return fn(Server$1.errors.UNKNOWN_SID, {
                    sid,
                });
            }
            const previousTransport = this.clients[sid].transport.name;
            if (!upgrade && previousTransport !== transport) {
                debug$b("bad request: unexpected transport without upgrade");
                return fn(Server$1.errors.BAD_REQUEST, {
                    name: "TRANSPORT_MISMATCH",
                    transport,
                    previousTransport,
                });
            }
        }
        else {
            // handshake is GET only
            if ("GET" !== req.method) {
                return fn(Server$1.errors.BAD_HANDSHAKE_METHOD, {
                    method: req.method,
                });
            }
            if (transport === "websocket" && !upgrade) {
                debug$b("invalid transport upgrade");
                return fn(Server$1.errors.BAD_REQUEST, {
                    name: "TRANSPORT_HANDSHAKE_ERROR",
                });
            }
            if (!this.opts.allowRequest)
                return fn();
            return this.opts.allowRequest(req, (message, success) => {
                if (!success) {
                    return fn(Server$1.errors.FORBIDDEN, {
                        message,
                    });
                }
                fn();
            });
        }
        fn();
    }
    /**
     * Adds a new middleware.
     *
     * @example
     * import helmet from "helmet";
     *
     * engine.use(helmet());
     *
     * @param fn
     */
    use(fn) {
        this.middlewares.push(fn);
    }
    /**
     * Apply the middlewares to the request.
     *
     * @param req
     * @param res
     * @param callback
     * @protected
     */
    _applyMiddlewares(req, res, callback) {
        if (this.middlewares.length === 0) {
            debug$b("no middleware to apply, skipping");
            return callback();
        }
        const apply = (i) => {
            debug$b("applying middleware n%d", i + 1);
            this.middlewares[i](req, res, (err) => {
                if (err) {
                    return callback(err);
                }
                if (i + 1 < this.middlewares.length) {
                    apply(i + 1);
                }
                else {
                    callback();
                }
            });
        };
        apply(0);
    }
    /**
     * Closes all clients.
     */
    close() {
        debug$b("closing all open clients");
        for (let i in this.clients) {
            if (this.clients.hasOwnProperty(i)) {
                this.clients[i].close(true);
            }
        }
        this.cleanup();
        return this;
    }
    /**
     * generate a socket id.
     * Overwrite this method to generate your custom socket id
     *
     * @param {IncomingMessage} req - the request object
     */
    generateId(req) {
        return base64id.generateId();
    }
    /**
     * Handshakes a new client.
     *
     * @param {String} transportName
     * @param {Object} req - the request object
     * @param {Function} closeConnection
     *
     * @protected
     */
    async handshake(transportName, req, closeConnection) {
        const protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default
        if (protocol === 3 && !this.opts.allowEIO3) {
            debug$b("unsupported protocol version");
            this.emit("connection_error", {
                req,
                code: Server$1.errors.UNSUPPORTED_PROTOCOL_VERSION,
                message: Server$1.errorMessages[Server$1.errors.UNSUPPORTED_PROTOCOL_VERSION],
                context: {
                    protocol,
                },
            });
            closeConnection(Server$1.errors.UNSUPPORTED_PROTOCOL_VERSION);
            return;
        }
        let id;
        try {
            id = await this.generateId(req);
        }
        catch (e) {
            debug$b("error while generating an id");
            this.emit("connection_error", {
                req,
                code: Server$1.errors.BAD_REQUEST,
                message: Server$1.errorMessages[Server$1.errors.BAD_REQUEST],
                context: {
                    name: "ID_GENERATION_ERROR",
                    error: e,
                },
            });
            closeConnection(Server$1.errors.BAD_REQUEST);
            return;
        }
        debug$b('handshaking client "%s"', id);
        try {
            var transport = this.createTransport(transportName, req);
            if ("polling" === transportName) {
                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
                transport.httpCompression = this.opts.httpCompression;
            }
            else if ("websocket" === transportName) {
                transport.perMessageDeflate = this.opts.perMessageDeflate;
            }
        }
        catch (e) {
            debug$b('error handshaking to transport "%s"', transportName);
            this.emit("connection_error", {
                req,
                code: Server$1.errors.BAD_REQUEST,
                message: Server$1.errorMessages[Server$1.errors.BAD_REQUEST],
                context: {
                    name: "TRANSPORT_HANDSHAKE_ERROR",
                    error: e,
                },
            });
            closeConnection(Server$1.errors.BAD_REQUEST);
            return;
        }
        const socket = new socket_1.Socket(id, this, transport, req, protocol);
        transport.on("headers", (headers, req) => {
            const isInitialRequest = !req._query.sid;
            if (isInitialRequest) {
                if (this.opts.cookie) {
                    headers["Set-Cookie"] = [
                        // @ts-ignore
                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie),
                    ];
                }
                this.emit("initial_headers", headers, req);
            }
            this.emit("headers", headers, req);
        });
        transport.onRequest(req);
        this.clients[id] = socket;
        this.clientsCount++;
        socket.once("close", () => {
            delete this.clients[id];
            this.clientsCount--;
        });
        this.emit("connection", socket);
        return transport;
    }
    async onWebTransportSession(session) {
        const timeout = setTimeout(() => {
            debug$b("the client failed to establish a bidirectional stream in the given period");
            session.close();
        }, this.opts.upgradeTimeout);
        const streamReader = session.incomingBidirectionalStreams.getReader();
        const result = await streamReader.read();
        if (result.done) {
            debug$b("session is closed");
            return;
        }
        const stream = result.value;
        const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, "nodebuffer");
        const reader = stream.readable.pipeThrough(transformStream).getReader();
        // reading the first packet of the stream
        const { value, done } = await reader.read();
        if (done) {
            debug$b("stream is closed");
            return;
        }
        clearTimeout(timeout);
        if (value.type !== "open") {
            debug$b("invalid WebTransport handshake");
            return session.close();
        }
        if (value.data === undefined) {
            const transport = new webtransport_1.WebTransport(session, stream, reader);
            // note: we cannot use "this.generateId()", because there is no "req" argument
            const id = base64id.generateId();
            debug$b('handshaking client "%s" (WebTransport)', id);
            const socket = new socket_1.Socket(id, this, transport, null, 4);
            this.clients[id] = socket;
            this.clientsCount++;
            socket.once("close", () => {
                delete this.clients[id];
                this.clientsCount--;
            });
            this.emit("connection", socket);
            return;
        }
        const sid = parseSessionId(value.data);
        if (!sid) {
            debug$b("invalid WebTransport handshake");
            return session.close();
        }
        const client = this.clients[sid];
        if (!client) {
            debug$b("upgrade attempt for closed client");
            session.close();
        }
        else if (client.upgrading) {
            debug$b("transport has already been trying to upgrade");
            session.close();
        }
        else if (client.upgraded) {
            debug$b("transport had already been upgraded");
            session.close();
        }
        else {
            debug$b("upgrading existing transport");
            const transport = new webtransport_1.WebTransport(session, stream, reader);
            client._maybeUpgrade(transport);
        }
    }
}
server$2.BaseServer = BaseServer;
/**
 * Protocol errors mappings.
 */
BaseServer.errors = {
    UNKNOWN_TRANSPORT: 0,
    UNKNOWN_SID: 1,
    BAD_HANDSHAKE_METHOD: 2,
    BAD_REQUEST: 3,
    FORBIDDEN: 4,
    UNSUPPORTED_PROTOCOL_VERSION: 5,
};
BaseServer.errorMessages = {
    0: "Transport unknown",
    1: "Session ID unknown",
    2: "Bad handshake method",
    3: "Bad request",
    4: "Forbidden",
    5: "Unsupported protocol version",
};
/**
 * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade
 * request.
 *
 * @see https://nodejs.org/api/http.html#class-httpserverresponse
 */
class WebSocketResponse {
    constructor(req, socket) {
        this.req = req;
        this.socket = socket;
        // temporarily store the response headers on the req object (see the "headers" event)
        req[kResponseHeaders] = {};
    }
    setHeader(name, value) {
        this.req[kResponseHeaders][name] = value;
    }
    getHeader(name) {
        return this.req[kResponseHeaders][name];
    }
    removeHeader(name) {
        delete this.req[kResponseHeaders][name];
    }
    write() { }
    writeHead() { }
    end() {
        // we could return a proper error code, but the WebSocket client will emit an "error" event anyway.
        this.socket.destroy();
    }
}
/**
 * An Engine.IO server based on Node.js built-in HTTP server and the `ws` package for WebSocket connections.
 */
let Server$1 = class Server extends BaseServer {
    /**
     * Initialize websocket server
     *
     * @protected
     */
    init() {
        if (!~this.opts.transports.indexOf("websocket"))
            return;
        if (this.ws)
            this.ws.close();
        this.ws = new this.opts.wsEngine({
            noServer: true,
            clientTracking: false,
            perMessageDeflate: this.opts.perMessageDeflate,
            maxPayload: this.opts.maxHttpBufferSize,
        });
        if (typeof this.ws.on === "function") {
            this.ws.on("headers", (headersArray, req) => {
                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)
                // we could also try to parse the array and then sync the values, but that will be error-prone
                const additionalHeaders = req[kResponseHeaders] || {};
                delete req[kResponseHeaders];
                const isInitialRequest = !req._query.sid;
                if (isInitialRequest) {
                    this.emit("initial_headers", additionalHeaders, req);
                }
                this.emit("headers", additionalHeaders, req);
                debug$b("writing headers: %j", additionalHeaders);
                Object.keys(additionalHeaders).forEach((key) => {
                    headersArray.push(`${key}: ${additionalHeaders[key]}`);
                });
            });
        }
    }
    cleanup() {
        if (this.ws) {
            debug$b("closing webSocketServer");
            this.ws.close();
            // don't delete this.ws because it can be used again if the http server starts listening again
        }
    }
    /**
     * Prepares a request by processing the query string.
     *
     * @private
     */
    prepare(req) {
        // try to leverage pre-existing `req._query` (e.g: from connect)
        if (!req._query) {
            req._query = (~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {});
        }
    }
    createTransport(transportName, req) {
        return new transports_1.default[transportName](req);
    }
    /**
     * Handles an Engine.IO HTTP request.
     *
     * @param {EngineRequest} req
     * @param {ServerResponse} res
     */
    handleRequest(req, res) {
        debug$b('handling "%s" http request "%s"', req.method, req.url);
        this.prepare(req);
        req.res = res;
        const callback = (errorCode, errorContext) => {
            if (errorCode !== undefined) {
                this.emit("connection_error", {
                    req,
                    code: errorCode,
                    message: Server.errorMessages[errorCode],
                    context: errorContext,
                });
                abortRequest(res, errorCode, errorContext);
                return;
            }
            if (req._query.sid) {
                debug$b("setting new request for existing client");
                this.clients[req._query.sid].transport.onRequest(req);
            }
            else {
                const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);
                this.handshake(req._query.transport, req, closeConnection);
            }
        };
        this._applyMiddlewares(req, res, (err) => {
            if (err) {
                callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
            }
            else {
                this.verify(req, false, callback);
            }
        });
    }
    /**
     * Handles an Engine.IO HTTP Upgrade.
     */
    handleUpgrade(req, socket, upgradeHead) {
        this.prepare(req);
        const res = new WebSocketResponse(req, socket);
        const callback = (errorCode, errorContext) => {
            if (errorCode !== undefined) {
                this.emit("connection_error", {
                    req,
                    code: errorCode,
                    message: Server.errorMessages[errorCode],
                    context: errorContext,
                });
                abortUpgrade(socket, errorCode, errorContext);
                return;
            }
            const head = Buffer.from(upgradeHead);
            upgradeHead = null;
            // some middlewares (like express-session) wait for the writeHead() call to flush their headers
            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244
            res.writeHead();
            // delegate to ws
            this.ws.handleUpgrade(req, socket, head, (websocket) => {
                this.onWebSocket(req, socket, websocket);
            });
        };
        this._applyMiddlewares(req, res, (err) => {
            if (err) {
                callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
            }
            else {
                this.verify(req, true, callback);
            }
        });
    }
    /**
     * Called upon a ws.io connection.
     *
     * @param {ws.Socket} websocket
     * @private
     */
    onWebSocket(req, socket, websocket) {
        websocket.on("error", onUpgradeError);
        if (transports_1.default[req._query.transport] !== undefined &&
            !transports_1.default[req._query.transport].prototype.handlesUpgrades) {
            debug$b("transport doesnt handle upgraded requests");
            websocket.close();
            return;
        }
        // get client id
        const id = req._query.sid;
        // keep a reference to the ws.Socket
        req.websocket = websocket;
        if (id) {
            const client = this.clients[id];
            if (!client) {
                debug$b("upgrade attempt for closed client");
                websocket.close();
            }
            else if (client.upgrading) {
                debug$b("transport has already been trying to upgrade");
                websocket.close();
            }
            else if (client.upgraded) {
                debug$b("transport had already been upgraded");
                websocket.close();
            }
            else {
                debug$b("upgrading existing transport");
                // transport error handling takes over
                websocket.removeListener("error", onUpgradeError);
                const transport = this.createTransport(req._query.transport, req);
                transport.perMessageDeflate = this.opts.perMessageDeflate;
                client._maybeUpgrade(transport);
            }
        }
        else {
            const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);
            this.handshake(req._query.transport, req, closeConnection);
        }
        function onUpgradeError() {
            debug$b("websocket error before upgrade");
            // websocket.close() not needed
        }
    }
    /**
     * Captures upgrade requests for a http.Server.
     *
     * @param {http.Server} server
     * @param {Object} options
     */
    attach(server, options = {}) {
        const path = this._computePath(options);
        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;
        function check(req) {
            // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)
            return path === req.url.slice(0, path.length);
        }
        // cache and clean up listeners
        const listeners = server.listeners("request").slice(0);
        server.removeAllListeners("request");
        server.on("close", this.close.bind(this));
        server.on("listening", this.init.bind(this));
        // add request handler
        server.on("request", (req, res) => {
            if (check(req)) {
                debug$b('intercepting request for path "%s"', path);
                this.handleRequest(req, res);
            }
            else {
                let i = 0;
                const l = listeners.length;
                for (; i < l; i++) {
                    listeners[i].call(server, req, res);
                }
            }
        });
        if (~this.opts.transports.indexOf("websocket")) {
            server.on("upgrade", (req, socket, head) => {
                if (check(req)) {
                    this.handleUpgrade(req, socket, head);
                }
                else if (false !== options.destroyUpgrade) {
                    // default node behavior is to disconnect when no handlers
                    // but by adding a handler, we prevent that
                    // and if no eio thing handles the upgrade
                    // then the socket needs to die!
                    setTimeout(function () {
                        // @ts-ignore
                        if (socket.writable && socket.bytesWritten <= 0) {
                            socket.on("error", (e) => {
                                debug$b("error while destroying upgrade: %s", e.message);
                            });
                            return socket.end();
                        }
                    }, destroyUpgradeTimeout);
                }
            });
        }
    }
};
server$2.Server = Server$1;
/**
 * Close the HTTP long-polling request
 *
 * @param res - the response object
 * @param errorCode - the error code
 * @param errorContext - additional error context
 *
 * @private
 */
function abortRequest(res, errorCode, errorContext) {
    const statusCode = errorCode === Server$1.errors.FORBIDDEN ? 403 : 400;
    const message = errorContext && errorContext.message
        ? errorContext.message
        : Server$1.errorMessages[errorCode];
    res.writeHead(statusCode, { "Content-Type": "application/json" });
    res.end(JSON.stringify({
        code: errorCode,
        message,
    }));
}
/**
 * Close the WebSocket connection
 *
 * @param {net.Socket} socket
 * @param {string} errorCode - the error code
 * @param {object} errorContext - additional error context
 */
function abortUpgrade(socket, errorCode, errorContext = {}) {
    socket.on("error", () => {
        debug$b("ignoring error from closed connection");
    });
    if (socket.writable) {
        const message = errorContext.message || Server$1.errorMessages[errorCode];
        const length = Buffer.byteLength(message);
        socket.write("HTTP/1.1 400 Bad Request\r\n" +
            "Connection: close\r\n" +
            "Content-type: text/html\r\n" +
            "Content-Length: " +
            length +
            "\r\n" +
            "\r\n" +
            message);
    }
    socket.destroy();
}
/* eslint-disable */
/**
 * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354
 *
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 *
 * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
// prettier-ignore
const validHdrChars = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255
];
function checkInvalidHeaderChar(val) {
    val += "";
    if (val.length < 1)
        return false;
    if (!validHdrChars[val.charCodeAt(0)]) {
        debug$b('invalid header, index 0, char "%s"', val.charCodeAt(0));
        return true;
    }
    if (val.length < 2)
        return false;
    if (!validHdrChars[val.charCodeAt(1)]) {
        debug$b('invalid header, index 1, char "%s"', val.charCodeAt(1));
        return true;
    }
    if (val.length < 3)
        return false;
    if (!validHdrChars[val.charCodeAt(2)]) {
        debug$b('invalid header, index 2, char "%s"', val.charCodeAt(2));
        return true;
    }
    if (val.length < 4)
        return false;
    if (!validHdrChars[val.charCodeAt(3)]) {
        debug$b('invalid header, index 3, char "%s"', val.charCodeAt(3));
        return true;
    }
    for (let i = 4; i < val.length; ++i) {
        if (!validHdrChars[val.charCodeAt(i)]) {
            debug$b('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
            return true;
        }
    }
    return false;
}

var userver = {};

var transportsUws = {};

var polling = {};

Object.defineProperty(polling, "__esModule", { value: true });
polling.Polling = void 0;
const transport_1$1 = transport;
const zlib_1 = require$$0$5;
const accepts = accepts$2;
const debug_1$6 = require$$13;
const debug$a = (0, debug_1$6.default)("engine:polling");
const compressionMethods = {
    gzip: zlib_1.createGzip,
    deflate: zlib_1.createDeflate,
};
class Polling extends transport_1$1.Transport {
    /**
     * HTTP polling constructor.
     */
    constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1000;
    }
    /**
     * Transport name
     */
    get name() {
        return "polling";
    }
    /**
     * Overrides onRequest.
     *
     * @param req
     *
     * @private
     */
    onRequest(req) {
        const res = req.res;
        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)
        req.res = null;
        if (req.getMethod() === "get") {
            this.onPollRequest(req, res);
        }
        else if (req.getMethod() === "post") {
            this.onDataRequest(req, res);
        }
        else {
            res.writeStatus("500 Internal Server Error");
            res.end();
        }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @private
     */
    onPollRequest(req, res) {
        if (this.req) {
            debug$a("request overlap");
            // assert: this.res, '.req and .res should be (un)set together'
            this.onError("overlap from client");
            res.writeStatus("500 Internal Server Error");
            res.end();
            return;
        }
        debug$a("setting request");
        this.req = req;
        this.res = res;
        const onClose = () => {
            this.writable = false;
            this.onError("poll connection closed prematurely");
        };
        const cleanup = () => {
            this.req = this.res = null;
        };
        req.cleanup = cleanup;
        res.onAborted(onClose);
        this.writable = true;
        this.emit("ready");
        // if we're still writable but had a pending close, trigger an empty send
        if (this.writable && this.shouldClose) {
            debug$a("triggering empty send to append close packet");
            this.send([{ type: "noop" }]);
        }
    }
    /**
     * The client sends a request with data.
     *
     * @private
     */
    onDataRequest(req, res) {
        if (this.dataReq) {
            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
            this.onError("data request overlap from client");
            res.writeStatus("500 Internal Server Error");
            res.end();
            return;
        }
        const expectedContentLength = Number(req.headers["content-length"]);
        if (!expectedContentLength) {
            this.onError("content-length header required");
            res.writeStatus("411 Length Required").end();
            return;
        }
        if (expectedContentLength > this.maxHttpBufferSize) {
            this.onError("payload too large");
            res.writeStatus("413 Payload Too Large").end();
            return;
        }
        const isBinary = "application/octet-stream" === req.headers["content-type"];
        if (isBinary && this.protocol === 4) {
            return this.onError("invalid content");
        }
        this.dataReq = req;
        this.dataRes = res;
        let buffer;
        let offset = 0;
        const headers = {
            // text/html is required instead of text/plain to avoid an
            // unwanted download dialog on certain user-agents (GH-43)
            "Content-Type": "text/html",
        };
        this.headers(req, headers);
        for (let key in headers) {
            res.writeHeader(key, String(headers[key]));
        }
        const onEnd = (buffer) => {
            this.onData(buffer.toString());
            this.onDataRequestCleanup();
            res.cork(() => {
                res.end("ok");
            });
        };
        res.onAborted(() => {
            this.onDataRequestCleanup();
            this.onError("data request connection closed prematurely");
        });
        res.onData((arrayBuffer, isLast) => {
            const totalLength = offset + arrayBuffer.byteLength;
            if (totalLength > expectedContentLength) {
                this.onError("content-length mismatch");
                res.close(); // calls onAborted
                return;
            }
            if (!buffer) {
                if (isLast) {
                    onEnd(Buffer.from(arrayBuffer));
                    return;
                }
                buffer = Buffer.allocUnsafe(expectedContentLength);
            }
            Buffer.from(arrayBuffer).copy(buffer, offset);
            if (isLast) {
                if (totalLength != expectedContentLength) {
                    this.onError("content-length mismatch");
                    res.writeStatus("400 Content-Length Mismatch").end();
                    this.onDataRequestCleanup();
                    return;
                }
                onEnd(buffer);
                return;
            }
            offset = totalLength;
        });
    }
    /**
     * Cleanup request.
     *
     * @private
     */
    onDataRequestCleanup() {
        this.dataReq = this.dataRes = null;
    }
    /**
     * Processes the incoming data payload.
     *
     * @param {String} encoded payload
     * @private
     */
    onData(data) {
        debug$a('received "%s"', data);
        const callback = (packet) => {
            if ("close" === packet.type) {
                debug$a("got xhr close packet");
                this.onClose();
                return false;
            }
            this.onPacket(packet);
        };
        if (this.protocol === 3) {
            this.parser.decodePayload(data, callback);
        }
        else {
            this.parser.decodePayload(data).forEach(callback);
        }
    }
    /**
     * Overrides onClose.
     *
     * @private
     */
    onClose() {
        if (this.writable) {
            // close pending poll request
            this.send([{ type: "noop" }]);
        }
        super.onClose();
    }
    /**
     * Writes a packet payload.
     *
     * @param {Object} packet
     * @private
     */
    send(packets) {
        this.writable = false;
        if (this.shouldClose) {
            debug$a("appending close packet to payload");
            packets.push({ type: "close" });
            this.shouldClose();
            this.shouldClose = null;
        }
        const doWrite = (data) => {
            const compress = packets.some((packet) => {
                return packet.options && packet.options.compress;
            });
            this.write(data, { compress });
        };
        if (this.protocol === 3) {
            this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        }
        else {
            this.parser.encodePayload(packets, doWrite);
        }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @private
     */
    write(data, options) {
        debug$a('writing "%s"', data);
        this.doWrite(data, options, () => {
            this.req.cleanup();
            this.emit("drain");
        });
    }
    /**
     * Performs the write.
     *
     * @private
     */
    doWrite(data, options, callback) {
        // explicit UTF-8 is required for pages not served under utf
        const isString = typeof data === "string";
        const contentType = isString
            ? "text/plain; charset=UTF-8"
            : "application/octet-stream";
        const headers = {
            "Content-Type": contentType,
        };
        const respond = (data) => {
            this.headers(this.req, headers);
            this.res.cork(() => {
                Object.keys(headers).forEach((key) => {
                    this.res.writeHeader(key, String(headers[key]));
                });
                this.res.end(data);
            });
            callback();
        };
        if (!this.httpCompression || !options.compress) {
            respond(data);
            return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len < this.httpCompression.threshold) {
            respond(data);
            return;
        }
        const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
        if (!encoding) {
            respond(data);
            return;
        }
        this.compress(data, encoding, (err, data) => {
            if (err) {
                this.res.writeStatus("500 Internal Server Error");
                this.res.end();
                callback(err);
                return;
            }
            headers["Content-Encoding"] = encoding;
            respond(data);
        });
    }
    /**
     * Compresses data.
     *
     * @private
     */
    compress(data, encoding, callback) {
        debug$a("compressing");
        const buffers = [];
        let nread = 0;
        compressionMethods[encoding](this.httpCompression)
            .on("error", callback)
            .on("data", function (chunk) {
            buffers.push(chunk);
            nread += chunk.length;
        })
            .on("end", function () {
            callback(null, Buffer.concat(buffers, nread));
        })
            .end(data);
    }
    /**
     * Closes the transport.
     *
     * @private
     */
    doClose(fn) {
        debug$a("closing");
        let closeTimeoutTimer;
        const onClose = () => {
            clearTimeout(closeTimeoutTimer);
            fn();
            this.onClose();
        };
        if (this.writable) {
            debug$a("transport writable - closing right away");
            this.send([{ type: "close" }]);
            onClose();
        }
        else if (this.discarded) {
            debug$a("transport discarded - closing right away");
            onClose();
        }
        else {
            debug$a("transport not writable - buffering orderly close");
            this.shouldClose = onClose;
            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
    }
    /**
     * Returns headers for a response.
     *
     * @param req - request
     * @param {Object} extra headers
     * @private
     */
    headers(req, headers) {
        headers = headers || {};
        // prevent XSS warnings on IE
        // https://github.com/LearnBoost/socket.io/pull/1333
        const ua = req.headers["user-agent"];
        if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
            headers["X-XSS-Protection"] = "0";
        }
        headers["cache-control"] = "no-store";
        this.emit("headers", headers, req);
        return headers;
    }
}
polling.Polling = Polling;

var websocket$1 = {};

Object.defineProperty(websocket$1, "__esModule", { value: true });
websocket$1.WebSocket = void 0;
const transport_1 = transport;
const debug_1$5 = require$$13;
const debug$9 = (0, debug_1$5.default)("engine:ws");
let WebSocket$4 = class WebSocket extends transport_1.Transport {
    /**
     * WebSocket transport
     *
     * @param req
     */
    constructor(req) {
        super(req);
        this.writable = false;
        this.perMessageDeflate = null;
    }
    /**
     * Transport name
     */
    get name() {
        return "websocket";
    }
    /**
     * Advertise upgrade support.
     */
    get handlesUpgrades() {
        return true;
    }
    /**
     * Writes a packet payload.
     *
     * @param {Array} packets
     * @private
     */
    send(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const isLast = i + 1 === packets.length;
            const send = (data) => {
                const isBinary = typeof data !== "string";
                const compress = this.perMessageDeflate &&
                    Buffer.byteLength(data) > this.perMessageDeflate.threshold;
                debug$9('writing "%s"', data);
                this.socket.send(data, isBinary, compress);
                if (isLast) {
                    this.emit("drain");
                    this.writable = true;
                    this.emit("ready");
                }
            };
            if (packet.options && typeof packet.options.wsPreEncoded === "string") {
                send(packet.options.wsPreEncoded);
            }
            else {
                this.parser.encodePacket(packet, this.supportsBinary, send);
            }
        }
    }
    /**
     * Closes the transport.
     *
     * @private
     */
    doClose(fn) {
        debug$9("closing");
        fn && fn();
        // call fn first since socket.end() immediately emits a "close" event
        this.socket.end();
    }
};
websocket$1.WebSocket = WebSocket$4;

Object.defineProperty(transportsUws, "__esModule", { value: true });
const polling_1 = polling;
const websocket_1 = websocket$1;
transportsUws.default = {
    polling: polling_1.Polling,
    websocket: websocket_1.WebSocket,
};

Object.defineProperty(userver, "__esModule", { value: true });
userver.uServer = void 0;
const debug_1$4 = require$$13;
const server_1 = server$2;
const transports_uws_1 = transportsUws;
const debug$8 = (0, debug_1$4.default)("engine:uws");
/**
 * An Engine.IO server based on the `uWebSockets.js` package.
 */
// TODO export it into its own package
class uServer extends server_1.BaseServer {
    init() { }
    cleanup() { }
    /**
     * Prepares a request by processing the query string.
     *
     * @private
     */
    prepare(req, res) {
        req.method = req.getMethod().toUpperCase();
        req.url = req.getUrl();
        const params = new URLSearchParams(req.getQuery());
        req._query = Object.fromEntries(params.entries());
        req.headers = {};
        req.forEach((key, value) => {
            req.headers[key] = value;
        });
        req.connection = {
            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString(),
        };
        res.onAborted(() => {
            debug$8("response has been aborted");
        });
    }
    createTransport(transportName, req) {
        return new transports_uws_1.default[transportName](req);
    }
    /**
     * Attach the engine to a WebSockets.js server
     * @param app
     * @param options
     */
    attach(app /* : TemplatedApp */, options = {}) {
        const path = this._computePath(options);
        app
            .any(path, this.handleRequest.bind(this))
            //
            .ws(path, {
            compression: options.compression,
            idleTimeout: options.idleTimeout,
            maxBackpressure: options.maxBackpressure,
            maxPayloadLength: this.opts.maxHttpBufferSize,
            upgrade: this.handleUpgrade.bind(this),
            open: (ws) => {
                const transport = ws.getUserData().transport;
                transport.socket = ws;
                transport.writable = true;
                transport.emit("ready");
            },
            message: (ws, message, isBinary) => {
                ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());
            },
            close: (ws, code, message) => {
                ws.getUserData().transport.onClose(code, message);
            },
        });
    }
    _applyMiddlewares(req, res, callback) {
        if (this.middlewares.length === 0) {
            return callback();
        }
        // needed to buffer headers until the status is computed
        req.res = new ResponseWrapper(res);
        super._applyMiddlewares(req, req.res, (err) => {
            // some middlewares (like express-session) wait for the writeHead() call to flush their headers
            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244
            req.res.writeHead();
            callback(err);
        });
    }
    handleRequest(res, req) {
        debug$8('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
        this.prepare(req, res);
        req.res = res;
        const callback = (errorCode, errorContext) => {
            if (errorCode !== undefined) {
                this.emit("connection_error", {
                    req,
                    code: errorCode,
                    message: server_1.Server.errorMessages[errorCode],
                    context: errorContext,
                });
                this.abortRequest(req.res, errorCode, errorContext);
                return;
            }
            if (req._query.sid) {
                debug$8("setting new request for existing client");
                // @ts-ignore
                this.clients[req._query.sid].transport.onRequest(req);
            }
            else {
                const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);
                this.handshake(req._query.transport, req, closeConnection);
            }
        };
        this._applyMiddlewares(req, res, (err) => {
            if (err) {
                callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
            }
            else {
                this.verify(req, false, callback);
            }
        });
    }
    handleUpgrade(res, req, context) {
        debug$8("on upgrade");
        this.prepare(req, res);
        req.res = res;
        const callback = async (errorCode, errorContext) => {
            if (errorCode !== undefined) {
                this.emit("connection_error", {
                    req,
                    code: errorCode,
                    message: server_1.Server.errorMessages[errorCode],
                    context: errorContext,
                });
                this.abortRequest(res, errorCode, errorContext);
                return;
            }
            const id = req._query.sid;
            let transport;
            if (id) {
                const client = this.clients[id];
                if (!client) {
                    debug$8("upgrade attempt for closed client");
                    return res.close();
                }
                else if (client.upgrading) {
                    debug$8("transport has already been trying to upgrade");
                    return res.close();
                }
                else if (client.upgraded) {
                    debug$8("transport had already been upgraded");
                    return res.close();
                }
                else {
                    debug$8("upgrading existing transport");
                    transport = this.createTransport(req._query.transport, req);
                    client._maybeUpgrade(transport);
                }
            }
            else {
                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));
                if (!transport) {
                    return;
                }
            }
            // calling writeStatus() triggers the flushing of any header added in a middleware
            req.res.writeStatus("101 Switching Protocols");
            res.upgrade({
                transport,
            }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);
        };
        this._applyMiddlewares(req, res, (err) => {
            if (err) {
                callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
            }
            else {
                this.verify(req, true, callback);
            }
        });
    }
    abortRequest(res, errorCode, errorContext) {
        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN
            ? "403 Forbidden"
            : "400 Bad Request";
        const message = errorContext && errorContext.message
            ? errorContext.message
            : server_1.Server.errorMessages[errorCode];
        res.writeStatus(statusCode);
        res.writeHeader("Content-Type", "application/json");
        res.end(JSON.stringify({
            code: errorCode,
            message,
        }));
    }
}
userver.uServer = uServer;
class ResponseWrapper {
    constructor(res) {
        this.res = res;
        this.statusWritten = false;
        this.headers = [];
        this.isAborted = false;
    }
    set statusCode(status) {
        if (!status) {
            return;
        }
        // FIXME: handle all status codes?
        this.writeStatus(status === 200 ? "200 OK" : "204 No Content");
    }
    writeHead(status) {
        this.statusCode = status;
    }
    setHeader(key, value) {
        if (Array.isArray(value)) {
            value.forEach((val) => {
                this.writeHeader(key, val);
            });
        }
        else {
            this.writeHeader(key, value);
        }
    }
    removeHeader() {
        // FIXME: not implemented
    }
    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134
    getHeader() { }
    writeStatus(status) {
        if (this.isAborted)
            return;
        this.res.writeStatus(status);
        this.statusWritten = true;
        this.writeBufferedHeaders();
        return this;
    }
    writeHeader(key, value) {
        if (this.isAborted)
            return;
        if (key === "Content-Length") {
            // the content length is automatically added by uWebSockets.js
            return;
        }
        if (this.statusWritten) {
            this.res.writeHeader(key, value);
        }
        else {
            this.headers.push([key, value]);
        }
    }
    writeBufferedHeaders() {
        this.headers.forEach(([key, value]) => {
            this.res.writeHeader(key, value);
        });
    }
    end(data) {
        if (this.isAborted)
            return;
        this.res.cork(() => {
            if (!this.statusWritten) {
                // status will be inferred as "200 OK"
                this.writeBufferedHeaders();
            }
            this.res.end(data);
        });
    }
    onData(fn) {
        if (this.isAborted)
            return;
        this.res.onData(fn);
    }
    onAborted(fn) {
        if (this.isAborted)
            return;
        this.res.onAborted(() => {
            // Any attempt to use the UWS response object after abort will throw!
            this.isAborted = true;
            fn();
        });
    }
    cork(fn) {
        if (this.isAborted)
            return;
        this.res.cork(fn);
    }
}

(function (exports$1) {
	Object.defineProperty(exports$1, "__esModule", { value: true });
	exports$1.protocol = exports$1.Transport = exports$1.Socket = exports$1.uServer = exports$1.parser = exports$1.transports = exports$1.Server = void 0;
	exports$1.listen = listen;
	exports$1.attach = attach;
	const http_1 = require$$1$6;
	const server_1 = server$2;
	Object.defineProperty(exports$1, "Server", { enumerable: true, get: function () { return server_1.Server; } });
	const index_1 = transports;
	exports$1.transports = index_1.default;
	const parser = esm;
	exports$1.parser = parser;
	var userver_1 = userver;
	Object.defineProperty(exports$1, "uServer", { enumerable: true, get: function () { return userver_1.uServer; } });
	var socket_1 = socket$1;
	Object.defineProperty(exports$1, "Socket", { enumerable: true, get: function () { return socket_1.Socket; } });
	var transport_1 = transport;
	Object.defineProperty(exports$1, "Transport", { enumerable: true, get: function () { return transport_1.Transport; } });
	exports$1.protocol = parser.protocol;
	/**
	 * Creates an http.Server exclusively used for WS upgrades.
	 *
	 * @param {Number} port
	 * @param {Function} callback
	 * @param {Object} options
	 * @return {Server} websocket.io server
	 */
	function listen(port, options, fn) {
	    if ("function" === typeof options) {
	        fn = options;
	        options = {};
	    }
	    const server = (0, http_1.createServer)(function (req, res) {
	        res.writeHead(501);
	        res.end("Not Implemented");
	    });
	    // create engine server
	    const engine = attach(server, options);
	    engine.httpServer = server;
	    server.listen(port, fn);
	    return engine;
	}
	/**
	 * Captures upgrade requests for a http.Server.
	 *
	 * @param {http.Server} server
	 * @param {Object} options
	 * @return {Server} engine server
	 */
	function attach(server, options) {
	    const engine = new server_1.Server(options);
	    engine.attach(server, options);
	    return engine;
	} 
} (engine_io));

const wrapper$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Server: engine_io.Server,
  Socket: engine_io.Socket,
  Transport: engine_io.Transport,
  attach: engine_io.attach,
  listen: engine_io.listen,
  parser: engine_io.parser,
  protocol: engine_io.protocol,
  transports: engine_io.transports
}, Symbol.toStringTag, { value: 'Module' }));

var dist$2 = {exports: {}};

const require$$1$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(fs);

const require$$6$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(wrapper$1);

var client$1 = {};

/**
 * Expose `Emitter`.
 */

var Emitter_1 = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString$2 = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString$2.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString$2.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}

/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (isBinary(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" &&
            data.num >= 0 &&
            data.num < buffers.length;
        if (isIndexValid) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        }
        else {
            throw new Error("illegal attachments");
        }
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}

const debug$7 = debug$h("socket.io-parser"); // debug()
/**
 * These strings must not be used as event names, as they have a special meaning.
 */
const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener", // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
const protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        debug$7("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if (hasBinary(obj)) {
                return this.encodeAsBinary({
                    type: obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK,
                    nsp: obj.nsp,
                    data: obj.data,
                    id: obj.id,
                });
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
        }
        debug$7("encoded %j as %s", obj, str);
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = deconstructPacket(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject$4(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends Emitter_1 {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) {
                throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if (isBinary(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        debug$7("decoded %s as %j", str, p);
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        }
        catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return isObject$4(payload);
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || isObject$4(payload);
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return (Array.isArray(payload) &&
                    (typeof payload[0] === "number" ||
                        (typeof payload[0] === "string" &&
                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = reconstructPacket(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}

const parser = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Decoder: Decoder,
  Encoder: Encoder,
  get PacketType () { return PacketType; },
  protocol: protocol
}, Symbol.toStringTag, { value: 'Module' }));

Object.defineProperty(client$1, "__esModule", { value: true });
client$1.Client = void 0;
const socket_io_parser_1$2 = parser;
const debugModule = require$$13;
const url = require$$7$2;
const debug$6 = debugModule("socket.io:client");
class Client {
    /**
     * Client constructor.
     *
     * @param server instance
     * @param conn
     * @package
     */
    constructor(server, conn) {
        this.sockets = new Map();
        this.nsps = new Map();
        this.server = server;
        this.conn = conn;
        this.encoder = server.encoder;
        this.decoder = new server._parser.Decoder();
        this.id = conn.id;
        this.setup();
    }
    /**
     * @return the reference to the request that originated the Engine.IO connection
     *
     * @public
     */
    get request() {
        return this.conn.request;
    }
    /**
     * Sets up event listeners.
     *
     * @private
     */
    setup() {
        this.onclose = this.onclose.bind(this);
        this.ondata = this.ondata.bind(this);
        this.onerror = this.onerror.bind(this);
        this.ondecoded = this.ondecoded.bind(this);
        // @ts-ignore
        this.decoder.on("decoded", this.ondecoded);
        this.conn.on("data", this.ondata);
        this.conn.on("error", this.onerror);
        this.conn.on("close", this.onclose);
        this.connectTimeout = setTimeout(() => {
            if (this.nsps.size === 0) {
                debug$6("no namespace joined yet, close the client");
                this.close();
            }
            else {
                debug$6("the client has already joined a namespace, nothing to do");
            }
        }, this.server._connectTimeout);
    }
    /**
     * Connects a client to a namespace.
     *
     * @param {String} name - the namespace
     * @param {Object} auth - the auth parameters
     * @private
     */
    connect(name, auth = {}) {
        if (this.server._nsps.has(name)) {
            debug$6("connecting to namespace %s", name);
            return this.doConnect(name, auth);
        }
        this.server._checkNamespace(name, auth, (dynamicNspName) => {
            if (dynamicNspName) {
                this.doConnect(name, auth);
            }
            else {
                debug$6("creation of namespace %s was denied", name);
                this._packet({
                    type: socket_io_parser_1$2.PacketType.CONNECT_ERROR,
                    nsp: name,
                    data: {
                        message: "Invalid namespace",
                    },
                });
            }
        });
    }
    /**
     * Connects a client to a namespace.
     *
     * @param name - the namespace
     * @param {Object} auth - the auth parameters
     *
     * @private
     */
    doConnect(name, auth) {
        const nsp = this.server.of(name);
        nsp._add(this, auth, (socket) => {
            this.sockets.set(socket.id, socket);
            this.nsps.set(nsp.name, socket);
            if (this.connectTimeout) {
                clearTimeout(this.connectTimeout);
                this.connectTimeout = undefined;
            }
        });
    }
    /**
     * Disconnects from all namespaces and closes transport.
     *
     * @private
     */
    _disconnect() {
        for (const socket of this.sockets.values()) {
            socket.disconnect();
        }
        this.sockets.clear();
        this.close();
    }
    /**
     * Removes a socket. Called by each `Socket`.
     *
     * @private
     */
    _remove(socket) {
        if (this.sockets.has(socket.id)) {
            const nsp = this.sockets.get(socket.id).nsp.name;
            this.sockets.delete(socket.id);
            this.nsps.delete(nsp);
        }
        else {
            debug$6("ignoring remove for %s", socket.id);
        }
    }
    /**
     * Closes the underlying connection.
     *
     * @private
     */
    close() {
        if ("open" === this.conn.readyState) {
            debug$6("forcing transport close");
            this.conn.close();
            this.onclose("forced server close");
        }
    }
    /**
     * Writes a packet to the transport.
     *
     * @param {Object} packet object
     * @param {Object} opts
     * @private
     */
    _packet(packet, opts = {}) {
        if (this.conn.readyState !== "open") {
            debug$6("ignoring packet write %j", packet);
            return;
        }
        const encodedPackets = opts.preEncoded
            ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()
            : this.encoder.encode(packet);
        this.writeToEngine(encodedPackets, opts);
    }
    writeToEngine(encodedPackets, opts) {
        if (opts.volatile && !this.conn.transport.writable) {
            debug$6("volatile packet is discarded since the transport is not currently writable");
            return;
        }
        const packets = Array.isArray(encodedPackets)
            ? encodedPackets
            : [encodedPackets];
        for (const encodedPacket of packets) {
            this.conn.write(encodedPacket, opts);
        }
    }
    /**
     * Called with incoming transport data.
     *
     * @private
     */
    ondata(data) {
        // try/catch is needed for protocol violations (GH-1880)
        try {
            this.decoder.add(data);
        }
        catch (e) {
            debug$6("invalid packet format");
            this.onerror(e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        let namespace;
        let authPayload;
        if (this.conn.protocol === 3) {
            const parsed = url.parse(packet.nsp, true);
            namespace = parsed.pathname;
            authPayload = parsed.query;
        }
        else {
            namespace = packet.nsp;
            authPayload = packet.data;
        }
        const socket = this.nsps.get(namespace);
        if (!socket && packet.type === socket_io_parser_1$2.PacketType.CONNECT) {
            this.connect(namespace, authPayload);
        }
        else if (socket &&
            packet.type !== socket_io_parser_1$2.PacketType.CONNECT &&
            packet.type !== socket_io_parser_1$2.PacketType.CONNECT_ERROR) {
            process.nextTick(function () {
                socket._onpacket(packet);
            });
        }
        else {
            debug$6("invalid state (packet type: %s)", packet.type);
            this.close();
        }
    }
    /**
     * Handles an error.
     *
     * @param {Object} err object
     * @private
     */
    onerror(err) {
        for (const socket of this.sockets.values()) {
            socket._onerror(err);
        }
        this.conn.close();
    }
    /**
     * Called upon transport close.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        debug$6("client close with reason %s", reason);
        // ignore a potential subsequent `close` event
        this.destroy();
        // `nsps` and `sockets` are cleaned up seamlessly
        for (const socket of this.sockets.values()) {
            socket._onclose(reason, description);
        }
        this.sockets.clear();
        this.decoder.destroy(); // clean up decoder
    }
    /**
     * Cleans up event listeners.
     * @private
     */
    destroy() {
        this.conn.removeListener("data", this.ondata);
        this.conn.removeListener("error", this.onerror);
        this.conn.removeListener("close", this.onclose);
        // @ts-ignore
        this.decoder.removeListener("decoded", this.ondecoded);
        if (this.connectTimeout) {
            clearTimeout(this.connectTimeout);
            this.connectTimeout = undefined;
        }
    }
}
client$1.Client = Client;

var namespace = {};

var socket = {};

var typedEvents = {};

Object.defineProperty(typedEvents, "__esModule", { value: true });
typedEvents.StrictEventEmitter = void 0;
const events_1$1 = require$$0$6;
/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */
class StrictEventEmitter extends events_1$1.EventEmitter {
    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    on(ev, listener) {
        return super.on(ev, listener);
    }
    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    once(ev, listener) {
        return super.once(ev, listener);
    }
    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */
    emit(ev, ...args) {
        return super.emit(ev, ...args);
    }
    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */
    emitReserved(ev, ...args) {
        return super.emit(ev, ...args);
    }
    /**
     * Emits an event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can get around the strict typing. This is useful for
     * calling `emit.apply`, which can be called as `emitUntyped.apply`.
     *
     * @param ev Event name
     * @param args Arguments to emit along with the event
     */
    emitUntyped(ev, ...args) {
        return super.emit(ev, ...args);
    }
    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */
    listeners(event) {
        return super.listeners(event);
    }
}
typedEvents.StrictEventEmitter = StrictEventEmitter;

var broadcastOperator = {};

var socketTypes = {};

Object.defineProperty(socketTypes, "__esModule", { value: true });
socketTypes.RESERVED_EVENTS = void 0;
socketTypes.RESERVED_EVENTS = new Set([
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener",
]);

Object.defineProperty(broadcastOperator, "__esModule", { value: true });
broadcastOperator.RemoteSocket = broadcastOperator.BroadcastOperator = void 0;
const socket_types_1$1 = socketTypes;
const socket_io_parser_1$1 = parser;
class BroadcastOperator {
    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {
        this.adapter = adapter;
        this.rooms = rooms;
        this.exceptRooms = exceptRooms;
        this.flags = flags;
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * io.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
        const rooms = new Set(this.rooms);
        if (Array.isArray(room)) {
            room.forEach((r) => rooms.add(r));
        }
        else {
            rooms.add(room);
        }
        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * // disconnect all clients in the "room-101" room
     * io.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
        return this.to(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * io.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * io.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
        const exceptRooms = new Set(this.exceptRooms);
        if (Array.isArray(room)) {
            room.forEach((r) => exceptRooms.add(r));
        }
        else {
            exceptRooms.add(room);
        }
        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     */
    compress(compress) {
        const flags = Object.assign({}, this.flags, { compress });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return a new BroadcastOperator instance
     */
    get volatile() {
        const flags = Object.assign({}, this.flags, { volatile: true });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * // the foo event will be broadcast to all connected clients on this node
     * io.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
        const flags = Object.assign({}, this.flags, { local: true });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Adds a timeout in milliseconds for the next operation
     *
     * @example
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
        const flags = Object.assign({}, this.flags, { timeout });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Emits to all clients.
     *
     * @example
     * // the foo event will be broadcast to all connected clients
     * io.emit("foo", "bar");
     *
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an acknowledgement expected from all connected clients
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @return Always true
     */
    emit(ev, ...args) {
        if (socket_types_1$1.RESERVED_EVENTS.has(ev)) {
            throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        // set up packet object
        const data = [ev, ...args];
        const packet = {
            type: socket_io_parser_1$1.PacketType.EVENT,
            data: data,
        };
        const withAck = typeof data[data.length - 1] === "function";
        if (!withAck) {
            this.adapter.broadcast(packet, {
                rooms: this.rooms,
                except: this.exceptRooms,
                flags: this.flags,
            });
            return true;
        }
        const ack = data.pop();
        let timedOut = false;
        let responses = [];
        const timer = setTimeout(() => {
            timedOut = true;
            ack.apply(this, [
                new Error("operation has timed out"),
                this.flags.expectSingleResponse ? null : responses,
            ]);
        }, this.flags.timeout);
        let expectedServerCount = -1;
        let actualServerCount = 0;
        let expectedClientCount = 0;
        const checkCompleteness = () => {
            if (!timedOut &&
                expectedServerCount === actualServerCount &&
                responses.length === expectedClientCount) {
                clearTimeout(timer);
                ack.apply(this, [
                    null,
                    this.flags.expectSingleResponse ? responses[0] : responses,
                ]);
            }
        };
        this.adapter.broadcastWithAck(packet, {
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        }, (clientCount) => {
            // each Socket.IO server in the cluster sends the number of clients that were notified
            expectedClientCount += clientCount;
            actualServerCount++;
            checkCompleteness();
        }, (clientResponse) => {
            // each client sends an acknowledgement
            responses.push(clientResponse);
            checkCompleteness();
        });
        this.adapter.serverCount().then((serverCount) => {
            expectedServerCount = serverCount;
            checkCompleteness();
        });
        return true;
    }
    /**
     * Emits an event and waits for an acknowledgement from all clients.
     *
     * @example
     * try {
     *   const responses = await io.timeout(1000).emitWithAck("some-event");
     *   console.log(responses); // one response per client
     * } catch (e) {
     *   // some clients did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when all clients have acknowledged the event
     */
    emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            args.push((err, responses) => {
                if (err) {
                    err.responses = responses;
                    return reject(err);
                }
                else {
                    return resolve(responses);
                }
            });
            this.emit(ev, ...args);
        });
    }
    /**
     * Gets a list of clients.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
     * {@link fetchSockets} instead.
     */
    allSockets() {
        if (!this.adapter) {
            throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
        }
        return this.adapter.sockets(this.rooms);
    }
    /**
     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // return all Socket instances
     * const sockets = await io.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await io.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
        return this.adapter
            .fetchSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        })
            .then((sockets) => {
            return sockets.map((socket) => {
                if (socket.server) {
                    return socket; // local instance
                }
                else {
                    return new RemoteSocket(this.adapter, socket);
                }
            });
        });
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     *
     * // make all socket instances join the "room1" room
     * io.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * io.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
        this.adapter.addSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances leave the "room1" room
     * io.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * io.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
        this.adapter.delSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * io.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * io.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
        this.adapter.disconnectSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
        }, close);
    }
}
broadcastOperator.BroadcastOperator = BroadcastOperator;
/**
 * Expose of subset of the attributes and methods of the Socket class
 */
class RemoteSocket {
    constructor(adapter, details) {
        this.id = details.id;
        this.handshake = details.handshake;
        this.rooms = new Set(details.rooms);
        this.data = details.data;
        this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {
            expectSingleResponse: true, // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()
        });
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * const sockets = await io.fetchSockets();
     *
     * for (const socket of sockets) {
     *   if (someCondition) {
     *     socket.timeout(1000).emit("some-event", (err) => {
     *       if (err) {
     *         // the client did not acknowledge the event in the given delay
     *       }
     *     });
     *   }
     * }
     *
     * // note: if possible, using a room instead of looping over all sockets is preferable
     * io.timeout(1000).to(someConditionRoom).emit("some-event", (err, responses) => {
     *   // ...
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
        return this.operator.timeout(timeout);
    }
    emit(ev, ...args) {
        return this.operator.emit(ev, ...args);
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} room - room or array of rooms
     */
    join(room) {
        return this.operator.socketsJoin(room);
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     */
    leave(room) {
        return this.operator.socketsLeave(room);
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     */
    disconnect(close = false) {
        this.operator.disconnectSockets(close);
        return this;
    }
}
broadcastOperator.RemoteSocket = RemoteSocket;

var __importDefault$2 = (socket && socket.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(socket, "__esModule", { value: true });
socket.Socket = void 0;
const socket_io_parser_1 = parser;
const debug_1$3 = __importDefault$2(require$$13);
const typed_events_1 = typedEvents;
const base64id_1 = __importDefault$2(base64idExports);
const broadcast_operator_1 = broadcastOperator;
const socket_types_1 = socketTypes;
const debug$5 = (0, debug_1$3.default)("socket.io:socket");
const RECOVERABLE_DISCONNECT_REASONS = new Set([
    "transport error",
    "transport close",
    "forced close",
    "ping timeout",
    "server shutting down",
    "forced server close",
]);
function noop() { }
/**
 * This is the main object for interacting with a client.
 *
 * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.
 *
 * Within each {@link Namespace}, you can also define arbitrary channels (called "rooms") that the {@link Socket} can
 * join and leave. That provides a convenient way to broadcast to a group of socket instances.
 *
 * @example
 * io.on("connection", (socket) => {
 *   console.log(`socket ${socket.id} connected`);
 *
 *   // send an event to the client
 *   socket.emit("foo", "bar");
 *
 *   socket.on("foobar", () => {
 *     // an event was received from the client
 *   });
 *
 *   // join the room named "room1"
 *   socket.join("room1");
 *
 *   // broadcast to everyone in the room named "room1"
 *   io.to("room1").emit("hello");
 *
 *   // upon disconnection
 *   socket.on("disconnect", (reason) => {
 *     console.log(`socket ${socket.id} disconnected due to ${reason}`);
 *   });
 * });
 */
let Socket$1 = class Socket extends typed_events_1.StrictEventEmitter {
    /**
     * Interface to a `Client` for a given `Namespace`.
     *
     * @param {Namespace} nsp
     * @param {Client} client
     * @param {Object} auth
     * @package
     */
    constructor(nsp, client, auth, previousSession) {
        super();
        this.nsp = nsp;
        this.client = client;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted to the client, the data attribute and the rooms will be restored.
         */
        this.recovered = false;
        /**
         * Additional information that can be attached to the Socket instance and which will be used in the
         * {@link Server.fetchSockets()} method.
         */
        this.data = {};
        /**
         * Whether the socket is currently connected or not.
         *
         * @example
         * io.use((socket, next) => {
         *   console.log(socket.connected); // false
         *   next();
         * });
         *
         * io.on("connection", (socket) => {
         *   console.log(socket.connected); // true
         * });
         */
        this.connected = false;
        this.acks = new Map();
        this.fns = [];
        this.flags = {};
        this.server = nsp.server;
        this.adapter = this.nsp.adapter;
        if (previousSession) {
            this.id = previousSession.sid;
            this.pid = previousSession.pid;
            previousSession.rooms.forEach((room) => this.join(room));
            this.data = previousSession.data;
            previousSession.missedPackets.forEach((packet) => {
                this.packet({
                    type: socket_io_parser_1.PacketType.EVENT,
                    data: packet,
                });
            });
            this.recovered = true;
        }
        else {
            if (client.conn.protocol === 3) {
                // @ts-ignore
                this.id = nsp.name !== "/" ? nsp.name + "#" + client.id : client.id;
            }
            else {
                this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information
            }
            if (this.server._opts.connectionStateRecovery) {
                this.pid = base64id_1.default.generateId();
            }
        }
        this.handshake = this.buildHandshake(auth);
        // prevents crash when the socket receives an "error" event without listener
        this.on("error", noop);
    }
    /**
     * Builds the `handshake` BC object
     *
     * @private
     */
    buildHandshake(auth) {
        var _a, _b, _c, _d;
        return {
            headers: ((_a = this.request) === null || _a === void 0 ? void 0 : _a.headers) || {},
            time: new Date() + "",
            address: this.conn.remoteAddress,
            xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),
            // @ts-ignore
            secure: !this.request || !!this.request.connection.encrypted,
            issued: +new Date(),
            url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,
            // @ts-ignore
            query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},
            auth,
        };
    }
    /**
     * Emits to this client.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.emit("hello", "world");
     *
     *   // all serializable datastructures are supported (no need to call JSON.stringify)
     *   socket.emit("hello", 1, "2", { 3: ["4"], 5: Buffer.from([6]) });
     *
     *   // with an acknowledgement from the client
     *   socket.emit("hello", "world", (val) => {
     *     // ...
     *   });
     * });
     *
     * @return Always returns `true`.
     */
    emit(ev, ...args) {
        if (socket_types_1.RESERVED_EVENTS.has(ev)) {
            throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        const data = [ev, ...args];
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: data,
        };
        // access last argument to see if it's an ACK callback
        if (typeof data[data.length - 1] === "function") {
            const id = this.nsp._ids++;
            debug$5("emitting packet with ack id %d", id);
            this.registerAckCallback(id, data.pop());
            packet.id = id;
        }
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        // @ts-ignore
        if (this.nsp.server.opts.connectionStateRecovery) {
            // this ensures the packet is stored and can be transmitted upon reconnection
            this.adapter.broadcast(packet, {
                rooms: new Set([this.id]),
                except: new Set(),
                flags,
            });
        }
        else {
            this.notifyOutgoingListeners(packet);
            this.packet(packet, flags);
        }
        return true;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * io.on("connection", async (socket) => {
     *   // without timeout
     *   const response = await socket.emitWithAck("hello", "world");
     *
     *   // with a specific timeout
     *   try {
     *     const response = await socket.timeout(1000).emitWithAck("hello", "world");
     *   } catch (err) {
     *     // the client did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @return a Promise that will be fulfilled when the client acknowledges the event
     */
    emitWithAck(ev, ...args) {
        // the timeout flag is optional
        const withErr = this.flags.timeout !== undefined;
        return new Promise((resolve, reject) => {
            args.push((arg1, arg2) => {
                if (withErr) {
                    return arg1 ? reject(arg1) : resolve(arg2);
                }
                else {
                    return resolve(arg1);
                }
            });
            this.emit(ev, ...args);
        });
    }
    /**
     * @private
     */
    registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === undefined) {
            this.acks.set(id, ack);
            return;
        }
        const timer = setTimeout(() => {
            debug$5("event with ack id %d has timed out after %d ms", id, timeout);
            this.acks.delete(id);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks.set(id, (...args) => {
            clearTimeout(timer);
            ack.apply(this, [null, ...args]);
        });
    }
    /**
     * Targets a room when broadcasting.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // the foo event will be broadcast to all connected clients in the room-101 room, except this socket
     *   socket.to("room-101").emit("foo", "bar");
     *
     *   // the code above is equivalent to:
     *   io.to("room-101").except(socket.id).emit("foo", "bar");
     *
     *   // with an array of rooms (a client will be notified at most once)
     *   socket.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     *   // with multiple chained calls
     *   socket.to("room-101").to("room-102").emit("foo", "bar");
     * });
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
        return this.newBroadcastOperator().to(room);
    }
    /**
     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * io.on("connection", (socket) => {
     *   // disconnect all clients in the "room-101" room, except this socket
     *   socket.in("room-101").disconnectSockets();
     * });
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
        return this.newBroadcastOperator().in(room);
    }
    /**
     * Excludes a room when broadcasting.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     *   // and this socket
     *   socket.except("room-101").emit("foo", "bar");
     *
     *   // with an array of rooms
     *   socket.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     *   // with multiple chained calls
     *   socket.except("room-101").except("room-102").emit("foo", "bar");
     * });
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
        return this.newBroadcastOperator().except(room);
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.send("hello");
     *
     *   // this is equivalent to
     *   socket.emit("message", "hello");
     * });
     *
     * @return self
     */
    send(...args) {
        this.emit("message", ...args);
        return this;
    }
    /**
     * Sends a `message` event. Alias of {@link send}.
     *
     * @return self
     */
    write(...args) {
        this.emit("message", ...args);
        return this;
    }
    /**
     * Writes a packet.
     *
     * @param {Object} packet - packet object
     * @param {Object} opts - options
     * @private
     */
    packet(packet, opts = {}) {
        packet.nsp = this.nsp.name;
        opts.compress = false !== opts.compress;
        this.client._packet(packet, opts);
    }
    /**
     * Joins a room.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // join a single room
     *   socket.join("room1");
     *
     *   // join multiple rooms
     *   socket.join(["room1", "room2"]);
     * });
     *
     * @param {String|Array} rooms - room or array of rooms
     * @return a Promise or nothing, depending on the adapter
     */
    join(rooms) {
        debug$5("join room %s", rooms);
        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
    }
    /**
     * Leaves a room.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // leave a single room
     *   socket.leave("room1");
     *
     *   // leave multiple rooms
     *   socket.leave("room1").leave("room2");
     * });
     *
     * @param {String} room
     * @return a Promise or nothing, depending on the adapter
     */
    leave(room) {
        debug$5("leave room %s", room);
        return this.adapter.del(this.id, room);
    }
    /**
     * Leave all rooms.
     *
     * @private
     */
    leaveAll() {
        this.adapter.delAll(this.id);
    }
    /**
     * Called by `Namespace` upon successful
     * middleware execution (ie: authorization).
     * Socket is added to namespace array before
     * call to join, so adapters can access it.
     *
     * @private
     */
    _onconnect() {
        debug$5("socket connected - writing packet");
        this.connected = true;
        this.join(this.id);
        if (this.conn.protocol === 3) {
            this.packet({ type: socket_io_parser_1.PacketType.CONNECT });
        }
        else {
            this.packet({
                type: socket_io_parser_1.PacketType.CONNECT,
                data: { sid: this.id, pid: this.pid },
            });
        }
    }
    /**
     * Called with each packet. Called by `Client`.
     *
     * @param {Object} packet
     * @private
     */
    _onpacket(packet) {
        debug$5("got packet %j", packet);
        switch (packet.type) {
            case socket_io_parser_1.PacketType.EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
        }
    }
    /**
     * Called upon event packet.
     *
     * @param {Packet} packet - packet object
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        debug$5("emitting event %j", args);
        if (null != packet.id) {
            debug$5("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        this.dispatch(args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @param {Number} id - packet id
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function () {
            // prevent double callbacks
            if (sent)
                return;
            const args = Array.prototype.slice.call(arguments);
            debug$5("sending ack %j", args);
            self.packet({
                id: id,
                type: socket_io_parser_1.PacketType.ACK,
                data: args,
            });
            sent = true;
        };
    }
    /**
     * Called upon ack packet.
     *
     * @private
     */
    onack(packet) {
        const ack = this.acks.get(packet.id);
        if ("function" == typeof ack) {
            debug$5("calling ack %s with %j", packet.id, packet.data);
            ack.apply(this, packet.data);
            this.acks.delete(packet.id);
        }
        else {
            debug$5("bad ack %s", packet.id);
        }
    }
    /**
     * Called upon client disconnect packet.
     *
     * @private
     */
    ondisconnect() {
        debug$5("got disconnect packet");
        this._onclose("client namespace disconnect");
    }
    /**
     * Handles a client error.
     *
     * @private
     */
    _onerror(err) {
        // FIXME the meaning of the "error" event is overloaded:
        //  - it can be sent by the client (`socket.emit("error")`)
        //  - it can be emitted when the connection encounters an error (an invalid packet for example)
        //  - it can be emitted when a packet is rejected in a middleware (`socket.use()`)
        this.emitReserved("error", err);
    }
    /**
     * Called upon closing. Called by `Client`.
     *
     * @param {String} reason
     * @param description
     * @throw {Error} optional error object
     *
     * @private
     */
    _onclose(reason, description) {
        if (!this.connected)
            return this;
        debug$5("closing socket - reason %s", reason);
        this.emitReserved("disconnecting", reason, description);
        if (this.server._opts.connectionStateRecovery &&
            RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
            debug$5("connection state recovery is enabled for sid %s", this.id);
            this.adapter.persistSession({
                sid: this.id,
                pid: this.pid,
                rooms: [...this.rooms],
                data: this.data,
            });
        }
        this._cleanup();
        this.client._remove(this);
        this.connected = false;
        this.emitReserved("disconnect", reason, description);
        return;
    }
    /**
     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room
     *
     * @private
     */
    _cleanup() {
        this.leaveAll();
        this.nsp._remove(this);
        this.join = noop;
    }
    /**
     * Produces an `error` packet.
     *
     * @param {Object} err - error object
     *
     * @private
     */
    _error(err) {
        this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });
    }
    /**
     * Disconnects this client.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // disconnect this socket (the connection might be kept alive for other namespaces)
     *   socket.disconnect();
     *
     *   // disconnect this socket and close the underlying connection
     *   socket.disconnect(true);
     * })
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return self
     */
    disconnect(close = false) {
        if (!this.connected)
            return this;
        if (close) {
            this.client._disconnect();
        }
        else {
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
            this._onclose("server namespace disconnect");
        }
        return this;
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.compress(false).emit("hello");
     * });
     *
     * @param {Boolean} compress - if `true`, compresses the sending data
     * @return {Socket} self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.volatile.emit("hello"); // the client may or may not receive it
     * });
     *
     * @return {Socket} self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the
     * sender.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // the foo event will be broadcast to all connected clients, except this socket
     *   socket.broadcast.emit("foo", "bar");
     * });
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get broadcast() {
        return this.newBroadcastOperator();
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * io.on("connection", (socket) => {
     *   // the foo event will be broadcast to all connected clients on this node, except this socket
     *   socket.local.emit("foo", "bar");
     * });
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
        return this.newBroadcastOperator().local;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the client:
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.timeout(5000).emit("my-event", (err) => {
     *     if (err) {
     *       // the client did not acknowledge the event in the given delay
     *     }
     *   });
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Dispatch incoming event to socket listeners.
     *
     * @param {Array} event - event that will get emitted
     * @private
     */
    dispatch(event) {
        debug$5("dispatching an event %j", event);
        this.run(event, (err) => {
            process.nextTick(() => {
                if (err) {
                    return this._onerror(err);
                }
                if (this.connected) {
                    super.emitUntyped.apply(this, event);
                }
                else {
                    debug$5("ignore packet received after disconnection");
                }
            });
        });
    }
    /**
     * Sets up socket middleware.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.use(([event, ...args], next) => {
     *     if (isUnauthorized(event)) {
     *       return next(new Error("unauthorized event"));
     *     }
     *     // do not forget to call next
     *     next();
     *   });
     *
     *   socket.on("error", (err) => {
     *     if (err && err.message === "unauthorized event") {
     *       socket.disconnect();
     *     }
     *   });
     * });
     *
     * @param {Function} fn - middleware function (event, next)
     * @return {Socket} self
     */
    use(fn) {
        this.fns.push(fn);
        return this;
    }
    /**
     * Executes the middleware for an incoming event.
     *
     * @param {Array} event - event that will get emitted
     * @param {Function} fn - last fn call in the middleware
     * @private
     */
    run(event, fn) {
        if (!this.fns.length)
            return fn();
        const fns = this.fns.slice(0);
        function run(i) {
            fns[i](event, (err) => {
                // upon error, short-circuit
                if (err)
                    return fn(err);
                // if no middleware left, summon callback
                if (!fns[i + 1])
                    return fn();
                // go on to next
                run(i + 1);
            });
        }
        run(0);
    }
    /**
     * Whether the socket is currently disconnected
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * A reference to the request that originated the underlying Engine.IO Socket.
     */
    get request() {
        return this.client.request;
    }
    /**
     * A reference to the underlying Client transport connection (Engine.IO Socket object).
     *
     * @example
     * io.on("connection", (socket) => {
     *   console.log(socket.conn.transport.name); // prints "polling" or "websocket"
     *
     *   socket.conn.once("upgrade", () => {
     *     console.log(socket.conn.transport.name); // prints "websocket"
     *   });
     * });
     */
    get conn() {
        return this.client.conn;
    }
    /**
     * Returns the rooms the socket is currently in.
     *
     * @example
     * io.on("connection", (socket) => {
     *   console.log(socket.rooms); // Set { <socket.id> }
     *
     *   socket.join("room1");
     *
     *   console.log(socket.rooms); // Set { <socket.id>, "room1" }
     * });
     */
    get rooms() {
        return this.adapter.socketRooms(this.id) || new Set();
    }
    /**
     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to
     * the callback.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.onAny((event, ...args) => {
     *     console.log(`got event ${event}`);
     *   });
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to
     * the callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is received.
     *
     * @example
     * io.on("connection", (socket) => {
     *   const catchAllListener = (event, ...args) => {
     *     console.log(`got event ${event}`);
     *   }
     *
     *   socket.onAny(catchAllListener);
     *
     *   // remove a specific listener
     *   socket.offAny(catchAllListener);
     *
     *   // or remove all listeners
     *   socket.offAny();
     * });
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to
     * the callback.
     *
     * Note: acknowledgements sent to the client are not included.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.onAnyOutgoing((event, ...args) => {
     *     console.log(`sent event ${event}`);
     *   });
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * io.on("connection", (socket) => {
     *   socket.prependAnyOutgoing((event, ...args) => {
     *     console.log(`sent event ${event}`);
     *   });
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is sent.
     *
     * @example
     * io.on("connection", (socket) => {
     *   const catchAllListener = (event, ...args) => {
     *     console.log(`sent event ${event}`);
     *   }
     *
     *   socket.onAnyOutgoing(catchAllListener);
     *
     *   // remove a specific listener
     *   socket.offAnyOutgoing(catchAllListener);
     *
     *   // or remove all listeners
     *   socket.offAnyOutgoing();
     * });
     *
     * @param listener - the catch-all listener
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent (emit or broadcast)
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
    newBroadcastOperator() {
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);
    }
};
socket.Socket = Socket$1;

(function (exports$1) {
	var __importDefault = (namespace && namespace.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports$1, "__esModule", { value: true });
	exports$1.Namespace = exports$1.RESERVED_EVENTS = void 0;
	const socket_1 = socket;
	const typed_events_1 = typedEvents;
	const debug_1 = __importDefault(require$$13);
	const broadcast_operator_1 = broadcastOperator;
	const debug = (0, debug_1.default)("socket.io:namespace");
	exports$1.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);
	/**
	 * A Namespace is a communication channel that allows you to split the logic of your application over a single shared
	 * connection.
	 *
	 * Each namespace has its own:
	 *
	 * - event handlers
	 *
	 * ```
	 * io.of("/orders").on("connection", (socket) => {
	 *   socket.on("order:list", () => {});
	 *   socket.on("order:create", () => {});
	 * });
	 *
	 * io.of("/users").on("connection", (socket) => {
	 *   socket.on("user:list", () => {});
	 * });
	 * ```
	 *
	 * - rooms
	 *
	 * ```
	 * const orderNamespace = io.of("/orders");
	 *
	 * orderNamespace.on("connection", (socket) => {
	 *   socket.join("room1");
	 *   orderNamespace.to("room1").emit("hello");
	 * });
	 *
	 * const userNamespace = io.of("/users");
	 *
	 * userNamespace.on("connection", (socket) => {
	 *   socket.join("room1"); // distinct from the room in the "orders" namespace
	 *   userNamespace.to("room1").emit("hol");
	 * });
	 * ```
	 *
	 * - middlewares
	 *
	 * ```
	 * const orderNamespace = io.of("/orders");
	 *
	 * orderNamespace.use((socket, next) => {
	 *   // ensure the socket has access to the "orders" namespace
	 * });
	 *
	 * const userNamespace = io.of("/users");
	 *
	 * userNamespace.use((socket, next) => {
	 *   // ensure the socket has access to the "users" namespace
	 * });
	 * ```
	 */
	class Namespace extends typed_events_1.StrictEventEmitter {
	    /**
	     * Namespace constructor.
	     *
	     * @param server instance
	     * @param name
	     */
	    constructor(server, name) {
	        super();
	        /**
	         * A map of currently connected sockets.
	         */
	        this.sockets = new Map();
	        /**
	         * A map of currently connecting sockets.
	         */
	        this._preConnectSockets = new Map();
	        this._fns = [];
	        /** @private */
	        this._ids = 0;
	        this.server = server;
	        this.name = name;
	        this._initAdapter();
	    }
	    /**
	     * Initializes the `Adapter` for this nsp.
	     * Run upon changing adapter by `Server#adapter`
	     * in addition to the constructor.
	     *
	     * @private
	     */
	    _initAdapter() {
	        // @ts-ignore
	        this.adapter = new (this.server.adapter())(this);
	    }
	    /**
	     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * myNamespace.use((socket, next) => {
	     *   // ...
	     *   next();
	     * });
	     *
	     * @param fn - the middleware function
	     */
	    use(fn) {
	        this._fns.push(fn);
	        return this;
	    }
	    /**
	     * Executes the middleware for an incoming client.
	     *
	     * @param socket - the socket that will get added
	     * @param fn - last fn call in the middleware
	     * @private
	     */
	    run(socket, fn) {
	        if (!this._fns.length)
	            return fn();
	        const fns = this._fns.slice(0);
	        function run(i) {
	            fns[i](socket, (err) => {
	                // upon error, short-circuit
	                if (err)
	                    return fn(err);
	                // if no middleware left, summon callback
	                if (!fns[i + 1])
	                    return fn();
	                // go on to next
	                run(i + 1);
	            });
	        }
	        run(0);
	    }
	    /**
	     * Targets a room when emitting.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // the foo event will be broadcast to all connected clients in the room-101 room
	     * myNamespace.to("room-101").emit("foo", "bar");
	     *
	     * // with an array of rooms (a client will be notified at most once)
	     * myNamespace.to(["room-101", "room-102"]).emit("foo", "bar");
	     *
	     * // with multiple chained calls
	     * myNamespace.to("room-101").to("room-102").emit("foo", "bar");
	     *
	     * @param room - a room, or an array of rooms
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    to(room) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
	    }
	    /**
	     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // disconnect all clients in the "room-101" room
	     * myNamespace.in("room-101").disconnectSockets();
	     *
	     * @param room - a room, or an array of rooms
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    in(room) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
	    }
	    /**
	     * Excludes a room when emitting.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
	     * myNamespace.except("room-101").emit("foo", "bar");
	     *
	     * // with an array of rooms
	     * myNamespace.except(["room-101", "room-102"]).emit("foo", "bar");
	     *
	     * // with multiple chained calls
	     * myNamespace.except("room-101").except("room-102").emit("foo", "bar");
	     *
	     * @param room - a room, or an array of rooms
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    except(room) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
	    }
	    /**
	     * Adds a new client.
	     *
	     * @return {Socket}
	     * @private
	     */
	    async _add(client, auth, fn) {
	        var _a;
	        debug("adding socket to nsp %s", this.name);
	        const socket = await this._createSocket(client, auth);
	        this._preConnectSockets.set(socket.id, socket);
	        if (
	        // @ts-ignore
	        ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) &&
	            socket.recovered &&
	            client.conn.readyState === "open") {
	            return this._doConnect(socket, fn);
	        }
	        this.run(socket, (err) => {
	            process.nextTick(() => {
	                if ("open" !== client.conn.readyState) {
	                    debug("next called after client was closed - ignoring socket");
	                    socket._cleanup();
	                    return;
	                }
	                if (err) {
	                    debug("middleware error, sending CONNECT_ERROR packet to the client");
	                    socket._cleanup();
	                    if (client.conn.protocol === 3) {
	                        return socket._error(err.data || err.message);
	                    }
	                    else {
	                        return socket._error({
	                            message: err.message,
	                            data: err.data,
	                        });
	                    }
	                }
	                this._doConnect(socket, fn);
	            });
	        });
	    }
	    async _createSocket(client, auth) {
	        const sessionId = auth.pid;
	        const offset = auth.offset;
	        if (
	        // @ts-ignore
	        this.server.opts.connectionStateRecovery &&
	            typeof sessionId === "string" &&
	            typeof offset === "string") {
	            let session;
	            try {
	                session = await this.adapter.restoreSession(sessionId, offset);
	            }
	            catch (e) {
	                debug("error while restoring session: %s", e);
	            }
	            if (session) {
	                debug("connection state recovered for sid %s", session.sid);
	                return new socket_1.Socket(this, client, auth, session);
	            }
	        }
	        return new socket_1.Socket(this, client, auth);
	    }
	    _doConnect(socket, fn) {
	        this._preConnectSockets.delete(socket.id);
	        this.sockets.set(socket.id, socket);
	        // it's paramount that the internal `onconnect` logic
	        // fires before user-set events to prevent state order
	        // violations (such as a disconnection before the connection
	        // logic is complete)
	        socket._onconnect();
	        if (fn)
	            fn(socket);
	        // fire user-set events
	        this.emitReserved("connect", socket);
	        this.emitReserved("connection", socket);
	    }
	    /**
	     * Removes a client. Called by each `Socket`.
	     *
	     * @private
	     */
	    _remove(socket) {
	        this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);
	    }
	    /**
	     * Emits to all connected clients.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * myNamespace.emit("hello", "world");
	     *
	     * // all serializable datastructures are supported (no need to call JSON.stringify)
	     * myNamespace.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
	     *
	     * // with an acknowledgement from the clients
	     * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
	     *   if (err) {
	     *     // some clients did not acknowledge the event in the given delay
	     *   } else {
	     *     console.log(responses); // one response per client
	     *   }
	     * });
	     *
	     * @return Always true
	     */
	    emit(ev, ...args) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
	    }
	    /**
	     * Sends a `message` event to all clients.
	     *
	     * This method mimics the WebSocket.send() method.
	     *
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * myNamespace.send("hello");
	     *
	     * // this is equivalent to
	     * myNamespace.emit("message", "hello");
	     *
	     * @return self
	     */
	    send(...args) {
	        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
	        // if you specify the EmitEvents, the type of args will be never.
	        this.emit("message", ...args);
	        return this;
	    }
	    /**
	     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.
	     *
	     * @return self
	     */
	    write(...args) {
	        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
	        // if you specify the EmitEvents, the type of args will be never.
	        this.emit("message", ...args);
	        return this;
	    }
	    /**
	     * Sends a message to the other Socket.IO servers of the cluster.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * myNamespace.serverSideEmit("hello", "world");
	     *
	     * myNamespace.on("hello", (arg1) => {
	     *   console.log(arg1); // prints "world"
	     * });
	     *
	     * // acknowledgements (without binary content) are supported too:
	     * myNamespace.serverSideEmit("ping", (err, responses) => {
	     *  if (err) {
	     *     // some servers did not acknowledge the event in the given delay
	     *   } else {
	     *     console.log(responses); // one response per server (except the current one)
	     *   }
	     * });
	     *
	     * myNamespace.on("ping", (cb) => {
	     *   cb("pong");
	     * });
	     *
	     * @param ev - the event name
	     * @param args - an array of arguments, which may include an acknowledgement callback at the end
	     */
	    serverSideEmit(ev, ...args) {
	        if (exports$1.RESERVED_EVENTS.has(ev)) {
	            throw new Error(`"${String(ev)}" is a reserved event name`);
	        }
	        args.unshift(ev);
	        this.adapter.serverSideEmit(args);
	        return true;
	    }
	    /**
	     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * try {
	     *   const responses = await myNamespace.serverSideEmitWithAck("ping");
	     *   console.log(responses); // one response per server (except the current one)
	     * } catch (e) {
	     *   // some servers did not acknowledge the event in the given delay
	     * }
	     *
	     * @param ev - the event name
	     * @param args - an array of arguments
	     *
	     * @return a Promise that will be fulfilled when all servers have acknowledged the event
	     */
	    serverSideEmitWithAck(ev, ...args) {
	        return new Promise((resolve, reject) => {
	            args.push((err, responses) => {
	                if (err) {
	                    err.responses = responses;
	                    return reject(err);
	                }
	                else {
	                    return resolve(responses);
	                }
	            });
	            this.serverSideEmit(ev, ...args);
	        });
	    }
	    /**
	     * Called when a packet is received from another Socket.IO server
	     *
	     * @param args - an array of arguments, which may include an acknowledgement callback at the end
	     *
	     * @private
	     */
	    _onServerSideEmit(args) {
	        super.emitUntyped.apply(this, args);
	    }
	    /**
	     * Gets a list of clients.
	     *
	     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or
	     * {@link Namespace#fetchSockets} instead.
	     */
	    allSockets() {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
	    }
	    /**
	     * Sets the compress flag.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * myNamespace.compress(false).emit("hello");
	     *
	     * @param compress - if `true`, compresses the sending data
	     * @return self
	     */
	    compress(compress) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
	     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
	     * and is in the middle of a request-response cycle).
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * myNamespace.volatile.emit("hello"); // the clients may or may not receive it
	     *
	     * @return self
	     */
	    get volatile() {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // the foo event will be broadcast to all connected clients on this node
	     * myNamespace.local.emit("foo", "bar");
	     *
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    get local() {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
	    }
	    /**
	     * Adds a timeout in milliseconds for the next operation.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
	     *   if (err) {
	     *     // some clients did not acknowledge the event in the given delay
	     *   } else {
	     *     console.log(responses); // one response per client
	     *   }
	     * });
	     *
	     * @param timeout
	     */
	    timeout(timeout) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
	    }
	    /**
	     * Returns the matching socket instances.
	     *
	     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // return all Socket instances
	     * const sockets = await myNamespace.fetchSockets();
	     *
	     * // return all Socket instances in the "room1" room
	     * const sockets = await myNamespace.in("room1").fetchSockets();
	     *
	     * for (const socket of sockets) {
	     *   console.log(socket.id);
	     *   console.log(socket.handshake);
	     *   console.log(socket.rooms);
	     *   console.log(socket.data);
	     *
	     *   socket.emit("hello");
	     *   socket.join("room1");
	     *   socket.leave("room2");
	     *   socket.disconnect();
	     * }
	     */
	    fetchSockets() {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
	    }
	    /**
	     * Makes the matching socket instances join the specified rooms.
	     *
	     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // make all socket instances join the "room1" room
	     * myNamespace.socketsJoin("room1");
	     *
	     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
	     * myNamespace.in("room1").socketsJoin(["room2", "room3"]);
	     *
	     * @param room - a room, or an array of rooms
	     */
	    socketsJoin(room) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
	    }
	    /**
	     * Makes the matching socket instances leave the specified rooms.
	     *
	     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // make all socket instances leave the "room1" room
	     * myNamespace.socketsLeave("room1");
	     *
	     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
	     * myNamespace.in("room1").socketsLeave(["room2", "room3"]);
	     *
	     * @param room - a room, or an array of rooms
	     */
	    socketsLeave(room) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
	    }
	    /**
	     * Makes the matching socket instances disconnect.
	     *
	     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
	     *
	     * @example
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
	     * myNamespace.disconnectSockets();
	     *
	     * // make all socket instances in the "room1" room disconnect and close the underlying connections
	     * myNamespace.in("room1").disconnectSockets(true);
	     *
	     * @param close - whether to close the underlying connection
	     */
	    disconnectSockets(close = false) {
	        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
	    }
	}
	exports$1.Namespace = Namespace; 
} (namespace));

var parentNamespace = {};

var dist$1 = {};

var inMemoryAdapter = {};

var yeast$1 = {};

Object.defineProperty(yeast$1, "__esModule", { value: true });
yeast$1.yeast = yeast$1.decode = yeast$1.encode = void 0;
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i$1 = 0, prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
    let encoded = "";
    do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
}
yeast$1.encode = encode;
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode$3(str) {
    let decoded = 0;
    for (i$1 = 0; i$1 < str.length; i$1++) {
        decoded = decoded * length + map[str.charAt(i$1)];
    }
    return decoded;
}
yeast$1.decode = decode$3;
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
    const now = encode(+new Date());
    if (now !== prev)
        return (seed = 0), (prev = now);
    return now + "." + encode(seed++);
}
yeast$1.yeast = yeast;
//
// Map each character to its index.
//
for (; i$1 < length; i$1++)
    map[alphabet[i$1]] = i$1;

const { Duplex: Duplex$3 } = require$$2$2;

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose$1(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex$3({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose$1, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose$1, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

var stream = createWebSocketStream;

const stream_default = /*@__PURE__*/getDefaultExportFromCjs(stream);

var bufferUtil$1 = {exports: {}};

var constants$2 = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};

var unmask$1;
var mask;

const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants$2;

const FastBuffer$2 = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat$1(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER$3;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer$2(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer$2(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer$2(data) {
  toBuffer$2.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer$2(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer$2.readOnly = false;
  }

  return buf;
}

bufferUtil$1.exports = {
  concat: concat$1,
  mask: _mask,
  toArrayBuffer: toArrayBuffer$2,
  toBuffer: toBuffer$2,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = require$$1$5;

    mask = bufferUtil$1.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    unmask$1 = bufferUtil$1.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}

var bufferUtilExports = bufferUtil$1.exports;

const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
let Limiter$1 = class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
};

var limiter = Limiter$1;

const zlib = require$$0$5;

const bufferUtil = bufferUtilExports;
const Limiter = limiter;
const { kStatusCode: kStatusCode$2 } = constants$2;

const FastBuffer$1 = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError$1 = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
let PerMessageDeflate$4 = class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError$1];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer$1(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
};

var permessageDeflate = PerMessageDeflate$4;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError$1] = new RangeError('Max payload size exceeded');
  this[kError$1].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode$2] = 1007;
  this[kCallback](err);
}

var validation = {exports: {}};

var isValidUTF8_1;

const { isUtf8 } = require$$0$3;

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars$2 = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode$2(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

validation.exports = {
  isValidStatusCode: isValidStatusCode$2,
  isValidUTF8: _isValidUTF8,
  tokenChars: tokenChars$2
};

if (isUtf8) {
  isValidUTF8_1 = validation.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = require$$1$4;

    isValidUTF8_1 = validation.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}

var validationExports = validation.exports;

const { Writable } = require$$2$2;

const PerMessageDeflate$3 = permessageDeflate;
const {
  BINARY_TYPES: BINARY_TYPES$1,
  EMPTY_BUFFER: EMPTY_BUFFER$2,
  kStatusCode: kStatusCode$1,
  kWebSocket: kWebSocket$2
} = constants$2;
const { concat, toArrayBuffer: toArrayBuffer$1, unmask } = bufferUtilExports;
const { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
let Receiver$1 = class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES$1[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket$2] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER$2;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer$1(concat(fragments, messageLength));
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER$2);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode$1(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode$1] = statusCode;
    return err;
  }
};

var receiver = Receiver$1;

const receiver_default = /*@__PURE__*/getDefaultExportFromCjs(receiver);

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

const { Duplex: Duplex$2 } = require$$2$2;
const { randomFillSync } = require$$3$3;

const PerMessageDeflate$2 = permessageDeflate;
const { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants$2;
const { isValidStatusCode } = validationExports;
const { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

/**
 * HyBi Sender implementation.
 */
let Sender$1 = class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER$1;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const params = this._queue[i];
          const callback = params[params.length - 1];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
};

var sender = Sender$1;

const sender_default = /*@__PURE__*/getDefaultExportFromCjs(sender);

const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants$2;

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute$1] &&
        listener[kListener$1] === handler &&
        !listener[kForOnEventAttribute$1]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];
    wrapper[kListener$1] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

var eventTarget = {
  EventTarget};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}

const { tokenChars: tokenChars$1 } = validationExports;

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse$b(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format$1(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

var extension$1 = { format: format$1, parse: parse$b };

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

const EventEmitter$7 = require$$0$6;
const https = require$$1$3;
const http$1 = require$$1$6;
const net = require$$3$2;
const tls = require$$4$1;
const { randomBytes, createHash: createHash$1 } = require$$3$3;
const { Duplex: Duplex$1, Readable: Readable$2 } = require$$2$2;
const { URL: URL$2 } = require$$7$2;

const PerMessageDeflate$1 = permessageDeflate;
const Receiver = receiver;
const Sender = sender;
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID: GUID$1,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket: kWebSocket$1,
  NOOP
} = constants$2;
const {
  EventTarget: { addEventListener, removeEventListener }
} = eventTarget;
const { format, parse: parse$a } = extension$1;
const { toBuffer } = bufferUtilExports;

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
let WebSocket$2 = class WebSocket extends EventEmitter$7 {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    this._sender = new Sender(socket, this._extensions, options.generateMask);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket$1] = this;
    socket[kWebSocket$1] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError$1);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate$1.extensionName]) {
      this._extensions[PerMessageDeflate$1.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake$1(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate$1.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake$1(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
};

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$2, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$2.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$2, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$2.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$2, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$2.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$2, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$2.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket$2.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket$2.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket$2.prototype.addEventListener = addEventListener;
WebSocket$2.prototype.removeEventListener = removeEventListener;

var websocket = WebSocket$2;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL$2) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL$2(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http$1.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake$1(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL$2(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake$1(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket$2.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake$1(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash$1('sha1')
      .update(key + GUID$1)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake$1(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake$1(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake$1(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse$a(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake$1(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate$1.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake$1(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake$1(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate$1.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket$2.CLOSING;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake$1(websocket, stream, message) {
  websocket._readyState = WebSocket$2.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake$1);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket$1];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket$1] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket$1];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket$1];

  if (websocket._socket[kWebSocket$1] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  websocket.emit('error', err);
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket$1].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket$1];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket$1].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket$1];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket$2.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket$1] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket$1];

  websocket._readyState = WebSocket$2.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError$1() {
  const websocket = this[kWebSocket$1];

  this.removeListener('error', socketOnError$1);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket$2.CLOSING;
    this.destroy();
  }
}

const WebSocket$3 = /*@__PURE__*/getDefaultExportFromCjs(websocket);

const { tokenChars } = validationExports;

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse$9(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

var subprotocol$1 = { parse: parse$9 };

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

const EventEmitter$6 = require$$0$6;
const http = require$$1$6;
const { Duplex } = require$$2$2;
const { createHash } = require$$3$3;

const extension = extension$1;
const PerMessageDeflate = permessageDeflate;
const subprotocol = subprotocol$1;
const WebSocket$1 = websocket;
const { GUID, kWebSocket } = constants$2;

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter$6 {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket: WebSocket$1,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

var websocketServer = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}

const websocketServer_default = /*@__PURE__*/getDefaultExportFromCjs(websocketServer);

const wrapper = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Receiver: receiver_default,
  Sender: sender_default,
  WebSocket: WebSocket$3,
  WebSocketServer: websocketServer_default,
  createWebSocketStream: stream_default,
  default: WebSocket$3
}, Symbol.toStringTag, { value: 'Module' }));

const require$$2$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(wrapper);

var _a;
Object.defineProperty(inMemoryAdapter, "__esModule", { value: true });
inMemoryAdapter.SessionAwareAdapter = inMemoryAdapter.Adapter = void 0;
const events_1 = require$$0$6;
const yeast_1 = yeast$1;
const WebSocket = require$$2$1;
const canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === "function";
class Adapter extends events_1.EventEmitter {
    /**
     * In-memory adapter constructor.
     *
     * @param {Namespace} nsp
     */
    constructor(nsp) {
        super();
        this.nsp = nsp;
        this.rooms = new Map();
        this.sids = new Map();
        this.encoder = nsp.server.encoder;
    }
    /**
     * To be overridden
     */
    init() { }
    /**
     * To be overridden
     */
    close() { }
    /**
     * Returns the number of Socket.IO servers in the cluster
     *
     * @public
     */
    serverCount() {
        return Promise.resolve(1);
    }
    /**
     * Adds a socket to a list of room.
     *
     * @param {SocketId}  id      the socket id
     * @param {Set<Room>} rooms   a set of rooms
     * @public
     */
    addAll(id, rooms) {
        if (!this.sids.has(id)) {
            this.sids.set(id, new Set());
        }
        for (const room of rooms) {
            this.sids.get(id).add(room);
            if (!this.rooms.has(room)) {
                this.rooms.set(room, new Set());
                this.emit("create-room", room);
            }
            if (!this.rooms.get(room).has(id)) {
                this.rooms.get(room).add(id);
                this.emit("join-room", room, id);
            }
        }
    }
    /**
     * Removes a socket from a room.
     *
     * @param {SocketId} id     the socket id
     * @param {Room}     room   the room name
     */
    del(id, room) {
        if (this.sids.has(id)) {
            this.sids.get(id).delete(room);
        }
        this._del(room, id);
    }
    _del(room, id) {
        const _room = this.rooms.get(room);
        if (_room != null) {
            const deleted = _room.delete(id);
            if (deleted) {
                this.emit("leave-room", room, id);
            }
            if (_room.size === 0 && this.rooms.delete(room)) {
                this.emit("delete-room", room);
            }
        }
    }
    /**
     * Removes a socket from all rooms it's joined.
     *
     * @param {SocketId} id   the socket id
     */
    delAll(id) {
        if (!this.sids.has(id)) {
            return;
        }
        for (const room of this.sids.get(id)) {
            this._del(room, id);
        }
        this.sids.delete(id);
    }
    /**
     * Broadcasts a packet.
     *
     * Options:
     *  - `flags` {Object} flags for this packet
     *  - `except` {Array} sids that should be excluded
     *  - `rooms` {Array} list of rooms to broadcast to
     *
     * @param {Object} packet   the packet object
     * @param {Object} opts     the options
     * @public
     */
    broadcast(packet, opts) {
        const flags = opts.flags || {};
        const packetOpts = {
            preEncoded: true,
            volatile: flags.volatile,
            compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        const encodedPackets = this._encode(packet, packetOpts);
        this.apply(opts, (socket) => {
            if (typeof socket.notifyOutgoingListeners === "function") {
                socket.notifyOutgoingListeners(packet);
            }
            socket.client.writeToEngine(encodedPackets, packetOpts);
        });
    }
    /**
     * Broadcasts a packet and expects multiple acknowledgements.
     *
     * Options:
     *  - `flags` {Object} flags for this packet
     *  - `except` {Array} sids that should be excluded
     *  - `rooms` {Array} list of rooms to broadcast to
     *
     * @param {Object} packet   the packet object
     * @param {Object} opts     the options
     * @param clientCountCallback - the number of clients that received the packet
     * @param ack                 - the callback that will be called for each client response
     *
     * @public
     */
    broadcastWithAck(packet, opts, clientCountCallback, ack) {
        const flags = opts.flags || {};
        const packetOpts = {
            preEncoded: true,
            volatile: flags.volatile,
            compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        // we can use the same id for each packet, since the _ids counter is common (no duplicate)
        packet.id = this.nsp._ids++;
        const encodedPackets = this._encode(packet, packetOpts);
        let clientCount = 0;
        this.apply(opts, (socket) => {
            // track the total number of acknowledgements that are expected
            clientCount++;
            // call the ack callback for each client response
            socket.acks.set(packet.id, ack);
            if (typeof socket.notifyOutgoingListeners === "function") {
                socket.notifyOutgoingListeners(packet);
            }
            socket.client.writeToEngine(encodedPackets, packetOpts);
        });
        clientCountCallback(clientCount);
    }
    _encode(packet, packetOpts) {
        const encodedPackets = this.encoder.encode(packet);
        if (canPreComputeFrame &&
            encodedPackets.length === 1 &&
            typeof encodedPackets[0] === "string") {
            // "4" being the "message" packet type in the Engine.IO protocol
            const data = Buffer.from("4" + encodedPackets[0]);
            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469
            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {
                readOnly: false,
                mask: false,
                rsv1: false,
                opcode: 1,
                fin: true,
            });
        }
        return encodedPackets;
    }
    /**
     * Gets a list of sockets by sid.
     *
     * @param {Set<Room>} rooms   the explicit set of rooms to check.
     */
    sockets(rooms) {
        const sids = new Set();
        this.apply({ rooms }, (socket) => {
            sids.add(socket.id);
        });
        return Promise.resolve(sids);
    }
    /**
     * Gets the list of rooms a given socket has joined.
     *
     * @param {SocketId} id   the socket id
     */
    socketRooms(id) {
        return this.sids.get(id);
    }
    /**
     * Returns the matching socket instances
     *
     * @param opts - the filters to apply
     */
    fetchSockets(opts) {
        const sockets = [];
        this.apply(opts, (socket) => {
            sockets.push(socket);
        });
        return Promise.resolve(sockets);
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to join
     */
    addSockets(opts, rooms) {
        this.apply(opts, (socket) => {
            socket.join(rooms);
        });
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to leave
     */
    delSockets(opts, rooms) {
        this.apply(opts, (socket) => {
            rooms.forEach((room) => socket.leave(room));
        });
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param opts - the filters to apply
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(opts, close) {
        this.apply(opts, (socket) => {
            socket.disconnect(close);
        });
    }
    apply(opts, callback) {
        const rooms = opts.rooms;
        const except = this.computeExceptSids(opts.except);
        if (rooms.size) {
            const ids = new Set();
            for (const room of rooms) {
                if (!this.rooms.has(room))
                    continue;
                for (const id of this.rooms.get(room)) {
                    if (ids.has(id) || except.has(id))
                        continue;
                    const socket = this.nsp.sockets.get(id);
                    if (socket) {
                        callback(socket);
                        ids.add(id);
                    }
                }
            }
        }
        else {
            for (const [id] of this.sids) {
                if (except.has(id))
                    continue;
                const socket = this.nsp.sockets.get(id);
                if (socket)
                    callback(socket);
            }
        }
    }
    computeExceptSids(exceptRooms) {
        const exceptSids = new Set();
        if (exceptRooms && exceptRooms.size > 0) {
            for (const room of exceptRooms) {
                if (this.rooms.has(room)) {
                    this.rooms.get(room).forEach((sid) => exceptSids.add(sid));
                }
            }
        }
        return exceptSids;
    }
    /**
     * Send a packet to the other Socket.IO servers in the cluster
     * @param packet - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(packet) {
        console.warn("this adapter does not support the serverSideEmit() functionality");
    }
    /**
     * Save the client session in order to restore it upon reconnection.
     */
    persistSession(session) { }
    /**
     * Restore the session and find the packets that were missed by the client.
     * @param pid
     * @param offset
     */
    restoreSession(pid, offset) {
        return null;
    }
}
inMemoryAdapter.Adapter = Adapter;
class SessionAwareAdapter extends Adapter {
    constructor(nsp) {
        super(nsp);
        this.nsp = nsp;
        this.sessions = new Map();
        this.packets = [];
        this.maxDisconnectionDuration =
            nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
        const timer = setInterval(() => {
            const threshold = Date.now() - this.maxDisconnectionDuration;
            this.sessions.forEach((session, sessionId) => {
                const hasExpired = session.disconnectedAt < threshold;
                if (hasExpired) {
                    this.sessions.delete(sessionId);
                }
            });
            for (let i = this.packets.length - 1; i >= 0; i--) {
                const hasExpired = this.packets[i].emittedAt < threshold;
                if (hasExpired) {
                    this.packets.splice(0, i + 1);
                    break;
                }
            }
        }, 60 * 1000);
        // prevents the timer from keeping the process alive
        timer.unref();
    }
    persistSession(session) {
        session.disconnectedAt = Date.now();
        this.sessions.set(session.pid, session);
    }
    restoreSession(pid, offset) {
        const session = this.sessions.get(pid);
        if (!session) {
            // the session may have expired
            return null;
        }
        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
        if (hasExpired) {
            // the session has expired
            this.sessions.delete(pid);
            return null;
        }
        const index = this.packets.findIndex((packet) => packet.id === offset);
        if (index === -1) {
            // the offset may be too old
            return null;
        }
        const missedPackets = [];
        for (let i = index + 1; i < this.packets.length; i++) {
            const packet = this.packets[i];
            if (shouldIncludePacket(session.rooms, packet.opts)) {
                missedPackets.push(packet.data);
            }
        }
        return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));
    }
    broadcast(packet, opts) {
        var _a;
        const isEventPacket = packet.type === 2;
        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and
        // restored on another server upon reconnection
        const withoutAcknowledgement = packet.id === undefined;
        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;
        if (isEventPacket && withoutAcknowledgement && notVolatile) {
            const id = (0, yeast_1.yeast)();
            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has
            // processed (and the format is backward-compatible)
            packet.data.push(id);
            this.packets.push({
                id,
                opts,
                data: packet.data,
                emittedAt: Date.now(),
            });
        }
        super.broadcast(packet, opts);
    }
}
inMemoryAdapter.SessionAwareAdapter = SessionAwareAdapter;
function shouldIncludePacket(sessionRooms, opts) {
    const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));
    const notExcluded = sessionRooms.every((room) => !opts.except.has(room));
    return included && notExcluded;
}

var clusterAdapter = {};

(function (exports$1) {
	var __rest = (clusterAdapter && clusterAdapter.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	Object.defineProperty(exports$1, "__esModule", { value: true });
	exports$1.ClusterAdapterWithHeartbeat = exports$1.ClusterAdapter = exports$1.MessageType = void 0;
	const in_memory_adapter_1 = inMemoryAdapter;
	const debug_1 = require$$13;
	const crypto_1 = require$$3$3;
	const debug = (0, debug_1.debug)("socket.io-adapter");
	const EMITTER_UID = "emitter";
	const DEFAULT_TIMEOUT = 5000;
	function randomId() {
	    return (0, crypto_1.randomBytes)(8).toString("hex");
	}
	var MessageType;
	(function (MessageType) {
	    MessageType[MessageType["INITIAL_HEARTBEAT"] = 1] = "INITIAL_HEARTBEAT";
	    MessageType[MessageType["HEARTBEAT"] = 2] = "HEARTBEAT";
	    MessageType[MessageType["BROADCAST"] = 3] = "BROADCAST";
	    MessageType[MessageType["SOCKETS_JOIN"] = 4] = "SOCKETS_JOIN";
	    MessageType[MessageType["SOCKETS_LEAVE"] = 5] = "SOCKETS_LEAVE";
	    MessageType[MessageType["DISCONNECT_SOCKETS"] = 6] = "DISCONNECT_SOCKETS";
	    MessageType[MessageType["FETCH_SOCKETS"] = 7] = "FETCH_SOCKETS";
	    MessageType[MessageType["FETCH_SOCKETS_RESPONSE"] = 8] = "FETCH_SOCKETS_RESPONSE";
	    MessageType[MessageType["SERVER_SIDE_EMIT"] = 9] = "SERVER_SIDE_EMIT";
	    MessageType[MessageType["SERVER_SIDE_EMIT_RESPONSE"] = 10] = "SERVER_SIDE_EMIT_RESPONSE";
	    MessageType[MessageType["BROADCAST_CLIENT_COUNT"] = 11] = "BROADCAST_CLIENT_COUNT";
	    MessageType[MessageType["BROADCAST_ACK"] = 12] = "BROADCAST_ACK";
	    MessageType[MessageType["ADAPTER_CLOSE"] = 13] = "ADAPTER_CLOSE";
	})(MessageType = exports$1.MessageType || (exports$1.MessageType = {}));
	function encodeOptions(opts) {
	    return {
	        rooms: [...opts.rooms],
	        except: [...opts.except],
	        flags: opts.flags,
	    };
	}
	function decodeOptions(opts) {
	    return {
	        rooms: new Set(opts.rooms),
	        except: new Set(opts.except),
	        flags: opts.flags,
	    };
	}
	/**
	 * A cluster-ready adapter. Any extending class must:
	 *
	 * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}
	 * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}
	 */
	class ClusterAdapter extends in_memory_adapter_1.Adapter {
	    constructor(nsp) {
	        super(nsp);
	        this.requests = new Map();
	        this.ackRequests = new Map();
	        this.uid = randomId();
	    }
	    /**
	     * Called when receiving a message from another member of the cluster.
	     *
	     * @param message
	     * @param offset
	     * @protected
	     */
	    onMessage(message, offset) {
	        if (message.uid === this.uid) {
	            return debug("[%s] ignore message from self", this.uid);
	        }
	        debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
	        switch (message.type) {
	            case MessageType.BROADCAST: {
	                const withAck = message.data.requestId !== undefined;
	                if (withAck) {
	                    super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount) => {
	                        debug("[%s] waiting for %d client acknowledgements", this.uid, clientCount);
	                        this.publishResponse(message.uid, {
	                            type: MessageType.BROADCAST_CLIENT_COUNT,
	                            data: {
	                                requestId: message.data.requestId,
	                                clientCount,
	                            },
	                        });
	                    }, (arg) => {
	                        debug("[%s] received acknowledgement with value %j", this.uid, arg);
	                        this.publishResponse(message.uid, {
	                            type: MessageType.BROADCAST_ACK,
	                            data: {
	                                requestId: message.data.requestId,
	                                packet: arg,
	                            },
	                        });
	                    });
	                }
	                else {
	                    const packet = message.data.packet;
	                    const opts = decodeOptions(message.data.opts);
	                    this.addOffsetIfNecessary(packet, opts, offset);
	                    super.broadcast(packet, opts);
	                }
	                break;
	            }
	            case MessageType.SOCKETS_JOIN:
	                super.addSockets(decodeOptions(message.data.opts), message.data.rooms);
	                break;
	            case MessageType.SOCKETS_LEAVE:
	                super.delSockets(decodeOptions(message.data.opts), message.data.rooms);
	                break;
	            case MessageType.DISCONNECT_SOCKETS:
	                super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);
	                break;
	            case MessageType.FETCH_SOCKETS: {
	                debug("[%s] calling fetchSockets with opts %j", this.uid, message.data.opts);
	                super
	                    .fetchSockets(decodeOptions(message.data.opts))
	                    .then((localSockets) => {
	                    this.publishResponse(message.uid, {
	                        type: MessageType.FETCH_SOCKETS_RESPONSE,
	                        data: {
	                            requestId: message.data.requestId,
	                            sockets: localSockets.map((socket) => {
	                                // remove sessionStore from handshake, as it may contain circular references
	                                const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, ["sessionStore"]);
	                                return {
	                                    id: socket.id,
	                                    handshake,
	                                    rooms: [...socket.rooms],
	                                    data: socket.data,
	                                };
	                            }),
	                        },
	                    });
	                });
	                break;
	            }
	            case MessageType.SERVER_SIDE_EMIT: {
	                const packet = message.data.packet;
	                const withAck = message.data.requestId !== undefined;
	                if (!withAck) {
	                    this.nsp._onServerSideEmit(packet);
	                    return;
	                }
	                let called = false;
	                const callback = (arg) => {
	                    // only one argument is expected
	                    if (called) {
	                        return;
	                    }
	                    called = true;
	                    debug("[%s] calling acknowledgement with %j", this.uid, arg);
	                    this.publishResponse(message.uid, {
	                        type: MessageType.SERVER_SIDE_EMIT_RESPONSE,
	                        data: {
	                            requestId: message.data.requestId,
	                            packet: arg,
	                        },
	                    });
	                };
	                this.nsp._onServerSideEmit([...packet, callback]);
	                break;
	            }
	            // @ts-ignore
	            case MessageType.BROADCAST_CLIENT_COUNT:
	            // @ts-ignore
	            case MessageType.BROADCAST_ACK:
	            // @ts-ignore
	            case MessageType.FETCH_SOCKETS_RESPONSE:
	            // @ts-ignore
	            case MessageType.SERVER_SIDE_EMIT_RESPONSE:
	                // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may
	                // always call the onMessage() method
	                this.onResponse(message);
	                break;
	            default:
	                debug("[%s] unknown message type: %s", this.uid, message.type);
	        }
	    }
	    /**
	     * Called when receiving a response from another member of the cluster.
	     *
	     * @param response
	     * @protected
	     */
	    onResponse(response) {
	        var _a, _b;
	        const requestId = response.data.requestId;
	        debug("[%s] received response %s to request %s", this.uid, response.type, requestId);
	        switch (response.type) {
	            case MessageType.BROADCAST_CLIENT_COUNT: {
	                (_a = this.ackRequests
	                    .get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);
	                break;
	            }
	            case MessageType.BROADCAST_ACK: {
	                (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);
	                break;
	            }
	            case MessageType.FETCH_SOCKETS_RESPONSE: {
	                const request = this.requests.get(requestId);
	                if (!request) {
	                    return;
	                }
	                request.current++;
	                response.data.sockets.forEach((socket) => request.responses.push(socket));
	                if (request.current === request.expected) {
	                    clearTimeout(request.timeout);
	                    request.resolve(request.responses);
	                    this.requests.delete(requestId);
	                }
	                break;
	            }
	            case MessageType.SERVER_SIDE_EMIT_RESPONSE: {
	                const request = this.requests.get(requestId);
	                if (!request) {
	                    return;
	                }
	                request.current++;
	                request.responses.push(response.data.packet);
	                if (request.current === request.expected) {
	                    clearTimeout(request.timeout);
	                    request.resolve(null, request.responses);
	                    this.requests.delete(requestId);
	                }
	                break;
	            }
	            default:
	                // @ts-ignore
	                debug("[%s] unknown response type: %s", this.uid, response.type);
	        }
	    }
	    async broadcast(packet, opts) {
	        var _a;
	        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
	        if (!onlyLocal) {
	            try {
	                const offset = await this.publishAndReturnOffset({
	                    type: MessageType.BROADCAST,
	                    data: {
	                        packet,
	                        opts: encodeOptions(opts),
	                    },
	                });
	                this.addOffsetIfNecessary(packet, opts, offset);
	            }
	            catch (e) {
	                return debug("[%s] error while broadcasting message: %s", this.uid, e.message);
	            }
	        }
	        super.broadcast(packet, opts);
	    }
	    /**
	     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it
	     * reconnects after a temporary disconnection.
	     *
	     * @param packet
	     * @param opts
	     * @param offset
	     * @private
	     */
	    addOffsetIfNecessary(packet, opts, offset) {
	        var _a;
	        if (!this.nsp.server.opts.connectionStateRecovery) {
	            return;
	        }
	        const isEventPacket = packet.type === 2;
	        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and
	        // restored on another server upon reconnection
	        const withoutAcknowledgement = packet.id === undefined;
	        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;
	        if (isEventPacket && withoutAcknowledgement && notVolatile) {
	            packet.data.push(offset);
	        }
	    }
	    broadcastWithAck(packet, opts, clientCountCallback, ack) {
	        var _a;
	        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;
	        if (!onlyLocal) {
	            const requestId = randomId();
	            this.ackRequests.set(requestId, {
	                clientCountCallback,
	                ack,
	            });
	            this.publish({
	                type: MessageType.BROADCAST,
	                data: {
	                    packet,
	                    requestId,
	                    opts: encodeOptions(opts),
	                },
	            });
	            // we have no way to know at this level whether the server has received an acknowledgement from each client, so we
	            // will simply clean up the ackRequests map after the given delay
	            setTimeout(() => {
	                this.ackRequests.delete(requestId);
	            }, opts.flags.timeout);
	        }
	        super.broadcastWithAck(packet, opts, clientCountCallback, ack);
	    }
	    async addSockets(opts, rooms) {
	        var _a;
	        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
	        if (!onlyLocal) {
	            try {
	                await this.publishAndReturnOffset({
	                    type: MessageType.SOCKETS_JOIN,
	                    data: {
	                        opts: encodeOptions(opts),
	                        rooms,
	                    },
	                });
	            }
	            catch (e) {
	                debug("[%s] error while publishing message: %s", this.uid, e.message);
	            }
	        }
	        super.addSockets(opts, rooms);
	    }
	    async delSockets(opts, rooms) {
	        var _a;
	        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
	        if (!onlyLocal) {
	            try {
	                await this.publishAndReturnOffset({
	                    type: MessageType.SOCKETS_LEAVE,
	                    data: {
	                        opts: encodeOptions(opts),
	                        rooms,
	                    },
	                });
	            }
	            catch (e) {
	                debug("[%s] error while publishing message: %s", this.uid, e.message);
	            }
	        }
	        super.delSockets(opts, rooms);
	    }
	    async disconnectSockets(opts, close) {
	        var _a;
	        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
	        if (!onlyLocal) {
	            try {
	                await this.publishAndReturnOffset({
	                    type: MessageType.DISCONNECT_SOCKETS,
	                    data: {
	                        opts: encodeOptions(opts),
	                        close,
	                    },
	                });
	            }
	            catch (e) {
	                debug("[%s] error while publishing message: %s", this.uid, e.message);
	            }
	        }
	        super.disconnectSockets(opts, close);
	    }
	    async fetchSockets(opts) {
	        var _a;
	        const [localSockets, serverCount] = await Promise.all([
	            super.fetchSockets(opts),
	            this.serverCount(),
	        ]);
	        const expectedResponseCount = serverCount - 1;
	        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {
	            return localSockets;
	        }
	        const requestId = randomId();
	        return new Promise((resolve, reject) => {
	            const timeout = setTimeout(() => {
	                const storedRequest = this.requests.get(requestId);
	                if (storedRequest) {
	                    reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));
	                    this.requests.delete(requestId);
	                }
	            }, opts.flags.timeout || DEFAULT_TIMEOUT);
	            const storedRequest = {
	                type: MessageType.FETCH_SOCKETS,
	                resolve,
	                timeout,
	                current: 0,
	                expected: expectedResponseCount,
	                responses: localSockets,
	            };
	            this.requests.set(requestId, storedRequest);
	            this.publish({
	                type: MessageType.FETCH_SOCKETS,
	                data: {
	                    opts: encodeOptions(opts),
	                    requestId,
	                },
	            });
	        });
	    }
	    async serverSideEmit(packet) {
	        const withAck = typeof packet[packet.length - 1] === "function";
	        if (!withAck) {
	            return this.publish({
	                type: MessageType.SERVER_SIDE_EMIT,
	                data: {
	                    packet,
	                },
	            });
	        }
	        const ack = packet.pop();
	        const expectedResponseCount = (await this.serverCount()) - 1;
	        debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
	        if (expectedResponseCount <= 0) {
	            return ack(null, []);
	        }
	        const requestId = randomId();
	        const timeout = setTimeout(() => {
	            const storedRequest = this.requests.get(requestId);
	            if (storedRequest) {
	                ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);
	                this.requests.delete(requestId);
	            }
	        }, DEFAULT_TIMEOUT);
	        const storedRequest = {
	            type: MessageType.SERVER_SIDE_EMIT,
	            resolve: ack,
	            timeout,
	            current: 0,
	            expected: expectedResponseCount,
	            responses: [],
	        };
	        this.requests.set(requestId, storedRequest);
	        this.publish({
	            type: MessageType.SERVER_SIDE_EMIT,
	            data: {
	                requestId,
	                packet,
	            },
	        });
	    }
	    publish(message) {
	        this.publishAndReturnOffset(message).catch((err) => {
	            debug("[%s] error while publishing message: %s", this.uid, err);
	        });
	    }
	    publishAndReturnOffset(message) {
	        message.uid = this.uid;
	        message.nsp = this.nsp.name;
	        return this.doPublish(message);
	    }
	    publishResponse(requesterUid, response) {
	        response.uid = this.uid;
	        response.nsp = this.nsp.name;
	        this.doPublishResponse(requesterUid, response).catch((err) => {
	            debug("[%s] error while publishing response: %s", this.uid, err);
	        });
	    }
	}
	exports$1.ClusterAdapter = ClusterAdapter;
	class ClusterAdapterWithHeartbeat extends ClusterAdapter {
	    constructor(nsp, opts) {
	        super(nsp);
	        this.nodesMap = new Map(); // uid => timestamp of last message
	        this.customRequests = new Map();
	        this._opts = Object.assign({
	            heartbeatInterval: 5000,
	            heartbeatTimeout: 10000,
	        }, opts);
	        this.cleanupTimer = setInterval(() => {
	            const now = Date.now();
	            this.nodesMap.forEach((lastSeen, uid) => {
	                const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;
	                if (nodeSeemsDown) {
	                    debug("[%s] node %s seems down", this.uid, uid);
	                    this.removeNode(uid);
	                }
	            });
	        }, 1000);
	    }
	    init() {
	        this.publish({
	            type: MessageType.INITIAL_HEARTBEAT,
	        });
	    }
	    scheduleHeartbeat() {
	        if (this.heartbeatTimer) {
	            this.heartbeatTimer.refresh();
	        }
	        else {
	            this.heartbeatTimer = setTimeout(() => {
	                this.publish({
	                    type: MessageType.HEARTBEAT,
	                });
	            }, this._opts.heartbeatInterval);
	        }
	    }
	    close() {
	        this.publish({
	            type: MessageType.ADAPTER_CLOSE,
	        });
	        clearTimeout(this.heartbeatTimer);
	        if (this.cleanupTimer) {
	            clearInterval(this.cleanupTimer);
	        }
	    }
	    onMessage(message, offset) {
	        if (message.uid === this.uid) {
	            return debug("[%s] ignore message from self", this.uid);
	        }
	        if (message.uid && message.uid !== EMITTER_UID) {
	            // we track the UID of each sender, in order to know how many servers there are in the cluster
	            this.nodesMap.set(message.uid, Date.now());
	        }
	        debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
	        switch (message.type) {
	            case MessageType.INITIAL_HEARTBEAT:
	                this.publish({
	                    type: MessageType.HEARTBEAT,
	                });
	                break;
	            case MessageType.HEARTBEAT:
	                // nothing to do
	                break;
	            case MessageType.ADAPTER_CLOSE:
	                this.removeNode(message.uid);
	                break;
	            default:
	                super.onMessage(message, offset);
	        }
	    }
	    serverCount() {
	        return Promise.resolve(1 + this.nodesMap.size);
	    }
	    publish(message) {
	        this.scheduleHeartbeat();
	        return super.publish(message);
	    }
	    async serverSideEmit(packet) {
	        const withAck = typeof packet[packet.length - 1] === "function";
	        if (!withAck) {
	            return this.publish({
	                type: MessageType.SERVER_SIDE_EMIT,
	                data: {
	                    packet,
	                },
	            });
	        }
	        const ack = packet.pop();
	        const expectedResponseCount = this.nodesMap.size;
	        debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
	        if (expectedResponseCount <= 0) {
	            return ack(null, []);
	        }
	        const requestId = randomId();
	        const timeout = setTimeout(() => {
	            const storedRequest = this.customRequests.get(requestId);
	            if (storedRequest) {
	                ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);
	                this.customRequests.delete(requestId);
	            }
	        }, DEFAULT_TIMEOUT);
	        const storedRequest = {
	            type: MessageType.SERVER_SIDE_EMIT,
	            resolve: ack,
	            timeout,
	            missingUids: new Set([...this.nodesMap.keys()]),
	            responses: [],
	        };
	        this.customRequests.set(requestId, storedRequest);
	        this.publish({
	            type: MessageType.SERVER_SIDE_EMIT,
	            data: {
	                requestId,
	                packet,
	            },
	        });
	    }
	    async fetchSockets(opts) {
	        var _a;
	        const [localSockets, serverCount] = await Promise.all([
	            super.fetchSockets({
	                rooms: opts.rooms,
	                except: opts.except,
	                flags: {
	                    local: true,
	                },
	            }),
	            this.serverCount(),
	        ]);
	        const expectedResponseCount = serverCount - 1;
	        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {
	            return localSockets;
	        }
	        const requestId = randomId();
	        return new Promise((resolve, reject) => {
	            const timeout = setTimeout(() => {
	                const storedRequest = this.customRequests.get(requestId);
	                if (storedRequest) {
	                    reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));
	                    this.customRequests.delete(requestId);
	                }
	            }, opts.flags.timeout || DEFAULT_TIMEOUT);
	            const storedRequest = {
	                type: MessageType.FETCH_SOCKETS,
	                resolve,
	                timeout,
	                missingUids: new Set([...this.nodesMap.keys()]),
	                responses: localSockets,
	            };
	            this.customRequests.set(requestId, storedRequest);
	            this.publish({
	                type: MessageType.FETCH_SOCKETS,
	                data: {
	                    opts: encodeOptions(opts),
	                    requestId,
	                },
	            });
	        });
	    }
	    onResponse(response) {
	        const requestId = response.data.requestId;
	        debug("[%s] received response %s to request %s", this.uid, response.type, requestId);
	        switch (response.type) {
	            case MessageType.FETCH_SOCKETS_RESPONSE: {
	                const request = this.customRequests.get(requestId);
	                if (!request) {
	                    return;
	                }
	                response.data.sockets.forEach((socket) => request.responses.push(socket));
	                request.missingUids.delete(response.uid);
	                if (request.missingUids.size === 0) {
	                    clearTimeout(request.timeout);
	                    request.resolve(request.responses);
	                    this.customRequests.delete(requestId);
	                }
	                break;
	            }
	            case MessageType.SERVER_SIDE_EMIT_RESPONSE: {
	                const request = this.customRequests.get(requestId);
	                if (!request) {
	                    return;
	                }
	                request.responses.push(response.data.packet);
	                request.missingUids.delete(response.uid);
	                if (request.missingUids.size === 0) {
	                    clearTimeout(request.timeout);
	                    request.resolve(null, request.responses);
	                    this.customRequests.delete(requestId);
	                }
	                break;
	            }
	            default:
	                super.onResponse(response);
	        }
	    }
	    removeNode(uid) {
	        this.customRequests.forEach((request, requestId) => {
	            request.missingUids.delete(uid);
	            if (request.missingUids.size === 0) {
	                clearTimeout(request.timeout);
	                if (request.type === MessageType.FETCH_SOCKETS) {
	                    request.resolve(request.responses);
	                }
	                else if (request.type === MessageType.SERVER_SIDE_EMIT) {
	                    request.resolve(null, request.responses);
	                }
	                this.customRequests.delete(requestId);
	            }
	        });
	        this.nodesMap.delete(uid);
	    }
	}
	exports$1.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat; 
} (clusterAdapter));

(function (exports$1) {
	Object.defineProperty(exports$1, "__esModule", { value: true });
	exports$1.MessageType = exports$1.ClusterAdapterWithHeartbeat = exports$1.ClusterAdapter = exports$1.SessionAwareAdapter = exports$1.Adapter = void 0;
	var in_memory_adapter_1 = inMemoryAdapter;
	Object.defineProperty(exports$1, "Adapter", { enumerable: true, get: function () { return in_memory_adapter_1.Adapter; } });
	Object.defineProperty(exports$1, "SessionAwareAdapter", { enumerable: true, get: function () { return in_memory_adapter_1.SessionAwareAdapter; } });
	var cluster_adapter_1 = clusterAdapter;
	Object.defineProperty(exports$1, "ClusterAdapter", { enumerable: true, get: function () { return cluster_adapter_1.ClusterAdapter; } });
	Object.defineProperty(exports$1, "ClusterAdapterWithHeartbeat", { enumerable: true, get: function () { return cluster_adapter_1.ClusterAdapterWithHeartbeat; } });
	Object.defineProperty(exports$1, "MessageType", { enumerable: true, get: function () { return cluster_adapter_1.MessageType; } }); 
} (dist$1));

var __importDefault$1 = (parentNamespace && parentNamespace.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(parentNamespace, "__esModule", { value: true });
parentNamespace.ParentNamespace = void 0;
const namespace_1 = namespace;
const socket_io_adapter_1$1 = dist$1;
const debug_1$2 = __importDefault$1(require$$13);
const debug$4 = (0, debug_1$2.default)("socket.io:parent-namespace");
/**
 * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either
 * with a regular expression or with a function.
 *
 * @example
 * const parentNamespace = io.of(/\/dynamic-\d+/);
 *
 * parentNamespace.on("connection", (socket) => {
 *   const childNamespace = socket.nsp;
 * }
 *
 * // will reach all the clients that are in one of the child namespaces, like "/dynamic-101"
 * parentNamespace.emit("hello", "world");
 *
 */
class ParentNamespace extends namespace_1.Namespace {
    constructor(server) {
        super(server, "/_" + ParentNamespace.count++);
        this.children = new Set();
    }
    /**
     * @private
     */
    _initAdapter() {
        this.adapter = new ParentBroadcastAdapter(this);
    }
    emit(ev, ...args) {
        this.children.forEach((nsp) => {
            nsp.emit(ev, ...args);
        });
        return true;
    }
    createChild(name) {
        debug$4("creating child namespace %s", name);
        const namespace = new namespace_1.Namespace(this.server, name);
        this["_fns"].forEach((fn) => namespace.use(fn));
        this.listeners("connect").forEach((listener) => namespace.on("connect", listener));
        this.listeners("connection").forEach((listener) => namespace.on("connection", listener));
        this.children.add(namespace);
        if (this.server._opts.cleanupEmptyChildNamespaces) {
            const remove = namespace._remove;
            namespace._remove = (socket) => {
                remove.call(namespace, socket);
                if (namespace.sockets.size === 0) {
                    debug$4("closing child namespace %s", name);
                    namespace.adapter.close();
                    this.server._nsps.delete(namespace.name);
                    this.children.delete(namespace);
                }
            };
        }
        this.server._nsps.set(name, namespace);
        // @ts-ignore
        this.server.sockets.emitReserved("new_namespace", namespace);
        return namespace;
    }
    fetchSockets() {
        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the
        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but
        // the behavior for namespaces created with a function is less clear
        // note: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace
        // may exist on one node but not exist on another (since it is created upon client connection)
        throw new Error("fetchSockets() is not supported on parent namespaces");
    }
}
parentNamespace.ParentNamespace = ParentNamespace;
ParentNamespace.count = 0;
/**
 * A dummy adapter that only supports broadcasting to child (concrete) namespaces.
 * @private file
 */
class ParentBroadcastAdapter extends socket_io_adapter_1$1.Adapter {
    broadcast(packet, opts) {
        this.nsp.children.forEach((nsp) => {
            nsp.adapter.broadcast(packet, opts);
        });
    }
}

var uws = {};

var __importDefault = (uws && uws.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(uws, "__esModule", { value: true });
uws.patchAdapter = patchAdapter;
uws.restoreAdapter = restoreAdapter;
uws.serveFile = serveFile;
const socket_io_adapter_1 = dist$1;
const fs_1 = require$$1$2;
const debug_1$1 = __importDefault(require$$13);
const debug$3 = (0, debug_1$1.default)("socket.io:adapter-uws");
const SEPARATOR = "\x1f"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;
function patchAdapter(app /* : TemplatedApp */) {
    socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {
        const isNew = !this.sids.has(id);
        addAll.call(this, id, rooms);
        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);
        if (!socket) {
            return;
        }
        if (socket.conn.transport.name === "websocket") {
            subscribe(this.nsp.name, socket, isNew, rooms);
            return;
        }
        if (isNew) {
            socket.conn.on("upgrade", () => {
                const rooms = this.sids.get(id);
                if (rooms) {
                    subscribe(this.nsp.name, socket, isNew, rooms);
                }
            });
        }
    };
    socket_io_adapter_1.Adapter.prototype.del = function (id, room) {
        del.call(this, id, room);
        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);
        if (socket && socket.conn.transport.name === "websocket") {
            // @ts-ignore
            const sessionId = socket.conn.id;
            // @ts-ignore
            const websocket = socket.conn.transport.socket;
            const topic = `${this.nsp.name}${SEPARATOR}${room}`;
            debug$3("unsubscribe connection %s from topic %s", sessionId, topic);
            websocket.unsubscribe(topic);
        }
    };
    socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {
        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;
        if (!useFastPublish) {
            broadcast.call(this, packet, opts);
            return;
        }
        const flags = opts.flags || {};
        const basePacketOpts = {
            preEncoded: true,
            volatile: flags.volatile,
            compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        const encodedPackets = this.encoder.encode(packet);
        const topic = opts.rooms.size === 0
            ? this.nsp.name
            : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;
        debug$3("fast publish to %s", topic);
        // fast publish for clients connected with WebSocket
        encodedPackets.forEach((encodedPacket) => {
            const isBinary = typeof encodedPacket !== "string";
            // "4" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol
            app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
        });
        this.apply(opts, (socket) => {
            if (socket.conn.transport.name !== "websocket") {
                // classic publish for clients connected with HTTP long-polling
                socket.client.writeToEngine(encodedPackets, basePacketOpts);
            }
        });
    };
}
function subscribe(namespaceName, socket, isNew, rooms) {
    // @ts-ignore
    const sessionId = socket.conn.id;
    // @ts-ignore
    const websocket = socket.conn.transport.socket;
    if (isNew) {
        debug$3("subscribe connection %s to topic %s", sessionId, namespaceName);
        websocket.subscribe(namespaceName);
    }
    rooms.forEach((room) => {
        const topic = `${namespaceName}${SEPARATOR}${room}`; // '#' can be used as wildcard
        debug$3("subscribe connection %s to topic %s", sessionId, topic);
        websocket.subscribe(topic);
    });
}
function restoreAdapter() {
    socket_io_adapter_1.Adapter.prototype.addAll = addAll;
    socket_io_adapter_1.Adapter.prototype.del = del;
    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
}
const toArrayBuffer = (buffer) => {
    const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;
    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
};
// imported from https://github.com/kolodziejczak-sz/uwebsocket-serve
function serveFile(res /* : HttpResponse */, filepath) {
    const { size } = (0, fs_1.statSync)(filepath);
    const readStream = (0, fs_1.createReadStream)(filepath);
    const destroyReadStream = () => !readStream.destroyed && readStream.destroy();
    const onError = (error) => {
        destroyReadStream();
        throw error;
    };
    const onDataChunk = (chunk) => {
        const arrayBufferChunk = toArrayBuffer(chunk);
        res.cork(() => {
            const lastOffset = res.getWriteOffset();
            const [ok, done] = res.tryEnd(arrayBufferChunk, size);
            if (!done && !ok) {
                readStream.pause();
                res.onWritable((offset) => {
                    const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
                    if (!done && ok) {
                        readStream.resume();
                    }
                    return ok;
                });
            }
        });
    };
    res.onAborted(destroyReadStream);
    readStream
        .on("data", onDataChunk)
        .on("error", onError)
        .on("end", destroyReadStream);
}

var version$2 = "4.8.1";
const require$$18 = {
	version: version$2};

var dist = dist$2.exports;

(function (module, exports$1) {
	var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dist && dist.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (dist && dist.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (dist && dist.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports$1, "__esModule", { value: true });
	exports$1.Namespace = exports$1.Socket = exports$1.Server = void 0;
	const http = require$$1$6;
	const fs_1 = require$$1$2;
	const zlib_1 = require$$0$5;
	const accepts = accepts$2;
	const stream_1 = require$$2$2;
	const path = require$$5$1;
	const engine_io_1 = require$$6$1;
	const client_1 = client$1;
	const events_1 = require$$0$6;
	const namespace_1 = namespace;
	Object.defineProperty(exports$1, "Namespace", { enumerable: true, get: function () { return namespace_1.Namespace; } });
	const parent_namespace_1 = parentNamespace;
	const socket_io_adapter_1 = dist$1;
	const parser$1 = __importStar(parser);
	const debug_1 = __importDefault(require$$13);
	const socket_1 = socket;
	Object.defineProperty(exports$1, "Socket", { enumerable: true, get: function () { return socket_1.Socket; } });
	const typed_events_1 = typedEvents;
	const uws_1 = uws;
	const cors_1 = __importDefault(libExports$1);
	const debug = (0, debug_1.default)("socket.io:server");
	const clientVersion = require$$18.version;
	const dotMapRegex = /\.map/;
	/**
	 * Represents a Socket.IO server.
	 *
	 * @example
	 * import { Server } from "socket.io";
	 *
	 * const io = new Server();
	 *
	 * io.on("connection", (socket) => {
	 *   console.log(`socket ${socket.id} connected`);
	 *
	 *   // send an event to the client
	 *   socket.emit("foo", "bar");
	 *
	 *   socket.on("foobar", () => {
	 *     // an event was received from the client
	 *   });
	 *
	 *   // upon disconnection
	 *   socket.on("disconnect", (reason) => {
	 *     console.log(`socket ${socket.id} disconnected due to ${reason}`);
	 *   });
	 * });
	 *
	 * io.listen(3000);
	 */
	class Server extends typed_events_1.StrictEventEmitter {
	    constructor(srv, opts = {}) {
	        super();
	        /**
	         * @private
	         */
	        this._nsps = new Map();
	        this.parentNsps = new Map();
	        /**
	         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular
	         * expression.
	         *
	         * @private
	         */
	        this.parentNamespacesFromRegExp = new Map();
	        if ("object" === typeof srv &&
	            srv instanceof Object &&
	            !srv.listen) {
	            opts = srv;
	            srv = undefined;
	        }
	        this.path(opts.path || "/socket.io");
	        this.connectTimeout(opts.connectTimeout || 45000);
	        this.serveClient(false !== opts.serveClient);
	        this._parser = opts.parser || parser$1;
	        this.encoder = new this._parser.Encoder();
	        this.opts = opts;
	        if (opts.connectionStateRecovery) {
	            opts.connectionStateRecovery = Object.assign({
	                maxDisconnectionDuration: 2 * 60 * 1000,
	                skipMiddlewares: true,
	            }, opts.connectionStateRecovery);
	            this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
	        }
	        else {
	            this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
	        }
	        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
	        this.sockets = this.of("/");
	        if (srv || typeof srv == "number")
	            this.attach(srv);
	        if (this.opts.cors) {
	            this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
	        }
	    }
	    get _opts() {
	        return this.opts;
	    }
	    serveClient(v) {
	        if (!arguments.length)
	            return this._serveClient;
	        this._serveClient = v;
	        return this;
	    }
	    /**
	     * Executes the middleware for an incoming namespace not already created on the server.
	     *
	     * @param name - name of incoming namespace
	     * @param auth - the auth parameters
	     * @param fn - callback
	     *
	     * @private
	     */
	    _checkNamespace(name, auth, fn) {
	        if (this.parentNsps.size === 0)
	            return fn(false);
	        const keysIterator = this.parentNsps.keys();
	        const run = () => {
	            const nextFn = keysIterator.next();
	            if (nextFn.done) {
	                return fn(false);
	            }
	            nextFn.value(name, auth, (err, allow) => {
	                if (err || !allow) {
	                    return run();
	                }
	                if (this._nsps.has(name)) {
	                    // the namespace was created in the meantime
	                    debug("dynamic namespace %s already exists", name);
	                    return fn(this._nsps.get(name));
	                }
	                const namespace = this.parentNsps.get(nextFn.value).createChild(name);
	                debug("dynamic namespace %s was created", name);
	                fn(namespace);
	            });
	        };
	        run();
	    }
	    path(v) {
	        if (!arguments.length)
	            return this._path;
	        this._path = v.replace(/\/$/, "");
	        const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
	        this.clientPathRegex = new RegExp("^" +
	            escapedPath +
	            "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
	        return this;
	    }
	    connectTimeout(v) {
	        if (v === undefined)
	            return this._connectTimeout;
	        this._connectTimeout = v;
	        return this;
	    }
	    adapter(v) {
	        if (!arguments.length)
	            return this._adapter;
	        this._adapter = v;
	        for (const nsp of this._nsps.values()) {
	            nsp._initAdapter();
	        }
	        return this;
	    }
	    /**
	     * Attaches socket.io to a server or port.
	     *
	     * @param srv - server or port
	     * @param opts - options passed to engine.io
	     * @return self
	     */
	    listen(srv, opts = {}) {
	        return this.attach(srv, opts);
	    }
	    /**
	     * Attaches socket.io to a server or port.
	     *
	     * @param srv - server or port
	     * @param opts - options passed to engine.io
	     * @return self
	     */
	    attach(srv, opts = {}) {
	        if ("function" == typeof srv) {
	            const msg = "You are trying to attach socket.io to an express " +
	                "request handler function. Please pass a http.Server instance.";
	            throw new Error(msg);
	        }
	        // handle a port as a string
	        if (Number(srv) == srv) {
	            srv = Number(srv);
	        }
	        if ("number" == typeof srv) {
	            debug("creating http server and binding to %d", srv);
	            const port = srv;
	            srv = http.createServer((req, res) => {
	                res.writeHead(404);
	                res.end();
	            });
	            srv.listen(port);
	        }
	        // merge the options passed to the Socket.IO server
	        Object.assign(opts, this.opts);
	        // set engine.io path to `/socket.io`
	        opts.path = opts.path || this._path;
	        this.initEngine(srv, opts);
	        return this;
	    }
	    attachApp(app /*: TemplatedApp */, opts = {}) {
	        // merge the options passed to the Socket.IO server
	        Object.assign(opts, this.opts);
	        // set engine.io path to `/socket.io`
	        opts.path = opts.path || this._path;
	        // initialize engine
	        debug("creating uWebSockets.js-based engine with opts %j", opts);
	        const engine = new engine_io_1.uServer(opts);
	        engine.attach(app, opts);
	        // bind to engine events
	        this.bind(engine);
	        if (this._serveClient) {
	            // attach static file serving
	            app.get(`${this._path}/*`, (res, req) => {
	                if (!this.clientPathRegex.test(req.getUrl())) {
	                    req.setYield(true);
	                    return;
	                }
	                const filename = req
	                    .getUrl()
	                    .replace(this._path, "")
	                    .replace(/\?.*$/, "")
	                    .replace(/^\//, "");
	                const isMap = dotMapRegex.test(filename);
	                const type = isMap ? "map" : "source";
	                // Per the standard, ETags must be quoted:
	                // https://tools.ietf.org/html/rfc7232#section-2.3
	                const expectedEtag = '"' + clientVersion + '"';
	                const weakEtag = "W/" + expectedEtag;
	                const etag = req.getHeader("if-none-match");
	                if (etag) {
	                    if (expectedEtag === etag || weakEtag === etag) {
	                        debug("serve client %s 304", type);
	                        res.writeStatus("304 Not Modified");
	                        res.end();
	                        return;
	                    }
	                }
	                debug("serve client %s", type);
	                res.writeHeader("cache-control", "public, max-age=0");
	                res.writeHeader("content-type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
	                res.writeHeader("etag", expectedEtag);
	                const filepath = path.join(__dirname, "../client-dist/", filename);
	                (0, uws_1.serveFile)(res, filepath);
	            });
	        }
	        (0, uws_1.patchAdapter)(app);
	    }
	    /**
	     * Initialize engine
	     *
	     * @param srv - the server to attach to
	     * @param opts - options passed to engine.io
	     * @private
	     */
	    initEngine(srv, opts) {
	        // initialize engine
	        debug("creating engine.io instance with opts %j", opts);
	        this.eio = (0, engine_io_1.attach)(srv, opts);
	        // attach static file serving
	        if (this._serveClient)
	            this.attachServe(srv);
	        // Export http server
	        this.httpServer = srv;
	        // bind to engine events
	        this.bind(this.eio);
	    }
	    /**
	     * Attaches the static file serving.
	     *
	     * @param srv http server
	     * @private
	     */
	    attachServe(srv) {
	        debug("attaching client serving req handler");
	        const evs = srv.listeners("request").slice(0);
	        srv.removeAllListeners("request");
	        srv.on("request", (req, res) => {
	            if (this.clientPathRegex.test(req.url)) {
	                if (this._corsMiddleware) {
	                    this._corsMiddleware(req, res, () => {
	                        this.serve(req, res);
	                    });
	                }
	                else {
	                    this.serve(req, res);
	                }
	            }
	            else {
	                for (let i = 0; i < evs.length; i++) {
	                    evs[i].call(srv, req, res);
	                }
	            }
	        });
	    }
	    /**
	     * Handles a request serving of client source and map
	     *
	     * @param req
	     * @param res
	     * @private
	     */
	    serve(req, res) {
	        const filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
	        const isMap = dotMapRegex.test(filename);
	        const type = isMap ? "map" : "source";
	        // Per the standard, ETags must be quoted:
	        // https://tools.ietf.org/html/rfc7232#section-2.3
	        const expectedEtag = '"' + clientVersion + '"';
	        const weakEtag = "W/" + expectedEtag;
	        const etag = req.headers["if-none-match"];
	        if (etag) {
	            if (expectedEtag === etag || weakEtag === etag) {
	                debug("serve client %s 304", type);
	                res.writeHead(304);
	                res.end();
	                return;
	            }
	        }
	        debug("serve client %s", type);
	        res.setHeader("Cache-Control", "public, max-age=0");
	        res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
	        res.setHeader("ETag", expectedEtag);
	        Server.sendFile(filename, req, res);
	    }
	    /**
	     * @param filename
	     * @param req
	     * @param res
	     * @private
	     */
	    static sendFile(filename, req, res) {
	        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, "../client-dist/", filename));
	        const encoding = accepts(req).encodings(["br", "gzip", "deflate"]);
	        const onError = (err) => {
	            if (err) {
	                res.end();
	            }
	        };
	        switch (encoding) {
	            case "br":
	                res.writeHead(200, { "content-encoding": "br" });
	                (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
	                break;
	            case "gzip":
	                res.writeHead(200, { "content-encoding": "gzip" });
	                (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
	                break;
	            case "deflate":
	                res.writeHead(200, { "content-encoding": "deflate" });
	                (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
	                break;
	            default:
	                res.writeHead(200);
	                (0, stream_1.pipeline)(readStream, res, onError);
	        }
	    }
	    /**
	     * Binds socket.io to an engine.io instance.
	     *
	     * @param engine engine.io (or compatible) server
	     * @return self
	     */
	    bind(engine) {
	        // TODO apply strict types to the engine: "connection" event, `close()` and a method to serve static content
	        //  this would allow to provide any custom engine, like one based on Deno or Bun built-in HTTP server
	        this.engine = engine;
	        this.engine.on("connection", this.onconnection.bind(this));
	        return this;
	    }
	    /**
	     * Called with each incoming transport connection.
	     *
	     * @param {engine.Socket} conn
	     * @return self
	     * @private
	     */
	    onconnection(conn) {
	        debug("incoming connection with id %s", conn.id);
	        const client = new client_1.Client(this, conn);
	        if (conn.protocol === 3) {
	            // @ts-ignore
	            client.connect("/");
	        }
	        return this;
	    }
	    /**
	     * Looks up a namespace.
	     *
	     * @example
	     * // with a simple string
	     * const myNamespace = io.of("/my-namespace");
	     *
	     * // with a regex
	     * const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
	     *   const namespace = socket.nsp; // newNamespace.name === "/dynamic-101"
	     *
	     *   // broadcast to all clients in the given sub-namespace
	     *   namespace.emit("hello");
	     * });
	     *
	     * @param name - nsp name
	     * @param fn optional, nsp `connection` ev handler
	     */
	    of(name, fn) {
	        if (typeof name === "function" || name instanceof RegExp) {
	            const parentNsp = new parent_namespace_1.ParentNamespace(this);
	            debug("initializing parent namespace %s", parentNsp.name);
	            if (typeof name === "function") {
	                this.parentNsps.set(name, parentNsp);
	            }
	            else {
	                this.parentNsps.set((nsp, conn, next) => next(null, name.test(nsp)), parentNsp);
	                this.parentNamespacesFromRegExp.set(name, parentNsp);
	            }
	            if (fn) {
	                // @ts-ignore
	                parentNsp.on("connect", fn);
	            }
	            return parentNsp;
	        }
	        if (String(name)[0] !== "/")
	            name = "/" + name;
	        let nsp = this._nsps.get(name);
	        if (!nsp) {
	            for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp) {
	                if (regex.test(name)) {
	                    debug("attaching namespace %s to parent namespace %s", name, regex);
	                    return parentNamespace.createChild(name);
	                }
	            }
	            debug("initializing namespace %s", name);
	            nsp = new namespace_1.Namespace(this, name);
	            this._nsps.set(name, nsp);
	            if (name !== "/") {
	                // @ts-ignore
	                this.sockets.emitReserved("new_namespace", nsp);
	            }
	        }
	        if (fn)
	            nsp.on("connect", fn);
	        return nsp;
	    }
	    /**
	     * Closes server connection
	     *
	     * @param [fn] optional, called as `fn([err])` on error OR all conns closed
	     */
	    async close(fn) {
	        await Promise.allSettled([...this._nsps.values()].map(async (nsp) => {
	            nsp.sockets.forEach((socket) => {
	                socket._onclose("server shutting down");
	            });
	            await nsp.adapter.close();
	        }));
	        this.engine.close();
	        // restore the Adapter prototype, when the Socket.IO server was attached to a uWebSockets.js server
	        (0, uws_1.restoreAdapter)();
	        if (this.httpServer) {
	            this.httpServer.close(fn);
	        }
	        else {
	            fn && fn();
	        }
	    }
	    /**
	     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
	     *
	     * @example
	     * io.use((socket, next) => {
	     *   // ...
	     *   next();
	     * });
	     *
	     * @param fn - the middleware function
	     */
	    use(fn) {
	        this.sockets.use(fn);
	        return this;
	    }
	    /**
	     * Targets a room when emitting.
	     *
	     * @example
	     * // the foo event will be broadcast to all connected clients in the room-101 room
	     * io.to("room-101").emit("foo", "bar");
	     *
	     * // with an array of rooms (a client will be notified at most once)
	     * io.to(["room-101", "room-102"]).emit("foo", "bar");
	     *
	     * // with multiple chained calls
	     * io.to("room-101").to("room-102").emit("foo", "bar");
	     *
	     * @param room - a room, or an array of rooms
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    to(room) {
	        return this.sockets.to(room);
	    }
	    /**
	     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
	     *
	     * @example
	     * // disconnect all clients in the "room-101" room
	     * io.in("room-101").disconnectSockets();
	     *
	     * @param room - a room, or an array of rooms
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    in(room) {
	        return this.sockets.in(room);
	    }
	    /**
	     * Excludes a room when emitting.
	     *
	     * @example
	     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
	     * io.except("room-101").emit("foo", "bar");
	     *
	     * // with an array of rooms
	     * io.except(["room-101", "room-102"]).emit("foo", "bar");
	     *
	     * // with multiple chained calls
	     * io.except("room-101").except("room-102").emit("foo", "bar");
	     *
	     * @param room - a room, or an array of rooms
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    except(room) {
	        return this.sockets.except(room);
	    }
	    /**
	     * Sends a `message` event to all clients.
	     *
	     * This method mimics the WebSocket.send() method.
	     *
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
	     *
	     * @example
	     * io.send("hello");
	     *
	     * // this is equivalent to
	     * io.emit("message", "hello");
	     *
	     * @return self
	     */
	    send(...args) {
	        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
	        // if you specify the EmitEvents, the type of args will be never.
	        this.sockets.emit("message", ...args);
	        return this;
	    }
	    /**
	     * Sends a `message` event to all clients. Alias of {@link send}.
	     *
	     * @return self
	     */
	    write(...args) {
	        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
	        // if you specify the EmitEvents, the type of args will be never.
	        this.sockets.emit("message", ...args);
	        return this;
	    }
	    /**
	     * Sends a message to the other Socket.IO servers of the cluster.
	     *
	     * @example
	     * io.serverSideEmit("hello", "world");
	     *
	     * io.on("hello", (arg1) => {
	     *   console.log(arg1); // prints "world"
	     * });
	     *
	     * // acknowledgements (without binary content) are supported too:
	     * io.serverSideEmit("ping", (err, responses) => {
	     *  if (err) {
	     *     // some servers did not acknowledge the event in the given delay
	     *   } else {
	     *     console.log(responses); // one response per server (except the current one)
	     *   }
	     * });
	     *
	     * io.on("ping", (cb) => {
	     *   cb("pong");
	     * });
	     *
	     * @param ev - the event name
	     * @param args - an array of arguments, which may include an acknowledgement callback at the end
	     */
	    serverSideEmit(ev, ...args) {
	        return this.sockets.serverSideEmit(ev, ...args);
	    }
	    /**
	     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
	     *
	     * @example
	     * try {
	     *   const responses = await io.serverSideEmitWithAck("ping");
	     *   console.log(responses); // one response per server (except the current one)
	     * } catch (e) {
	     *   // some servers did not acknowledge the event in the given delay
	     * }
	     *
	     * @param ev - the event name
	     * @param args - an array of arguments
	     *
	     * @return a Promise that will be fulfilled when all servers have acknowledged the event
	     */
	    serverSideEmitWithAck(ev, ...args) {
	        return this.sockets.serverSideEmitWithAck(ev, ...args);
	    }
	    /**
	     * Gets a list of socket ids.
	     *
	     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
	     * {@link Server#fetchSockets} instead.
	     */
	    allSockets() {
	        return this.sockets.allSockets();
	    }
	    /**
	     * Sets the compress flag.
	     *
	     * @example
	     * io.compress(false).emit("hello");
	     *
	     * @param compress - if `true`, compresses the sending data
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    compress(compress) {
	        return this.sockets.compress(compress);
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
	     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
	     * and is in the middle of a request-response cycle).
	     *
	     * @example
	     * io.volatile.emit("hello"); // the clients may or may not receive it
	     *
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    get volatile() {
	        return this.sockets.volatile;
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
	     *
	     * @example
	     * // the foo event will be broadcast to all connected clients on this node
	     * io.local.emit("foo", "bar");
	     *
	     * @return a new {@link BroadcastOperator} instance for chaining
	     */
	    get local() {
	        return this.sockets.local;
	    }
	    /**
	     * Adds a timeout in milliseconds for the next operation.
	     *
	     * @example
	     * io.timeout(1000).emit("some-event", (err, responses) => {
	     *   if (err) {
	     *     // some clients did not acknowledge the event in the given delay
	     *   } else {
	     *     console.log(responses); // one response per client
	     *   }
	     * });
	     *
	     * @param timeout
	     */
	    timeout(timeout) {
	        return this.sockets.timeout(timeout);
	    }
	    /**
	     * Returns the matching socket instances.
	     *
	     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
	     *
	     * @example
	     * // return all Socket instances
	     * const sockets = await io.fetchSockets();
	     *
	     * // return all Socket instances in the "room1" room
	     * const sockets = await io.in("room1").fetchSockets();
	     *
	     * for (const socket of sockets) {
	     *   console.log(socket.id);
	     *   console.log(socket.handshake);
	     *   console.log(socket.rooms);
	     *   console.log(socket.data);
	     *
	     *   socket.emit("hello");
	     *   socket.join("room1");
	     *   socket.leave("room2");
	     *   socket.disconnect();
	     * }
	     */
	    fetchSockets() {
	        return this.sockets.fetchSockets();
	    }
	    /**
	     * Makes the matching socket instances join the specified rooms.
	     *
	     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
	     *
	     * @example
	     *
	     * // make all socket instances join the "room1" room
	     * io.socketsJoin("room1");
	     *
	     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
	     * io.in("room1").socketsJoin(["room2", "room3"]);
	     *
	     * @param room - a room, or an array of rooms
	     */
	    socketsJoin(room) {
	        return this.sockets.socketsJoin(room);
	    }
	    /**
	     * Makes the matching socket instances leave the specified rooms.
	     *
	     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
	     *
	     * @example
	     * // make all socket instances leave the "room1" room
	     * io.socketsLeave("room1");
	     *
	     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
	     * io.in("room1").socketsLeave(["room2", "room3"]);
	     *
	     * @param room - a room, or an array of rooms
	     */
	    socketsLeave(room) {
	        return this.sockets.socketsLeave(room);
	    }
	    /**
	     * Makes the matching socket instances disconnect.
	     *
	     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
	     *
	     * @example
	     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
	     * io.disconnectSockets();
	     *
	     * // make all socket instances in the "room1" room disconnect and close the underlying connections
	     * io.in("room1").disconnectSockets(true);
	     *
	     * @param close - whether to close the underlying connection
	     */
	    disconnectSockets(close = false) {
	        return this.sockets.disconnectSockets(close);
	    }
	}
	exports$1.Server = Server;
	/**
	 * Expose main namespace (/).
	 */
	const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {
	    return typeof events_1.EventEmitter.prototype[key] === "function";
	});
	emitterMethods.forEach(function (fn) {
	    Server.prototype[fn] = function () {
	        return this.sockets[fn].apply(this.sockets, arguments);
	    };
	});
	module.exports = (srv, opts) => new Server(srv, opts);
	module.exports.Server = Server;
	module.exports.Namespace = namespace_1.Namespace;
	module.exports.Socket = socket_1.Socket; 
} (dist$2, dist$2.exports));

var distExports = dist$2.exports;
const io = /*@__PURE__*/getDefaultExportFromCjs(distExports);

const {Server, Namespace, Socket} = io;

var jws$3 = {};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

(function (module, exports$1) {
	/* eslint-disable node/no-deprecated-api */
	var buffer = require$$0$3;
	var Buffer = buffer.Buffer;

	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
	  for (var key in src) {
	    dst[key] = src[key];
	  }
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
	  module.exports = buffer;
	} else {
	  // Copy properties from require('buffer')
	  copyProps(buffer, exports$1);
	  exports$1.Buffer = SafeBuffer;
	}

	function SafeBuffer (arg, encodingOrOffset, length) {
	  return Buffer(arg, encodingOrOffset, length)
	}

	SafeBuffer.prototype = Object.create(Buffer.prototype);

	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer);

	SafeBuffer.from = function (arg, encodingOrOffset, length) {
	  if (typeof arg === 'number') {
	    throw new TypeError('Argument must not be a number')
	  }
	  return Buffer(arg, encodingOrOffset, length)
	};

	SafeBuffer.alloc = function (size, fill, encoding) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  var buf = Buffer(size);
	  if (fill !== undefined) {
	    if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	  } else {
	    buf.fill(0);
	  }
	  return buf
	};

	SafeBuffer.allocUnsafe = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return Buffer(size)
	};

	SafeBuffer.allocUnsafeSlow = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return buffer.SlowBuffer(size)
	}; 
} (safeBuffer, safeBuffer.exports));

var safeBufferExports = safeBuffer.exports;

const require$$0$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(util$5);

/*global module, process*/

var Buffer$7 = safeBufferExports.Buffer;
var Stream$2 = require$$2$2;
var util$4 = require$$0$2;

function DataStream$2(data) {
  this.buffer = null;
  this.writable = true;
  this.readable = true;

  // No input
  if (!data) {
    this.buffer = Buffer$7.alloc(0);
    return this;
  }

  // Stream
  if (typeof data.pipe === 'function') {
    this.buffer = Buffer$7.alloc(0);
    data.pipe(this);
    return this;
  }

  // Buffer or String
  // or Object (assumedly a passworded key)
  if (data.length || typeof data === 'object') {
    this.buffer = data;
    this.writable = false;
    process.nextTick(function () {
      this.emit('end', data);
      this.readable = false;
      this.emit('close');
    }.bind(this));
    return this;
  }

  throw new TypeError('Unexpected data type ('+ typeof data + ')');
}
util$4.inherits(DataStream$2, Stream$2);

DataStream$2.prototype.write = function write(data) {
  this.buffer = Buffer$7.concat([this.buffer, Buffer$7.from(data)]);
  this.emit('data', data);
};

DataStream$2.prototype.end = function end(data) {
  if (data)
    this.write(data);
  this.emit('end', data);
  this.emit('close');
  this.writable = false;
  this.readable = false;
};

var dataStream = DataStream$2;

function getParamSize(keySize) {
	var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
	return result;
}

var paramBytesForAlg = {
	ES256: getParamSize(256),
	ES384: getParamSize(384),
	ES512: getParamSize(521)
};

function getParamBytesForAlg$1(alg) {
	var paramBytes = paramBytesForAlg[alg];
	if (paramBytes) {
		return paramBytes;
	}

	throw new Error('Unknown algorithm "' + alg + '"');
}

var paramBytesForAlg_1 = getParamBytesForAlg$1;

var Buffer$6 = safeBufferExports.Buffer;

var getParamBytesForAlg = paramBytesForAlg_1;

var MAX_OCTET = 0x80,
	CLASS_UNIVERSAL = 0,
	PRIMITIVE_BIT = 0x20,
	TAG_SEQ = 0x10,
	TAG_INT = 0x02,
	ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
	ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);

function base64Url(base64) {
	return base64
		.replace(/=/g, '')
		.replace(/\+/g, '-')
		.replace(/\//g, '_');
}

function signatureAsBuffer(signature) {
	if (Buffer$6.isBuffer(signature)) {
		return signature;
	} else if ('string' === typeof signature) {
		return Buffer$6.from(signature, 'base64');
	}

	throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
}

function derToJose(signature, alg) {
	signature = signatureAsBuffer(signature);
	var paramBytes = getParamBytesForAlg(alg);

	// the DER encoded param should at most be the param size, plus a padding
	// zero, since due to being a signed integer
	var maxEncodedParamLength = paramBytes + 1;

	var inputLength = signature.length;

	var offset = 0;
	if (signature[offset++] !== ENCODED_TAG_SEQ) {
		throw new Error('Could not find expected "seq"');
	}

	var seqLength = signature[offset++];
	if (seqLength === (MAX_OCTET | 1)) {
		seqLength = signature[offset++];
	}

	if (inputLength - offset < seqLength) {
		throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
	}

	if (signature[offset++] !== ENCODED_TAG_INT) {
		throw new Error('Could not find expected "int" for "r"');
	}

	var rLength = signature[offset++];

	if (inputLength - offset - 2 < rLength) {
		throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
	}

	if (maxEncodedParamLength < rLength) {
		throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
	}

	var rOffset = offset;
	offset += rLength;

	if (signature[offset++] !== ENCODED_TAG_INT) {
		throw new Error('Could not find expected "int" for "s"');
	}

	var sLength = signature[offset++];

	if (inputLength - offset !== sLength) {
		throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
	}

	if (maxEncodedParamLength < sLength) {
		throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
	}

	var sOffset = offset;
	offset += sLength;

	if (offset !== inputLength) {
		throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
	}

	var rPadding = paramBytes - rLength,
		sPadding = paramBytes - sLength;

	var dst = Buffer$6.allocUnsafe(rPadding + rLength + sPadding + sLength);

	for (offset = 0; offset < rPadding; ++offset) {
		dst[offset] = 0;
	}
	signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);

	offset = paramBytes;

	for (var o = offset; offset < o + sPadding; ++offset) {
		dst[offset] = 0;
	}
	signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);

	dst = dst.toString('base64');
	dst = base64Url(dst);

	return dst;
}

function countPadding(buf, start, stop) {
	var padding = 0;
	while (start + padding < stop && buf[start + padding] === 0) {
		++padding;
	}

	var needsSign = buf[start + padding] >= MAX_OCTET;
	if (needsSign) {
		--padding;
	}

	return padding;
}

function joseToDer(signature, alg) {
	signature = signatureAsBuffer(signature);
	var paramBytes = getParamBytesForAlg(alg);

	var signatureBytes = signature.length;
	if (signatureBytes !== paramBytes * 2) {
		throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
	}

	var rPadding = countPadding(signature, 0, paramBytes);
	var sPadding = countPadding(signature, paramBytes, signature.length);
	var rLength = paramBytes - rPadding;
	var sLength = paramBytes - sPadding;

	var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;

	var shortLength = rsBytes < MAX_OCTET;

	var dst = Buffer$6.allocUnsafe((shortLength ? 2 : 3) + rsBytes);

	var offset = 0;
	dst[offset++] = ENCODED_TAG_SEQ;
	if (shortLength) {
		// Bit 8 has value "0"
		// bits 7-1 give the length.
		dst[offset++] = rsBytes;
	} else {
		// Bit 8 of first octet has value "1"
		// bits 7-1 give the number of additional length octets.
		dst[offset++] = MAX_OCTET	| 1;
		// length, base 256
		dst[offset++] = rsBytes & 0xff;
	}
	dst[offset++] = ENCODED_TAG_INT;
	dst[offset++] = rLength;
	if (rPadding < 0) {
		dst[offset++] = 0;
		offset += signature.copy(dst, offset, 0, paramBytes);
	} else {
		offset += signature.copy(dst, offset, rPadding, paramBytes);
	}
	dst[offset++] = ENCODED_TAG_INT;
	dst[offset++] = sLength;
	if (sPadding < 0) {
		dst[offset++] = 0;
		signature.copy(dst, offset, paramBytes);
	} else {
		signature.copy(dst, offset, paramBytes + sPadding);
	}

	return dst;
}

var ecdsaSigFormatter = {
	derToJose: derToJose,
	joseToDer: joseToDer
};

/*jshint node:true */

var bufferEqualConstantTime;
var hasRequiredBufferEqualConstantTime;

function requireBufferEqualConstantTime () {
	if (hasRequiredBufferEqualConstantTime) return bufferEqualConstantTime;
	hasRequiredBufferEqualConstantTime = 1;
	var Buffer = require$$0$3.Buffer; // browserify
	var SlowBuffer = require$$0$3.SlowBuffer;

	bufferEqualConstantTime = bufferEq;

	function bufferEq(a, b) {

	  // shortcutting on type is necessary for correctness
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    return false;
	  }

	  // buffer sizes should be well-known information, so despite this
	  // shortcutting, it doesn't leak any information about the *contents* of the
	  // buffers.
	  if (a.length !== b.length) {
	    return false;
	  }

	  var c = 0;
	  for (var i = 0; i < a.length; i++) {
	    /*jshint bitwise:false */
	    c |= a[i] ^ b[i]; // XOR
	  }
	  return c === 0;
	}

	bufferEq.install = function() {
	  Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
	    return bufferEq(this, that);
	  };
	};

	var origBufEqual = Buffer.prototype.equal;
	var origSlowBufEqual = SlowBuffer.prototype.equal;
	bufferEq.restore = function() {
	  Buffer.prototype.equal = origBufEqual;
	  SlowBuffer.prototype.equal = origSlowBufEqual;
	};
	return bufferEqualConstantTime;
}

var Buffer$5 = safeBufferExports.Buffer;
var crypto = require$$3$3;
var formatEcdsa = ecdsaSigFormatter;
var util$3 = require$$0$2;

var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
var MSG_INVALID_SECRET = 'secret must be a string or buffer';
var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
if (supportsKeyObjects) {
  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
  MSG_INVALID_SECRET += 'or a KeyObject';
}

function checkIsPublicKey(key) {
  if (Buffer$5.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return;
  }

  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key !== 'object') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.type !== 'string') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.asymmetricKeyType !== 'string') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.export !== 'function') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
}
function checkIsPrivateKey(key) {
  if (Buffer$5.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return;
  }

  if (typeof key === 'object') {
    return;
  }

  throw typeError(MSG_INVALID_SIGNER_KEY);
}
function checkIsSecretKey(key) {
  if (Buffer$5.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return key;
  }

  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (typeof key !== 'object') {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (key.type !== 'secret') {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (typeof key.export !== 'function') {
    throw typeError(MSG_INVALID_SECRET);
  }
}

function fromBase64(base64) {
  return base64
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function toBase64(base64url) {
  base64url = base64url.toString();

  var padding = 4 - base64url.length % 4;
  if (padding !== 4) {
    for (var i = 0; i < padding; ++i) {
      base64url += '=';
    }
  }

  return base64url
    .replace(/\-/g, '+')
    .replace(/_/g, '/');
}

function typeError(template) {
  var args = [].slice.call(arguments, 1);
  var errMsg = util$3.format.bind(util$3, template).apply(null, args);
  return new TypeError(errMsg);
}

function bufferOrString(obj) {
  return Buffer$5.isBuffer(obj) || typeof obj === 'string';
}

function normalizeInput(thing) {
  if (!bufferOrString(thing))
    thing = JSON.stringify(thing);
  return thing;
}

function createHmacSigner(bits) {
  return function sign(thing, secret) {
    checkIsSecretKey(secret);
    thing = normalizeInput(thing);
    var hmac = crypto.createHmac('sha' + bits, secret);
    var sig = (hmac.update(thing), hmac.digest('base64'));
    return fromBase64(sig);
  }
}

var bufferEqual;
var timingSafeEqual = 'timingSafeEqual' in crypto ? function timingSafeEqual(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  return crypto.timingSafeEqual(a, b)
} : function timingSafeEqual(a, b) {
  if (!bufferEqual) {
    bufferEqual = /*@__PURE__*/ requireBufferEqualConstantTime();
  }

  return bufferEqual(a, b)
};

function createHmacVerifier(bits) {
  return function verify(thing, signature, secret) {
    var computedSig = createHmacSigner(bits)(thing, secret);
    return timingSafeEqual(Buffer$5.from(signature), Buffer$5.from(computedSig));
  }
}

function createKeySigner(bits) {
 return function sign(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    // Even though we are specifying "RSA" here, this works with ECDSA
    // keys as well.
    var signer = crypto.createSign('RSA-SHA' + bits);
    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
    return fromBase64(sig);
  }
}

function createKeyVerifier(bits) {
  return function verify(thing, signature, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto.createVerify('RSA-SHA' + bits);
    verifier.update(thing);
    return verifier.verify(publicKey, signature, 'base64');
  }
}

function createPSSKeySigner(bits) {
  return function sign(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    var signer = crypto.createSign('RSA-SHA' + bits);
    var sig = (signer.update(thing), signer.sign({
      key: privateKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
    }, 'base64'));
    return fromBase64(sig);
  }
}

function createPSSKeyVerifier(bits) {
  return function verify(thing, signature, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto.createVerify('RSA-SHA' + bits);
    verifier.update(thing);
    return verifier.verify({
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
    }, signature, 'base64');
  }
}

function createECDSASigner(bits) {
  var inner = createKeySigner(bits);
  return function sign() {
    var signature = inner.apply(null, arguments);
    signature = formatEcdsa.derToJose(signature, 'ES' + bits);
    return signature;
  };
}

function createECDSAVerifer(bits) {
  var inner = createKeyVerifier(bits);
  return function verify(thing, signature, publicKey) {
    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
    var result = inner(thing, signature, publicKey);
    return result;
  };
}

function createNoneSigner() {
  return function sign() {
    return '';
  }
}

function createNoneVerifier() {
  return function verify(thing, signature) {
    return signature === '';
  }
}

var jwa$2 = function jwa(algorithm) {
  var signerFactories = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner,
  };
  var verifierFactories = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier,
  };
  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
  if (!match)
    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
  var algo = (match[1] || match[3]).toLowerCase();
  var bits = match[2];

  return {
    sign: signerFactories[algo](bits),
    verify: verifierFactories[algo](bits),
  }
};

/*global module*/

var Buffer$4 = require$$0$3.Buffer;

var tostring = function toString(obj) {
  if (typeof obj === 'string')
    return obj;
  if (typeof obj === 'number' || Buffer$4.isBuffer(obj))
    return obj.toString();
  return JSON.stringify(obj);
};

/*global module*/

var Buffer$3 = safeBufferExports.Buffer;
var DataStream$1 = dataStream;
var jwa$1 = jwa$2;
var Stream$1 = require$$2$2;
var toString$1 = tostring;
var util$2 = require$$0$2;

function base64url(string, encoding) {
  return Buffer$3
    .from(string, encoding)
    .toString('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function jwsSecuredInput(header, payload, encoding) {
  encoding = encoding || 'utf8';
  var encodedHeader = base64url(toString$1(header), 'binary');
  var encodedPayload = base64url(toString$1(payload), encoding);
  return util$2.format('%s.%s', encodedHeader, encodedPayload);
}

function jwsSign(opts) {
  var header = opts.header;
  var payload = opts.payload;
  var secretOrKey = opts.secret || opts.privateKey;
  var encoding = opts.encoding;
  var algo = jwa$1(header.alg);
  var securedInput = jwsSecuredInput(header, payload, encoding);
  var signature = algo.sign(securedInput, secretOrKey);
  return util$2.format('%s.%s', securedInput, signature);
}

function SignStream$1(opts) {
  var secret = opts.secret;
  secret = secret == null ? opts.privateKey : secret;
  secret = secret == null ? opts.key : secret;
  if (/^hs/i.test(opts.header.alg) === true && secret == null) {
    throw new TypeError('secret must be a string or buffer or a KeyObject')
  }
  var secretStream = new DataStream$1(secret);
  this.readable = true;
  this.header = opts.header;
  this.encoding = opts.encoding;
  this.secret = this.privateKey = this.key = secretStream;
  this.payload = new DataStream$1(opts.payload);
  this.secret.once('close', function () {
    if (!this.payload.writable && this.readable)
      this.sign();
  }.bind(this));

  this.payload.once('close', function () {
    if (!this.secret.writable && this.readable)
      this.sign();
  }.bind(this));
}
util$2.inherits(SignStream$1, Stream$1);

SignStream$1.prototype.sign = function sign() {
  try {
    var signature = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    this.emit('done', signature);
    this.emit('data', signature);
    this.emit('end');
    this.readable = false;
    return signature;
  } catch (e) {
    this.readable = false;
    this.emit('error', e);
    this.emit('close');
  }
};

SignStream$1.sign = jwsSign;

var signStream = SignStream$1;

/*global module*/

var Buffer$2 = safeBufferExports.Buffer;
var DataStream = dataStream;
var jwa = jwa$2;
var Stream = require$$2$2;
var toString = tostring;
var util$1 = require$$0$2;
var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;

function isObject$3(thing) {
  return Object.prototype.toString.call(thing) === '[object Object]';
}

function safeJsonParse(thing) {
  if (isObject$3(thing))
    return thing;
  try { return JSON.parse(thing); }
  catch (e) { return undefined; }
}

function headerFromJWS(jwsSig) {
  var encodedHeader = jwsSig.split('.', 1)[0];
  return safeJsonParse(Buffer$2.from(encodedHeader, 'base64').toString('binary'));
}

function securedInputFromJWS(jwsSig) {
  return jwsSig.split('.', 2).join('.');
}

function signatureFromJWS(jwsSig) {
  return jwsSig.split('.')[2];
}

function payloadFromJWS(jwsSig, encoding) {
  encoding = encoding || 'utf8';
  var payload = jwsSig.split('.')[1];
  return Buffer$2.from(payload, 'base64').toString(encoding);
}

function isValidJws(string) {
  return JWS_REGEX.test(string) && !!headerFromJWS(string);
}

function jwsVerify(jwsSig, algorithm, secretOrKey) {
  if (!algorithm) {
    var err = new Error("Missing algorithm parameter for jws.verify");
    err.code = "MISSING_ALGORITHM";
    throw err;
  }
  jwsSig = toString(jwsSig);
  var signature = signatureFromJWS(jwsSig);
  var securedInput = securedInputFromJWS(jwsSig);
  var algo = jwa(algorithm);
  return algo.verify(securedInput, signature, secretOrKey);
}

function jwsDecode(jwsSig, opts) {
  opts = opts || {};
  jwsSig = toString(jwsSig);

  if (!isValidJws(jwsSig))
    return null;

  var header = headerFromJWS(jwsSig);

  if (!header)
    return null;

  var payload = payloadFromJWS(jwsSig);
  if (header.typ === 'JWT' || opts.json)
    payload = JSON.parse(payload, opts.encoding);

  return {
    header: header,
    payload: payload,
    signature: signatureFromJWS(jwsSig)
  };
}

function VerifyStream$1(opts) {
  opts = opts || {};
  var secretOrKey = opts.secret;
  secretOrKey = secretOrKey == null ? opts.publicKey : secretOrKey;
  secretOrKey = secretOrKey == null ? opts.key : secretOrKey;
  if (/^hs/i.test(opts.algorithm) === true && secretOrKey == null) {
    throw new TypeError('secret must be a string or buffer or a KeyObject')
  }
  var secretStream = new DataStream(secretOrKey);
  this.readable = true;
  this.algorithm = opts.algorithm;
  this.encoding = opts.encoding;
  this.secret = this.publicKey = this.key = secretStream;
  this.signature = new DataStream(opts.signature);
  this.secret.once('close', function () {
    if (!this.signature.writable && this.readable)
      this.verify();
  }.bind(this));

  this.signature.once('close', function () {
    if (!this.secret.writable && this.readable)
      this.verify();
  }.bind(this));
}
util$1.inherits(VerifyStream$1, Stream);
VerifyStream$1.prototype.verify = function verify() {
  try {
    var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
    var obj = jwsDecode(this.signature.buffer, this.encoding);
    this.emit('done', valid, obj);
    this.emit('data', valid);
    this.emit('end');
    this.readable = false;
    return valid;
  } catch (e) {
    this.readable = false;
    this.emit('error', e);
    this.emit('close');
  }
};

VerifyStream$1.decode = jwsDecode;
VerifyStream$1.isValid = isValidJws;
VerifyStream$1.verify = jwsVerify;

var verifyStream = VerifyStream$1;

/*global exports*/

var SignStream = signStream;
var VerifyStream = verifyStream;

var ALGORITHMS = [
  'HS256', 'HS384', 'HS512',
  'RS256', 'RS384', 'RS512',
  'PS256', 'PS384', 'PS512',
  'ES256', 'ES384', 'ES512'
];

jws$3.ALGORITHMS = ALGORITHMS;
jws$3.sign = SignStream.sign;
jws$3.verify = VerifyStream.verify;
jws$3.decode = VerifyStream.decode;
jws$3.isValid = VerifyStream.isValid;
jws$3.createSign = function createSign(opts) {
  return new SignStream(opts);
};
jws$3.createVerify = function createVerify(opts) {
  return new VerifyStream(opts);
};

var jws$2 = jws$3;

var decode$2 = function (jwt, options) {
  options = options || {};
  var decoded = jws$2.decode(jwt, options);
  if (!decoded) { return null; }
  var payload = decoded.payload;

  //try parse the payload
  if(typeof payload === 'string') {
    try {
      var obj = JSON.parse(payload);
      if(obj !== null && typeof obj === 'object') {
        payload = obj;
      }
    } catch (e) { }
  }

  //return header if `complete` option is enabled.  header includes claims
  //such as `kid` and `alg` used to select the key within a JWKS needed to
  //verify the signature
  if (options.complete === true) {
    return {
      header: decoded.header,
      payload: payload,
      signature: decoded.signature
    };
  }
  return payload;
};

var JsonWebTokenError$3 = function (message, error) {
  Error.call(this, message);
  if(Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
};

JsonWebTokenError$3.prototype = Object.create(Error.prototype);
JsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;

var JsonWebTokenError_1 = JsonWebTokenError$3;

var JsonWebTokenError$2 = JsonWebTokenError_1;

var NotBeforeError$1 = function (message, date) {
  JsonWebTokenError$2.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
};

NotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);

NotBeforeError$1.prototype.constructor = NotBeforeError$1;

var NotBeforeError_1 = NotBeforeError$1;

var JsonWebTokenError$1 = JsonWebTokenError_1;

var TokenExpiredError$1 = function (message, expiredAt) {
  JsonWebTokenError$1.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
};

TokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);

TokenExpiredError$1.prototype.constructor = TokenExpiredError$1;

var TokenExpiredError_1 = TokenExpiredError$1;

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$1 = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$8(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$8(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

var ms = ms$1;

var timespan$2 = function (time, iat) {
  var timestamp = iat || Math.floor(Date.now() / 1000);

  if (typeof time === 'string') {
    var milliseconds = ms(time);
    if (typeof milliseconds === 'undefined') {
      return;
    }
    return Math.floor(timestamp + milliseconds / 1000);
  } else if (typeof time === 'number') {
    return timestamp + time;
  } else {
    return;
  }

};

var re$2 = {exports: {}};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';

const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$2 = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991;

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
];

var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
};

const debug$2 = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {};

var debug_1 = debug$2;

(function (module, exports$1) {

	const {
	  MAX_SAFE_COMPONENT_LENGTH,
	  MAX_SAFE_BUILD_LENGTH,
	  MAX_LENGTH,
	} = constants$1;
	const debug = debug_1;
	exports$1 = module.exports = {};

	// The actual regexps go on exports.re
	const re = exports$1.re = [];
	const safeRe = exports$1.safeRe = [];
	const src = exports$1.src = [];
	const safeSrc = exports$1.safeSrc = [];
	const t = exports$1.t = {};
	let R = 0;

	const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

	// Replace some greedy regex tokens to prevent regex dos issues. These regex are
	// used internally via the safeRe object since all inputs in this library get
	// normalized first to trim and collapse all extra whitespace. The original
	// regexes are exported for userland consumption and lower level usage. A
	// future breaking change could export the safer regex only with a note that
	// all input should have extra whitespace removed.
	const safeRegexReplacements = [
	  ['\\s', 1],
	  ['\\d', MAX_LENGTH],
	  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
	];

	const makeSafeRegex = (value) => {
	  for (const [token, max] of safeRegexReplacements) {
	    value = value
	      .split(`${token}*`).join(`${token}{0,${max}}`)
	      .split(`${token}+`).join(`${token}{1,${max}}`);
	  }
	  return value
	};

	const createToken = (name, value, isGlobal) => {
	  const safe = makeSafeRegex(value);
	  const index = R++;
	  debug(name, index, value);
	  t[name] = index;
	  src[index] = value;
	  safeSrc[index] = safe;
	  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
	  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
	};

	// The following Regular Expressions can be used for tokenizing,
	// validating, and parsing SemVer version strings.

	// ## Numeric Identifier
	// A single `0`, or a non-zero digit followed by zero or more digits.

	createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
	createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

	// ## Non-numeric Identifier
	// Zero or more digits, followed by a letter or hyphen, and then zero or
	// more letters, digits, or hyphens.

	createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

	// ## Main Version
	// Three dot-separated numeric identifiers.

	createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
	                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
	                   `(${src[t.NUMERICIDENTIFIER]})`);

	createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
	                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
	                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

	// ## Pre-release Version Identifier
	// A numeric identifier, or a non-numeric identifier.
	// Non-numberic identifiers include numberic identifiers but can be longer.
	// Therefore non-numberic identifiers must go first.

	createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]
	}|${src[t.NUMERICIDENTIFIER]})`);

	createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]
	}|${src[t.NUMERICIDENTIFIERLOOSE]})`);

	// ## Pre-release Version
	// Hyphen, followed by one or more dot-separated pre-release version
	// identifiers.

	createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
	}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

	createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
	}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

	// ## Build Metadata Identifier
	// Any combination of digits, letters, or hyphens.

	createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

	// ## Build Metadata
	// Plus sign, followed by one or more period-separated build metadata
	// identifiers.

	createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
	}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

	// ## Full Version String
	// A main version, followed optionally by a pre-release version and
	// build metadata.

	// Note that the only major, minor, patch, and pre-release sections of
	// the version string are capturing groups.  The build metadata is not a
	// capturing group, because it should not ever be used in version
	// comparison.

	createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
	}${src[t.PRERELEASE]}?${
	  src[t.BUILD]}?`);

	createToken('FULL', `^${src[t.FULLPLAIN]}$`);

	// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
	// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
	// common in the npm registry.
	createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
	}${src[t.PRERELEASELOOSE]}?${
	  src[t.BUILD]}?`);

	createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

	createToken('GTLT', '((?:<|>)?=?)');

	// Something like "2.*" or "1.2.x".
	// Note that "x.x" is a valid xRange identifer, meaning "any version"
	// Only the first item is strictly required.
	createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
	createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

	createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:${src[t.PRERELEASE]})?${
	                     src[t.BUILD]}?` +
	                   `)?)?`);

	createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:${src[t.PRERELEASELOOSE]})?${
	                          src[t.BUILD]}?` +
	                        `)?)?`);

	createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
	createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

	// Coercion.
	// Extract anything that could conceivably be a part of a valid semver
	createToken('COERCEPLAIN', `${'(^|[^\\d])' +
	              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
	              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
	              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
	createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
	createToken('COERCEFULL', src[t.COERCEPLAIN] +
	              `(?:${src[t.PRERELEASE]})?` +
	              `(?:${src[t.BUILD]})?` +
	              `(?:$|[^\\d])`);
	createToken('COERCERTL', src[t.COERCE], true);
	createToken('COERCERTLFULL', src[t.COERCEFULL], true);

	// Tilde ranges.
	// Meaning is "reasonably at or greater than"
	createToken('LONETILDE', '(?:~>?)');

	createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
	exports$1.tildeTrimReplace = '$1~';

	createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
	createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

	// Caret ranges.
	// Meaning is "at least and backwards compatible with"
	createToken('LONECARET', '(?:\\^)');

	createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
	exports$1.caretTrimReplace = '$1^';

	createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
	createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

	// A simple gt/lt/eq thing, or just "" to indicate "any version"
	createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
	createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

	// An expression to strip any whitespace between the gtlt and the thing
	// it modifies, so that `> 1.2.3` ==> `>1.2.3`
	createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
	}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
	exports$1.comparatorTrimReplace = '$1$2$3';

	// Something like `1.2.3 - 1.2.4`
	// Note that these all use the loose form, because they'll be
	// checked against either the strict or loose comparator form
	// later.
	createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
	                   `\\s+-\\s+` +
	                   `(${src[t.XRANGEPLAIN]})` +
	                   `\\s*$`);

	createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
	                        `\\s+-\\s+` +
	                        `(${src[t.XRANGEPLAINLOOSE]})` +
	                        `\\s*$`);

	// Star ranges basically just allow anything at all.
	createToken('STAR', '(<|>)?=?\\s*\\*');
	// >=0.0.0 is like a star
	createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
	createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
} (re$2, re$2.exports));

var reExports = re$2.exports;

// parse out just the options we care about
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({ });
const parseOptions$1 = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
};
var parseOptions_1 = parseOptions$1;

const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  if (typeof a === 'number' && typeof b === 'number') {
    return a === b ? 0 : a < b ? -1 : 1
  }

  const anum = numeric.test(a);
  const bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
};

const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);

var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers,
};

const debug$1 = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1 } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;

const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor (version, options) {
    options = parseOptions(options);

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
        version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug$1('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;

    const m = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version;

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER$1 || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER$1 || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER$1 || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER$1) {
            return num
          }
        }
        return id
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`;
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug$1('SemVer.compare', this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options);
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    if (this.major < other.major) {
      return -1
    }
    if (this.major > other.major) {
      return 1
    }
    if (this.minor < other.minor) {
      return -1
    }
    if (this.minor > other.minor) {
      return 1
    }
    if (this.patch < other.patch) {
      return -1
    }
    if (this.patch > other.patch) {
      return 1
    }
    return 0
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug$1('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug$1('build compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    if (release.startsWith('pre')) {
      if (!identifier && identifierBase === false) {
        throw new Error('invalid increment argument: identifier is empty')
      }
      // Avoid an invalid semver results
      if (identifier) {
        const match = `-${identifier}`.match(this.options.loose ? re$1[t$1.PRERELEASELOOSE] : re$1[t$1.PRERELEASE]);
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`)
        }
      }
    }

    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier, identifierBase);
        break
      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier, identifierBase);
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier, identifierBase);
        this.inc('pre', identifier, identifierBase);
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase);
        }
        this.inc('pre', identifier, identifierBase);
        break
      case 'release':
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`)
        }
        this.prerelease.length = 0;
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0;

        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base];
          if (identifierBase === false) {
            prerelease = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease;
            }
          } else {
            this.prerelease = prerelease;
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`;
    }
    return this
  }
};

var semver$4 = SemVer$d;

const SemVer$c = semver$4;
const parse$7 = (version, options, throwErrors = false) => {
  if (version instanceof SemVer$c) {
    return version
  }
  try {
    return new SemVer$c(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
};

var parse_1 = parse$7;

const parse$6 = parse_1;
const valid$2 = (version, options) => {
  const v = parse$6(version, options);
  return v ? v.version : null
};
var valid_1 = valid$2;

const parse$5 = parse_1;
const clean$1 = (version, options) => {
  const s = parse$5(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null
};
var clean_1 = clean$1;

const SemVer$b = semver$4;

const inc$1 = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier;
    identifier = options;
    options = undefined;
  }

  try {
    return new SemVer$b(
      version instanceof SemVer$b ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
};
var inc_1 = inc$1;

const parse$4 = parse_1;

const diff$1 = (version1, version2) => {
  const v1 = parse$4(version1, null, true);
  const v2 = parse$4(version2, null, true);
  const comparison = v1.compare(v2);

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;

  if (lowHasPre && !highHasPre) {
    // Going from prerelease -> no prerelease requires some special casing

    // If the low version has only a major, then it will always be a major
    // Some examples:
    // 1.0.0-1 -> 1.0.0
    // 1.0.0-1 -> 1.1.1
    // 1.0.0-1 -> 2.0.0
    if (!lowVersion.patch && !lowVersion.minor) {
      return 'major'
    }

    // If the main part has no difference
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return 'minor'
      }
      return 'patch'
    }
  }

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : '';

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // high and low are preleases
  return 'prerelease'
};

var diff_1 = diff$1;

const SemVer$a = semver$4;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;

const SemVer$9 = semver$4;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;

const SemVer$8 = semver$4;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;

const parse$3 = parse_1;
const prerelease$1 = (version, options) => {
  const parsed = parse$3(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
};
var prerelease_1 = prerelease$1;

const SemVer$7 = semver$4;
const compare$b = (a, b, loose) =>
  new SemVer$7(a, loose).compare(new SemVer$7(b, loose));

var compare_1 = compare$b;

const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;

const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;

const SemVer$6 = semver$4;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
};
var compareBuild_1 = compareBuild$3;

const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;

const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;

const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;

const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;

const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;

const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;

const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;

const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;

const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;

const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version;
      }
      if (typeof b === 'object') {
        b = b.version;
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version;
      }
      if (typeof b === 'object') {
        b = b.version;
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq$1(a, b, loose)

    case '!=':
      return neq$1(a, b, loose)

    case '>':
      return gt$3(a, b, loose)

    case '>=':
      return gte$2(a, b, loose)

    case '<':
      return lt$2(a, b, loose)

    case '<=':
      return lte$2(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
};
var cmp_1 = cmp$1;

const SemVer$5 = semver$4;
const parse$2 = parse_1;
const { safeRe: re, t } = reExports;

const coerce$1 = (version, options) => {
  if (version instanceof SemVer$5) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {};

  let match = null;
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    // leave it in a clean state
    coerceRtlRegex.lastIndex = -1;
  }

  if (match === null) {
    return null
  }

  const major = match[2];
  const minor = match[3] || '0';
  const patch = match[4] || '0';
  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';

  return parse$2(`${major}.${minor}.${patch}${prerelease}${build}`, options)
};
var coerce_1 = coerce$1;

var lrucache;
var hasRequiredLrucache;

function requireLrucache () {
	if (hasRequiredLrucache) return lrucache;
	hasRequiredLrucache = 1;

	class LRUCache {
	  constructor () {
	    this.max = 1000;
	    this.map = new Map();
	  }

	  get (key) {
	    const value = this.map.get(key);
	    if (value === undefined) {
	      return undefined
	    } else {
	      // Remove the key from the map and add it to the end
	      this.map.delete(key);
	      this.map.set(key, value);
	      return value
	    }
	  }

	  delete (key) {
	    return this.map.delete(key)
	  }

	  set (key, value) {
	    const deleted = this.delete(key);

	    if (!deleted && value !== undefined) {
	      // If cache is full, delete the least recently used item
	      if (this.map.size >= this.max) {
	        const firstKey = this.map.keys().next().value;
	        this.delete(firstKey);
	      }

	      this.map.set(key, value);
	    }

	    return this
	  }
	}

	lrucache = LRUCache;
	return lrucache;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	const SPACE_CHARACTERS = /\s+/g;

	// hoisted class for cyclic dependency
	class Range {
	  constructor (range, options) {
	    options = parseOptions(options);

	    if (range instanceof Range) {
	      if (
	        range.loose === !!options.loose &&
	        range.includePrerelease === !!options.includePrerelease
	      ) {
	        return range
	      } else {
	        return new Range(range.raw, options)
	      }
	    }

	    if (range instanceof Comparator) {
	      // just put it in the set and return
	      this.raw = range.value;
	      this.set = [[range]];
	      this.formatted = undefined;
	      return this
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;

	    // First reduce all whitespace as much as possible so we do not have to rely
	    // on potentially slow regexes like \s*. This is then stored and used for
	    // future error messages as well.
	    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');

	    // First, split on ||
	    this.set = this.raw
	      .split('||')
	      // map the range to a 2d array of comparators
	      .map(r => this.parseRange(r.trim()))
	      // throw out any comparator lists that are empty
	      // this generally means that it was not a valid range, which is allowed
	      // in loose mode, but will still throw if the WHOLE range is invalid.
	      .filter(c => c.length);

	    if (!this.set.length) {
	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
	    }

	    // if we have any that are not the null set, throw out null sets.
	    if (this.set.length > 1) {
	      // keep the first one, in case they're all null sets
	      const first = this.set[0];
	      this.set = this.set.filter(c => !isNullSet(c[0]));
	      if (this.set.length === 0) {
	        this.set = [first];
	      } else if (this.set.length > 1) {
	        // if we have any that are *, then the range is just *
	        for (const c of this.set) {
	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break
	          }
	        }
	      }
	    }

	    this.formatted = undefined;
	  }

	  get range () {
	    if (this.formatted === undefined) {
	      this.formatted = '';
	      for (let i = 0; i < this.set.length; i++) {
	        if (i > 0) {
	          this.formatted += '||';
	        }
	        const comps = this.set[i];
	        for (let k = 0; k < comps.length; k++) {
	          if (k > 0) {
	            this.formatted += ' ';
	          }
	          this.formatted += comps[k].toString().trim();
	        }
	      }
	    }
	    return this.formatted
	  }

	  format () {
	    return this.range
	  }

	  toString () {
	    return this.range
	  }

	  parseRange (range) {
	    // memoize range parsing for performance.
	    // this is a very hot path, and fully deterministic.
	    const memoOpts =
	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
	      (this.options.loose && FLAG_LOOSE);
	    const memoKey = memoOpts + ':' + range;
	    const cached = cache.get(memoKey);
	    if (cached) {
	      return cached
	    }

	    const loose = this.options.loose;
	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug('hyphen replace', range);

	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range);

	    // `~ 1.2.3` => `~1.2.3`
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    debug('tilde trim', range);

	    // `^ 1.2.3` => `^1.2.3`
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    debug('caret trim', range);

	    // At this point, the range is completely trimmed and
	    // ready to be split into comparators.

	    let rangeList = range
	      .split(' ')
	      .map(comp => parseComparator(comp, this.options))
	      .join(' ')
	      .split(/\s+/)
	      // >=0.0.0 is equivalent to *
	      .map(comp => replaceGTE0(comp, this.options));

	    if (loose) {
	      // in loose mode, throw out any that are not valid comparators
	      rangeList = rangeList.filter(comp => {
	        debug('loose invalid filter', comp, this.options);
	        return !!comp.match(re[t.COMPARATORLOOSE])
	      });
	    }
	    debug('range list', rangeList);

	    // if any comparators are the null set, then replace with JUST null set
	    // if more than one comparator, remove any * comparators
	    // also, don't include the same comparator more than once
	    const rangeMap = new Map();
	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
	    for (const comp of comparators) {
	      if (isNullSet(comp)) {
	        return [comp]
	      }
	      rangeMap.set(comp.value, comp);
	    }
	    if (rangeMap.size > 1 && rangeMap.has('')) {
	      rangeMap.delete('');
	    }

	    const result = [...rangeMap.values()];
	    cache.set(memoKey, result);
	    return result
	  }

	  intersects (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required')
	    }

	    return this.set.some((thisComparators) => {
	      return (
	        isSatisfiable(thisComparators, options) &&
	        range.set.some((rangeComparators) => {
	          return (
	            isSatisfiable(rangeComparators, options) &&
	            thisComparators.every((thisComparator) => {
	              return rangeComparators.every((rangeComparator) => {
	                return thisComparator.intersects(rangeComparator, options)
	              })
	            })
	          )
	        })
	      )
	    })
	  }

	  // if ANY of the sets match ALL of its comparators, then pass
	  test (version) {
	    if (!version) {
	      return false
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    for (let i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true
	      }
	    }
	    return false
	  }
	}

	range = Range;

	const LRU = /*@__PURE__*/ requireLrucache();
	const cache = new LRU();

	const parseOptions = parseOptions_1;
	const Comparator = /*@__PURE__*/ requireComparator();
	const debug = debug_1;
	const SemVer = semver$4;
	const {
	  safeRe: re,
	  t,
	  comparatorTrimReplace,
	  tildeTrimReplace,
	  caretTrimReplace,
	} = reExports;
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;

	const isNullSet = c => c.value === '<0.0.0-0';
	const isAny = c => c.value === '';

	// take a set of comparators and determine whether there
	// exists a version which can satisfy it
	const isSatisfiable = (comparators, options) => {
	  let result = true;
	  const remainingComparators = comparators.slice();
	  let testComparator = remainingComparators.pop();

	  while (result && remainingComparators.length) {
	    result = remainingComparators.every((otherComparator) => {
	      return testComparator.intersects(otherComparator, options)
	    });

	    testComparator = remainingComparators.pop();
	  }

	  return result
	};

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	const parseComparator = (comp, options) => {
	  comp = comp.replace(re[t.BUILD], '');
	  debug('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug('stars', comp);
	  return comp
	};

	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
	// ~0.0.1 --> >=0.0.1 <0.1.0-0
	const replaceTildes = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceTilde(c, options))
	    .join(' ')
	};

	const replaceTilde = (comp, options) => {
	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('tilde', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      // ~1.2 == >=1.2.0 <1.3.0-0
	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
	    } else if (pr) {
	      debug('replaceTilde pr', pr);
	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
	    } else {
	      // ~1.2.3 == >=1.2.3 <1.3.0-0
	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('tilde return', ret);
	    return ret
	  })
	};

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
	// ^1.2.3 --> >=1.2.3 <2.0.0-0
	// ^1.2.0 --> >=1.2.0 <2.0.0-0
	// ^0.0.1 --> >=0.0.1 <0.0.2-0
	// ^0.1.0 --> >=0.1.0 <0.2.0-0
	const replaceCarets = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceCaret(c, options))
	    .join(' ')
	};

	const replaceCaret = (comp, options) => {
	  debug('caret', comp, options);
	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	  const z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('caret', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
	      } else {
	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
	      }
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
	      }
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
	      }
	    }

	    debug('caret return', ret);
	    return ret
	  })
	};

	const replaceXRanges = (comp, options) => {
	  debug('replaceXRanges', comp, options);
	  return comp
	    .split(/\s+/)
	    .map((c) => replaceXRange(c, options))
	    .join(' ')
	};

	const replaceXRange = (comp, options) => {
	  comp = comp.trim();
	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    const xM = isX(M);
	    const xm = xM || isX(m);
	    const xp = xm || isX(p);
	    const anyX = xp;

	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }

	    // if we're including prereleases in the match, then we need
	    // to fix this to -0, the lowest possible prerelease value
	    pr = options.includePrerelease ? '-0' : '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0-0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // we know patch is an x, because we have any x at all.
	      // replace X with 0
	      if (xm) {
	        m = 0;
	      }
	      p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }

	      if (gtlt === '<') {
	        pr = '-0';
	      }

	      ret = `${gtlt + M}.${m}.${p}${pr}`;
	    } else if (xm) {
	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
	    } else if (xp) {
	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('xRange return', ret);

	    return ret
	  })
	};

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	const replaceStars = (comp, options) => {
	  debug('replaceStars', comp, options);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp
	    .trim()
	    .replace(re[t.STAR], '')
	};

	const replaceGTE0 = (comp, options) => {
	  debug('replaceGTE0', comp, options);
	  return comp
	    .trim()
	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
	};

	// This function is passed to string.replace(re[t.HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
	// TODO build?
	const hyphenReplace = incPr => ($0,
	  from, fM, fm, fp, fpr, fb,
	  to, tM, tm, tp, tpr) => {
	  if (isX(fM)) {
	    from = '';
	  } else if (isX(fm)) {
	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
	  } else if (isX(fp)) {
	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
	  } else if (fpr) {
	    from = `>=${from}`;
	  } else {
	    from = `>=${from}${incPr ? '-0' : ''}`;
	  }

	  if (isX(tM)) {
	    to = '';
	  } else if (isX(tm)) {
	    to = `<${+tM + 1}.0.0-0`;
	  } else if (isX(tp)) {
	    to = `<${tM}.${+tm + 1}.0-0`;
	  } else if (tpr) {
	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
	  } else if (incPr) {
	    to = `<${tM}.${tm}.${+tp + 1}-0`;
	  } else {
	    to = `<=${to}`;
	  }

	  return `${from} ${to}`.trim()
	};

	const testSet = (set, version, options) => {
	  for (let i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false
	    }
	  }

	  if (version.prerelease.length && !options.includePrerelease) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (let i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === Comparator.ANY) {
	        continue
	      }

	      if (set[i].semver.prerelease.length > 0) {
	        const allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch) {
	          return true
	        }
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false
	  }

	  return true
	};
	return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator () {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;

	const ANY = Symbol('SemVer ANY');
	// hoisted class for cyclic dependency
	class Comparator {
	  static get ANY () {
	    return ANY
	  }

	  constructor (comp, options) {
	    options = parseOptions(options);

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp
	      } else {
	        comp = comp.value;
	      }
	    }

	    comp = comp.trim().split(/\s+/).join(' ');
	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  parse (comp) {
	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    const m = comp.match(r);

	    if (!m) {
	      throw new TypeError(`Invalid comparator: ${comp}`)
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';
	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    // if it literally is just '>' or '' then allow anything.
	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  }

	  toString () {
	    return this.value
	  }

	  test (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options)
	  }

	  intersects (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required')
	    }

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true
	      }
	      return new Range(comp.value, options).test(this.value)
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true
	      }
	      return new Range(this.value, options).test(comp.semver)
	    }

	    options = parseOptions(options);

	    // Special cases where nothing can possibly be lower
	    if (options.includePrerelease &&
	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
	      return false
	    }
	    if (!options.includePrerelease &&
	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
	      return false
	    }

	    // Same direction increasing (> or >=)
	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
	      return true
	    }
	    // Same direction decreasing (< or <=)
	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // same SemVer and both sides are inclusive (<= or >=)
	    if (
	      (this.semver.version === comp.semver.version) &&
	      this.operator.includes('=') && comp.operator.includes('=')) {
	      return true
	    }
	    // opposite directions less than
	    if (cmp(this.semver, '<', comp.semver, options) &&
	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // opposite directions greater than
	    if (cmp(this.semver, '>', comp.semver, options) &&
	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
	      return true
	    }
	    return false
	  }
	}

	comparator = Comparator;

	const parseOptions = parseOptions_1;
	const { safeRe: re, t } = reExports;
	const cmp = cmp_1;
	const debug = debug_1;
	const SemVer = semver$4;
	const Range = /*@__PURE__*/ requireRange();
	return comparator;
}

const Range$9 = /*@__PURE__*/ requireRange();
const satisfies$4 = (version, range, options) => {
  try {
    range = new Range$9(range, options);
  } catch (er) {
    return false
  }
  return range.test(version)
};
var satisfies_1 = satisfies$4;

const Range$8 = /*@__PURE__*/ requireRange();

// Mostly just for testing and legacy API reasons
const toComparators$1 = (range, options) =>
  new Range$8(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

var toComparators_1 = toComparators$1;

const SemVer$4 = semver$4;
const Range$7 = /*@__PURE__*/ requireRange();

const maxSatisfying$1 = (versions, range, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer$4(max, options);
      }
    }
  });
  return max
};
var maxSatisfying_1 = maxSatisfying$1;

const SemVer$3 = semver$4;
const Range$6 = /*@__PURE__*/ requireRange();
const minSatisfying$1 = (versions, range, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer$3(min, options);
      }
    }
  });
  return min
};
var minSatisfying_1 = minSatisfying$1;

const SemVer$2 = semver$4;
const Range$5 = /*@__PURE__*/ requireRange();
const gt$2 = gt_1;

const minVersion$1 = (range, loose) => {
  range = new Range$5(range, loose);

  let minver = new SemVer$2('0.0.0');
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer$2('0.0.0-0');
  if (range.test(minver)) {
    return minver
  }

  minver = null;
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i];

    let setMin = null;
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer$2(comparator.semver.version);
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
};
var minVersion_1 = minVersion$1;

const Range$4 = /*@__PURE__*/ requireRange();
const validRange$1 = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range$4(range, options).range || '*'
  } catch (er) {
    return null
  }
};
var valid$1 = validRange$1;

const SemVer$1 = semver$4;
const Comparator$2 = /*@__PURE__*/ requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = /*@__PURE__*/ requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;

const outside$3 = (version, range, hilo, options) => {
  version = new SemVer$1(version, options);
  range = new Range$3(range, options);

  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = '>';
      ecomp = '>=';
      break
    case '<':
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = '<';
      ecomp = '<=';
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies$3(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i];

    let high = null;
    let low = null;

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY$1) {
        comparator = new Comparator$2('>=0.0.0');
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
};

var outside_1 = outside$3;

// Determine if version is greater than all the versions possible in the range.
const outside$2 = outside_1;
const gtr$1 = (version, range, options) => outside$2(version, range, '>', options);
var gtr_1 = gtr$1;

const outside$1 = outside_1;
// Determine if version is less than all the versions possible in the range
const ltr$1 = (version, range, options) => outside$1(version, range, '<', options);
var ltr_1 = ltr$1;

const Range$2 = /*@__PURE__*/ requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options)
};
var intersects_1 = intersects$1;

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range, options) => {
  const set = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version of v) {
    const included = satisfies$2(version, range, options);
    if (included) {
      prev = version;
      if (!first) {
        first = version;
      }
    } else {
      if (prev) {
        set.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set.push([first, null]);
  }

  const ranges = [];
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push('*');
    } else if (!max) {
      ranges.push(`>=${min}`);
    } else if (min === v[0]) {
      ranges.push(`<=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(' || ');
  const original = typeof range.raw === 'string' ? range.raw : String(range);
  return simplified.length < original.length ? simplified : range
};

const Range$1 = /*@__PURE__*/ requireRange();
const Comparator$1 = /*@__PURE__*/ requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
};

const minimumVersionWithPreRelease = [new Comparator$1('>=0.0.0-0')];
const minimumVersion = [new Comparator$1('>=0.0.0')];

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion;
    }
  }

  const eqSet = new Set();
  let gt, lt;
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options);
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp;
  if (gt && lt) {
    gtltComp = compare$1(gt.semver, lt.semver, options);
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies$1(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies$1(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies$1(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower;
  let hasDomLT, hasDomGT;
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false;
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false;
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options);
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies$1(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options);
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies$1(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
};

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
};

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
};

var subset_1 = subset$1;

// just pre-load all the stuff that index.js lazily exports
const internalRe = reExports;
const constants = constants$1;
const SemVer = semver$4;
const identifiers = identifiers$1;
const parse$1 = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = /*@__PURE__*/ requireComparator();
const Range = /*@__PURE__*/ requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver$3 = {
  parse: parse$1,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
};

const semver$2 = semver$3;

var asymmetricKeyDetailsSupported = semver$2.satisfies(process.version, '>=15.7.0');

const semver$1 = semver$3;

var rsaPssKeyDetailsSupported = semver$1.satisfies(process.version, '>=16.9.0');

const ASYMMETRIC_KEY_DETAILS_SUPPORTED = asymmetricKeyDetailsSupported;
const RSA_PSS_KEY_DETAILS_SUPPORTED = rsaPssKeyDetailsSupported;

const allowedAlgorithmsForKeys = {
  'ec': ['ES256', 'ES384', 'ES512'],
  'rsa': ['RS256', 'PS256', 'RS384', 'PS384', 'RS512', 'PS512'],
  'rsa-pss': ['PS256', 'PS384', 'PS512']
};

const allowedCurves = {
  ES256: 'prime256v1',
  ES384: 'secp384r1',
  ES512: 'secp521r1',
};

var validateAsymmetricKey$2 = function(algorithm, key) {
  if (!algorithm || !key) return;

  const keyType = key.asymmetricKeyType;
  if (!keyType) return;

  const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];

  if (!allowedAlgorithms) {
    throw new Error(`Unknown key type "${keyType}".`);
  }

  if (!allowedAlgorithms.includes(algorithm)) {
    throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(', ')}.`)
  }

  /*
   * Ignore the next block from test coverage because it gets executed
   * conditionally depending on the Node version. Not ignoring it would
   * prevent us from reaching the target % of coverage for versions of
   * Node under 15.7.0.
   */
  /* istanbul ignore next */
  if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
    switch (keyType) {
    case 'ec':
      const keyCurve = key.asymmetricKeyDetails.namedCurve;
      const allowedCurve = allowedCurves[algorithm];

      if (keyCurve !== allowedCurve) {
        throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
      }
      break;

    case 'rsa-pss':
      if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
        const length = parseInt(algorithm.slice(-3), 10);
        const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;

        if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
          throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
        }

        if (saltLength !== undefined && saltLength > length >> 3) {
          throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`)
        }
      }
      break;
    }
  }
};

var semver = semver$3;

var psSupported = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');

const JsonWebTokenError = JsonWebTokenError_1;
const NotBeforeError = NotBeforeError_1;
const TokenExpiredError = TokenExpiredError_1;
const decode$1 = decode$2;
const timespan$1 = timespan$2;
const validateAsymmetricKey$1 = validateAsymmetricKey$2;
const PS_SUPPORTED$1 = psSupported;
const jws$1 = jws$3;
const {KeyObject: KeyObject$1, createSecretKey: createSecretKey$1, createPublicKey} = require$$3$3;

const PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
const EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];
const RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
const HS_ALGS = ['HS256', 'HS384', 'HS512'];

if (PS_SUPPORTED$1) {
  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
}

var verify = function (jwtString, secretOrPublicKey, options, callback) {
  if ((typeof options === 'function') && !callback) {
    callback = options;
    options = {};
  }

  if (!options) {
    options = {};
  }

  //clone this object since we are going to mutate it.
  options = Object.assign({}, options);

  let done;

  if (callback) {
    done = callback;
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }

  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
    return done(new JsonWebTokenError('clockTimestamp must be a number'));
  }

  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {
    return done(new JsonWebTokenError('nonce must be a non-empty string'));
  }

  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {
    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));
  }

  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

  if (!jwtString){
    return done(new JsonWebTokenError('jwt must be provided'));
  }

  if (typeof jwtString !== 'string') {
    return done(new JsonWebTokenError('jwt must be a string'));
  }

  const parts = jwtString.split('.');

  if (parts.length !== 3){
    return done(new JsonWebTokenError('jwt malformed'));
  }

  let decodedToken;

  try {
    decodedToken = decode$1(jwtString, { complete: true });
  } catch(err) {
    return done(err);
  }

  if (!decodedToken) {
    return done(new JsonWebTokenError('invalid token'));
  }

  const header = decodedToken.header;
  let getSecret;

  if(typeof secretOrPublicKey === 'function') {
    if(!callback) {
      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));
    }

    getSecret = secretOrPublicKey;
  }
  else {
    getSecret = function(header, secretCallback) {
      return secretCallback(null, secretOrPublicKey);
    };
  }

  return getSecret(header, function(err, secretOrPublicKey) {
    if(err) {
      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));
    }

    const hasSignature = parts[2].trim() !== '';

    if (!hasSignature && secretOrPublicKey){
      return done(new JsonWebTokenError('jwt signature is required'));
    }

    if (hasSignature && !secretOrPublicKey) {
      return done(new JsonWebTokenError('secret or public key must be provided'));
    }

    if (!hasSignature && !options.algorithms) {
      return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
    }

    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject$1)) {
      try {
        secretOrPublicKey = createPublicKey(secretOrPublicKey);
      } catch (_) {
        try {
          secretOrPublicKey = createSecretKey$1(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);
        } catch (_) {
          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'))
        }
      }
    }

    if (!options.algorithms) {
      if (secretOrPublicKey.type === 'secret') {
        options.algorithms = HS_ALGS;
      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {
        options.algorithms = RSA_KEY_ALGS;
      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {
        options.algorithms = EC_KEY_ALGS;
      } else {
        options.algorithms = PUB_KEY_ALGS;
      }
    }

    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
      return done(new JsonWebTokenError('invalid algorithm'));
    }

    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {
      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using ${header.alg}`)))
    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {
      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))
    }

    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey$1(header.alg, secretOrPublicKey);
      } catch (e) {
        return done(e);
      }
    }

    let valid;

    try {
      valid = jws$1.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
    } catch (e) {
      return done(e);
    }

    if (!valid) {
      return done(new JsonWebTokenError('invalid signature'));
    }

    const payload = decodedToken.payload;

    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
      if (typeof payload.nbf !== 'number') {
        return done(new JsonWebTokenError('invalid nbf value'));
      }
      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
      }
    }

    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
      if (typeof payload.exp !== 'number') {
        return done(new JsonWebTokenError('invalid exp value'));
      }
      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
      }
    }

    if (options.audience) {
      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

      const match = target.some(function (targetAudience) {
        return audiences.some(function (audience) {
          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
        });
      });

      if (!match) {
        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
      }
    }

    if (options.issuer) {
      const invalid_issuer =
              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

      if (invalid_issuer) {
        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
      }
    }

    if (options.subject) {
      if (payload.sub !== options.subject) {
        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
      }
    }

    if (options.jwtid) {
      if (payload.jti !== options.jwtid) {
        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
      }
    }

    if (options.nonce) {
      if (payload.nonce !== options.nonce) {
        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
      }
    }

    if (options.maxAge) {
      if (typeof payload.iat !== 'number') {
        return done(new JsonWebTokenError('iat required when maxAge is specified'));
      }

      const maxAgeTimestamp = timespan$1(options.maxAge, payload.iat);
      if (typeof maxAgeTimestamp === 'undefined') {
        return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));
      }
    }

    if (options.complete === true) {
      const signature = decodedToken.signature;

      return done(null, {
        header: header,
        payload: payload,
        signature: signature
      });
    }

    return done(null, payload);
  });
};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER$2 = 1.7976931348623157e+308,
    NAN$2 = 0 / 0;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    stringTag$1 = '[object String]',
    symbolTag$2 = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim$2 = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary$2 = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal$2 = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt$2 = parseInt;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (-1);

  while ((++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$6.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$6 = objectProto$6.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg$1(Object.keys, Object),
    nativeMax = Math.max;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray$1(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$1.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;

  return value === proto;
}

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes$1(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger$2(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString$2(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty$1.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString$6.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike$6(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$2(value) ? objectToString$6.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$2(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$6(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString$2(value) {
  return typeof value == 'string' ||
    (!isArray$1(value) && isObjectLike$6(value) && objectToString$6.call(value) == stringTag$1);
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$2(value) {
  return typeof value == 'symbol' ||
    (isObjectLike$6(value) && objectToString$6.call(value) == symbolTag$2);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite$2(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$2(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER$2;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger$2(value) {
  var result = toFinite$2(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber$2(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN$2;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$2(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$2, '');
  var isBinary = reIsBinary$2.test(value);
  return (isBinary || reIsOctal$2.test(value))
    ? freeParseInt$2(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex$2.test(value) ? NAN$2 : +value);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object ? baseValues(object, keys(object)) : [];
}

var lodash_includes = includes$1;

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$5 = objectProto$5.toString;

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean$1(value) {
  return value === true || value === false ||
    (isObjectLike$5(value) && objectToString$5.call(value) == boolTag);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$5(value) {
  return !!value && typeof value == 'object';
}

var lodash_isboolean = isBoolean$1;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0,
    MAX_INTEGER$1 = 1.7976931348623157e+308,
    NAN$1 = 0 / 0;

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim$1 = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary$1 = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal$1 = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt$1 = parseInt;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$4 = objectProto$4.toString;

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function isInteger$1(value) {
  return typeof value == 'number' && value == toInteger$1(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$4(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$1(value) {
  return typeof value == 'symbol' ||
    (isObjectLike$4(value) && objectToString$4.call(value) == symbolTag$1);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$1(value);
  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER$1;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger$1(value) {
  var result = toFinite$1(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber$1(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN$1;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$1, '');
  var isBinary = reIsBinary$1.test(value);
  return (isBinary || reIsOctal$1.test(value))
    ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex$1.test(value) ? NAN$1 : +value);
}

var lodash_isinteger = isInteger$1;

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$3 = objectProto$3.toString;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$3(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 * as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber$1(value) {
  return typeof value == 'number' ||
    (isObjectLike$3(value) && objectToString$3.call(value) == numberTag);
}

var lodash_isnumber = isNumber$1;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto$2.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$2 = objectProto$2.toString;

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$2(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject$1(value) {
  if (!isObjectLike$2(value) ||
      objectToString$2.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

var lodash_isplainobject = isPlainObject$1;

/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$1 = objectProto$1.toString;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$1(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString$1(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike$1(value) && objectToString$1.call(value) == stringTag);
}

var lodash_isstring = isString$1;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once$1(func) {
  return before(2, func);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_once = once$1;

const timespan = timespan$2;
const PS_SUPPORTED = psSupported;
const validateAsymmetricKey = validateAsymmetricKey$2;
const jws = jws$3;
const includes = lodash_includes;
const isBoolean = lodash_isboolean;
const isInteger = lodash_isinteger;
const isNumber = lodash_isnumber;
const isPlainObject = lodash_isplainobject;
const isString = lodash_isstring;
const once = lodash_once;
const { KeyObject, createSecretKey, createPrivateKey } = require$$3$3;

const SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];
if (PS_SUPPORTED) {
  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
}

const sign_options_schema = {
  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject, message: '"header" must be an object' },
  encoding: { isValid: isString, message: '"encoding" must be a string' },
  issuer: { isValid: isString, message: '"issuer" must be a string' },
  subject: { isValid: isString, message: '"subject" must be a string' },
  jwtid: { isValid: isString, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
  allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean'},
  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean'}
};

const registered_claims_schema = {
  iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
};

function validate$1(schema, allowUnknown, object, parameterName) {
  if (!isPlainObject(object)) {
    throw new Error('Expected "' + parameterName + '" to be a plain object.');
  }
  Object.keys(object)
    .forEach(function(key) {
      const validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object[key])) {
        throw new Error(validator.message);
      }
    });
}

function validateOptions(options) {
  return validate$1(sign_options_schema, false, options, 'options');
}

function validatePayload(payload) {
  return validate$1(registered_claims_schema, true, payload, 'payload');
}

const options_to_payload = {
  'audience': 'aud',
  'issuer': 'iss',
  'subject': 'sub',
  'jwtid': 'jti'
};

const options_for_objects = [
  'expiresIn',
  'notBefore',
  'noTimestamp',
  'audience',
  'issuer',
  'subject',
  'jwtid',
];

var sign = function (payload, secretOrPrivateKey, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  } else {
    options = options || {};
  }

  const isObjectPayload = typeof payload === 'object' &&
                        !Buffer.isBuffer(payload);

  const header = Object.assign({
    alg: options.algorithm || 'HS256',
    typ: isObjectPayload ? 'JWT' : undefined,
    kid: options.keyid
  }, options.header);

  function failure(err) {
    if (callback) {
      return callback(err);
    }
    throw err;
  }

  if (!secretOrPrivateKey && options.algorithm !== 'none') {
    return failure(new Error('secretOrPrivateKey must have a value'));
  }

  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
    try {
      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
    } catch (_) {
      try {
        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
      } catch (_) {
        return failure(new Error('secretOrPrivateKey is not valid key material'));
      }
    }
  }

  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {
    return failure(new Error((`secretOrPrivateKey must be a symmetric key when using ${header.alg}`)))
  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
    if (secretOrPrivateKey.type !== 'private') {
      return failure(new Error((`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`)))
    }
    if (!options.allowInsecureKeySizes &&
      !header.alg.startsWith('ES') &&
      secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+
      secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
    }
  }

  if (typeof payload === 'undefined') {
    return failure(new Error('payload is required'));
  } else if (isObjectPayload) {
    try {
      validatePayload(payload);
    }
    catch (error) {
      return failure(error);
    }
    if (!options.mutatePayload) {
      payload = Object.assign({},payload);
    }
  } else {
    const invalid_options = options_for_objects.filter(function (opt) {
      return typeof options[opt] !== 'undefined';
    });

    if (invalid_options.length > 0) {
      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
    }
  }

  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  }

  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  }

  try {
    validateOptions(options);
  }
  catch (error) {
    return failure(error);
  }

  if (!options.allowInvalidAsymmetricKeyTypes) {
    try {
      validateAsymmetricKey(header.alg, secretOrPrivateKey);
    } catch (error) {
      return failure(error);
    }
  }

  const timestamp = payload.iat || Math.floor(Date.now() / 1000);

  if (options.noTimestamp) {
    delete payload.iat;
  } else if (isObjectPayload) {
    payload.iat = timestamp;
  }

  if (typeof options.notBefore !== 'undefined') {
    try {
      payload.nbf = timespan(options.notBefore, timestamp);
    }
    catch (err) {
      return failure(err);
    }
    if (typeof payload.nbf === 'undefined') {
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
    try {
      payload.exp = timespan(options.expiresIn, timestamp);
    }
    catch (err) {
      return failure(err);
    }
    if (typeof payload.exp === 'undefined') {
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  Object.keys(options_to_payload).forEach(function (key) {
    const claim = options_to_payload[key];
    if (typeof options[key] !== 'undefined') {
      if (typeof payload[claim] !== 'undefined') {
        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
      }
      payload[claim] = options[key];
    }
  });

  const encoding = options.encoding || 'utf8';

  if (typeof callback === 'function') {
    callback = callback && once(callback);

    jws.createSign({
      header: header,
      privateKey: secretOrPrivateKey,
      payload: payload,
      encoding: encoding
    }).once('error', callback)
      .once('done', function (signature) {
        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
        if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`))
        }
        callback(null, signature);
      });
  } else {
    let signature = jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
    if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`)
    }
    return signature
  }
};

var jsonwebtoken = {
  decode: decode$2,
  verify: verify,
  sign: sign,
  JsonWebTokenError: JsonWebTokenError_1,
  NotBeforeError: NotBeforeError_1,
  TokenExpiredError: TokenExpiredError_1,
};

const jwt$1 = /*@__PURE__*/getDefaultExportFromCjs(jsonwebtoken);

const config = useRuntimeConfig$1();
function generateAccessToken(user) {
  const payload = {
    userId: user.id,
    email: user.email,
    roles: user.roles
  };
  return jwt$1.sign(payload, config.jwtSecret, {
    expiresIn: config.jwtExpiresIn
  });
}
function generateRefreshToken(userId) {
  return jwt$1.sign({ userId }, config.jwtRefreshSecret, {
    expiresIn: config.jwtRefreshExpiresIn
  });
}
function verifyAccessToken(token) {
  try {
    return jwt$1.verify(token, config.jwtSecret);
  } catch (error) {
    if (error.name === "TokenExpiredError") {
      throw createError$2({
        statusCode: 401,
        message: "Session expired due to inactivity"
      });
    }
    throw createError$2({
      statusCode: 401,
      message: "Invalid or expired token"
    });
  }
}

const jwt = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  generateAccessToken: generateAccessToken,
  generateRefreshToken: generateRefreshToken,
  verifyAccessToken: verifyAccessToken
}, Symbol.toStringTag, { value: 'Module' }));

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var bcrypt$2 = {exports: {}};

/*
 Copyright (c) 2012 Nevins Bartolomeo <nevins.bartolomeo@gmail.com>
 Copyright (c) 2012 Shane Girish <shaneGirish@gmail.com>
 Copyright (c) 2014 Daniel Wirtz <dcode@dcode.io>

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var bcrypt$1 = bcrypt$2.exports;

(function (module) {
	/**
	 * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	 * Released under the Apache License, Version 2.0
	 * see: https://github.com/dcodeIO/bcrypt.js for details
	 */
	(function(global, factory) {

	    /* AMD */ if (typeof commonjsRequire === 'function' && 'object' === "object" && module && module["exports"])
	        module["exports"] = factory();
	    /* Global */ else
	        (global["dcodeIO"] = global["dcodeIO"] || {})["bcrypt"] = factory();

	}(bcrypt$1, function() {

	    /**
	     * bcrypt namespace.
	     * @type {Object.<string,*>}
	     */
	    var bcrypt = {};

	    /**
	     * The random implementation to use as a fallback.
	     * @type {?function(number):!Array.<number>}
	     * @inner
	     */
	    var randomFallback = null;

	    /**
	     * Generates cryptographically secure random bytes.
	     * @function
	     * @param {number} len Bytes length
	     * @returns {!Array.<number>} Random bytes
	     * @throws {Error} If no random implementation is available
	     * @inner
	     */
	    function random(len) {
	        /* node */ if (module && module['exports'])
	            try {
	                return require("crypto")['randomBytes'](len);
	            } catch (e) {}
	        /* WCA */ try {
	            var a; (self['crypto']||self['msCrypto'])['getRandomValues'](a = new Uint32Array(len));
	            return Array.prototype.slice.call(a);
	        } catch (e) {}
	        /* fallback */ if (!randomFallback)
	            throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
	        return randomFallback(len);
	    }

	    // Test if any secure randomness source is available
	    var randomAvailable = false;
	    try {
	        random(1);
	        randomAvailable = true;
	    } catch (e) {}

	    // Default fallback, if any
	    randomFallback = null;
	    /**
	     * Sets the pseudo random number generator to use as a fallback if neither node's `crypto` module nor the Web Crypto
	     *  API is available. Please note: It is highly important that the PRNG used is cryptographically secure and that it
	     *  is seeded properly!
	     * @param {?function(number):!Array.<number>} random Function taking the number of bytes to generate as its
	     *  sole argument, returning the corresponding array of cryptographically secure random byte values.
	     * @see http://nodejs.org/api/crypto.html
	     * @see http://www.w3.org/TR/WebCryptoAPI/
	     */
	    bcrypt.setRandomFallback = function(random) {
	        randomFallback = random;
	    };

	    /**
	     * Synchronously generates a salt.
	     * @param {number=} rounds Number of rounds to use, defaults to 10 if omitted
	     * @param {number=} seed_length Not supported.
	     * @returns {string} Resulting salt
	     * @throws {Error} If a random fallback is required but not set
	     * @expose
	     */
	    bcrypt.genSaltSync = function(rounds, seed_length) {
	        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
	        if (typeof rounds !== 'number')
	            throw Error("Illegal arguments: "+(typeof rounds)+", "+(typeof seed_length));
	        if (rounds < 4)
	            rounds = 4;
	        else if (rounds > 31)
	            rounds = 31;
	        var salt = [];
	        salt.push("$2a$");
	        if (rounds < 10)
	            salt.push("0");
	        salt.push(rounds.toString());
	        salt.push('$');
	        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN)); // May throw
	        return salt.join('');
	    };

	    /**
	     * Asynchronously generates a salt.
	     * @param {(number|function(Error, string=))=} rounds Number of rounds to use, defaults to 10 if omitted
	     * @param {(number|function(Error, string=))=} seed_length Not supported.
	     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting salt
	     * @returns {!Promise} If `callback` has been omitted
	     * @throws {Error} If `callback` is present but not a function
	     * @expose
	     */
	    bcrypt.genSalt = function(rounds, seed_length, callback) {
	        if (typeof seed_length === 'function')
	            callback = seed_length,
	            seed_length = undefined; // Not supported.
	        if (typeof rounds === 'function')
	            callback = rounds,
	            rounds = undefined;
	        if (typeof rounds === 'undefined')
	            rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
	        else if (typeof rounds !== 'number')
	            throw Error("illegal arguments: "+(typeof rounds));

	        function _async(callback) {
	            nextTick(function() { // Pretty thin, but salting is fast enough
	                try {
	                    callback(null, bcrypt.genSaltSync(rounds));
	                } catch (err) {
	                    callback(err);
	                }
	            });
	        }

	        if (callback) {
	            if (typeof callback !== 'function')
	                throw Error("Illegal callback: "+typeof(callback));
	            _async(callback);
	        } else
	            return new Promise(function(resolve, reject) {
	                _async(function(err, res) {
	                    if (err) {
	                        reject(err);
	                        return;
	                    }
	                    resolve(res);
	                });
	            });
	    };

	    /**
	     * Synchronously generates a hash for the given string.
	     * @param {string} s String to hash
	     * @param {(number|string)=} salt Salt length to generate or salt to use, default to 10
	     * @returns {string} Resulting hash
	     * @expose
	     */
	    bcrypt.hashSync = function(s, salt) {
	        if (typeof salt === 'undefined')
	            salt = GENSALT_DEFAULT_LOG2_ROUNDS;
	        if (typeof salt === 'number')
	            salt = bcrypt.genSaltSync(salt);
	        if (typeof s !== 'string' || typeof salt !== 'string')
	            throw Error("Illegal arguments: "+(typeof s)+', '+(typeof salt));
	        return _hash(s, salt);
	    };

	    /**
	     * Asynchronously generates a hash for the given string.
	     * @param {string} s String to hash
	     * @param {number|string} salt Salt length to generate or salt to use
	     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash
	     * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed
	     *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.
	     * @returns {!Promise} If `callback` has been omitted
	     * @throws {Error} If `callback` is present but not a function
	     * @expose
	     */
	    bcrypt.hash = function(s, salt, callback, progressCallback) {

	        function _async(callback) {
	            if (typeof s === 'string' && typeof salt === 'number')
	                bcrypt.genSalt(salt, function(err, salt) {
	                    _hash(s, salt, callback, progressCallback);
	                });
	            else if (typeof s === 'string' && typeof salt === 'string')
	                _hash(s, salt, callback, progressCallback);
	            else
	                nextTick(callback.bind(this, Error("Illegal arguments: "+(typeof s)+', '+(typeof salt))));
	        }

	        if (callback) {
	            if (typeof callback !== 'function')
	                throw Error("Illegal callback: "+typeof(callback));
	            _async(callback);
	        } else
	            return new Promise(function(resolve, reject) {
	                _async(function(err, res) {
	                    if (err) {
	                        reject(err);
	                        return;
	                    }
	                    resolve(res);
	                });
	            });
	    };

	    /**
	     * Compares two strings of the same length in constant time.
	     * @param {string} known Must be of the correct length
	     * @param {string} unknown Must be the same length as `known`
	     * @returns {boolean}
	     * @inner
	     */
	    function safeStringCompare(known, unknown) {
	        var right = 0,
	            wrong = 0;
	        for (var i=0, k=known.length; i<k; ++i) {
	            if (known.charCodeAt(i) === unknown.charCodeAt(i))
	                ++right;
	            else
	                ++wrong;
	        }
	        // Prevent removal of unused variables (never true, actually)
	        if (right < 0)
	            return false;
	        return wrong === 0;
	    }

	    /**
	     * Synchronously tests a string against a hash.
	     * @param {string} s String to compare
	     * @param {string} hash Hash to test against
	     * @returns {boolean} true if matching, otherwise false
	     * @throws {Error} If an argument is illegal
	     * @expose
	     */
	    bcrypt.compareSync = function(s, hash) {
	        if (typeof s !== "string" || typeof hash !== "string")
	            throw Error("Illegal arguments: "+(typeof s)+', '+(typeof hash));
	        if (hash.length !== 60)
	            return false;
	        return safeStringCompare(bcrypt.hashSync(s, hash.substr(0, hash.length-31)), hash);
	    };

	    /**
	     * Asynchronously compares the given data against the given hash.
	     * @param {string} s Data to compare
	     * @param {string} hash Data to be compared to
	     * @param {function(Error, boolean)=} callback Callback receiving the error, if any, otherwise the result
	     * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed
	     *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.
	     * @returns {!Promise} If `callback` has been omitted
	     * @throws {Error} If `callback` is present but not a function
	     * @expose
	     */
	    bcrypt.compare = function(s, hash, callback, progressCallback) {

	        function _async(callback) {
	            if (typeof s !== "string" || typeof hash !== "string") {
	                nextTick(callback.bind(this, Error("Illegal arguments: "+(typeof s)+', '+(typeof hash))));
	                return;
	            }
	            if (hash.length !== 60) {
	                nextTick(callback.bind(this, null, false));
	                return;
	            }
	            bcrypt.hash(s, hash.substr(0, 29), function(err, comp) {
	                if (err)
	                    callback(err);
	                else
	                    callback(null, safeStringCompare(comp, hash));
	            }, progressCallback);
	        }

	        if (callback) {
	            if (typeof callback !== 'function')
	                throw Error("Illegal callback: "+typeof(callback));
	            _async(callback);
	        } else
	            return new Promise(function(resolve, reject) {
	                _async(function(err, res) {
	                    if (err) {
	                        reject(err);
	                        return;
	                    }
	                    resolve(res);
	                });
	            });
	    };

	    /**
	     * Gets the number of rounds used to encrypt the specified hash.
	     * @param {string} hash Hash to extract the used number of rounds from
	     * @returns {number} Number of rounds used
	     * @throws {Error} If `hash` is not a string
	     * @expose
	     */
	    bcrypt.getRounds = function(hash) {
	        if (typeof hash !== "string")
	            throw Error("Illegal arguments: "+(typeof hash));
	        return parseInt(hash.split("$")[2], 10);
	    };

	    /**
	     * Gets the salt portion from a hash. Does not validate the hash.
	     * @param {string} hash Hash to extract the salt from
	     * @returns {string} Extracted salt part
	     * @throws {Error} If `hash` is not a string or otherwise invalid
	     * @expose
	     */
	    bcrypt.getSalt = function(hash) {
	        if (typeof hash !== 'string')
	            throw Error("Illegal arguments: "+(typeof hash));
	        if (hash.length !== 60)
	            throw Error("Illegal hash length: "+hash.length+" != 60");
	        return hash.substring(0, 29);
	    };

	    /**
	     * Continues with the callback on the next tick.
	     * @function
	     * @param {function(...[*])} callback Callback to execute
	     * @inner
	     */
	    var nextTick = typeof process !== 'undefined' && process && typeof process.nextTick === 'function'
	        ? (typeof setImmediate === 'function' ? setImmediate : process.nextTick)
	        : setTimeout;

	    /**
	     * Converts a JavaScript string to UTF8 bytes.
	     * @param {string} str String
	     * @returns {!Array.<number>} UTF8 bytes
	     * @inner
	     */
	    function stringToBytes(str) {
	        var out = [],
	            i = 0;
	        utfx.encodeUTF16toUTF8(function() {
	            if (i >= str.length) return null;
	            return str.charCodeAt(i++);
	        }, function(b) {
	            out.push(b);
	        });
	        return out;
	    }

	    // A base64 implementation for the bcrypt algorithm. This is partly non-standard.

	    /**
	     * bcrypt's own non-standard base64 dictionary.
	     * @type {!Array.<string>}
	     * @const
	     * @inner
	     **/
	    var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split('');

	    /**
	     * @type {!Array.<number>}
	     * @const
	     * @inner
	     **/
	    var BASE64_INDEX = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0,
	        1, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1,
	        -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
	        20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1, 28, 29, 30,
	        31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
	        48, 49, 50, 51, 52, 53, -1, -1, -1, -1, -1];

	    /**
	     * @type {!function(...number):string}
	     * @inner
	     */
	    var stringFromCharCode = String.fromCharCode;

	    /**
	     * Encodes a byte array to base64 with up to len bytes of input.
	     * @param {!Array.<number>} b Byte array
	     * @param {number} len Maximum input length
	     * @returns {string}
	     * @inner
	     */
	    function base64_encode(b, len) {
	        var off = 0,
	            rs = [],
	            c1, c2;
	        if (len <= 0 || len > b.length)
	            throw Error("Illegal len: "+len);
	        while (off < len) {
	            c1 = b[off++] & 0xff;
	            rs.push(BASE64_CODE[(c1 >> 2) & 0x3f]);
	            c1 = (c1 & 0x03) << 4;
	            if (off >= len) {
	                rs.push(BASE64_CODE[c1 & 0x3f]);
	                break;
	            }
	            c2 = b[off++] & 0xff;
	            c1 |= (c2 >> 4) & 0x0f;
	            rs.push(BASE64_CODE[c1 & 0x3f]);
	            c1 = (c2 & 0x0f) << 2;
	            if (off >= len) {
	                rs.push(BASE64_CODE[c1 & 0x3f]);
	                break;
	            }
	            c2 = b[off++] & 0xff;
	            c1 |= (c2 >> 6) & 0x03;
	            rs.push(BASE64_CODE[c1 & 0x3f]);
	            rs.push(BASE64_CODE[c2 & 0x3f]);
	        }
	        return rs.join('');
	    }

	    /**
	     * Decodes a base64 encoded string to up to len bytes of output.
	     * @param {string} s String to decode
	     * @param {number} len Maximum output length
	     * @returns {!Array.<number>}
	     * @inner
	     */
	    function base64_decode(s, len) {
	        var off = 0,
	            slen = s.length,
	            olen = 0,
	            rs = [],
	            c1, c2, c3, c4, o, code;
	        if (len <= 0)
	            throw Error("Illegal len: "+len);
	        while (off < slen - 1 && olen < len) {
	            code = s.charCodeAt(off++);
	            c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
	            code = s.charCodeAt(off++);
	            c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
	            if (c1 == -1 || c2 == -1)
	                break;
	            o = (c1 << 2) >>> 0;
	            o |= (c2 & 0x30) >> 4;
	            rs.push(stringFromCharCode(o));
	            if (++olen >= len || off >= slen)
	                break;
	            code = s.charCodeAt(off++);
	            c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
	            if (c3 == -1)
	                break;
	            o = ((c2 & 0x0f) << 4) >>> 0;
	            o |= (c3 & 0x3c) >> 2;
	            rs.push(stringFromCharCode(o));
	            if (++olen >= len || off >= slen)
	                break;
	            code = s.charCodeAt(off++);
	            c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
	            o = ((c3 & 0x03) << 6) >>> 0;
	            o |= c4;
	            rs.push(stringFromCharCode(o));
	            ++olen;
	        }
	        var res = [];
	        for (off = 0; off<olen; off++)
	            res.push(rs[off].charCodeAt(0));
	        return res;
	    }

	    /**
	     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
	     * Released under the Apache License, Version 2.0
	     * see: https://github.com/dcodeIO/utfx for details
	     */
	    var utfx = function() {

	        /**
	         * utfx namespace.
	         * @inner
	         * @type {!Object.<string,*>}
	         */
	        var utfx = {};

	        /**
	         * Maximum valid code point.
	         * @type {number}
	         * @const
	         */
	        utfx.MAX_CODEPOINT = 0x10FFFF;

	        /**
	         * Encodes UTF8 code points to UTF8 bytes.
	         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
	         *  respectively `null` if there are no more code points left or a single numeric code point.
	         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
	         */
	        utfx.encodeUTF8 = function(src, dst) {
	            var cp = null;
	            if (typeof src === 'number')
	                cp = src,
	                src = function() { return null; };
	            while (cp !== null || (cp = src()) !== null) {
	                if (cp < 0x80)
	                    dst(cp&0x7F);
	                else if (cp < 0x800)
	                    dst(((cp>>6)&0x1F)|0xC0),
	                    dst((cp&0x3F)|0x80);
	                else if (cp < 0x10000)
	                    dst(((cp>>12)&0x0F)|0xE0),
	                    dst(((cp>>6)&0x3F)|0x80),
	                    dst((cp&0x3F)|0x80);
	                else
	                    dst(((cp>>18)&0x07)|0xF0),
	                    dst(((cp>>12)&0x3F)|0x80),
	                    dst(((cp>>6)&0x3F)|0x80),
	                    dst((cp&0x3F)|0x80);
	                cp = null;
	            }
	        };

	        /**
	         * Decodes UTF8 bytes to UTF8 code points.
	         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
	         *  are no more bytes left.
	         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
	         * @throws {RangeError} If a starting byte is invalid in UTF8
	         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
	         *  remaining bytes.
	         */
	        utfx.decodeUTF8 = function(src, dst) {
	            var a, b, c, d, fail = function(b) {
	                b = b.slice(0, b.indexOf(null));
	                var err = Error(b.toString());
	                err.name = "TruncatedError";
	                err['bytes'] = b;
	                throw err;
	            };
	            while ((a = src()) !== null) {
	                if ((a&0x80) === 0)
	                    dst(a);
	                else if ((a&0xE0) === 0xC0)
	                    ((b = src()) === null) && fail([a, b]),
	                    dst(((a&0x1F)<<6) | (b&0x3F));
	                else if ((a&0xF0) === 0xE0)
	                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
	                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
	                else if ((a&0xF8) === 0xF0)
	                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
	                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
	                else throw RangeError("Illegal starting byte: "+a);
	            }
	        };

	        /**
	         * Converts UTF16 characters to UTF8 code points.
	         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
	         *  `null` if there are no more characters left.
	         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
	         *  point.
	         */
	        utfx.UTF16toUTF8 = function(src, dst) {
	            var c1, c2 = null;
	            while (true) {
	                if ((c1 = c2 !== null ? c2 : src()) === null)
	                    break;
	                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
	                    if ((c2 = src()) !== null) {
	                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
	                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
	                            c2 = null; continue;
	                        }
	                    }
	                }
	                dst(c1);
	            }
	            if (c2 !== null) dst(c2);
	        };

	        /**
	         * Converts UTF8 code points to UTF16 characters.
	         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
	         *  respectively `null` if there are no more code points left or a single numeric code point.
	         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
	         * @throws {RangeError} If a code point is out of range
	         */
	        utfx.UTF8toUTF16 = function(src, dst) {
	            var cp = null;
	            if (typeof src === 'number')
	                cp = src, src = function() { return null; };
	            while (cp !== null || (cp = src()) !== null) {
	                if (cp <= 0xFFFF)
	                    dst(cp);
	                else
	                    cp -= 0x10000,
	                    dst((cp>>10)+0xD800),
	                    dst((cp%0x400)+0xDC00);
	                cp = null;
	            }
	        };

	        /**
	         * Converts and encodes UTF16 characters to UTF8 bytes.
	         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
	         *  if there are no more characters left.
	         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
	         */
	        utfx.encodeUTF16toUTF8 = function(src, dst) {
	            utfx.UTF16toUTF8(src, function(cp) {
	                utfx.encodeUTF8(cp, dst);
	            });
	        };

	        /**
	         * Decodes and converts UTF8 bytes to UTF16 characters.
	         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
	         *  are no more bytes left.
	         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
	         * @throws {RangeError} If a starting byte is invalid in UTF8
	         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
	         */
	        utfx.decodeUTF8toUTF16 = function(src, dst) {
	            utfx.decodeUTF8(src, function(cp) {
	                utfx.UTF8toUTF16(cp, dst);
	            });
	        };

	        /**
	         * Calculates the byte length of an UTF8 code point.
	         * @param {number} cp UTF8 code point
	         * @returns {number} Byte length
	         */
	        utfx.calculateCodePoint = function(cp) {
	            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
	        };

	        /**
	         * Calculates the number of UTF8 bytes required to store UTF8 code points.
	         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
	         *  `null` if there are no more code points left.
	         * @returns {number} The number of UTF8 bytes required
	         */
	        utfx.calculateUTF8 = function(src) {
	            var cp, l=0;
	            while ((cp = src()) !== null)
	                l += utfx.calculateCodePoint(cp);
	            return l;
	        };

	        /**
	         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
	         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
	         *  `null` if there are no more characters left.
	         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
	         */
	        utfx.calculateUTF16asUTF8 = function(src) {
	            var n=0, l=0;
	            utfx.UTF16toUTF8(src, function(cp) {
	                ++n; l += utfx.calculateCodePoint(cp);
	            });
	            return [n,l];
	        };

	        return utfx;
	    }();

	    Date.now = Date.now || function() { return +new Date; };

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var BCRYPT_SALT_LEN = 16;

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var GENSALT_DEFAULT_LOG2_ROUNDS = 10;

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var BLOWFISH_NUM_ROUNDS = 16;

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var MAX_EXECUTION_TIME = 100;

	    /**
	     * @type {Array.<number>}
	     * @const
	     * @inner
	     */
	    var P_ORIG = [
	        0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822,
	        0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377,
	        0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5,
	        0xb5470917, 0x9216d5d9, 0x8979fb1b
	    ];

	    /**
	     * @type {Array.<number>}
	     * @const
	     * @inner
	     */
	    var S_ORIG = [
	        0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed,
	        0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7,
	        0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3,
	        0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
	        0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023,
	        0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e,
	        0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda,
	        0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
	        0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af,
	        0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6,
	        0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381,
	        0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
	        0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d,
	        0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5,
	        0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a,
	        0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
	        0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c,
	        0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,
	        0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3,
	        0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
	        0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724,
	        0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b,
	        0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd,
	        0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
	        0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f,
	        0x9b30952c, 0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd,
	        0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39,
	        0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
	        0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df,
	        0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760,
	        0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e,
	        0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
	        0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98,
	        0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565,
	        0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341,
	        0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
	        0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0,
	        0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64,
	        0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191,
	        0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
	        0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0,
	        0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705,
	        0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5,
	        0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
	        0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b,
	        0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f,
	        0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968,
	        0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
	        0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5,
	        0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6,
	        0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799,
	        0x6e85076a, 0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
	        0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71,
	        0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29,
	        0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6,
	        0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
	        0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f,
	        0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286,
	        0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec,
	        0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
	        0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9,
	        0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc,
	        0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e,
	        0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
	        0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290,
	        0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810,
	        0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6,
	        0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
	        0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847,
	        0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451,
	        0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6,
	        0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
	        0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570,
	        0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa,
	        0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978,
	        0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
	        0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 0x5223a708,
	        0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883,
	        0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185,
	        0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
	        0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830,
	        0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239,
	        0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab,
	        0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
	        0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19,
	        0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77,
	        0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1,
	        0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
	        0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef,
	        0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3,
	        0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15,
	        0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
	        0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2,
	        0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492,
	        0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174,
	        0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
	        0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759,
	        0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e,
	        0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc,
	        0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
	        0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465,
	        0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a,
	        0xe6e39f2b, 0xdb83adf7, 0xe93d5a68, 0x948140f7, 0xf64c261c,
	        0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
	        0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e,
	        0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af,
	        0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0,
	        0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
	        0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462,
	        0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c,
	        0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399,
	        0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
	        0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74,
	        0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397,
	        0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7,
	        0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
	        0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802,
	        0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22,
	        0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4,
	        0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
	        0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2,
	        0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1,
	        0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c,
	        0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
	        0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341,
	        0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8,
	        0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b,
	        0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
	        0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88,
	        0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979,
	        0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc,
	        0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
	        0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659,
	        0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f,
	        0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086, 0x60787bf8,
	        0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
	        0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be,
	        0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2,
	        0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255,
	        0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
	        0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1,
	        0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09,
	        0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025,
	        0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
	        0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01,
	        0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641,
	        0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa,
	        0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
	        0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409,
	        0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9,
	        0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3,
	        0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
	        0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234,
	        0x92638212, 0x670efa8e, 0x406000e0, 0x3a39ce37, 0xd3faf5cf,
	        0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740,
	        0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
	        0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f,
	        0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d,
	        0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8,
	        0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
	        0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba,
	        0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1,
	        0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69,
	        0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
	        0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a,
	        0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b,
	        0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd,
	        0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
	        0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4,
	        0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2,
	        0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb,
	        0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
	        0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751,
	        0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce,
	        0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369,
	        0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
	        0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd,
	        0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45,
	        0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae,
	        0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
	        0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08,
	        0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d,
	        0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b,
	        0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
	        0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e,
	        0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,
	        0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c,
	        0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
	        0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361,
	        0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c,
	        0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be,
	        0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
	        0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d,
	        0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891,
	        0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5,
	        0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
	        0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292,
	        0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a,
	        0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2,
	        0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
	        0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c,
	        0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8,
	        0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4,
	        0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
	        0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
	    ];

	    /**
	     * @type {Array.<number>}
	     * @const
	     * @inner
	     */
	    var C_ORIG = [
	        0x4f727068, 0x65616e42, 0x65686f6c, 0x64657253, 0x63727944,
	        0x6f756274
	    ];

	    /**
	     * @param {Array.<number>} lr
	     * @param {number} off
	     * @param {Array.<number>} P
	     * @param {Array.<number>} S
	     * @returns {Array.<number>}
	     * @inner
	     */
	    function _encipher(lr, off, P, S) { // This is our bottleneck: 1714/1905 ticks / 90% - see profile.txt
	        var n,
	            l = lr[off],
	            r = lr[off + 1];

	        l ^= P[0];

	        /*
	        for (var i=0, k=BLOWFISH_NUM_ROUNDS-2; i<=k;)
	            // Feistel substitution on left word
	            n  = S[l >>> 24],
	            n += S[0x100 | ((l >> 16) & 0xff)],
	            n ^= S[0x200 | ((l >> 8) & 0xff)],
	            n += S[0x300 | (l & 0xff)],
	            r ^= n ^ P[++i],
	            // Feistel substitution on right word
	            n  = S[r >>> 24],
	            n += S[0x100 | ((r >> 16) & 0xff)],
	            n ^= S[0x200 | ((r >> 8) & 0xff)],
	            n += S[0x300 | (r & 0xff)],
	            l ^= n ^ P[++i];
	        */

	        //The following is an unrolled version of the above loop.
	        //Iteration 0
	        n  = S[l >>> 24];
	        n += S[0x100 | ((l >> 16) & 0xff)];
	        n ^= S[0x200 | ((l >> 8) & 0xff)];
	        n += S[0x300 | (l & 0xff)];
	        r ^= n ^ P[1];
	        n  = S[r >>> 24];
	        n += S[0x100 | ((r >> 16) & 0xff)];
	        n ^= S[0x200 | ((r >> 8) & 0xff)];
	        n += S[0x300 | (r & 0xff)];
	        l ^= n ^ P[2];
	        //Iteration 1
	        n  = S[l >>> 24];
	        n += S[0x100 | ((l >> 16) & 0xff)];
	        n ^= S[0x200 | ((l >> 8) & 0xff)];
	        n += S[0x300 | (l & 0xff)];
	        r ^= n ^ P[3];
	        n  = S[r >>> 24];
	        n += S[0x100 | ((r >> 16) & 0xff)];
	        n ^= S[0x200 | ((r >> 8) & 0xff)];
	        n += S[0x300 | (r & 0xff)];
	        l ^= n ^ P[4];
	        //Iteration 2
	        n  = S[l >>> 24];
	        n += S[0x100 | ((l >> 16) & 0xff)];
	        n ^= S[0x200 | ((l >> 8) & 0xff)];
	        n += S[0x300 | (l & 0xff)];
	        r ^= n ^ P[5];
	        n  = S[r >>> 24];
	        n += S[0x100 | ((r >> 16) & 0xff)];
	        n ^= S[0x200 | ((r >> 8) & 0xff)];
	        n += S[0x300 | (r & 0xff)];
	        l ^= n ^ P[6];
	        //Iteration 3
	        n  = S[l >>> 24];
	        n += S[0x100 | ((l >> 16) & 0xff)];
	        n ^= S[0x200 | ((l >> 8) & 0xff)];
	        n += S[0x300 | (l & 0xff)];
	        r ^= n ^ P[7];
	        n  = S[r >>> 24];
	        n += S[0x100 | ((r >> 16) & 0xff)];
	        n ^= S[0x200 | ((r >> 8) & 0xff)];
	        n += S[0x300 | (r & 0xff)];
	        l ^= n ^ P[8];
	        //Iteration 4
	        n  = S[l >>> 24];
	        n += S[0x100 | ((l >> 16) & 0xff)];
	        n ^= S[0x200 | ((l >> 8) & 0xff)];
	        n += S[0x300 | (l & 0xff)];
	        r ^= n ^ P[9];
	        n  = S[r >>> 24];
	        n += S[0x100 | ((r >> 16) & 0xff)];
	        n ^= S[0x200 | ((r >> 8) & 0xff)];
	        n += S[0x300 | (r & 0xff)];
	        l ^= n ^ P[10];
	        //Iteration 5
	        n  = S[l >>> 24];
	        n += S[0x100 | ((l >> 16) & 0xff)];
	        n ^= S[0x200 | ((l >> 8) & 0xff)];
	        n += S[0x300 | (l & 0xff)];
	        r ^= n ^ P[11];
	        n  = S[r >>> 24];
	        n += S[0x100 | ((r >> 16) & 0xff)];
	        n ^= S[0x200 | ((r >> 8) & 0xff)];
	        n += S[0x300 | (r & 0xff)];
	        l ^= n ^ P[12];
	        //Iteration 6
	        n  = S[l >>> 24];
	        n += S[0x100 | ((l >> 16) & 0xff)];
	        n ^= S[0x200 | ((l >> 8) & 0xff)];
	        n += S[0x300 | (l & 0xff)];
	        r ^= n ^ P[13];
	        n  = S[r >>> 24];
	        n += S[0x100 | ((r >> 16) & 0xff)];
	        n ^= S[0x200 | ((r >> 8) & 0xff)];
	        n += S[0x300 | (r & 0xff)];
	        l ^= n ^ P[14];
	        //Iteration 7
	        n  = S[l >>> 24];
	        n += S[0x100 | ((l >> 16) & 0xff)];
	        n ^= S[0x200 | ((l >> 8) & 0xff)];
	        n += S[0x300 | (l & 0xff)];
	        r ^= n ^ P[15];
	        n  = S[r >>> 24];
	        n += S[0x100 | ((r >> 16) & 0xff)];
	        n ^= S[0x200 | ((r >> 8) & 0xff)];
	        n += S[0x300 | (r & 0xff)];
	        l ^= n ^ P[16];

	        lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
	        lr[off + 1] = l;
	        return lr;
	    }

	    /**
	     * @param {Array.<number>} data
	     * @param {number} offp
	     * @returns {{key: number, offp: number}}
	     * @inner
	     */
	    function _streamtoword(data, offp) {
	        for (var i = 0, word = 0; i < 4; ++i)
	            word = (word << 8) | (data[offp] & 0xff),
	            offp = (offp + 1) % data.length;
	        return { key: word, offp: offp };
	    }

	    /**
	     * @param {Array.<number>} key
	     * @param {Array.<number>} P
	     * @param {Array.<number>} S
	     * @inner
	     */
	    function _key(key, P, S) {
	        var offset = 0,
	            lr = [0, 0],
	            plen = P.length,
	            slen = S.length,
	            sw;
	        for (var i = 0; i < plen; i++)
	            sw = _streamtoword(key, offset),
	            offset = sw.offp,
	            P[i] = P[i] ^ sw.key;
	        for (i = 0; i < plen; i += 2)
	            lr = _encipher(lr, 0, P, S),
	            P[i] = lr[0],
	            P[i + 1] = lr[1];
	        for (i = 0; i < slen; i += 2)
	            lr = _encipher(lr, 0, P, S),
	            S[i] = lr[0],
	            S[i + 1] = lr[1];
	    }

	    /**
	     * Expensive key schedule Blowfish.
	     * @param {Array.<number>} data
	     * @param {Array.<number>} key
	     * @param {Array.<number>} P
	     * @param {Array.<number>} S
	     * @inner
	     */
	    function _ekskey(data, key, P, S) {
	        var offp = 0,
	            lr = [0, 0],
	            plen = P.length,
	            slen = S.length,
	            sw;
	        for (var i = 0; i < plen; i++)
	            sw = _streamtoword(key, offp),
	            offp = sw.offp,
	            P[i] = P[i] ^ sw.key;
	        offp = 0;
	        for (i = 0; i < plen; i += 2)
	            sw = _streamtoword(data, offp),
	            offp = sw.offp,
	            lr[0] ^= sw.key,
	            sw = _streamtoword(data, offp),
	            offp = sw.offp,
	            lr[1] ^= sw.key,
	            lr = _encipher(lr, 0, P, S),
	            P[i] = lr[0],
	            P[i + 1] = lr[1];
	        for (i = 0; i < slen; i += 2)
	            sw = _streamtoword(data, offp),
	            offp = sw.offp,
	            lr[0] ^= sw.key,
	            sw = _streamtoword(data, offp),
	            offp = sw.offp,
	            lr[1] ^= sw.key,
	            lr = _encipher(lr, 0, P, S),
	            S[i] = lr[0],
	            S[i + 1] = lr[1];
	    }

	    /**
	     * Internaly crypts a string.
	     * @param {Array.<number>} b Bytes to crypt
	     * @param {Array.<number>} salt Salt bytes to use
	     * @param {number} rounds Number of rounds
	     * @param {function(Error, Array.<number>=)=} callback Callback receiving the error, if any, and the resulting bytes. If
	     *  omitted, the operation will be performed synchronously.
	     *  @param {function(number)=} progressCallback Callback called with the current progress
	     * @returns {!Array.<number>|undefined} Resulting bytes if callback has been omitted, otherwise `undefined`
	     * @inner
	     */
	    function _crypt(b, salt, rounds, callback, progressCallback) {
	        var cdata = C_ORIG.slice(),
	            clen = cdata.length,
	            err;

	        // Validate
	        if (rounds < 4 || rounds > 31) {
	            err = Error("Illegal number of rounds (4-31): "+rounds);
	            if (callback) {
	                nextTick(callback.bind(this, err));
	                return;
	            } else
	                throw err;
	        }
	        if (salt.length !== BCRYPT_SALT_LEN) {
	            err =Error("Illegal salt length: "+salt.length+" != "+BCRYPT_SALT_LEN);
	            if (callback) {
	                nextTick(callback.bind(this, err));
	                return;
	            } else
	                throw err;
	        }
	        rounds = (1 << rounds) >>> 0;

	        var P, S, i = 0, j;

	        //Use typed arrays when available - huge speedup!
	        if (Int32Array) {
	            P = new Int32Array(P_ORIG);
	            S = new Int32Array(S_ORIG);
	        } else {
	            P = P_ORIG.slice();
	            S = S_ORIG.slice();
	        }

	        _ekskey(salt, b, P, S);

	        /**
	         * Calcualtes the next round.
	         * @returns {Array.<number>|undefined} Resulting array if callback has been omitted, otherwise `undefined`
	         * @inner
	         */
	        function next() {
	            if (progressCallback)
	                progressCallback(i / rounds);
	            if (i < rounds) {
	                var start = Date.now();
	                for (; i < rounds;) {
	                    i = i + 1;
	                    _key(b, P, S);
	                    _key(salt, P, S);
	                    if (Date.now() - start > MAX_EXECUTION_TIME)
	                        break;
	                }
	            } else {
	                for (i = 0; i < 64; i++)
	                    for (j = 0; j < (clen >> 1); j++)
	                        _encipher(cdata, j << 1, P, S);
	                var ret = [];
	                for (i = 0; i < clen; i++)
	                    ret.push(((cdata[i] >> 24) & 0xff) >>> 0),
	                    ret.push(((cdata[i] >> 16) & 0xff) >>> 0),
	                    ret.push(((cdata[i] >> 8) & 0xff) >>> 0),
	                    ret.push((cdata[i] & 0xff) >>> 0);
	                if (callback) {
	                    callback(null, ret);
	                    return;
	                } else
	                    return ret;
	            }
	            if (callback)
	                nextTick(next);
	        }

	        // Async
	        if (typeof callback !== 'undefined') {
	            next();

	            // Sync
	        } else {
	            var res;
	            while (true)
	                if (typeof(res = next()) !== 'undefined')
	                    return res || [];
	        }
	    }

	    /**
	     * Internally hashes a string.
	     * @param {string} s String to hash
	     * @param {?string} salt Salt to use, actually never null
	     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash. If omitted,
	     *  hashing is perormed synchronously.
	     *  @param {function(number)=} progressCallback Callback called with the current progress
	     * @returns {string|undefined} Resulting hash if callback has been omitted, otherwise `undefined`
	     * @inner
	     */
	    function _hash(s, salt, callback, progressCallback) {
	        var err;
	        if (typeof s !== 'string' || typeof salt !== 'string') {
	            err = Error("Invalid string / salt: Not a string");
	            if (callback) {
	                nextTick(callback.bind(this, err));
	                return;
	            }
	            else
	                throw err;
	        }

	        // Validate the salt
	        var minor, offset;
	        if (salt.charAt(0) !== '$' || salt.charAt(1) !== '2') {
	            err = Error("Invalid salt version: "+salt.substring(0,2));
	            if (callback) {
	                nextTick(callback.bind(this, err));
	                return;
	            }
	            else
	                throw err;
	        }
	        if (salt.charAt(2) === '$')
	            minor = String.fromCharCode(0),
	            offset = 3;
	        else {
	            minor = salt.charAt(2);
	            if ((minor !== 'a' && minor !== 'b' && minor !== 'y') || salt.charAt(3) !== '$') {
	                err = Error("Invalid salt revision: "+salt.substring(2,4));
	                if (callback) {
	                    nextTick(callback.bind(this, err));
	                    return;
	                } else
	                    throw err;
	            }
	            offset = 4;
	        }

	        // Extract number of rounds
	        if (salt.charAt(offset + 2) > '$') {
	            err = Error("Missing salt rounds");
	            if (callback) {
	                nextTick(callback.bind(this, err));
	                return;
	            } else
	                throw err;
	        }
	        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10,
	            r2 = parseInt(salt.substring(offset + 1, offset + 2), 10),
	            rounds = r1 + r2,
	            real_salt = salt.substring(offset + 3, offset + 25);
	        s += minor >= 'a' ? "\x00" : "";

	        var passwordb = stringToBytes(s),
	            saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);

	        /**
	         * Finishes hashing.
	         * @param {Array.<number>} bytes Byte array
	         * @returns {string}
	         * @inner
	         */
	        function finish(bytes) {
	            var res = [];
	            res.push("$2");
	            if (minor >= 'a')
	                res.push(minor);
	            res.push("$");
	            if (rounds < 10)
	                res.push("0");
	            res.push(rounds.toString());
	            res.push("$");
	            res.push(base64_encode(saltb, saltb.length));
	            res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
	            return res.join('');
	        }

	        // Sync
	        if (typeof callback == 'undefined')
	            return finish(_crypt(passwordb, saltb, rounds));

	        // Async
	        else {
	            _crypt(passwordb, saltb, rounds, function(err, bytes) {
	                if (err)
	                    callback(err, null);
	                else
	                    callback(null, finish(bytes));
	            }, progressCallback);
	        }
	    }

	    /**
	     * Encodes a byte array to base64 with up to len bytes of input, using the custom bcrypt alphabet.
	     * @function
	     * @param {!Array.<number>} b Byte array
	     * @param {number} len Maximum input length
	     * @returns {string}
	     * @expose
	     */
	    bcrypt.encodeBase64 = base64_encode;

	    /**
	     * Decodes a base64 encoded string to up to len bytes of output, using the custom bcrypt alphabet.
	     * @function
	     * @param {string} s String to decode
	     * @param {number} len Maximum output length
	     * @returns {!Array.<number>}
	     * @expose
	     */
	    bcrypt.decodeBase64 = base64_decode;

	    return bcrypt;
	})); 
} (bcrypt$2));

var bcryptExports = bcrypt$2.exports;

/*
 Copyright (c) 2012 Nevins Bartolomeo <nevins.bartolomeo@gmail.com>
 Copyright (c) 2012 Shane Girish <shaneGirish@gmail.com>
 Copyright (c) 2013 Daniel Wirtz <dcode@dcode.io>

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var bcryptjs = bcryptExports;

const bcrypt = /*@__PURE__*/getDefaultExportFromCjs(bcryptjs);

var promise = {};

var SqlString$2 = {};

(function (exports$1) {
	var SqlString  = exports$1;

	var ID_GLOBAL_REGEXP    = /`/g;
	var QUAL_GLOBAL_REGEXP  = /\./g;
	var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
	var CHARS_ESCAPE_MAP    = {
	  '\0'   : '\\0',
	  '\b'   : '\\b',
	  '\t'   : '\\t',
	  '\n'   : '\\n',
	  '\r'   : '\\r',
	  '\x1a' : '\\Z',
	  '"'    : '\\"',
	  '\''   : '\\\'',
	  '\\'   : '\\\\'
	};

	SqlString.escapeId = function escapeId(val, forbidQualified) {
	  if (Array.isArray(val)) {
	    var sql = '';

	    for (var i = 0; i < val.length; i++) {
	      sql += (i === 0 ? '' : ', ') + SqlString.escapeId(val[i], forbidQualified);
	    }

	    return sql;
	  } else if (forbidQualified) {
	    return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``') + '`';
	  } else {
	    return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``').replace(QUAL_GLOBAL_REGEXP, '`.`') + '`';
	  }
	};

	SqlString.escape = function escape(val, stringifyObjects, timeZone) {
	  if (val === undefined || val === null) {
	    return 'NULL';
	  }

	  switch (typeof val) {
	    case 'boolean': return (val) ? 'true' : 'false';
	    case 'number': return val + '';
	    case 'object':
	      if (Object.prototype.toString.call(val) === '[object Date]') {
	        return SqlString.dateToString(val, timeZone || 'local');
	      } else if (Array.isArray(val)) {
	        return SqlString.arrayToList(val, timeZone);
	      } else if (Buffer.isBuffer(val)) {
	        return SqlString.bufferToString(val);
	      } else if (typeof val.toSqlString === 'function') {
	        return String(val.toSqlString());
	      } else if (stringifyObjects) {
	        return escapeString(val.toString());
	      } else {
	        return SqlString.objectToValues(val, timeZone);
	      }
	    default: return escapeString(val);
	  }
	};

	SqlString.arrayToList = function arrayToList(array, timeZone) {
	  var sql = '';

	  for (var i = 0; i < array.length; i++) {
	    var val = array[i];

	    if (Array.isArray(val)) {
	      sql += (i === 0 ? '' : ', ') + '(' + SqlString.arrayToList(val, timeZone) + ')';
	    } else {
	      sql += (i === 0 ? '' : ', ') + SqlString.escape(val, true, timeZone);
	    }
	  }

	  return sql;
	};

	SqlString.format = function format(sql, values, stringifyObjects, timeZone) {
	  if (values == null) {
	    return sql;
	  }

	  if (!Array.isArray(values)) {
	    values = [values];
	  }

	  var chunkIndex        = 0;
	  var placeholdersRegex = /\?+/g;
	  var result            = '';
	  var valuesIndex       = 0;
	  var match;

	  while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
	    var len = match[0].length;

	    if (len > 2) {
	      continue;
	    }

	    var value = len === 2
	      ? SqlString.escapeId(values[valuesIndex])
	      : SqlString.escape(values[valuesIndex], stringifyObjects, timeZone);

	    result += sql.slice(chunkIndex, match.index) + value;
	    chunkIndex = placeholdersRegex.lastIndex;
	    valuesIndex++;
	  }

	  if (chunkIndex === 0) {
	    // Nothing was replaced
	    return sql;
	  }

	  if (chunkIndex < sql.length) {
	    return result + sql.slice(chunkIndex);
	  }

	  return result;
	};

	SqlString.dateToString = function dateToString(date, timeZone) {
	  var dt = new Date(date);

	  if (isNaN(dt.getTime())) {
	    return 'NULL';
	  }

	  var year;
	  var month;
	  var day;
	  var hour;
	  var minute;
	  var second;
	  var millisecond;

	  if (timeZone === 'local') {
	    year        = dt.getFullYear();
	    month       = dt.getMonth() + 1;
	    day         = dt.getDate();
	    hour        = dt.getHours();
	    minute      = dt.getMinutes();
	    second      = dt.getSeconds();
	    millisecond = dt.getMilliseconds();
	  } else {
	    var tz = convertTimezone(timeZone);

	    if (tz !== false && tz !== 0) {
	      dt.setTime(dt.getTime() + (tz * 60000));
	    }

	    year       = dt.getUTCFullYear();
	    month       = dt.getUTCMonth() + 1;
	    day         = dt.getUTCDate();
	    hour        = dt.getUTCHours();
	    minute      = dt.getUTCMinutes();
	    second      = dt.getUTCSeconds();
	    millisecond = dt.getUTCMilliseconds();
	  }

	  // YYYY-MM-DD HH:mm:ss.mmm
	  var str = zeroPad(year, 4) + '-' + zeroPad(month, 2) + '-' + zeroPad(day, 2) + ' ' +
	    zeroPad(hour, 2) + ':' + zeroPad(minute, 2) + ':' + zeroPad(second, 2) + '.' +
	    zeroPad(millisecond, 3);

	  return escapeString(str);
	};

	SqlString.bufferToString = function bufferToString(buffer) {
	  return 'X' + escapeString(buffer.toString('hex'));
	};

	SqlString.objectToValues = function objectToValues(object, timeZone) {
	  var sql = '';

	  for (var key in object) {
	    var val = object[key];

	    if (typeof val === 'function') {
	      continue;
	    }

	    sql += (sql.length === 0 ? '' : ', ') + SqlString.escapeId(key) + ' = ' + SqlString.escape(val, true, timeZone);
	  }

	  return sql;
	};

	SqlString.raw = function raw(sql) {
	  if (typeof sql !== 'string') {
	    throw new TypeError('argument sql must be a string');
	  }

	  return {
	    toSqlString: function toSqlString() { return sql; }
	  };
	};

	function escapeString(val) {
	  var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
	  var escapedVal = '';
	  var match;

	  while ((match = CHARS_GLOBAL_REGEXP.exec(val))) {
	    escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
	    chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
	  }

	  if (chunkIndex === 0) {
	    // Nothing was escaped
	    return "'" + val + "'";
	  }

	  if (chunkIndex < val.length) {
	    return "'" + escapedVal + val.slice(chunkIndex) + "'";
	  }

	  return "'" + escapedVal + "'";
	}

	function zeroPad(number, length) {
	  number = number.toString();
	  while (number.length < length) {
	    number = '0' + number;
	  }

	  return number;
	}

	function convertTimezone(tz) {
	  if (tz === 'Z') {
	    return 0;
	  }

	  var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
	  if (m) {
	    return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;
	  }
	  return false;
	} 
} (SqlString$2));

var sqlstring = SqlString$2;

const createLRU$3 = (options) => {
  let { max } = options;
  if (!(Number.isInteger(max) && max > 0))
    throw new TypeError("`max` must be a positive integer");
  let size = 0;
  let head = 0;
  let tail = 0;
  let free = [];
  const { onEviction } = options;
  const keyMap = /* @__PURE__ */ new Map();
  const keyList = new Array(max).fill(void 0);
  const valList = new Array(max).fill(void 0);
  const next = new Array(max).fill(0);
  const prev = new Array(max).fill(0);
  const setTail = (index, type) => {
    if (index === tail) return;
    const nextIndex = next[index];
    const prevIndex = prev[index];
    if (index === head) head = nextIndex;
    else if (type === "get" || prevIndex !== 0) next[prevIndex] = nextIndex;
    if (nextIndex !== 0) prev[nextIndex] = prevIndex;
    next[tail] = index;
    prev[index] = tail;
    next[index] = 0;
    tail = index;
  };
  const _evict = () => {
    const evictHead = head;
    const key = keyList[evictHead];
    onEviction == null ? void 0 : onEviction(key, valList[evictHead]);
    keyMap.delete(key);
    keyList[evictHead] = void 0;
    valList[evictHead] = void 0;
    head = next[evictHead];
    if (head !== 0) prev[head] = 0;
    size--;
    if (size === 0) head = tail = 0;
    free.push(evictHead);
    return evictHead;
  };
  return {
    /** Adds a key-value pair to the cache. Updates the value if the key already exists. */
    set(key, value) {
      if (key === void 0) return;
      let index = keyMap.get(key);
      if (index === void 0) {
        index = size === max ? _evict() : free.length > 0 ? free.pop() : size;
        keyMap.set(key, index);
        keyList[index] = key;
        size++;
      } else onEviction == null ? void 0 : onEviction(key, valList[index]);
      valList[index] = value;
      if (size === 1) head = tail = index;
      else setTail(index, "set");
    },
    /** Retrieves the value for a given key and moves the key to the most recent position. */
    get(key) {
      const index = keyMap.get(key);
      if (index === void 0) return;
      if (index !== tail) setTail(index, "get");
      return valList[index];
    },
    /** Retrieves the value for a given key without changing its position. */
    peek: (key) => {
      const index = keyMap.get(key);
      return index !== void 0 ? valList[index] : void 0;
    },
    /** Checks if a key exists in the cache. */
    has: (key) => keyMap.has(key),
    /** Iterates over all keys in the cache, from most recent to least recent. */
    *keys() {
      let current = tail;
      for (let i = 0; i < size; i++) {
        yield keyList[current];
        current = prev[current];
      }
    },
    /** Iterates over all values in the cache, from most recent to least recent. */
    *values() {
      let current = tail;
      for (let i = 0; i < size; i++) {
        yield valList[current];
        current = prev[current];
      }
    },
    /** Iterates over `[key, value]` pairs in the cache, from most recent to least recent. */
    *entries() {
      let current = tail;
      for (let i = 0; i < size; i++) {
        yield [keyList[current], valList[current]];
        current = prev[current];
      }
    },
    /** Iterates over each value-key pair in the cache, from most recent to least recent. */
    forEach: (callback) => {
      let current = tail;
      for (let i = 0; i < size; i++) {
        const key = keyList[current];
        const value = valList[current];
        callback(value, key);
        current = prev[current];
      }
    },
    /** Deletes a key-value pair from the cache. */
    delete(key) {
      const index = keyMap.get(key);
      if (index === void 0) return false;
      onEviction == null ? void 0 : onEviction(key, valList[index]);
      keyMap.delete(key);
      free.push(index);
      keyList[index] = void 0;
      valList[index] = void 0;
      const prevIndex = prev[index];
      const nextIndex = next[index];
      if (prevIndex !== 0) next[prevIndex] = nextIndex;
      if (nextIndex !== 0) prev[nextIndex] = prevIndex;
      if (index === head) head = nextIndex;
      if (index === tail) tail = prevIndex;
      size--;
      return true;
    },
    /** Evicts the oldest item or the specified number of the oldest items from the cache. */
    evict: (number) => {
      let toPrune = Math.min(number, size);
      while (toPrune > 0) {
        _evict();
        toPrune--;
      }
    },
    /** Clears all key-value pairs from the cache. */
    clear() {
      if (typeof onEviction === "function") {
        let current = head;
        for (let i = 0; i < size; i++) {
          onEviction(keyList[current], valList[current]);
          current = next[current];
        }
      }
      keyMap.clear();
      keyList.fill(void 0);
      valList.fill(void 0);
      free = [];
      size = 0;
      head = tail = 0;
    },
    /** Resizes the cache to a new maximum size, evicting items if necessary. */
    resize: (newMax) => {
      if (!(Number.isInteger(newMax) && newMax > 0))
        throw new TypeError("`max` must be a positive integer");
      if (newMax === max) return;
      if (newMax < max) {
        let current = tail;
        const preserve = Math.min(size, newMax);
        const remove = size - preserve;
        const newKeyList = new Array(newMax);
        const newValList = new Array(newMax);
        const newNext = new Array(newMax);
        const newPrev = new Array(newMax);
        for (let i = 1; i <= remove; i++)
          onEviction == null ? void 0 : onEviction(keyList[i], valList[i]);
        for (let i = preserve - 1; i >= 0; i--) {
          newKeyList[i] = keyList[current];
          newValList[i] = valList[current];
          newNext[i] = i + 1;
          newPrev[i] = i - 1;
          keyMap.set(newKeyList[i], i);
          current = prev[current];
        }
        head = 0;
        tail = preserve - 1;
        size = preserve;
        keyList.length = newMax;
        valList.length = newMax;
        next.length = newMax;
        prev.length = newMax;
        for (let i = 0; i < preserve; i++) {
          keyList[i] = newKeyList[i];
          valList[i] = newValList[i];
          next[i] = newNext[i];
          prev[i] = newPrev[i];
        }
        free = [];
        for (let i = preserve; i < newMax; i++) free.push(i);
      } else {
        const fill = newMax - max;
        keyList.push(...new Array(fill).fill(void 0));
        valList.push(...new Array(fill).fill(void 0));
        next.push(...new Array(fill).fill(0));
        prev.push(...new Array(fill).fill(0));
      }
      max = newMax;
    },
    /** Returns the maximum number of items that can be stored in the cache. */
    get max() {
      return max;
    },
    /** Returns the number of items currently stored in the cache. */
    get size() {
      return size;
    },
    /** Returns the number of currently available slots in the cache before reaching the maximum size. */
    get available() {
      return max - size;
    }
  };
};

const lib$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  createLRU: createLRU$3
}, Symbol.toStringTag, { value: 'Module' }));

const require$$7$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(lib$3);

const { createLRU: createLRU$2 } = require$$7$1;

const parserCache$2 = createLRU$2({
  max: 15000,
});

function keyFromFields(type, fields, options, config) {
  const res = [
    type,
    typeof options.nestTables,
    options.nestTables,
    Boolean(options.rowsAsArray),
    Boolean(options.supportBigNumbers || config.supportBigNumbers),
    Boolean(options.bigNumberStrings || config.bigNumberStrings),
    typeof options.typeCast === 'boolean'
      ? options.typeCast
      : typeof options.typeCast,
    options.timezone || config.timezone,
    Boolean(options.decimalNumbers),
    options.dateStrings,
  ];

  for (let i = 0; i < fields.length; ++i) {
    const field = fields[i];

    res.push([
      field.name,
      field.columnType,
      field.length,
      field.schema,
      field.table,
      field.flags,
      field.characterSet,
    ]);
  }

  return JSON.stringify(res, null, 0);
}

function getParser(type, fields, options, config, compiler) {
  const key = keyFromFields(type, fields, options, config);
  let parser = parserCache$2.get(key);

  if (parser) {
    return parser;
  }

  parser = compiler(fields, options, config);
  parserCache$2.set(key, parser);
  return parser;
}

function setMaxCache(max) {
  parserCache$2.resize(max);
}

function clearCache() {
  parserCache$2.clear();
}

var parser_cache = {
  getParser: getParser,
  setMaxCache: setMaxCache,
  clearCache: clearCache,
  _keyFromFields: keyFromFields,
};

const require$$0$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(process$5);

/**
 * Custom implementation of a double ended queue.
 */
function Denque(array, options) {
  var options = options || {};
  this._capacity = options.capacity;

  this._head = 0;
  this._tail = 0;

  if (Array.isArray(array)) {
    this._fromArray(array);
  } else {
    this._capacityMask = 0x3;
    this._list = new Array(4);
  }
}

/**
 * --------------
 *  PUBLIC API
 * -------------
 */

/**
 * Returns the item at the specified index from the list.
 * 0 is the first element, 1 is the second, and so on...
 * Elements at negative values are that many from the end: -1 is one before the end
 * (the last element), -2 is two before the end (one before last), etc.
 * @param index
 * @returns {*}
 */
Denque.prototype.peekAt = function peekAt(index) {
  var i = index;
  // expect a number or return undefined
  if ((i !== (i | 0))) {
    return void 0;
  }
  var len = this.size();
  if (i >= len || i < -len) return undefined;
  if (i < 0) i += len;
  i = (this._head + i) & this._capacityMask;
  return this._list[i];
};

/**
 * Alias for peekAt()
 * @param i
 * @returns {*}
 */
Denque.prototype.get = function get(i) {
  return this.peekAt(i);
};

/**
 * Returns the first item in the list without removing it.
 * @returns {*}
 */
Denque.prototype.peek = function peek() {
  if (this._head === this._tail) return undefined;
  return this._list[this._head];
};

/**
 * Alias for peek()
 * @returns {*}
 */
Denque.prototype.peekFront = function peekFront() {
  return this.peek();
};

/**
 * Returns the item that is at the back of the queue without removing it.
 * Uses peekAt(-1)
 */
Denque.prototype.peekBack = function peekBack() {
  return this.peekAt(-1);
};

/**
 * Returns the current length of the queue
 * @return {Number}
 */
Object.defineProperty(Denque.prototype, 'length', {
  get: function length() {
    return this.size();
  }
});

/**
 * Return the number of items on the list, or 0 if empty.
 * @returns {number}
 */
Denque.prototype.size = function size() {
  if (this._head === this._tail) return 0;
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};

/**
 * Add an item at the beginning of the list.
 * @param item
 */
Denque.prototype.unshift = function unshift(item) {
  if (arguments.length === 0) return this.size();
  var len = this._list.length;
  this._head = (this._head - 1 + len) & this._capacityMask;
  this._list[this._head] = item;
  if (this._tail === this._head) this._growArray();
  if (this._capacity && this.size() > this._capacity) this.pop();
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};

/**
 * Remove and return the first item on the list,
 * Returns undefined if the list is empty.
 * @returns {*}
 */
Denque.prototype.shift = function shift() {
  var head = this._head;
  if (head === this._tail) return undefined;
  var item = this._list[head];
  this._list[head] = undefined;
  this._head = (head + 1) & this._capacityMask;
  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();
  return item;
};

/**
 * Add an item to the bottom of the list.
 * @param item
 */
Denque.prototype.push = function push(item) {
  if (arguments.length === 0) return this.size();
  var tail = this._tail;
  this._list[tail] = item;
  this._tail = (tail + 1) & this._capacityMask;
  if (this._tail === this._head) {
    this._growArray();
  }
  if (this._capacity && this.size() > this._capacity) {
    this.shift();
  }
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};

/**
 * Remove and return the last item on the list.
 * Returns undefined if the list is empty.
 * @returns {*}
 */
Denque.prototype.pop = function pop() {
  var tail = this._tail;
  if (tail === this._head) return undefined;
  var len = this._list.length;
  this._tail = (tail - 1 + len) & this._capacityMask;
  var item = this._list[this._tail];
  this._list[this._tail] = undefined;
  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();
  return item;
};

/**
 * Remove and return the item at the specified index from the list.
 * Returns undefined if the list is empty.
 * @param index
 * @returns {*}
 */
Denque.prototype.removeOne = function removeOne(index) {
  var i = index;
  // expect a number or return undefined
  if ((i !== (i | 0))) {
    return void 0;
  }
  if (this._head === this._tail) return void 0;
  var size = this.size();
  var len = this._list.length;
  if (i >= size || i < -size) return void 0;
  if (i < 0) i += size;
  i = (this._head + i) & this._capacityMask;
  var item = this._list[i];
  var k;
  if (index < size / 2) {
    for (k = index; k > 0; k--) {
      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];
    }
    this._list[i] = void 0;
    this._head = (this._head + 1 + len) & this._capacityMask;
  } else {
    for (k = size - 1 - index; k > 0; k--) {
      this._list[i] = this._list[i = (i + 1 + len) & this._capacityMask];
    }
    this._list[i] = void 0;
    this._tail = (this._tail - 1 + len) & this._capacityMask;
  }
  return item;
};

/**
 * Remove number of items from the specified index from the list.
 * Returns array of removed items.
 * Returns undefined if the list is empty.
 * @param index
 * @param count
 * @returns {array}
 */
Denque.prototype.remove = function remove(index, count) {
  var i = index;
  var removed;
  var del_count = count;
  // expect a number or return undefined
  if ((i !== (i | 0))) {
    return void 0;
  }
  if (this._head === this._tail) return void 0;
  var size = this.size();
  var len = this._list.length;
  if (i >= size || i < -size || count < 1) return void 0;
  if (i < 0) i += size;
  if (count === 1 || !count) {
    removed = new Array(1);
    removed[0] = this.removeOne(i);
    return removed;
  }
  if (i === 0 && i + count >= size) {
    removed = this.toArray();
    this.clear();
    return removed;
  }
  if (i + count > size) count = size - i;
  var k;
  removed = new Array(count);
  for (k = 0; k < count; k++) {
    removed[k] = this._list[(this._head + i + k) & this._capacityMask];
  }
  i = (this._head + i) & this._capacityMask;
  if (index + count === size) {
    this._tail = (this._tail - count + len) & this._capacityMask;
    for (k = count; k > 0; k--) {
      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;
    }
    return removed;
  }
  if (index === 0) {
    this._head = (this._head + count + len) & this._capacityMask;
    for (k = count - 1; k > 0; k--) {
      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;
    }
    return removed;
  }
  if (i < size / 2) {
    this._head = (this._head + index + count + len) & this._capacityMask;
    for (k = index; k > 0; k--) {
      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);
    }
    i = (this._head - 1 + len) & this._capacityMask;
    while (del_count > 0) {
      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;
      del_count--;
    }
    if (index < 0) this._tail = i;
  } else {
    this._tail = i;
    i = (i + count + len) & this._capacityMask;
    for (k = size - (count + index); k > 0; k--) {
      this.push(this._list[i++]);
    }
    i = this._tail;
    while (del_count > 0) {
      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;
      del_count--;
    }
  }
  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();
  return removed;
};

/**
 * Native splice implementation.
 * Remove number of items from the specified index from the list and/or add new elements.
 * Returns array of removed items or empty array if count == 0.
 * Returns undefined if the list is empty.
 *
 * @param index
 * @param count
 * @param {...*} [elements]
 * @returns {array}
 */
Denque.prototype.splice = function splice(index, count) {
  var i = index;
  // expect a number or return undefined
  if ((i !== (i | 0))) {
    return void 0;
  }
  var size = this.size();
  if (i < 0) i += size;
  if (i > size) return void 0;
  if (arguments.length > 2) {
    var k;
    var temp;
    var removed;
    var arg_len = arguments.length;
    var len = this._list.length;
    var arguments_index = 2;
    if (!size || i < size / 2) {
      temp = new Array(i);
      for (k = 0; k < i; k++) {
        temp[k] = this._list[(this._head + k) & this._capacityMask];
      }
      if (count === 0) {
        removed = [];
        if (i > 0) {
          this._head = (this._head + i + len) & this._capacityMask;
        }
      } else {
        removed = this.remove(i, count);
        this._head = (this._head + i + len) & this._capacityMask;
      }
      while (arg_len > arguments_index) {
        this.unshift(arguments[--arg_len]);
      }
      for (k = i; k > 0; k--) {
        this.unshift(temp[k - 1]);
      }
    } else {
      temp = new Array(size - (i + count));
      var leng = temp.length;
      for (k = 0; k < leng; k++) {
        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];
      }
      if (count === 0) {
        removed = [];
        if (i != size) {
          this._tail = (this._head + i + len) & this._capacityMask;
        }
      } else {
        removed = this.remove(i, count);
        this._tail = (this._tail - leng + len) & this._capacityMask;
      }
      while (arguments_index < arg_len) {
        this.push(arguments[arguments_index++]);
      }
      for (k = 0; k < leng; k++) {
        this.push(temp[k]);
      }
    }
    return removed;
  } else {
    return this.remove(i, count);
  }
};

/**
 * Soft clear - does not reset capacity.
 */
Denque.prototype.clear = function clear() {
  this._list = new Array(this._list.length);
  this._head = 0;
  this._tail = 0;
};

/**
 * Returns true or false whether the list is empty.
 * @returns {boolean}
 */
Denque.prototype.isEmpty = function isEmpty() {
  return this._head === this._tail;
};

/**
 * Returns an array of all queue items.
 * @returns {Array}
 */
Denque.prototype.toArray = function toArray() {
  return this._copyArray(false);
};

/**
 * -------------
 *   INTERNALS
 * -------------
 */

/**
 * Fills the queue with items from an array
 * For use in the constructor
 * @param array
 * @private
 */
Denque.prototype._fromArray = function _fromArray(array) {
  var length = array.length;
  var capacity = this._nextPowerOf2(length);

  this._list = new Array(capacity);
  this._capacityMask = capacity - 1;
  this._tail = length;

  for (var i = 0; i < length; i++) this._list[i] = array[i];
};

/**
 *
 * @param fullCopy
 * @param size Initialize the array with a specific size. Will default to the current list size
 * @returns {Array}
 * @private
 */
Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
  var src = this._list;
  var capacity = src.length;
  var length = this.length;
  size = size | length;

  // No prealloc requested and the buffer is contiguous
  if (size == length && this._head < this._tail) {
    // Simply do a fast slice copy
    return this._list.slice(this._head, this._tail);
  }

  var dest = new Array(size);

  var k = 0;
  var i;
  if (fullCopy || this._head > this._tail) {
    for (i = this._head; i < capacity; i++) dest[k++] = src[i];
    for (i = 0; i < this._tail; i++) dest[k++] = src[i];
  } else {
    for (i = this._head; i < this._tail; i++) dest[k++] = src[i];
  }

  return dest;
};

/**
 * Grows the internal list array.
 * @private
 */
Denque.prototype._growArray = function _growArray() {
  if (this._head != 0) {
    // double array size and copy existing data, head to end, then beginning to tail.
    var newList = this._copyArray(true, this._list.length << 1);

    this._tail = this._list.length;
    this._head = 0;

    this._list = newList;
  } else {
    this._tail = this._list.length;
    this._list.length <<= 1;
  }

  this._capacityMask = (this._capacityMask << 1) | 1;
};

/**
 * Shrinks the internal list array.
 * @private
 */
Denque.prototype._shrinkArray = function _shrinkArray() {
  this._list.length >>>= 1;
  this._capacityMask >>>= 1;
};

/**
 * Find the next power of 2, at least 4
 * @private
 * @param {number} num 
 * @returns {number}
 */
Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
  var log2 = Math.log(num) / Math.log(2);
  var nextPow2 = 1 << (log2 + 1);

  return Math.max(nextPow2, 4);
};

var denque = Denque;

var errors = {};

(function (exports$1) {

	// originally copied from https://raw.githubusercontent.com/mysqljs/mysql/7770ee5bb13260c56a160b91fe480d9165dbeeba/lib/protocol/constants/errors.js
	// (c) node-mysql authors

	// updated to contain error codes as is contained in MySQL 8.0
	// by adapting node-mysql: /.../generate-error-constants.js

	/**
	 * MySQL error constants
	 *
	 * Extracted from version 8.0.33
	 *
	 * !! Generated by generate-error-constants.js, do not modify by hand !!
	 */

	exports$1.EE_CANTCREATEFILE = 1;
	exports$1.EE_READ = 2;
	exports$1.EE_WRITE = 3;
	exports$1.EE_BADCLOSE = 4;
	exports$1.EE_OUTOFMEMORY = 5;
	exports$1.EE_DELETE = 6;
	exports$1.EE_LINK = 7;
	exports$1.EE_EOFERR = 9;
	exports$1.EE_CANTLOCK = 10;
	exports$1.EE_CANTUNLOCK = 11;
	exports$1.EE_DIR = 12;
	exports$1.EE_STAT = 13;
	exports$1.EE_CANT_CHSIZE = 14;
	exports$1.EE_CANT_OPEN_STREAM = 15;
	exports$1.EE_GETWD = 16;
	exports$1.EE_SETWD = 17;
	exports$1.EE_LINK_WARNING = 18;
	exports$1.EE_OPEN_WARNING = 19;
	exports$1.EE_DISK_FULL = 20;
	exports$1.EE_CANT_MKDIR = 21;
	exports$1.EE_UNKNOWN_CHARSET = 22;
	exports$1.EE_OUT_OF_FILERESOURCES = 23;
	exports$1.EE_CANT_READLINK = 24;
	exports$1.EE_CANT_SYMLINK = 25;
	exports$1.EE_REALPATH = 26;
	exports$1.EE_SYNC = 27;
	exports$1.EE_UNKNOWN_COLLATION = 28;
	exports$1.EE_FILENOTFOUND = 29;
	exports$1.EE_FILE_NOT_CLOSED = 30;
	exports$1.EE_CHANGE_OWNERSHIP = 31;
	exports$1.EE_CHANGE_PERMISSIONS = 32;
	exports$1.EE_CANT_SEEK = 33;
	exports$1.EE_CAPACITY_EXCEEDED = 34;
	exports$1.EE_DISK_FULL_WITH_RETRY_MSG = 35;
	exports$1.EE_FAILED_TO_CREATE_TIMER = 36;
	exports$1.EE_FAILED_TO_DELETE_TIMER = 37;
	exports$1.EE_FAILED_TO_CREATE_TIMER_QUEUE = 38;
	exports$1.EE_FAILED_TO_START_TIMER_NOTIFY_THREAD = 39;
	exports$1.EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT = 40;
	exports$1.EE_EXITING_TIMER_NOTIFY_THREAD = 41;
	exports$1.EE_WIN_LIBRARY_LOAD_FAILED = 42;
	exports$1.EE_WIN_RUN_TIME_ERROR_CHECK = 43;
	exports$1.EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE = 44;
	exports$1.EE_FAILED_TO_KILL_ALL_THREADS = 45;
	exports$1.EE_FAILED_TO_CREATE_IO_COMPLETION_PORT = 46;
	exports$1.EE_FAILED_TO_OPEN_DEFAULTS_FILE = 47;
	exports$1.EE_FAILED_TO_HANDLE_DEFAULTS_FILE = 48;
	exports$1.EE_WRONG_DIRECTIVE_IN_CONFIG_FILE = 49;
	exports$1.EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION = 50;
	exports$1.EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE = 51;
	exports$1.EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE = 52;
	exports$1.EE_CONFIG_FILE_PERMISSION_ERROR = 53;
	exports$1.EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE = 54;
	exports$1.EE_USING_DISABLED_OPTION = 55;
	exports$1.EE_USING_DISABLED_SHORT_OPTION = 56;
	exports$1.EE_USING_PASSWORD_ON_CLI_IS_INSECURE = 57;
	exports$1.EE_UNKNOWN_SUFFIX_FOR_VARIABLE = 58;
	exports$1.EE_SSL_ERROR_FROM_FILE = 59;
	exports$1.EE_SSL_ERROR = 60;
	exports$1.EE_NET_SEND_ERROR_IN_BOOTSTRAP = 61;
	exports$1.EE_PACKETS_OUT_OF_ORDER = 62;
	exports$1.EE_UNKNOWN_PROTOCOL_OPTION = 63;
	exports$1.EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY = 64;
	exports$1.EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT = 65;
	exports$1.EE_DEBUG_INFO = 66;
	exports$1.EE_UNKNOWN_VARIABLE = 67;
	exports$1.EE_UNKNOWN_OPTION = 68;
	exports$1.EE_UNKNOWN_SHORT_OPTION = 69;
	exports$1.EE_OPTION_WITHOUT_ARGUMENT = 70;
	exports$1.EE_OPTION_REQUIRES_ARGUMENT = 71;
	exports$1.EE_SHORT_OPTION_REQUIRES_ARGUMENT = 72;
	exports$1.EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE = 73;
	exports$1.EE_OPTION_WITH_EMPTY_VALUE = 74;
	exports$1.EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION = 75;
	exports$1.EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION = 76;
	exports$1.EE_FAILED_TO_SET_OPTION_VALUE = 77;
	exports$1.EE_INCORRECT_INT_VALUE_FOR_OPTION = 78;
	exports$1.EE_INCORRECT_UINT_VALUE_FOR_OPTION = 79;
	exports$1.EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION = 80;
	exports$1.EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION = 81;
	exports$1.EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION = 82;
	exports$1.EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION = 83;
	exports$1.EE_INVALID_DECIMAL_VALUE_FOR_OPTION = 84;
	exports$1.EE_COLLATION_PARSER_ERROR = 85;
	exports$1.EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR = 86;
	exports$1.EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR = 87;
	exports$1.EE_SHIFT_CHAR_OUT_OF_RANGE = 88;
	exports$1.EE_RESET_CHAR_OUT_OF_RANGE = 89;
	exports$1.EE_UNKNOWN_LDML_TAG = 90;
	exports$1.EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR = 91;
	exports$1.EE_FAILED_PROCESSING_DIRECTIVE = 92;
	exports$1.EE_PTHREAD_KILL_FAILED = 93;
	exports$1.HA_ERR_KEY_NOT_FOUND = 120;
	exports$1.HA_ERR_FOUND_DUPP_KEY = 121;
	exports$1.HA_ERR_INTERNAL_ERROR = 122;
	exports$1.HA_ERR_RECORD_CHANGED = 123;
	exports$1.HA_ERR_WRONG_INDEX = 124;
	exports$1.HA_ERR_ROLLED_BACK = 125;
	exports$1.HA_ERR_CRASHED = 126;
	exports$1.HA_ERR_WRONG_IN_RECORD = 127;
	exports$1.HA_ERR_OUT_OF_MEM = 128;
	exports$1.HA_ERR_NOT_A_TABLE = 130;
	exports$1.HA_ERR_WRONG_COMMAND = 131;
	exports$1.HA_ERR_OLD_FILE = 132;
	exports$1.HA_ERR_NO_ACTIVE_RECORD = 133;
	exports$1.HA_ERR_RECORD_DELETED = 134;
	exports$1.HA_ERR_RECORD_FILE_FULL = 135;
	exports$1.HA_ERR_INDEX_FILE_FULL = 136;
	exports$1.HA_ERR_END_OF_FILE = 137;
	exports$1.HA_ERR_UNSUPPORTED = 138;
	exports$1.HA_ERR_TOO_BIG_ROW = 139;
	exports$1.HA_WRONG_CREATE_OPTION = 140;
	exports$1.HA_ERR_FOUND_DUPP_UNIQUE = 141;
	exports$1.HA_ERR_UNKNOWN_CHARSET = 142;
	exports$1.HA_ERR_WRONG_MRG_TABLE_DEF = 143;
	exports$1.HA_ERR_CRASHED_ON_REPAIR = 144;
	exports$1.HA_ERR_CRASHED_ON_USAGE = 145;
	exports$1.HA_ERR_LOCK_WAIT_TIMEOUT = 146;
	exports$1.HA_ERR_LOCK_TABLE_FULL = 147;
	exports$1.HA_ERR_READ_ONLY_TRANSACTION = 148;
	exports$1.HA_ERR_LOCK_DEADLOCK = 149;
	exports$1.HA_ERR_CANNOT_ADD_FOREIGN = 150;
	exports$1.HA_ERR_NO_REFERENCED_ROW = 151;
	exports$1.HA_ERR_ROW_IS_REFERENCED = 152;
	exports$1.HA_ERR_NO_SAVEPOINT = 153;
	exports$1.HA_ERR_NON_UNIQUE_BLOCK_SIZE = 154;
	exports$1.HA_ERR_NO_SUCH_TABLE = 155;
	exports$1.HA_ERR_TABLE_EXIST = 156;
	exports$1.HA_ERR_NO_CONNECTION = 157;
	exports$1.HA_ERR_NULL_IN_SPATIAL = 158;
	exports$1.HA_ERR_TABLE_DEF_CHANGED = 159;
	exports$1.HA_ERR_NO_PARTITION_FOUND = 160;
	exports$1.HA_ERR_RBR_LOGGING_FAILED = 161;
	exports$1.HA_ERR_DROP_INDEX_FK = 162;
	exports$1.HA_ERR_FOREIGN_DUPLICATE_KEY = 163;
	exports$1.HA_ERR_TABLE_NEEDS_UPGRADE = 164;
	exports$1.HA_ERR_TABLE_READONLY = 165;
	exports$1.HA_ERR_AUTOINC_READ_FAILED = 166;
	exports$1.HA_ERR_AUTOINC_ERANGE = 167;
	exports$1.HA_ERR_GENERIC = 168;
	exports$1.HA_ERR_RECORD_IS_THE_SAME = 169;
	exports$1.HA_ERR_LOGGING_IMPOSSIBLE = 170;
	exports$1.HA_ERR_CORRUPT_EVENT = 171;
	exports$1.HA_ERR_NEW_FILE = 172;
	exports$1.HA_ERR_ROWS_EVENT_APPLY = 173;
	exports$1.HA_ERR_INITIALIZATION = 174;
	exports$1.HA_ERR_FILE_TOO_SHORT = 175;
	exports$1.HA_ERR_WRONG_CRC = 176;
	exports$1.HA_ERR_TOO_MANY_CONCURRENT_TRXS = 177;
	exports$1.HA_ERR_NOT_IN_LOCK_PARTITIONS = 178;
	exports$1.HA_ERR_INDEX_COL_TOO_LONG = 179;
	exports$1.HA_ERR_INDEX_CORRUPT = 180;
	exports$1.HA_ERR_UNDO_REC_TOO_BIG = 181;
	exports$1.HA_FTS_INVALID_DOCID = 182;
	exports$1.HA_ERR_TABLE_IN_FK_CHECK = 183;
	exports$1.HA_ERR_TABLESPACE_EXISTS = 184;
	exports$1.HA_ERR_TOO_MANY_FIELDS = 185;
	exports$1.HA_ERR_ROW_IN_WRONG_PARTITION = 186;
	exports$1.HA_ERR_INNODB_READ_ONLY = 187;
	exports$1.HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT = 188;
	exports$1.HA_ERR_TEMP_FILE_WRITE_FAILURE = 189;
	exports$1.HA_ERR_INNODB_FORCED_RECOVERY = 190;
	exports$1.HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE = 191;
	exports$1.HA_ERR_FK_DEPTH_EXCEEDED = 192;
	exports$1.HA_MISSING_CREATE_OPTION = 193;
	exports$1.HA_ERR_SE_OUT_OF_MEMORY = 194;
	exports$1.HA_ERR_TABLE_CORRUPT = 195;
	exports$1.HA_ERR_QUERY_INTERRUPTED = 196;
	exports$1.HA_ERR_TABLESPACE_MISSING = 197;
	exports$1.HA_ERR_TABLESPACE_IS_NOT_EMPTY = 198;
	exports$1.HA_ERR_WRONG_FILE_NAME = 199;
	exports$1.HA_ERR_NOT_ALLOWED_COMMAND = 200;
	exports$1.HA_ERR_COMPUTE_FAILED = 201;
	exports$1.HA_ERR_ROW_FORMAT_CHANGED = 202;
	exports$1.HA_ERR_NO_WAIT_LOCK = 203;
	exports$1.HA_ERR_DISK_FULL_NOWAIT = 204;
	exports$1.HA_ERR_NO_SESSION_TEMP = 205;
	exports$1.HA_ERR_WRONG_TABLE_NAME = 206;
	exports$1.HA_ERR_TOO_LONG_PATH = 207;
	exports$1.HA_ERR_SAMPLING_INIT_FAILED = 208;
	exports$1.HA_ERR_FTS_TOO_MANY_NESTED_EXP = 209;
	exports$1.ER_HASHCHK = 1000;
	exports$1.ER_NISAMCHK = 1001;
	exports$1.ER_NO = 1002;
	exports$1.ER_YES = 1003;
	exports$1.ER_CANT_CREATE_FILE = 1004;
	exports$1.ER_CANT_CREATE_TABLE = 1005;
	exports$1.ER_CANT_CREATE_DB = 1006;
	exports$1.ER_DB_CREATE_EXISTS = 1007;
	exports$1.ER_DB_DROP_EXISTS = 1008;
	exports$1.ER_DB_DROP_DELETE = 1009;
	exports$1.ER_DB_DROP_RMDIR = 1010;
	exports$1.ER_CANT_DELETE_FILE = 1011;
	exports$1.ER_CANT_FIND_SYSTEM_REC = 1012;
	exports$1.ER_CANT_GET_STAT = 1013;
	exports$1.ER_CANT_GET_WD = 1014;
	exports$1.ER_CANT_LOCK = 1015;
	exports$1.ER_CANT_OPEN_FILE = 1016;
	exports$1.ER_FILE_NOT_FOUND = 1017;
	exports$1.ER_CANT_READ_DIR = 1018;
	exports$1.ER_CANT_SET_WD = 1019;
	exports$1.ER_CHECKREAD = 1020;
	exports$1.ER_DISK_FULL = 1021;
	exports$1.ER_DUP_KEY = 1022;
	exports$1.ER_ERROR_ON_CLOSE = 1023;
	exports$1.ER_ERROR_ON_READ = 1024;
	exports$1.ER_ERROR_ON_RENAME = 1025;
	exports$1.ER_ERROR_ON_WRITE = 1026;
	exports$1.ER_FILE_USED = 1027;
	exports$1.ER_FILSORT_ABORT = 1028;
	exports$1.ER_FORM_NOT_FOUND = 1029;
	exports$1.ER_GET_ERRNO = 1030;
	exports$1.ER_ILLEGAL_HA = 1031;
	exports$1.ER_KEY_NOT_FOUND = 1032;
	exports$1.ER_NOT_FORM_FILE = 1033;
	exports$1.ER_NOT_KEYFILE = 1034;
	exports$1.ER_OLD_KEYFILE = 1035;
	exports$1.ER_OPEN_AS_READONLY = 1036;
	exports$1.ER_OUTOFMEMORY = 1037;
	exports$1.ER_OUT_OF_SORTMEMORY = 1038;
	exports$1.ER_UNEXPECTED_EOF = 1039;
	exports$1.ER_CON_COUNT_ERROR = 1040;
	exports$1.ER_OUT_OF_RESOURCES = 1041;
	exports$1.ER_BAD_HOST_ERROR = 1042;
	exports$1.ER_HANDSHAKE_ERROR = 1043;
	exports$1.ER_DBACCESS_DENIED_ERROR = 1044;
	exports$1.ER_ACCESS_DENIED_ERROR = 1045;
	exports$1.ER_NO_DB_ERROR = 1046;
	exports$1.ER_UNKNOWN_COM_ERROR = 1047;
	exports$1.ER_BAD_NULL_ERROR = 1048;
	exports$1.ER_BAD_DB_ERROR = 1049;
	exports$1.ER_TABLE_EXISTS_ERROR = 1050;
	exports$1.ER_BAD_TABLE_ERROR = 1051;
	exports$1.ER_NON_UNIQ_ERROR = 1052;
	exports$1.ER_SERVER_SHUTDOWN = 1053;
	exports$1.ER_BAD_FIELD_ERROR = 1054;
	exports$1.ER_WRONG_FIELD_WITH_GROUP = 1055;
	exports$1.ER_WRONG_GROUP_FIELD = 1056;
	exports$1.ER_WRONG_SUM_SELECT = 1057;
	exports$1.ER_WRONG_VALUE_COUNT = 1058;
	exports$1.ER_TOO_LONG_IDENT = 1059;
	exports$1.ER_DUP_FIELDNAME = 1060;
	exports$1.ER_DUP_KEYNAME = 1061;
	exports$1.ER_DUP_ENTRY = 1062;
	exports$1.ER_WRONG_FIELD_SPEC = 1063;
	exports$1.ER_PARSE_ERROR = 1064;
	exports$1.ER_EMPTY_QUERY = 1065;
	exports$1.ER_NONUNIQ_TABLE = 1066;
	exports$1.ER_INVALID_DEFAULT = 1067;
	exports$1.ER_MULTIPLE_PRI_KEY = 1068;
	exports$1.ER_TOO_MANY_KEYS = 1069;
	exports$1.ER_TOO_MANY_KEY_PARTS = 1070;
	exports$1.ER_TOO_LONG_KEY = 1071;
	exports$1.ER_KEY_COLUMN_DOES_NOT_EXITS = 1072;
	exports$1.ER_BLOB_USED_AS_KEY = 1073;
	exports$1.ER_TOO_BIG_FIELDLENGTH = 1074;
	exports$1.ER_WRONG_AUTO_KEY = 1075;
	exports$1.ER_READY = 1076;
	exports$1.ER_NORMAL_SHUTDOWN = 1077;
	exports$1.ER_GOT_SIGNAL = 1078;
	exports$1.ER_SHUTDOWN_COMPLETE = 1079;
	exports$1.ER_FORCING_CLOSE = 1080;
	exports$1.ER_IPSOCK_ERROR = 1081;
	exports$1.ER_NO_SUCH_INDEX = 1082;
	exports$1.ER_WRONG_FIELD_TERMINATORS = 1083;
	exports$1.ER_BLOBS_AND_NO_TERMINATED = 1084;
	exports$1.ER_TEXTFILE_NOT_READABLE = 1085;
	exports$1.ER_FILE_EXISTS_ERROR = 1086;
	exports$1.ER_LOAD_INFO = 1087;
	exports$1.ER_ALTER_INFO = 1088;
	exports$1.ER_WRONG_SUB_KEY = 1089;
	exports$1.ER_CANT_REMOVE_ALL_FIELDS = 1090;
	exports$1.ER_CANT_DROP_FIELD_OR_KEY = 1091;
	exports$1.ER_INSERT_INFO = 1092;
	exports$1.ER_UPDATE_TABLE_USED = 1093;
	exports$1.ER_NO_SUCH_THREAD = 1094;
	exports$1.ER_KILL_DENIED_ERROR = 1095;
	exports$1.ER_NO_TABLES_USED = 1096;
	exports$1.ER_TOO_BIG_SET = 1097;
	exports$1.ER_NO_UNIQUE_LOGFILE = 1098;
	exports$1.ER_TABLE_NOT_LOCKED_FOR_WRITE = 1099;
	exports$1.ER_TABLE_NOT_LOCKED = 1100;
	exports$1.ER_BLOB_CANT_HAVE_DEFAULT = 1101;
	exports$1.ER_WRONG_DB_NAME = 1102;
	exports$1.ER_WRONG_TABLE_NAME = 1103;
	exports$1.ER_TOO_BIG_SELECT = 1104;
	exports$1.ER_UNKNOWN_ERROR = 1105;
	exports$1.ER_UNKNOWN_PROCEDURE = 1106;
	exports$1.ER_WRONG_PARAMCOUNT_TO_PROCEDURE = 1107;
	exports$1.ER_WRONG_PARAMETERS_TO_PROCEDURE = 1108;
	exports$1.ER_UNKNOWN_TABLE = 1109;
	exports$1.ER_FIELD_SPECIFIED_TWICE = 1110;
	exports$1.ER_INVALID_GROUP_FUNC_USE = 1111;
	exports$1.ER_UNSUPPORTED_EXTENSION = 1112;
	exports$1.ER_TABLE_MUST_HAVE_COLUMNS = 1113;
	exports$1.ER_RECORD_FILE_FULL = 1114;
	exports$1.ER_UNKNOWN_CHARACTER_SET = 1115;
	exports$1.ER_TOO_MANY_TABLES = 1116;
	exports$1.ER_TOO_MANY_FIELDS = 1117;
	exports$1.ER_TOO_BIG_ROWSIZE = 1118;
	exports$1.ER_STACK_OVERRUN = 1119;
	exports$1.ER_WRONG_OUTER_JOIN = 1120;
	exports$1.ER_NULL_COLUMN_IN_INDEX = 1121;
	exports$1.ER_CANT_FIND_UDF = 1122;
	exports$1.ER_CANT_INITIALIZE_UDF = 1123;
	exports$1.ER_UDF_NO_PATHS = 1124;
	exports$1.ER_UDF_EXISTS = 1125;
	exports$1.ER_CANT_OPEN_LIBRARY = 1126;
	exports$1.ER_CANT_FIND_DL_ENTRY = 1127;
	exports$1.ER_FUNCTION_NOT_DEFINED = 1128;
	exports$1.ER_HOST_IS_BLOCKED = 1129;
	exports$1.ER_HOST_NOT_PRIVILEGED = 1130;
	exports$1.ER_PASSWORD_ANONYMOUS_USER = 1131;
	exports$1.ER_PASSWORD_NOT_ALLOWED = 1132;
	exports$1.ER_PASSWORD_NO_MATCH = 1133;
	exports$1.ER_UPDATE_INFO = 1134;
	exports$1.ER_CANT_CREATE_THREAD = 1135;
	exports$1.ER_WRONG_VALUE_COUNT_ON_ROW = 1136;
	exports$1.ER_CANT_REOPEN_TABLE = 1137;
	exports$1.ER_INVALID_USE_OF_NULL = 1138;
	exports$1.ER_REGEXP_ERROR = 1139;
	exports$1.ER_MIX_OF_GROUP_FUNC_AND_FIELDS = 1140;
	exports$1.ER_NONEXISTING_GRANT = 1141;
	exports$1.ER_TABLEACCESS_DENIED_ERROR = 1142;
	exports$1.ER_COLUMNACCESS_DENIED_ERROR = 1143;
	exports$1.ER_ILLEGAL_GRANT_FOR_TABLE = 1144;
	exports$1.ER_GRANT_WRONG_HOST_OR_USER = 1145;
	exports$1.ER_NO_SUCH_TABLE = 1146;
	exports$1.ER_NONEXISTING_TABLE_GRANT = 1147;
	exports$1.ER_NOT_ALLOWED_COMMAND = 1148;
	exports$1.ER_SYNTAX_ERROR = 1149;
	exports$1.ER_UNUSED1 = 1150;
	exports$1.ER_UNUSED2 = 1151;
	exports$1.ER_ABORTING_CONNECTION = 1152;
	exports$1.ER_NET_PACKET_TOO_LARGE = 1153;
	exports$1.ER_NET_READ_ERROR_FROM_PIPE = 1154;
	exports$1.ER_NET_FCNTL_ERROR = 1155;
	exports$1.ER_NET_PACKETS_OUT_OF_ORDER = 1156;
	exports$1.ER_NET_UNCOMPRESS_ERROR = 1157;
	exports$1.ER_NET_READ_ERROR = 1158;
	exports$1.ER_NET_READ_INTERRUPTED = 1159;
	exports$1.ER_NET_ERROR_ON_WRITE = 1160;
	exports$1.ER_NET_WRITE_INTERRUPTED = 1161;
	exports$1.ER_TOO_LONG_STRING = 1162;
	exports$1.ER_TABLE_CANT_HANDLE_BLOB = 1163;
	exports$1.ER_TABLE_CANT_HANDLE_AUTO_INCREMENT = 1164;
	exports$1.ER_UNUSED3 = 1165;
	exports$1.ER_WRONG_COLUMN_NAME = 1166;
	exports$1.ER_WRONG_KEY_COLUMN = 1167;
	exports$1.ER_WRONG_MRG_TABLE = 1168;
	exports$1.ER_DUP_UNIQUE = 1169;
	exports$1.ER_BLOB_KEY_WITHOUT_LENGTH = 1170;
	exports$1.ER_PRIMARY_CANT_HAVE_NULL = 1171;
	exports$1.ER_TOO_MANY_ROWS = 1172;
	exports$1.ER_REQUIRES_PRIMARY_KEY = 1173;
	exports$1.ER_NO_RAID_COMPILED = 1174;
	exports$1.ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE = 1175;
	exports$1.ER_KEY_DOES_NOT_EXITS = 1176;
	exports$1.ER_CHECK_NO_SUCH_TABLE = 1177;
	exports$1.ER_CHECK_NOT_IMPLEMENTED = 1178;
	exports$1.ER_CANT_DO_THIS_DURING_AN_TRANSACTION = 1179;
	exports$1.ER_ERROR_DURING_COMMIT = 1180;
	exports$1.ER_ERROR_DURING_ROLLBACK = 1181;
	exports$1.ER_ERROR_DURING_FLUSH_LOGS = 1182;
	exports$1.ER_ERROR_DURING_CHECKPOINT = 1183;
	exports$1.ER_NEW_ABORTING_CONNECTION = 1184;
	exports$1.ER_DUMP_NOT_IMPLEMENTED = 1185;
	exports$1.ER_FLUSH_MASTER_BINLOG_CLOSED = 1186;
	exports$1.ER_INDEX_REBUILD = 1187;
	exports$1.ER_SOURCE = 1188;
	exports$1.ER_SOURCE_NET_READ = 1189;
	exports$1.ER_SOURCE_NET_WRITE = 1190;
	exports$1.ER_FT_MATCHING_KEY_NOT_FOUND = 1191;
	exports$1.ER_LOCK_OR_ACTIVE_TRANSACTION = 1192;
	exports$1.ER_UNKNOWN_SYSTEM_VARIABLE = 1193;
	exports$1.ER_CRASHED_ON_USAGE = 1194;
	exports$1.ER_CRASHED_ON_REPAIR = 1195;
	exports$1.ER_WARNING_NOT_COMPLETE_ROLLBACK = 1196;
	exports$1.ER_TRANS_CACHE_FULL = 1197;
	exports$1.ER_SLAVE_MUST_STOP = 1198;
	exports$1.ER_REPLICA_NOT_RUNNING = 1199;
	exports$1.ER_BAD_REPLICA = 1200;
	exports$1.ER_CONNECTION_METADATA = 1201;
	exports$1.ER_REPLICA_THREAD = 1202;
	exports$1.ER_TOO_MANY_USER_CONNECTIONS = 1203;
	exports$1.ER_SET_CONSTANTS_ONLY = 1204;
	exports$1.ER_LOCK_WAIT_TIMEOUT = 1205;
	exports$1.ER_LOCK_TABLE_FULL = 1206;
	exports$1.ER_READ_ONLY_TRANSACTION = 1207;
	exports$1.ER_DROP_DB_WITH_READ_LOCK = 1208;
	exports$1.ER_CREATE_DB_WITH_READ_LOCK = 1209;
	exports$1.ER_WRONG_ARGUMENTS = 1210;
	exports$1.ER_NO_PERMISSION_TO_CREATE_USER = 1211;
	exports$1.ER_UNION_TABLES_IN_DIFFERENT_DIR = 1212;
	exports$1.ER_LOCK_DEADLOCK = 1213;
	exports$1.ER_TABLE_CANT_HANDLE_FT = 1214;
	exports$1.ER_CANNOT_ADD_FOREIGN = 1215;
	exports$1.ER_NO_REFERENCED_ROW = 1216;
	exports$1.ER_ROW_IS_REFERENCED = 1217;
	exports$1.ER_CONNECT_TO_SOURCE = 1218;
	exports$1.ER_QUERY_ON_MASTER = 1219;
	exports$1.ER_ERROR_WHEN_EXECUTING_COMMAND = 1220;
	exports$1.ER_WRONG_USAGE = 1221;
	exports$1.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT = 1222;
	exports$1.ER_CANT_UPDATE_WITH_READLOCK = 1223;
	exports$1.ER_MIXING_NOT_ALLOWED = 1224;
	exports$1.ER_DUP_ARGUMENT = 1225;
	exports$1.ER_USER_LIMIT_REACHED = 1226;
	exports$1.ER_SPECIFIC_ACCESS_DENIED_ERROR = 1227;
	exports$1.ER_LOCAL_VARIABLE = 1228;
	exports$1.ER_GLOBAL_VARIABLE = 1229;
	exports$1.ER_NO_DEFAULT = 1230;
	exports$1.ER_WRONG_VALUE_FOR_VAR = 1231;
	exports$1.ER_WRONG_TYPE_FOR_VAR = 1232;
	exports$1.ER_VAR_CANT_BE_READ = 1233;
	exports$1.ER_CANT_USE_OPTION_HERE = 1234;
	exports$1.ER_NOT_SUPPORTED_YET = 1235;
	exports$1.ER_SOURCE_FATAL_ERROR_READING_BINLOG = 1236;
	exports$1.ER_REPLICA_IGNORED_TABLE = 1237;
	exports$1.ER_INCORRECT_GLOBAL_LOCAL_VAR = 1238;
	exports$1.ER_WRONG_FK_DEF = 1239;
	exports$1.ER_KEY_REF_DO_NOT_MATCH_TABLE_REF = 1240;
	exports$1.ER_OPERAND_COLUMNS = 1241;
	exports$1.ER_SUBQUERY_NO_1_ROW = 1242;
	exports$1.ER_UNKNOWN_STMT_HANDLER = 1243;
	exports$1.ER_CORRUPT_HELP_DB = 1244;
	exports$1.ER_CYCLIC_REFERENCE = 1245;
	exports$1.ER_AUTO_CONVERT = 1246;
	exports$1.ER_ILLEGAL_REFERENCE = 1247;
	exports$1.ER_DERIVED_MUST_HAVE_ALIAS = 1248;
	exports$1.ER_SELECT_REDUCED = 1249;
	exports$1.ER_TABLENAME_NOT_ALLOWED_HERE = 1250;
	exports$1.ER_NOT_SUPPORTED_AUTH_MODE = 1251;
	exports$1.ER_SPATIAL_CANT_HAVE_NULL = 1252;
	exports$1.ER_COLLATION_CHARSET_MISMATCH = 1253;
	exports$1.ER_SLAVE_WAS_RUNNING = 1254;
	exports$1.ER_SLAVE_WAS_NOT_RUNNING = 1255;
	exports$1.ER_TOO_BIG_FOR_UNCOMPRESS = 1256;
	exports$1.ER_ZLIB_Z_MEM_ERROR = 1257;
	exports$1.ER_ZLIB_Z_BUF_ERROR = 1258;
	exports$1.ER_ZLIB_Z_DATA_ERROR = 1259;
	exports$1.ER_CUT_VALUE_GROUP_CONCAT = 1260;
	exports$1.ER_WARN_TOO_FEW_RECORDS = 1261;
	exports$1.ER_WARN_TOO_MANY_RECORDS = 1262;
	exports$1.ER_WARN_NULL_TO_NOTNULL = 1263;
	exports$1.ER_WARN_DATA_OUT_OF_RANGE = 1264;
	exports$1.WARN_DATA_TRUNCATED = 1265;
	exports$1.ER_WARN_USING_OTHER_HANDLER = 1266;
	exports$1.ER_CANT_AGGREGATE_2COLLATIONS = 1267;
	exports$1.ER_DROP_USER = 1268;
	exports$1.ER_REVOKE_GRANTS = 1269;
	exports$1.ER_CANT_AGGREGATE_3COLLATIONS = 1270;
	exports$1.ER_CANT_AGGREGATE_NCOLLATIONS = 1271;
	exports$1.ER_VARIABLE_IS_NOT_STRUCT = 1272;
	exports$1.ER_UNKNOWN_COLLATION = 1273;
	exports$1.ER_REPLICA_IGNORED_SSL_PARAMS = 1274;
	exports$1.ER_SERVER_IS_IN_SECURE_AUTH_MODE = 1275;
	exports$1.ER_WARN_FIELD_RESOLVED = 1276;
	exports$1.ER_BAD_REPLICA_UNTIL_COND = 1277;
	exports$1.ER_MISSING_SKIP_REPLICA = 1278;
	exports$1.ER_UNTIL_COND_IGNORED = 1279;
	exports$1.ER_WRONG_NAME_FOR_INDEX = 1280;
	exports$1.ER_WRONG_NAME_FOR_CATALOG = 1281;
	exports$1.ER_WARN_QC_RESIZE = 1282;
	exports$1.ER_BAD_FT_COLUMN = 1283;
	exports$1.ER_UNKNOWN_KEY_CACHE = 1284;
	exports$1.ER_WARN_HOSTNAME_WONT_WORK = 1285;
	exports$1.ER_UNKNOWN_STORAGE_ENGINE = 1286;
	exports$1.ER_WARN_DEPRECATED_SYNTAX = 1287;
	exports$1.ER_NON_UPDATABLE_TABLE = 1288;
	exports$1.ER_FEATURE_DISABLED = 1289;
	exports$1.ER_OPTION_PREVENTS_STATEMENT = 1290;
	exports$1.ER_DUPLICATED_VALUE_IN_TYPE = 1291;
	exports$1.ER_TRUNCATED_WRONG_VALUE = 1292;
	exports$1.ER_TOO_MUCH_AUTO_TIMESTAMP_COLS = 1293;
	exports$1.ER_INVALID_ON_UPDATE = 1294;
	exports$1.ER_UNSUPPORTED_PS = 1295;
	exports$1.ER_GET_ERRMSG = 1296;
	exports$1.ER_GET_TEMPORARY_ERRMSG = 1297;
	exports$1.ER_UNKNOWN_TIME_ZONE = 1298;
	exports$1.ER_WARN_INVALID_TIMESTAMP = 1299;
	exports$1.ER_INVALID_CHARACTER_STRING = 1300;
	exports$1.ER_WARN_ALLOWED_PACKET_OVERFLOWED = 1301;
	exports$1.ER_CONFLICTING_DECLARATIONS = 1302;
	exports$1.ER_SP_NO_RECURSIVE_CREATE = 1303;
	exports$1.ER_SP_ALREADY_EXISTS = 1304;
	exports$1.ER_SP_DOES_NOT_EXIST = 1305;
	exports$1.ER_SP_DROP_FAILED = 1306;
	exports$1.ER_SP_STORE_FAILED = 1307;
	exports$1.ER_SP_LILABEL_MISMATCH = 1308;
	exports$1.ER_SP_LABEL_REDEFINE = 1309;
	exports$1.ER_SP_LABEL_MISMATCH = 1310;
	exports$1.ER_SP_UNINIT_VAR = 1311;
	exports$1.ER_SP_BADSELECT = 1312;
	exports$1.ER_SP_BADRETURN = 1313;
	exports$1.ER_SP_BADSTATEMENT = 1314;
	exports$1.ER_UPDATE_LOG_DEPRECATED_IGNORED = 1315;
	exports$1.ER_UPDATE_LOG_DEPRECATED_TRANSLATED = 1316;
	exports$1.ER_QUERY_INTERRUPTED = 1317;
	exports$1.ER_SP_WRONG_NO_OF_ARGS = 1318;
	exports$1.ER_SP_COND_MISMATCH = 1319;
	exports$1.ER_SP_NORETURN = 1320;
	exports$1.ER_SP_NORETURNEND = 1321;
	exports$1.ER_SP_BAD_CURSOR_QUERY = 1322;
	exports$1.ER_SP_BAD_CURSOR_SELECT = 1323;
	exports$1.ER_SP_CURSOR_MISMATCH = 1324;
	exports$1.ER_SP_CURSOR_ALREADY_OPEN = 1325;
	exports$1.ER_SP_CURSOR_NOT_OPEN = 1326;
	exports$1.ER_SP_UNDECLARED_VAR = 1327;
	exports$1.ER_SP_WRONG_NO_OF_FETCH_ARGS = 1328;
	exports$1.ER_SP_FETCH_NO_DATA = 1329;
	exports$1.ER_SP_DUP_PARAM = 1330;
	exports$1.ER_SP_DUP_VAR = 1331;
	exports$1.ER_SP_DUP_COND = 1332;
	exports$1.ER_SP_DUP_CURS = 1333;
	exports$1.ER_SP_CANT_ALTER = 1334;
	exports$1.ER_SP_SUBSELECT_NYI = 1335;
	exports$1.ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG = 1336;
	exports$1.ER_SP_VARCOND_AFTER_CURSHNDLR = 1337;
	exports$1.ER_SP_CURSOR_AFTER_HANDLER = 1338;
	exports$1.ER_SP_CASE_NOT_FOUND = 1339;
	exports$1.ER_FPARSER_TOO_BIG_FILE = 1340;
	exports$1.ER_FPARSER_BAD_HEADER = 1341;
	exports$1.ER_FPARSER_EOF_IN_COMMENT = 1342;
	exports$1.ER_FPARSER_ERROR_IN_PARAMETER = 1343;
	exports$1.ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER = 1344;
	exports$1.ER_VIEW_NO_EXPLAIN = 1345;
	exports$1.ER_FRM_UNKNOWN_TYPE = 1346;
	exports$1.ER_WRONG_OBJECT = 1347;
	exports$1.ER_NONUPDATEABLE_COLUMN = 1348;
	exports$1.ER_VIEW_SELECT_DERIVED = 1349;
	exports$1.ER_VIEW_SELECT_CLAUSE = 1350;
	exports$1.ER_VIEW_SELECT_VARIABLE = 1351;
	exports$1.ER_VIEW_SELECT_TMPTABLE = 1352;
	exports$1.ER_VIEW_WRONG_LIST = 1353;
	exports$1.ER_WARN_VIEW_MERGE = 1354;
	exports$1.ER_WARN_VIEW_WITHOUT_KEY = 1355;
	exports$1.ER_VIEW_INVALID = 1356;
	exports$1.ER_SP_NO_DROP_SP = 1357;
	exports$1.ER_SP_GOTO_IN_HNDLR = 1358;
	exports$1.ER_TRG_ALREADY_EXISTS = 1359;
	exports$1.ER_TRG_DOES_NOT_EXIST = 1360;
	exports$1.ER_TRG_ON_VIEW_OR_TEMP_TABLE = 1361;
	exports$1.ER_TRG_CANT_CHANGE_ROW = 1362;
	exports$1.ER_TRG_NO_SUCH_ROW_IN_TRG = 1363;
	exports$1.ER_NO_DEFAULT_FOR_FIELD = 1364;
	exports$1.ER_DIVISION_BY_ZERO = 1365;
	exports$1.ER_TRUNCATED_WRONG_VALUE_FOR_FIELD = 1366;
	exports$1.ER_ILLEGAL_VALUE_FOR_TYPE = 1367;
	exports$1.ER_VIEW_NONUPD_CHECK = 1368;
	exports$1.ER_VIEW_CHECK_FAILED = 1369;
	exports$1.ER_PROCACCESS_DENIED_ERROR = 1370;
	exports$1.ER_RELAY_LOG_FAIL = 1371;
	exports$1.ER_PASSWD_LENGTH = 1372;
	exports$1.ER_UNKNOWN_TARGET_BINLOG = 1373;
	exports$1.ER_IO_ERR_LOG_INDEX_READ = 1374;
	exports$1.ER_BINLOG_PURGE_PROHIBITED = 1375;
	exports$1.ER_FSEEK_FAIL = 1376;
	exports$1.ER_BINLOG_PURGE_FATAL_ERR = 1377;
	exports$1.ER_LOG_IN_USE = 1378;
	exports$1.ER_LOG_PURGE_UNKNOWN_ERR = 1379;
	exports$1.ER_RELAY_LOG_INIT = 1380;
	exports$1.ER_NO_BINARY_LOGGING = 1381;
	exports$1.ER_RESERVED_SYNTAX = 1382;
	exports$1.ER_WSAS_FAILED = 1383;
	exports$1.ER_DIFF_GROUPS_PROC = 1384;
	exports$1.ER_NO_GROUP_FOR_PROC = 1385;
	exports$1.ER_ORDER_WITH_PROC = 1386;
	exports$1.ER_LOGGING_PROHIBIT_CHANGING_OF = 1387;
	exports$1.ER_NO_FILE_MAPPING = 1388;
	exports$1.ER_WRONG_MAGIC = 1389;
	exports$1.ER_PS_MANY_PARAM = 1390;
	exports$1.ER_KEY_PART_0 = 1391;
	exports$1.ER_VIEW_CHECKSUM = 1392;
	exports$1.ER_VIEW_MULTIUPDATE = 1393;
	exports$1.ER_VIEW_NO_INSERT_FIELD_LIST = 1394;
	exports$1.ER_VIEW_DELETE_MERGE_VIEW = 1395;
	exports$1.ER_CANNOT_USER = 1396;
	exports$1.ER_XAER_NOTA = 1397;
	exports$1.ER_XAER_INVAL = 1398;
	exports$1.ER_XAER_RMFAIL = 1399;
	exports$1.ER_XAER_OUTSIDE = 1400;
	exports$1.ER_XAER_RMERR = 1401;
	exports$1.ER_XA_RBROLLBACK = 1402;
	exports$1.ER_NONEXISTING_PROC_GRANT = 1403;
	exports$1.ER_PROC_AUTO_GRANT_FAIL = 1404;
	exports$1.ER_PROC_AUTO_REVOKE_FAIL = 1405;
	exports$1.ER_DATA_TOO_LONG = 1406;
	exports$1.ER_SP_BAD_SQLSTATE = 1407;
	exports$1.ER_STARTUP = 1408;
	exports$1.ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR = 1409;
	exports$1.ER_CANT_CREATE_USER_WITH_GRANT = 1410;
	exports$1.ER_WRONG_VALUE_FOR_TYPE = 1411;
	exports$1.ER_TABLE_DEF_CHANGED = 1412;
	exports$1.ER_SP_DUP_HANDLER = 1413;
	exports$1.ER_SP_NOT_VAR_ARG = 1414;
	exports$1.ER_SP_NO_RETSET = 1415;
	exports$1.ER_CANT_CREATE_GEOMETRY_OBJECT = 1416;
	exports$1.ER_FAILED_ROUTINE_BREAK_BINLOG = 1417;
	exports$1.ER_BINLOG_UNSAFE_ROUTINE = 1418;
	exports$1.ER_BINLOG_CREATE_ROUTINE_NEED_SUPER = 1419;
	exports$1.ER_EXEC_STMT_WITH_OPEN_CURSOR = 1420;
	exports$1.ER_STMT_HAS_NO_OPEN_CURSOR = 1421;
	exports$1.ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG = 1422;
	exports$1.ER_NO_DEFAULT_FOR_VIEW_FIELD = 1423;
	exports$1.ER_SP_NO_RECURSION = 1424;
	exports$1.ER_TOO_BIG_SCALE = 1425;
	exports$1.ER_TOO_BIG_PRECISION = 1426;
	exports$1.ER_M_BIGGER_THAN_D = 1427;
	exports$1.ER_WRONG_LOCK_OF_SYSTEM_TABLE = 1428;
	exports$1.ER_CONNECT_TO_FOREIGN_DATA_SOURCE = 1429;
	exports$1.ER_QUERY_ON_FOREIGN_DATA_SOURCE = 1430;
	exports$1.ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST = 1431;
	exports$1.ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE = 1432;
	exports$1.ER_FOREIGN_DATA_STRING_INVALID = 1433;
	exports$1.ER_CANT_CREATE_FEDERATED_TABLE = 1434;
	exports$1.ER_TRG_IN_WRONG_SCHEMA = 1435;
	exports$1.ER_STACK_OVERRUN_NEED_MORE = 1436;
	exports$1.ER_TOO_LONG_BODY = 1437;
	exports$1.ER_WARN_CANT_DROP_DEFAULT_KEYCACHE = 1438;
	exports$1.ER_TOO_BIG_DISPLAYWIDTH = 1439;
	exports$1.ER_XAER_DUPID = 1440;
	exports$1.ER_DATETIME_FUNCTION_OVERFLOW = 1441;
	exports$1.ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG = 1442;
	exports$1.ER_VIEW_PREVENT_UPDATE = 1443;
	exports$1.ER_PS_NO_RECURSION = 1444;
	exports$1.ER_SP_CANT_SET_AUTOCOMMIT = 1445;
	exports$1.ER_MALFORMED_DEFINER = 1446;
	exports$1.ER_VIEW_FRM_NO_USER = 1447;
	exports$1.ER_VIEW_OTHER_USER = 1448;
	exports$1.ER_NO_SUCH_USER = 1449;
	exports$1.ER_FORBID_SCHEMA_CHANGE = 1450;
	exports$1.ER_ROW_IS_REFERENCED_2 = 1451;
	exports$1.ER_NO_REFERENCED_ROW_2 = 1452;
	exports$1.ER_SP_BAD_VAR_SHADOW = 1453;
	exports$1.ER_TRG_NO_DEFINER = 1454;
	exports$1.ER_OLD_FILE_FORMAT = 1455;
	exports$1.ER_SP_RECURSION_LIMIT = 1456;
	exports$1.ER_SP_PROC_TABLE_CORRUPT = 1457;
	exports$1.ER_SP_WRONG_NAME = 1458;
	exports$1.ER_TABLE_NEEDS_UPGRADE = 1459;
	exports$1.ER_SP_NO_AGGREGATE = 1460;
	exports$1.ER_MAX_PREPARED_STMT_COUNT_REACHED = 1461;
	exports$1.ER_VIEW_RECURSIVE = 1462;
	exports$1.ER_NON_GROUPING_FIELD_USED = 1463;
	exports$1.ER_TABLE_CANT_HANDLE_SPKEYS = 1464;
	exports$1.ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA = 1465;
	exports$1.ER_REMOVED_SPACES = 1466;
	exports$1.ER_AUTOINC_READ_FAILED = 1467;
	exports$1.ER_USERNAME = 1468;
	exports$1.ER_HOSTNAME = 1469;
	exports$1.ER_WRONG_STRING_LENGTH = 1470;
	exports$1.ER_NON_INSERTABLE_TABLE = 1471;
	exports$1.ER_ADMIN_WRONG_MRG_TABLE = 1472;
	exports$1.ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT = 1473;
	exports$1.ER_NAME_BECOMES_EMPTY = 1474;
	exports$1.ER_AMBIGUOUS_FIELD_TERM = 1475;
	exports$1.ER_FOREIGN_SERVER_EXISTS = 1476;
	exports$1.ER_FOREIGN_SERVER_DOESNT_EXIST = 1477;
	exports$1.ER_ILLEGAL_HA_CREATE_OPTION = 1478;
	exports$1.ER_PARTITION_REQUIRES_VALUES_ERROR = 1479;
	exports$1.ER_PARTITION_WRONG_VALUES_ERROR = 1480;
	exports$1.ER_PARTITION_MAXVALUE_ERROR = 1481;
	exports$1.ER_PARTITION_SUBPARTITION_ERROR = 1482;
	exports$1.ER_PARTITION_SUBPART_MIX_ERROR = 1483;
	exports$1.ER_PARTITION_WRONG_NO_PART_ERROR = 1484;
	exports$1.ER_PARTITION_WRONG_NO_SUBPART_ERROR = 1485;
	exports$1.ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR = 1486;
	exports$1.ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR = 1487;
	exports$1.ER_FIELD_NOT_FOUND_PART_ERROR = 1488;
	exports$1.ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR = 1489;
	exports$1.ER_INCONSISTENT_PARTITION_INFO_ERROR = 1490;
	exports$1.ER_PARTITION_FUNC_NOT_ALLOWED_ERROR = 1491;
	exports$1.ER_PARTITIONS_MUST_BE_DEFINED_ERROR = 1492;
	exports$1.ER_RANGE_NOT_INCREASING_ERROR = 1493;
	exports$1.ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR = 1494;
	exports$1.ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR = 1495;
	exports$1.ER_PARTITION_ENTRY_ERROR = 1496;
	exports$1.ER_MIX_HANDLER_ERROR = 1497;
	exports$1.ER_PARTITION_NOT_DEFINED_ERROR = 1498;
	exports$1.ER_TOO_MANY_PARTITIONS_ERROR = 1499;
	exports$1.ER_SUBPARTITION_ERROR = 1500;
	exports$1.ER_CANT_CREATE_HANDLER_FILE = 1501;
	exports$1.ER_BLOB_FIELD_IN_PART_FUNC_ERROR = 1502;
	exports$1.ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF = 1503;
	exports$1.ER_NO_PARTS_ERROR = 1504;
	exports$1.ER_PARTITION_MGMT_ON_NONPARTITIONED = 1505;
	exports$1.ER_FOREIGN_KEY_ON_PARTITIONED = 1506;
	exports$1.ER_DROP_PARTITION_NON_EXISTENT = 1507;
	exports$1.ER_DROP_LAST_PARTITION = 1508;
	exports$1.ER_COALESCE_ONLY_ON_HASH_PARTITION = 1509;
	exports$1.ER_REORG_HASH_ONLY_ON_SAME_NO = 1510;
	exports$1.ER_REORG_NO_PARAM_ERROR = 1511;
	exports$1.ER_ONLY_ON_RANGE_LIST_PARTITION = 1512;
	exports$1.ER_ADD_PARTITION_SUBPART_ERROR = 1513;
	exports$1.ER_ADD_PARTITION_NO_NEW_PARTITION = 1514;
	exports$1.ER_COALESCE_PARTITION_NO_PARTITION = 1515;
	exports$1.ER_REORG_PARTITION_NOT_EXIST = 1516;
	exports$1.ER_SAME_NAME_PARTITION = 1517;
	exports$1.ER_NO_BINLOG_ERROR = 1518;
	exports$1.ER_CONSECUTIVE_REORG_PARTITIONS = 1519;
	exports$1.ER_REORG_OUTSIDE_RANGE = 1520;
	exports$1.ER_PARTITION_FUNCTION_FAILURE = 1521;
	exports$1.ER_PART_STATE_ERROR = 1522;
	exports$1.ER_LIMITED_PART_RANGE = 1523;
	exports$1.ER_PLUGIN_IS_NOT_LOADED = 1524;
	exports$1.ER_WRONG_VALUE = 1525;
	exports$1.ER_NO_PARTITION_FOR_GIVEN_VALUE = 1526;
	exports$1.ER_FILEGROUP_OPTION_ONLY_ONCE = 1527;
	exports$1.ER_CREATE_FILEGROUP_FAILED = 1528;
	exports$1.ER_DROP_FILEGROUP_FAILED = 1529;
	exports$1.ER_TABLESPACE_AUTO_EXTEND_ERROR = 1530;
	exports$1.ER_WRONG_SIZE_NUMBER = 1531;
	exports$1.ER_SIZE_OVERFLOW_ERROR = 1532;
	exports$1.ER_ALTER_FILEGROUP_FAILED = 1533;
	exports$1.ER_BINLOG_ROW_LOGGING_FAILED = 1534;
	exports$1.ER_BINLOG_ROW_WRONG_TABLE_DEF = 1535;
	exports$1.ER_BINLOG_ROW_RBR_TO_SBR = 1536;
	exports$1.ER_EVENT_ALREADY_EXISTS = 1537;
	exports$1.ER_EVENT_STORE_FAILED = 1538;
	exports$1.ER_EVENT_DOES_NOT_EXIST = 1539;
	exports$1.ER_EVENT_CANT_ALTER = 1540;
	exports$1.ER_EVENT_DROP_FAILED = 1541;
	exports$1.ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG = 1542;
	exports$1.ER_EVENT_ENDS_BEFORE_STARTS = 1543;
	exports$1.ER_EVENT_EXEC_TIME_IN_THE_PAST = 1544;
	exports$1.ER_EVENT_OPEN_TABLE_FAILED = 1545;
	exports$1.ER_EVENT_NEITHER_M_EXPR_NOR_M_AT = 1546;
	exports$1.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED = 1547;
	exports$1.ER_CANNOT_LOAD_FROM_TABLE = 1548;
	exports$1.ER_EVENT_CANNOT_DELETE = 1549;
	exports$1.ER_EVENT_COMPILE_ERROR = 1550;
	exports$1.ER_EVENT_SAME_NAME = 1551;
	exports$1.ER_EVENT_DATA_TOO_LONG = 1552;
	exports$1.ER_DROP_INDEX_FK = 1553;
	exports$1.ER_WARN_DEPRECATED_SYNTAX_WITH_VER = 1554;
	exports$1.ER_CANT_WRITE_LOCK_LOG_TABLE = 1555;
	exports$1.ER_CANT_LOCK_LOG_TABLE = 1556;
	exports$1.ER_FOREIGN_DUPLICATE_KEY = 1557;
	exports$1.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE = 1558;
	exports$1.ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR = 1559;
	exports$1.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1560;
	exports$1.ER_NDB_CANT_SWITCH_BINLOG_FORMAT = 1561;
	exports$1.ER_PARTITION_NO_TEMPORARY = 1562;
	exports$1.ER_PARTITION_CONST_DOMAIN_ERROR = 1563;
	exports$1.ER_PARTITION_FUNCTION_IS_NOT_ALLOWED = 1564;
	exports$1.ER_DDL_LOG_ERROR = 1565;
	exports$1.ER_NULL_IN_VALUES_LESS_THAN = 1566;
	exports$1.ER_WRONG_PARTITION_NAME = 1567;
	exports$1.ER_CANT_CHANGE_TX_CHARACTERISTICS = 1568;
	exports$1.ER_DUP_ENTRY_AUTOINCREMENT_CASE = 1569;
	exports$1.ER_EVENT_MODIFY_QUEUE_ERROR = 1570;
	exports$1.ER_EVENT_SET_VAR_ERROR = 1571;
	exports$1.ER_PARTITION_MERGE_ERROR = 1572;
	exports$1.ER_CANT_ACTIVATE_LOG = 1573;
	exports$1.ER_RBR_NOT_AVAILABLE = 1574;
	exports$1.ER_BASE64_DECODE_ERROR = 1575;
	exports$1.ER_EVENT_RECURSION_FORBIDDEN = 1576;
	exports$1.ER_EVENTS_DB_ERROR = 1577;
	exports$1.ER_ONLY_INTEGERS_ALLOWED = 1578;
	exports$1.ER_UNSUPORTED_LOG_ENGINE = 1579;
	exports$1.ER_BAD_LOG_STATEMENT = 1580;
	exports$1.ER_CANT_RENAME_LOG_TABLE = 1581;
	exports$1.ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT = 1582;
	exports$1.ER_WRONG_PARAMETERS_TO_NATIVE_FCT = 1583;
	exports$1.ER_WRONG_PARAMETERS_TO_STORED_FCT = 1584;
	exports$1.ER_NATIVE_FCT_NAME_COLLISION = 1585;
	exports$1.ER_DUP_ENTRY_WITH_KEY_NAME = 1586;
	exports$1.ER_BINLOG_PURGE_EMFILE = 1587;
	exports$1.ER_EVENT_CANNOT_CREATE_IN_THE_PAST = 1588;
	exports$1.ER_EVENT_CANNOT_ALTER_IN_THE_PAST = 1589;
	exports$1.ER_SLAVE_INCIDENT = 1590;
	exports$1.ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT = 1591;
	exports$1.ER_BINLOG_UNSAFE_STATEMENT = 1592;
	exports$1.ER_BINLOG_FATAL_ERROR = 1593;
	exports$1.ER_SLAVE_RELAY_LOG_READ_FAILURE = 1594;
	exports$1.ER_SLAVE_RELAY_LOG_WRITE_FAILURE = 1595;
	exports$1.ER_SLAVE_CREATE_EVENT_FAILURE = 1596;
	exports$1.ER_SLAVE_MASTER_COM_FAILURE = 1597;
	exports$1.ER_BINLOG_LOGGING_IMPOSSIBLE = 1598;
	exports$1.ER_VIEW_NO_CREATION_CTX = 1599;
	exports$1.ER_VIEW_INVALID_CREATION_CTX = 1600;
	exports$1.ER_SR_INVALID_CREATION_CTX = 1601;
	exports$1.ER_TRG_CORRUPTED_FILE = 1602;
	exports$1.ER_TRG_NO_CREATION_CTX = 1603;
	exports$1.ER_TRG_INVALID_CREATION_CTX = 1604;
	exports$1.ER_EVENT_INVALID_CREATION_CTX = 1605;
	exports$1.ER_TRG_CANT_OPEN_TABLE = 1606;
	exports$1.ER_CANT_CREATE_SROUTINE = 1607;
	exports$1.ER_NEVER_USED = 1608;
	exports$1.ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT = 1609;
	exports$1.ER_REPLICA_CORRUPT_EVENT = 1610;
	exports$1.ER_LOAD_DATA_INVALID_COLUMN = 1611;
	exports$1.ER_LOG_PURGE_NO_FILE = 1612;
	exports$1.ER_XA_RBTIMEOUT = 1613;
	exports$1.ER_XA_RBDEADLOCK = 1614;
	exports$1.ER_NEED_REPREPARE = 1615;
	exports$1.ER_DELAYED_NOT_SUPPORTED = 1616;
	exports$1.WARN_NO_CONNECTION_METADATA = 1617;
	exports$1.WARN_OPTION_IGNORED = 1618;
	exports$1.ER_PLUGIN_DELETE_BUILTIN = 1619;
	exports$1.WARN_PLUGIN_BUSY = 1620;
	exports$1.ER_VARIABLE_IS_READONLY = 1621;
	exports$1.ER_WARN_ENGINE_TRANSACTION_ROLLBACK = 1622;
	exports$1.ER_SLAVE_HEARTBEAT_FAILURE = 1623;
	exports$1.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE = 1624;
	exports$1.ER_NDB_REPLICATION_SCHEMA_ERROR = 1625;
	exports$1.ER_CONFLICT_FN_PARSE_ERROR = 1626;
	exports$1.ER_EXCEPTIONS_WRITE_ERROR = 1627;
	exports$1.ER_TOO_LONG_TABLE_COMMENT = 1628;
	exports$1.ER_TOO_LONG_FIELD_COMMENT = 1629;
	exports$1.ER_FUNC_INEXISTENT_NAME_COLLISION = 1630;
	exports$1.ER_DATABASE_NAME = 1631;
	exports$1.ER_TABLE_NAME = 1632;
	exports$1.ER_PARTITION_NAME = 1633;
	exports$1.ER_SUBPARTITION_NAME = 1634;
	exports$1.ER_TEMPORARY_NAME = 1635;
	exports$1.ER_RENAMED_NAME = 1636;
	exports$1.ER_TOO_MANY_CONCURRENT_TRXS = 1637;
	exports$1.WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED = 1638;
	exports$1.ER_DEBUG_SYNC_TIMEOUT = 1639;
	exports$1.ER_DEBUG_SYNC_HIT_LIMIT = 1640;
	exports$1.ER_DUP_SIGNAL_SET = 1641;
	exports$1.ER_SIGNAL_WARN = 1642;
	exports$1.ER_SIGNAL_NOT_FOUND = 1643;
	exports$1.ER_SIGNAL_EXCEPTION = 1644;
	exports$1.ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER = 1645;
	exports$1.ER_SIGNAL_BAD_CONDITION_TYPE = 1646;
	exports$1.WARN_COND_ITEM_TRUNCATED = 1647;
	exports$1.ER_COND_ITEM_TOO_LONG = 1648;
	exports$1.ER_UNKNOWN_LOCALE = 1649;
	exports$1.ER_REPLICA_IGNORE_SERVER_IDS = 1650;
	exports$1.ER_QUERY_CACHE_DISABLED = 1651;
	exports$1.ER_SAME_NAME_PARTITION_FIELD = 1652;
	exports$1.ER_PARTITION_COLUMN_LIST_ERROR = 1653;
	exports$1.ER_WRONG_TYPE_COLUMN_VALUE_ERROR = 1654;
	exports$1.ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR = 1655;
	exports$1.ER_MAXVALUE_IN_VALUES_IN = 1656;
	exports$1.ER_TOO_MANY_VALUES_ERROR = 1657;
	exports$1.ER_ROW_SINGLE_PARTITION_FIELD_ERROR = 1658;
	exports$1.ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD = 1659;
	exports$1.ER_PARTITION_FIELDS_TOO_LONG = 1660;
	exports$1.ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE = 1661;
	exports$1.ER_BINLOG_ROW_MODE_AND_STMT_ENGINE = 1662;
	exports$1.ER_BINLOG_UNSAFE_AND_STMT_ENGINE = 1663;
	exports$1.ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE = 1664;
	exports$1.ER_BINLOG_STMT_MODE_AND_ROW_ENGINE = 1665;
	exports$1.ER_BINLOG_ROW_INJECTION_AND_STMT_MODE = 1666;
	exports$1.ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1667;
	exports$1.ER_BINLOG_UNSAFE_LIMIT = 1668;
	exports$1.ER_UNUSED4 = 1669;
	exports$1.ER_BINLOG_UNSAFE_SYSTEM_TABLE = 1670;
	exports$1.ER_BINLOG_UNSAFE_AUTOINC_COLUMNS = 1671;
	exports$1.ER_BINLOG_UNSAFE_UDF = 1672;
	exports$1.ER_BINLOG_UNSAFE_SYSTEM_VARIABLE = 1673;
	exports$1.ER_BINLOG_UNSAFE_SYSTEM_FUNCTION = 1674;
	exports$1.ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS = 1675;
	exports$1.ER_MESSAGE_AND_STATEMENT = 1676;
	exports$1.ER_SLAVE_CONVERSION_FAILED = 1677;
	exports$1.ER_REPLICA_CANT_CREATE_CONVERSION = 1678;
	exports$1.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1679;
	exports$1.ER_PATH_LENGTH = 1680;
	exports$1.ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT = 1681;
	exports$1.ER_WRONG_NATIVE_TABLE_STRUCTURE = 1682;
	exports$1.ER_WRONG_PERFSCHEMA_USAGE = 1683;
	exports$1.ER_WARN_I_S_SKIPPED_TABLE = 1684;
	exports$1.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1685;
	exports$1.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1686;
	exports$1.ER_SPATIAL_MUST_HAVE_GEOM_COL = 1687;
	exports$1.ER_TOO_LONG_INDEX_COMMENT = 1688;
	exports$1.ER_LOCK_ABORTED = 1689;
	exports$1.ER_DATA_OUT_OF_RANGE = 1690;
	exports$1.ER_WRONG_SPVAR_TYPE_IN_LIMIT = 1691;
	exports$1.ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1692;
	exports$1.ER_BINLOG_UNSAFE_MIXED_STATEMENT = 1693;
	exports$1.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1694;
	exports$1.ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1695;
	exports$1.ER_FAILED_READ_FROM_PAR_FILE = 1696;
	exports$1.ER_VALUES_IS_NOT_INT_TYPE_ERROR = 1697;
	exports$1.ER_ACCESS_DENIED_NO_PASSWORD_ERROR = 1698;
	exports$1.ER_SET_PASSWORD_AUTH_PLUGIN = 1699;
	exports$1.ER_GRANT_PLUGIN_USER_EXISTS = 1700;
	exports$1.ER_TRUNCATE_ILLEGAL_FK = 1701;
	exports$1.ER_PLUGIN_IS_PERMANENT = 1702;
	exports$1.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN = 1703;
	exports$1.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX = 1704;
	exports$1.ER_STMT_CACHE_FULL = 1705;
	exports$1.ER_MULTI_UPDATE_KEY_CONFLICT = 1706;
	exports$1.ER_TABLE_NEEDS_REBUILD = 1707;
	exports$1.WARN_OPTION_BELOW_LIMIT = 1708;
	exports$1.ER_INDEX_COLUMN_TOO_LONG = 1709;
	exports$1.ER_ERROR_IN_TRIGGER_BODY = 1710;
	exports$1.ER_ERROR_IN_UNKNOWN_TRIGGER_BODY = 1711;
	exports$1.ER_INDEX_CORRUPT = 1712;
	exports$1.ER_UNDO_RECORD_TOO_BIG = 1713;
	exports$1.ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT = 1714;
	exports$1.ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE = 1715;
	exports$1.ER_BINLOG_UNSAFE_REPLACE_SELECT = 1716;
	exports$1.ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT = 1717;
	exports$1.ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT = 1718;
	exports$1.ER_BINLOG_UNSAFE_UPDATE_IGNORE = 1719;
	exports$1.ER_PLUGIN_NO_UNINSTALL = 1720;
	exports$1.ER_PLUGIN_NO_INSTALL = 1721;
	exports$1.ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT = 1722;
	exports$1.ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC = 1723;
	exports$1.ER_BINLOG_UNSAFE_INSERT_TWO_KEYS = 1724;
	exports$1.ER_TABLE_IN_FK_CHECK = 1725;
	exports$1.ER_UNSUPPORTED_ENGINE = 1726;
	exports$1.ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST = 1727;
	exports$1.ER_CANNOT_LOAD_FROM_TABLE_V2 = 1728;
	exports$1.ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE = 1729;
	exports$1.ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT = 1730;
	exports$1.ER_PARTITION_EXCHANGE_DIFFERENT_OPTION = 1731;
	exports$1.ER_PARTITION_EXCHANGE_PART_TABLE = 1732;
	exports$1.ER_PARTITION_EXCHANGE_TEMP_TABLE = 1733;
	exports$1.ER_PARTITION_INSTEAD_OF_SUBPARTITION = 1734;
	exports$1.ER_UNKNOWN_PARTITION = 1735;
	exports$1.ER_TABLES_DIFFERENT_METADATA = 1736;
	exports$1.ER_ROW_DOES_NOT_MATCH_PARTITION = 1737;
	exports$1.ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX = 1738;
	exports$1.ER_WARN_INDEX_NOT_APPLICABLE = 1739;
	exports$1.ER_PARTITION_EXCHANGE_FOREIGN_KEY = 1740;
	exports$1.ER_NO_SUCH_KEY_VALUE = 1741;
	exports$1.ER_RPL_INFO_DATA_TOO_LONG = 1742;
	exports$1.ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE = 1743;
	exports$1.ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE = 1744;
	exports$1.ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX = 1745;
	exports$1.ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT = 1746;
	exports$1.ER_PARTITION_CLAUSE_ON_NONPARTITIONED = 1747;
	exports$1.ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET = 1748;
	exports$1.ER_NO_SUCH_PARTITION = 1749;
	exports$1.ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE = 1750;
	exports$1.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE = 1751;
	exports$1.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE = 1752;
	exports$1.ER_MTA_FEATURE_IS_NOT_SUPPORTED = 1753;
	exports$1.ER_MTA_UPDATED_DBS_GREATER_MAX = 1754;
	exports$1.ER_MTA_CANT_PARALLEL = 1755;
	exports$1.ER_MTA_INCONSISTENT_DATA = 1756;
	exports$1.ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING = 1757;
	exports$1.ER_DA_INVALID_CONDITION_NUMBER = 1758;
	exports$1.ER_INSECURE_PLAIN_TEXT = 1759;
	exports$1.ER_INSECURE_CHANGE_SOURCE = 1760;
	exports$1.ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO = 1761;
	exports$1.ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO = 1762;
	exports$1.ER_SQLTHREAD_WITH_SECURE_REPLICA = 1763;
	exports$1.ER_TABLE_HAS_NO_FT = 1764;
	exports$1.ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER = 1765;
	exports$1.ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION = 1766;
	exports$1.ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST = 1767;
	exports$1.ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION = 1768;
	exports$1.ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION = 1769;
	exports$1.ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL = 1770;
	exports$1.ER_SKIPPING_LOGGED_TRANSACTION = 1771;
	exports$1.ER_MALFORMED_GTID_SET_SPECIFICATION = 1772;
	exports$1.ER_MALFORMED_GTID_SET_ENCODING = 1773;
	exports$1.ER_MALFORMED_GTID_SPECIFICATION = 1774;
	exports$1.ER_GNO_EXHAUSTED = 1775;
	exports$1.ER_BAD_REPLICA_AUTO_POSITION = 1776;
	exports$1.ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF = 1777;
	exports$1.ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET = 1778;
	exports$1.ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON = 1779;
	exports$1.ER_GTID_MODE_REQUIRES_BINLOG = 1780;
	exports$1.ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF = 1781;
	exports$1.ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON = 1782;
	exports$1.ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF = 1783;
	exports$1.ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF = 1784;
	exports$1.ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE = 1785;
	exports$1.ER_GTID_UNSAFE_CREATE_SELECT = 1786;
	exports$1.ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION = 1787;
	exports$1.ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME = 1788;
	exports$1.ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS = 1789;
	exports$1.ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID = 1790;
	exports$1.ER_UNKNOWN_EXPLAIN_FORMAT = 1791;
	exports$1.ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION = 1792;
	exports$1.ER_TOO_LONG_TABLE_PARTITION_COMMENT = 1793;
	exports$1.ER_REPLICA_CONFIGURATION = 1794;
	exports$1.ER_INNODB_FT_LIMIT = 1795;
	exports$1.ER_INNODB_NO_FT_TEMP_TABLE = 1796;
	exports$1.ER_INNODB_FT_WRONG_DOCID_COLUMN = 1797;
	exports$1.ER_INNODB_FT_WRONG_DOCID_INDEX = 1798;
	exports$1.ER_INNODB_ONLINE_LOG_TOO_BIG = 1799;
	exports$1.ER_UNKNOWN_ALTER_ALGORITHM = 1800;
	exports$1.ER_UNKNOWN_ALTER_LOCK = 1801;
	exports$1.ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS = 1802;
	exports$1.ER_MTA_RECOVERY_FAILURE = 1803;
	exports$1.ER_MTA_RESET_WORKERS = 1804;
	exports$1.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2 = 1805;
	exports$1.ER_REPLICA_SILENT_RETRY_TRANSACTION = 1806;
	exports$1.ER_DISCARD_FK_CHECKS_RUNNING = 1807;
	exports$1.ER_TABLE_SCHEMA_MISMATCH = 1808;
	exports$1.ER_TABLE_IN_SYSTEM_TABLESPACE = 1809;
	exports$1.ER_IO_READ_ERROR = 1810;
	exports$1.ER_IO_WRITE_ERROR = 1811;
	exports$1.ER_TABLESPACE_MISSING = 1812;
	exports$1.ER_TABLESPACE_EXISTS = 1813;
	exports$1.ER_TABLESPACE_DISCARDED = 1814;
	exports$1.ER_INTERNAL_ERROR = 1815;
	exports$1.ER_INNODB_IMPORT_ERROR = 1816;
	exports$1.ER_INNODB_INDEX_CORRUPT = 1817;
	exports$1.ER_INVALID_YEAR_COLUMN_LENGTH = 1818;
	exports$1.ER_NOT_VALID_PASSWORD = 1819;
	exports$1.ER_MUST_CHANGE_PASSWORD = 1820;
	exports$1.ER_FK_NO_INDEX_CHILD = 1821;
	exports$1.ER_FK_NO_INDEX_PARENT = 1822;
	exports$1.ER_FK_FAIL_ADD_SYSTEM = 1823;
	exports$1.ER_FK_CANNOT_OPEN_PARENT = 1824;
	exports$1.ER_FK_INCORRECT_OPTION = 1825;
	exports$1.ER_FK_DUP_NAME = 1826;
	exports$1.ER_PASSWORD_FORMAT = 1827;
	exports$1.ER_FK_COLUMN_CANNOT_DROP = 1828;
	exports$1.ER_FK_COLUMN_CANNOT_DROP_CHILD = 1829;
	exports$1.ER_FK_COLUMN_NOT_NULL = 1830;
	exports$1.ER_DUP_INDEX = 1831;
	exports$1.ER_FK_COLUMN_CANNOT_CHANGE = 1832;
	exports$1.ER_FK_COLUMN_CANNOT_CHANGE_CHILD = 1833;
	exports$1.ER_UNUSED5 = 1834;
	exports$1.ER_MALFORMED_PACKET = 1835;
	exports$1.ER_READ_ONLY_MODE = 1836;
	exports$1.ER_GTID_NEXT_TYPE_UNDEFINED_GTID = 1837;
	exports$1.ER_VARIABLE_NOT_SETTABLE_IN_SP = 1838;
	exports$1.ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF = 1839;
	exports$1.ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY = 1840;
	exports$1.ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY = 1841;
	exports$1.ER_GTID_PURGED_WAS_CHANGED = 1842;
	exports$1.ER_GTID_EXECUTED_WAS_CHANGED = 1843;
	exports$1.ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES = 1844;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED = 1845;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON = 1846;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY = 1847;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION = 1848;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME = 1849;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE = 1850;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK = 1851;
	exports$1.ER_UNUSED6 = 1852;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK = 1853;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC = 1854;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS = 1855;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS = 1856;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS = 1857;
	exports$1.ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE = 1858;
	exports$1.ER_DUP_UNKNOWN_IN_INDEX = 1859;
	exports$1.ER_IDENT_CAUSES_TOO_LONG_PATH = 1860;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL = 1861;
	exports$1.ER_MUST_CHANGE_PASSWORD_LOGIN = 1862;
	exports$1.ER_ROW_IN_WRONG_PARTITION = 1863;
	exports$1.ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX = 1864;
	exports$1.ER_INNODB_NO_FT_USES_PARSER = 1865;
	exports$1.ER_BINLOG_LOGICAL_CORRUPTION = 1866;
	exports$1.ER_WARN_PURGE_LOG_IN_USE = 1867;
	exports$1.ER_WARN_PURGE_LOG_IS_ACTIVE = 1868;
	exports$1.ER_AUTO_INCREMENT_CONFLICT = 1869;
	exports$1.WARN_ON_BLOCKHOLE_IN_RBR = 1870;
	exports$1.ER_REPLICA_CM_INIT_REPOSITORY = 1871;
	exports$1.ER_REPLICA_AM_INIT_REPOSITORY = 1872;
	exports$1.ER_ACCESS_DENIED_CHANGE_USER_ERROR = 1873;
	exports$1.ER_INNODB_READ_ONLY = 1874;
	exports$1.ER_STOP_REPLICA_SQL_THREAD_TIMEOUT = 1875;
	exports$1.ER_STOP_REPLICA_IO_THREAD_TIMEOUT = 1876;
	exports$1.ER_TABLE_CORRUPT = 1877;
	exports$1.ER_TEMP_FILE_WRITE_FAILURE = 1878;
	exports$1.ER_INNODB_FT_AUX_NOT_HEX_ID = 1879;
	exports$1.ER_OLD_TEMPORALS_UPGRADED = 1880;
	exports$1.ER_INNODB_FORCED_RECOVERY = 1881;
	exports$1.ER_AES_INVALID_IV = 1882;
	exports$1.ER_PLUGIN_CANNOT_BE_UNINSTALLED = 1883;
	exports$1.ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID = 1884;
	exports$1.ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE = 1885;
	exports$1.ER_MISSING_KEY = 1886;
	exports$1.WARN_NAMED_PIPE_ACCESS_EVERYONE = 1887;
	exports$1.ER_FILE_CORRUPT = 3000;
	exports$1.ER_ERROR_ON_SOURCE = 3001;
	exports$1.ER_INCONSISTENT_ERROR = 3002;
	exports$1.ER_STORAGE_ENGINE_NOT_LOADED = 3003;
	exports$1.ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER = 3004;
	exports$1.ER_WARN_LEGACY_SYNTAX_CONVERTED = 3005;
	exports$1.ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN = 3006;
	exports$1.ER_CANNOT_DISCARD_TEMPORARY_TABLE = 3007;
	exports$1.ER_FK_DEPTH_EXCEEDED = 3008;
	exports$1.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2 = 3009;
	exports$1.ER_WARN_TRIGGER_DOESNT_HAVE_CREATED = 3010;
	exports$1.ER_REFERENCED_TRG_DOES_NOT_EXIST = 3011;
	exports$1.ER_EXPLAIN_NOT_SUPPORTED = 3012;
	exports$1.ER_INVALID_FIELD_SIZE = 3013;
	exports$1.ER_MISSING_HA_CREATE_OPTION = 3014;
	exports$1.ER_ENGINE_OUT_OF_MEMORY = 3015;
	exports$1.ER_PASSWORD_EXPIRE_ANONYMOUS_USER = 3016;
	exports$1.ER_REPLICA_SQL_THREAD_MUST_STOP = 3017;
	exports$1.ER_NO_FT_MATERIALIZED_SUBQUERY = 3018;
	exports$1.ER_INNODB_UNDO_LOG_FULL = 3019;
	exports$1.ER_INVALID_ARGUMENT_FOR_LOGARITHM = 3020;
	exports$1.ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP = 3021;
	exports$1.ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO = 3022;
	exports$1.ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS = 3023;
	exports$1.ER_QUERY_TIMEOUT = 3024;
	exports$1.ER_NON_RO_SELECT_DISABLE_TIMER = 3025;
	exports$1.ER_DUP_LIST_ENTRY = 3026;
	exports$1.ER_SQL_MODE_NO_EFFECT = 3027;
	exports$1.ER_AGGREGATE_ORDER_FOR_UNION = 3028;
	exports$1.ER_AGGREGATE_ORDER_NON_AGG_QUERY = 3029;
	exports$1.ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR = 3030;
	exports$1.ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER = 3031;
	exports$1.ER_SERVER_OFFLINE_MODE = 3032;
	exports$1.ER_GIS_DIFFERENT_SRIDS = 3033;
	exports$1.ER_GIS_UNSUPPORTED_ARGUMENT = 3034;
	exports$1.ER_GIS_UNKNOWN_ERROR = 3035;
	exports$1.ER_GIS_UNKNOWN_EXCEPTION = 3036;
	exports$1.ER_GIS_INVALID_DATA = 3037;
	exports$1.ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION = 3038;
	exports$1.ER_BOOST_GEOMETRY_CENTROID_EXCEPTION = 3039;
	exports$1.ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION = 3040;
	exports$1.ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION = 3041;
	exports$1.ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION = 3042;
	exports$1.ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION = 3043;
	exports$1.ER_STD_BAD_ALLOC_ERROR = 3044;
	exports$1.ER_STD_DOMAIN_ERROR = 3045;
	exports$1.ER_STD_LENGTH_ERROR = 3046;
	exports$1.ER_STD_INVALID_ARGUMENT = 3047;
	exports$1.ER_STD_OUT_OF_RANGE_ERROR = 3048;
	exports$1.ER_STD_OVERFLOW_ERROR = 3049;
	exports$1.ER_STD_RANGE_ERROR = 3050;
	exports$1.ER_STD_UNDERFLOW_ERROR = 3051;
	exports$1.ER_STD_LOGIC_ERROR = 3052;
	exports$1.ER_STD_RUNTIME_ERROR = 3053;
	exports$1.ER_STD_UNKNOWN_EXCEPTION = 3054;
	exports$1.ER_GIS_DATA_WRONG_ENDIANESS = 3055;
	exports$1.ER_CHANGE_SOURCE_PASSWORD_LENGTH = 3056;
	exports$1.ER_USER_LOCK_WRONG_NAME = 3057;
	exports$1.ER_USER_LOCK_DEADLOCK = 3058;
	exports$1.ER_REPLACE_INACCESSIBLE_ROWS = 3059;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS = 3060;
	exports$1.ER_ILLEGAL_USER_VAR = 3061;
	exports$1.ER_GTID_MODE_OFF = 3062;
	exports$1.ER_UNSUPPORTED_BY_REPLICATION_THREAD = 3063;
	exports$1.ER_INCORRECT_TYPE = 3064;
	exports$1.ER_FIELD_IN_ORDER_NOT_SELECT = 3065;
	exports$1.ER_AGGREGATE_IN_ORDER_NOT_SELECT = 3066;
	exports$1.ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN = 3067;
	exports$1.ER_NET_OK_PACKET_TOO_LARGE = 3068;
	exports$1.ER_INVALID_JSON_DATA = 3069;
	exports$1.ER_INVALID_GEOJSON_MISSING_MEMBER = 3070;
	exports$1.ER_INVALID_GEOJSON_WRONG_TYPE = 3071;
	exports$1.ER_INVALID_GEOJSON_UNSPECIFIED = 3072;
	exports$1.ER_DIMENSION_UNSUPPORTED = 3073;
	exports$1.ER_REPLICA_CHANNEL_DOES_NOT_EXIST = 3074;
	exports$1.ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT = 3075;
	exports$1.ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG = 3076;
	exports$1.ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY = 3077;
	exports$1.ER_SLAVE_CHANNEL_DELETE = 3078;
	exports$1.ER_REPLICA_MULTIPLE_CHANNELS_CMD = 3079;
	exports$1.ER_REPLICA_MAX_CHANNELS_EXCEEDED = 3080;
	exports$1.ER_REPLICA_CHANNEL_MUST_STOP = 3081;
	exports$1.ER_REPLICA_CHANNEL_NOT_RUNNING = 3082;
	exports$1.ER_REPLICA_CHANNEL_WAS_RUNNING = 3083;
	exports$1.ER_REPLICA_CHANNEL_WAS_NOT_RUNNING = 3084;
	exports$1.ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP = 3085;
	exports$1.ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER = 3086;
	exports$1.ER_WRONG_FIELD_WITH_GROUP_V2 = 3087;
	exports$1.ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2 = 3088;
	exports$1.ER_WARN_DEPRECATED_SYSVAR_UPDATE = 3089;
	exports$1.ER_WARN_DEPRECATED_SQLMODE = 3090;
	exports$1.ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID = 3091;
	exports$1.ER_GROUP_REPLICATION_CONFIGURATION = 3092;
	exports$1.ER_GROUP_REPLICATION_RUNNING = 3093;
	exports$1.ER_GROUP_REPLICATION_APPLIER_INIT_ERROR = 3094;
	exports$1.ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT = 3095;
	exports$1.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR = 3096;
	exports$1.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR = 3097;
	exports$1.ER_BEFORE_DML_VALIDATION_ERROR = 3098;
	exports$1.ER_PREVENTS_VARIABLE_WITHOUT_RBR = 3099;
	exports$1.ER_RUN_HOOK_ERROR = 3100;
	exports$1.ER_TRANSACTION_ROLLBACK_DURING_COMMIT = 3101;
	exports$1.ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED = 3102;
	exports$1.ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN = 3103;
	exports$1.ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN = 3104;
	exports$1.ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN = 3105;
	exports$1.ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN = 3106;
	exports$1.ER_GENERATED_COLUMN_NON_PRIOR = 3107;
	exports$1.ER_DEPENDENT_BY_GENERATED_COLUMN = 3108;
	exports$1.ER_GENERATED_COLUMN_REF_AUTO_INC = 3109;
	exports$1.ER_FEATURE_NOT_AVAILABLE = 3110;
	exports$1.ER_CANT_SET_GTID_MODE = 3111;
	exports$1.ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF = 3112;
	exports$1.ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION = 3113;
	exports$1.ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON = 3114;
	exports$1.ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF = 3115;
	exports$1.ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX = 3116;
	exports$1.ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX = 3117;
	exports$1.ER_ACCOUNT_HAS_BEEN_LOCKED = 3118;
	exports$1.ER_WRONG_TABLESPACE_NAME = 3119;
	exports$1.ER_TABLESPACE_IS_NOT_EMPTY = 3120;
	exports$1.ER_WRONG_FILE_NAME = 3121;
	exports$1.ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION = 3122;
	exports$1.ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR = 3123;
	exports$1.ER_WARN_BAD_MAX_EXECUTION_TIME = 3124;
	exports$1.ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME = 3125;
	exports$1.ER_WARN_CONFLICTING_HINT = 3126;
	exports$1.ER_WARN_UNKNOWN_QB_NAME = 3127;
	exports$1.ER_UNRESOLVED_HINT_NAME = 3128;
	exports$1.ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE = 3129;
	exports$1.ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED = 3130;
	exports$1.ER_LOCKING_SERVICE_WRONG_NAME = 3131;
	exports$1.ER_LOCKING_SERVICE_DEADLOCK = 3132;
	exports$1.ER_LOCKING_SERVICE_TIMEOUT = 3133;
	exports$1.ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED = 3134;
	exports$1.ER_SQL_MODE_MERGED = 3135;
	exports$1.ER_VTOKEN_PLUGIN_TOKEN_MISMATCH = 3136;
	exports$1.ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND = 3137;
	exports$1.ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID = 3138;
	exports$1.ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED = 3139;
	exports$1.ER_INVALID_JSON_TEXT = 3140;
	exports$1.ER_INVALID_JSON_TEXT_IN_PARAM = 3141;
	exports$1.ER_INVALID_JSON_BINARY_DATA = 3142;
	exports$1.ER_INVALID_JSON_PATH = 3143;
	exports$1.ER_INVALID_JSON_CHARSET = 3144;
	exports$1.ER_INVALID_JSON_CHARSET_IN_FUNCTION = 3145;
	exports$1.ER_INVALID_TYPE_FOR_JSON = 3146;
	exports$1.ER_INVALID_CAST_TO_JSON = 3147;
	exports$1.ER_INVALID_JSON_PATH_CHARSET = 3148;
	exports$1.ER_INVALID_JSON_PATH_WILDCARD = 3149;
	exports$1.ER_JSON_VALUE_TOO_BIG = 3150;
	exports$1.ER_JSON_KEY_TOO_BIG = 3151;
	exports$1.ER_JSON_USED_AS_KEY = 3152;
	exports$1.ER_JSON_VACUOUS_PATH = 3153;
	exports$1.ER_JSON_BAD_ONE_OR_ALL_ARG = 3154;
	exports$1.ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE = 3155;
	exports$1.ER_INVALID_JSON_VALUE_FOR_CAST = 3156;
	exports$1.ER_JSON_DOCUMENT_TOO_DEEP = 3157;
	exports$1.ER_JSON_DOCUMENT_NULL_KEY = 3158;
	exports$1.ER_SECURE_TRANSPORT_REQUIRED = 3159;
	exports$1.ER_NO_SECURE_TRANSPORTS_CONFIGURED = 3160;
	exports$1.ER_DISABLED_STORAGE_ENGINE = 3161;
	exports$1.ER_USER_DOES_NOT_EXIST = 3162;
	exports$1.ER_USER_ALREADY_EXISTS = 3163;
	exports$1.ER_AUDIT_API_ABORT = 3164;
	exports$1.ER_INVALID_JSON_PATH_ARRAY_CELL = 3165;
	exports$1.ER_BUFPOOL_RESIZE_INPROGRESS = 3166;
	exports$1.ER_FEATURE_DISABLED_SEE_DOC = 3167;
	exports$1.ER_SERVER_ISNT_AVAILABLE = 3168;
	exports$1.ER_SESSION_WAS_KILLED = 3169;
	exports$1.ER_CAPACITY_EXCEEDED = 3170;
	exports$1.ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER = 3171;
	exports$1.ER_TABLE_NEEDS_UPG_PART = 3172;
	exports$1.ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID = 3173;
	exports$1.ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL = 3174;
	exports$1.ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT = 3175;
	exports$1.ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE = 3176;
	exports$1.ER_LOCK_REFUSED_BY_ENGINE = 3177;
	exports$1.ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN = 3178;
	exports$1.ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE = 3179;
	exports$1.ER_MASTER_KEY_ROTATION_ERROR_BY_SE = 3180;
	exports$1.ER_MASTER_KEY_ROTATION_BINLOG_FAILED = 3181;
	exports$1.ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE = 3182;
	exports$1.ER_TABLESPACE_CANNOT_ENCRYPT = 3183;
	exports$1.ER_INVALID_ENCRYPTION_OPTION = 3184;
	exports$1.ER_CANNOT_FIND_KEY_IN_KEYRING = 3185;
	exports$1.ER_CAPACITY_EXCEEDED_IN_PARSER = 3186;
	exports$1.ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE = 3187;
	exports$1.ER_KEYRING_UDF_KEYRING_SERVICE_ERROR = 3188;
	exports$1.ER_USER_COLUMN_OLD_LENGTH = 3189;
	exports$1.ER_CANT_RESET_SOURCE = 3190;
	exports$1.ER_GROUP_REPLICATION_MAX_GROUP_SIZE = 3191;
	exports$1.ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED = 3192;
	exports$1.ER_TABLE_REFERENCED = 3193;
	exports$1.ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE = 3194;
	exports$1.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO = 3195;
	exports$1.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID = 3196;
	exports$1.ER_XA_RETRY = 3197;
	exports$1.ER_KEYRING_AWS_UDF_AWS_KMS_ERROR = 3198;
	exports$1.ER_BINLOG_UNSAFE_XA = 3199;
	exports$1.ER_UDF_ERROR = 3200;
	exports$1.ER_KEYRING_MIGRATION_FAILURE = 3201;
	exports$1.ER_KEYRING_ACCESS_DENIED_ERROR = 3202;
	exports$1.ER_KEYRING_MIGRATION_STATUS = 3203;
	exports$1.ER_PLUGIN_FAILED_TO_OPEN_TABLES = 3204;
	exports$1.ER_PLUGIN_FAILED_TO_OPEN_TABLE = 3205;
	exports$1.ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED = 3206;
	exports$1.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET = 3207;
	exports$1.ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY = 3208;
	exports$1.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED = 3209;
	exports$1.ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED = 3210;
	exports$1.ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE = 3211;
	exports$1.ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED = 3212;
	exports$1.ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS = 3213;
	exports$1.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE = 3214;
	exports$1.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT = 3215;
	exports$1.ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED = 3216;
	exports$1.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE = 3217;
	exports$1.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE = 3218;
	exports$1.ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR = 3219;
	exports$1.ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY = 3220;
	exports$1.ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY = 3221;
	exports$1.ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS = 3222;
	exports$1.ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC = 3223;
	exports$1.ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER = 3224;
	exports$1.ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER = 3225;
	exports$1.WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP = 3226;
	exports$1.ER_XA_REPLICATION_FILTERS = 3227;
	exports$1.ER_CANT_OPEN_ERROR_LOG = 3228;
	exports$1.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3229;
	exports$1.ER_CANT_START_SERVER_NAMED_PIPE = 3230;
	exports$1.ER_WRITE_SET_EXCEEDS_LIMIT = 3231;
	exports$1.ER_DEPRECATED_TLS_VERSION_SESSION_57 = 3232;
	exports$1.ER_WARN_DEPRECATED_TLS_VERSION_57 = 3233;
	exports$1.ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE = 3234;
	exports$1.ER_AES_INVALID_KDF_NAME = 3235;
	exports$1.ER_AES_INVALID_KDF_ITERATIONS = 3236;
	exports$1.WARN_AES_KEY_SIZE = 3237;
	exports$1.ER_AES_INVALID_KDF_OPTION_SIZE = 3238;
	exports$1.ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE = 3500;
	exports$1.ER_ACL_OPERATION_FAILED = 3501;
	exports$1.ER_UNSUPPORTED_INDEX_ALGORITHM = 3502;
	exports$1.ER_NO_SUCH_DB = 3503;
	exports$1.ER_TOO_BIG_ENUM = 3504;
	exports$1.ER_TOO_LONG_SET_ENUM_VALUE = 3505;
	exports$1.ER_INVALID_DD_OBJECT = 3506;
	exports$1.ER_UPDATING_DD_TABLE = 3507;
	exports$1.ER_INVALID_DD_OBJECT_ID = 3508;
	exports$1.ER_INVALID_DD_OBJECT_NAME = 3509;
	exports$1.ER_TABLESPACE_MISSING_WITH_NAME = 3510;
	exports$1.ER_TOO_LONG_ROUTINE_COMMENT = 3511;
	exports$1.ER_SP_LOAD_FAILED = 3512;
	exports$1.ER_INVALID_BITWISE_OPERANDS_SIZE = 3513;
	exports$1.ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE = 3514;
	exports$1.ER_WARN_UNSUPPORTED_HINT = 3515;
	exports$1.ER_UNEXPECTED_GEOMETRY_TYPE = 3516;
	exports$1.ER_SRS_PARSE_ERROR = 3517;
	exports$1.ER_SRS_PROJ_PARAMETER_MISSING = 3518;
	exports$1.ER_WARN_SRS_NOT_FOUND = 3519;
	exports$1.ER_SRS_NOT_CARTESIAN = 3520;
	exports$1.ER_SRS_NOT_CARTESIAN_UNDEFINED = 3521;
	exports$1.ER_PK_INDEX_CANT_BE_INVISIBLE = 3522;
	exports$1.ER_UNKNOWN_AUTHID = 3523;
	exports$1.ER_FAILED_ROLE_GRANT = 3524;
	exports$1.ER_OPEN_ROLE_TABLES = 3525;
	exports$1.ER_FAILED_DEFAULT_ROLES = 3526;
	exports$1.ER_COMPONENTS_NO_SCHEME = 3527;
	exports$1.ER_COMPONENTS_NO_SCHEME_SERVICE = 3528;
	exports$1.ER_COMPONENTS_CANT_LOAD = 3529;
	exports$1.ER_ROLE_NOT_GRANTED = 3530;
	exports$1.ER_FAILED_REVOKE_ROLE = 3531;
	exports$1.ER_RENAME_ROLE = 3532;
	exports$1.ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION = 3533;
	exports$1.ER_COMPONENTS_CANT_SATISFY_DEPENDENCY = 3534;
	exports$1.ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION = 3535;
	exports$1.ER_COMPONENTS_LOAD_CANT_INITIALIZE = 3536;
	exports$1.ER_COMPONENTS_UNLOAD_NOT_LOADED = 3537;
	exports$1.ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE = 3538;
	exports$1.ER_COMPONENTS_CANT_RELEASE_SERVICE = 3539;
	exports$1.ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE = 3540;
	exports$1.ER_COMPONENTS_CANT_UNLOAD = 3541;
	exports$1.ER_WARN_UNLOAD_THE_NOT_PERSISTED = 3542;
	exports$1.ER_COMPONENT_TABLE_INCORRECT = 3543;
	exports$1.ER_COMPONENT_MANIPULATE_ROW_FAILED = 3544;
	exports$1.ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP = 3545;
	exports$1.ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS = 3546;
	exports$1.ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES = 3547;
	exports$1.ER_SRS_NOT_FOUND = 3548;
	exports$1.ER_VARIABLE_NOT_PERSISTED = 3549;
	exports$1.ER_IS_QUERY_INVALID_CLAUSE = 3550;
	exports$1.ER_UNABLE_TO_STORE_STATISTICS = 3551;
	exports$1.ER_NO_SYSTEM_SCHEMA_ACCESS = 3552;
	exports$1.ER_NO_SYSTEM_TABLESPACE_ACCESS = 3553;
	exports$1.ER_NO_SYSTEM_TABLE_ACCESS = 3554;
	exports$1.ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE = 3555;
	exports$1.ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE = 3556;
	exports$1.ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE = 3557;
	exports$1.ER_INVALID_OPTION_KEY = 3558;
	exports$1.ER_INVALID_OPTION_VALUE = 3559;
	exports$1.ER_INVALID_OPTION_KEY_VALUE_PAIR = 3560;
	exports$1.ER_INVALID_OPTION_START_CHARACTER = 3561;
	exports$1.ER_INVALID_OPTION_END_CHARACTER = 3562;
	exports$1.ER_INVALID_OPTION_CHARACTERS = 3563;
	exports$1.ER_DUPLICATE_OPTION_KEY = 3564;
	exports$1.ER_WARN_SRS_NOT_FOUND_AXIS_ORDER = 3565;
	exports$1.ER_NO_ACCESS_TO_NATIVE_FCT = 3566;
	exports$1.ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE = 3567;
	exports$1.ER_UNRESOLVED_TABLE_LOCK = 3568;
	exports$1.ER_DUPLICATE_TABLE_LOCK = 3569;
	exports$1.ER_BINLOG_UNSAFE_SKIP_LOCKED = 3570;
	exports$1.ER_BINLOG_UNSAFE_NOWAIT = 3571;
	exports$1.ER_LOCK_NOWAIT = 3572;
	exports$1.ER_CTE_RECURSIVE_REQUIRES_UNION = 3573;
	exports$1.ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST = 3574;
	exports$1.ER_CTE_RECURSIVE_FORBIDS_AGGREGATION = 3575;
	exports$1.ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER = 3576;
	exports$1.ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE = 3577;
	exports$1.ER_SWITCH_TMP_ENGINE = 3578;
	exports$1.ER_WINDOW_NO_SUCH_WINDOW = 3579;
	exports$1.ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH = 3580;
	exports$1.ER_WINDOW_NO_CHILD_PARTITIONING = 3581;
	exports$1.ER_WINDOW_NO_INHERIT_FRAME = 3582;
	exports$1.ER_WINDOW_NO_REDEFINE_ORDER_BY = 3583;
	exports$1.ER_WINDOW_FRAME_START_ILLEGAL = 3584;
	exports$1.ER_WINDOW_FRAME_END_ILLEGAL = 3585;
	exports$1.ER_WINDOW_FRAME_ILLEGAL = 3586;
	exports$1.ER_WINDOW_RANGE_FRAME_ORDER_TYPE = 3587;
	exports$1.ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE = 3588;
	exports$1.ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE = 3589;
	exports$1.ER_WINDOW_RANGE_BOUND_NOT_CONSTANT = 3590;
	exports$1.ER_WINDOW_DUPLICATE_NAME = 3591;
	exports$1.ER_WINDOW_ILLEGAL_ORDER_BY = 3592;
	exports$1.ER_WINDOW_INVALID_WINDOW_FUNC_USE = 3593;
	exports$1.ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE = 3594;
	exports$1.ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC = 3595;
	exports$1.ER_WINDOW_ROWS_INTERVAL_USE = 3596;
	exports$1.ER_WINDOW_NO_GROUP_ORDER = 3597;
	exports$1.ER_WINDOW_EXPLAIN_JSON = 3598;
	exports$1.ER_WINDOW_FUNCTION_IGNORES_FRAME = 3599;
	exports$1.ER_WL9236_NOW = 3600;
	exports$1.ER_INVALID_NO_OF_ARGS = 3601;
	exports$1.ER_FIELD_IN_GROUPING_NOT_GROUP_BY = 3602;
	exports$1.ER_TOO_LONG_TABLESPACE_COMMENT = 3603;
	exports$1.ER_ENGINE_CANT_DROP_TABLE = 3604;
	exports$1.ER_ENGINE_CANT_DROP_MISSING_TABLE = 3605;
	exports$1.ER_TABLESPACE_DUP_FILENAME = 3606;
	exports$1.ER_DB_DROP_RMDIR2 = 3607;
	exports$1.ER_IMP_NO_FILES_MATCHED = 3608;
	exports$1.ER_IMP_SCHEMA_DOES_NOT_EXIST = 3609;
	exports$1.ER_IMP_TABLE_ALREADY_EXISTS = 3610;
	exports$1.ER_IMP_INCOMPATIBLE_MYSQLD_VERSION = 3611;
	exports$1.ER_IMP_INCOMPATIBLE_DD_VERSION = 3612;
	exports$1.ER_IMP_INCOMPATIBLE_SDI_VERSION = 3613;
	exports$1.ER_WARN_INVALID_HINT = 3614;
	exports$1.ER_VAR_DOES_NOT_EXIST = 3615;
	exports$1.ER_LONGITUDE_OUT_OF_RANGE = 3616;
	exports$1.ER_LATITUDE_OUT_OF_RANGE = 3617;
	exports$1.ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS = 3618;
	exports$1.ER_ILLEGAL_PRIVILEGE_LEVEL = 3619;
	exports$1.ER_NO_SYSTEM_VIEW_ACCESS = 3620;
	exports$1.ER_COMPONENT_FILTER_FLABBERGASTED = 3621;
	exports$1.ER_PART_EXPR_TOO_LONG = 3622;
	exports$1.ER_UDF_DROP_DYNAMICALLY_REGISTERED = 3623;
	exports$1.ER_UNABLE_TO_STORE_COLUMN_STATISTICS = 3624;
	exports$1.ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS = 3625;
	exports$1.ER_UNABLE_TO_DROP_COLUMN_STATISTICS = 3626;
	exports$1.ER_UNABLE_TO_BUILD_HISTOGRAM = 3627;
	exports$1.ER_MANDATORY_ROLE = 3628;
	exports$1.ER_MISSING_TABLESPACE_FILE = 3629;
	exports$1.ER_PERSIST_ONLY_ACCESS_DENIED_ERROR = 3630;
	exports$1.ER_CMD_NEED_SUPER = 3631;
	exports$1.ER_PATH_IN_DATADIR = 3632;
	exports$1.ER_CLONE_DDL_IN_PROGRESS = 3633;
	exports$1.ER_CLONE_TOO_MANY_CONCURRENT_CLONES = 3634;
	exports$1.ER_APPLIER_LOG_EVENT_VALIDATION_ERROR = 3635;
	exports$1.ER_CTE_MAX_RECURSION_DEPTH = 3636;
	exports$1.ER_NOT_HINT_UPDATABLE_VARIABLE = 3637;
	exports$1.ER_CREDENTIALS_CONTRADICT_TO_HISTORY = 3638;
	exports$1.ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID = 3639;
	exports$1.ER_CLIENT_DOES_NOT_SUPPORT = 3640;
	exports$1.ER_I_S_SKIPPED_TABLESPACE = 3641;
	exports$1.ER_TABLESPACE_ENGINE_MISMATCH = 3642;
	exports$1.ER_WRONG_SRID_FOR_COLUMN = 3643;
	exports$1.ER_CANNOT_ALTER_SRID_DUE_TO_INDEX = 3644;
	exports$1.ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED = 3645;
	exports$1.ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED = 3646;
	exports$1.ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES = 3647;
	exports$1.ER_COULD_NOT_APPLY_JSON_DIFF = 3648;
	exports$1.ER_CORRUPTED_JSON_DIFF = 3649;
	exports$1.ER_RESOURCE_GROUP_EXISTS = 3650;
	exports$1.ER_RESOURCE_GROUP_NOT_EXISTS = 3651;
	exports$1.ER_INVALID_VCPU_ID = 3652;
	exports$1.ER_INVALID_VCPU_RANGE = 3653;
	exports$1.ER_INVALID_THREAD_PRIORITY = 3654;
	exports$1.ER_DISALLOWED_OPERATION = 3655;
	exports$1.ER_RESOURCE_GROUP_BUSY = 3656;
	exports$1.ER_RESOURCE_GROUP_DISABLED = 3657;
	exports$1.ER_FEATURE_UNSUPPORTED = 3658;
	exports$1.ER_ATTRIBUTE_IGNORED = 3659;
	exports$1.ER_INVALID_THREAD_ID = 3660;
	exports$1.ER_RESOURCE_GROUP_BIND_FAILED = 3661;
	exports$1.ER_INVALID_USE_OF_FORCE_OPTION = 3662;
	exports$1.ER_GROUP_REPLICATION_COMMAND_FAILURE = 3663;
	exports$1.ER_SDI_OPERATION_FAILED = 3664;
	exports$1.ER_MISSING_JSON_TABLE_VALUE = 3665;
	exports$1.ER_WRONG_JSON_TABLE_VALUE = 3666;
	exports$1.ER_TF_MUST_HAVE_ALIAS = 3667;
	exports$1.ER_TF_FORBIDDEN_JOIN_TYPE = 3668;
	exports$1.ER_JT_VALUE_OUT_OF_RANGE = 3669;
	exports$1.ER_JT_MAX_NESTED_PATH = 3670;
	exports$1.ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD = 3671;
	exports$1.ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL = 3672;
	exports$1.ER_BAD_NULL_ERROR_NOT_IGNORED = 3673;
	exports$1.WARN_USELESS_SPATIAL_INDEX = 3674;
	exports$1.ER_DISK_FULL_NOWAIT = 3675;
	exports$1.ER_PARSE_ERROR_IN_DIGEST_FN = 3676;
	exports$1.ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN = 3677;
	exports$1.ER_SCHEMA_DIR_EXISTS = 3678;
	exports$1.ER_SCHEMA_DIR_MISSING = 3679;
	exports$1.ER_SCHEMA_DIR_CREATE_FAILED = 3680;
	exports$1.ER_SCHEMA_DIR_UNKNOWN = 3681;
	exports$1.ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326 = 3682;
	exports$1.ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER = 3683;
	exports$1.ER_REGEXP_BUFFER_OVERFLOW = 3684;
	exports$1.ER_REGEXP_ILLEGAL_ARGUMENT = 3685;
	exports$1.ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR = 3686;
	exports$1.ER_REGEXP_INTERNAL_ERROR = 3687;
	exports$1.ER_REGEXP_RULE_SYNTAX = 3688;
	exports$1.ER_REGEXP_BAD_ESCAPE_SEQUENCE = 3689;
	exports$1.ER_REGEXP_UNIMPLEMENTED = 3690;
	exports$1.ER_REGEXP_MISMATCHED_PAREN = 3691;
	exports$1.ER_REGEXP_BAD_INTERVAL = 3692;
	exports$1.ER_REGEXP_MAX_LT_MIN = 3693;
	exports$1.ER_REGEXP_INVALID_BACK_REF = 3694;
	exports$1.ER_REGEXP_LOOK_BEHIND_LIMIT = 3695;
	exports$1.ER_REGEXP_MISSING_CLOSE_BRACKET = 3696;
	exports$1.ER_REGEXP_INVALID_RANGE = 3697;
	exports$1.ER_REGEXP_STACK_OVERFLOW = 3698;
	exports$1.ER_REGEXP_TIME_OUT = 3699;
	exports$1.ER_REGEXP_PATTERN_TOO_BIG = 3700;
	exports$1.ER_CANT_SET_ERROR_LOG_SERVICE = 3701;
	exports$1.ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE = 3702;
	exports$1.ER_COMPONENT_FILTER_DIAGNOSTICS = 3703;
	exports$1.ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS = 3704;
	exports$1.ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS = 3705;
	exports$1.ER_NONPOSITIVE_RADIUS = 3706;
	exports$1.ER_RESTART_SERVER_FAILED = 3707;
	exports$1.ER_SRS_MISSING_MANDATORY_ATTRIBUTE = 3708;
	exports$1.ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS = 3709;
	exports$1.ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE = 3710;
	exports$1.ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE = 3711;
	exports$1.ER_SRS_ID_ALREADY_EXISTS = 3712;
	exports$1.ER_WARN_SRS_ID_ALREADY_EXISTS = 3713;
	exports$1.ER_CANT_MODIFY_SRID_0 = 3714;
	exports$1.ER_WARN_RESERVED_SRID_RANGE = 3715;
	exports$1.ER_CANT_MODIFY_SRS_USED_BY_COLUMN = 3716;
	exports$1.ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE = 3717;
	exports$1.ER_SRS_ATTRIBUTE_STRING_TOO_LONG = 3718;
	exports$1.ER_DEPRECATED_UTF8_ALIAS = 3719;
	exports$1.ER_DEPRECATED_NATIONAL = 3720;
	exports$1.ER_INVALID_DEFAULT_UTF8MB4_COLLATION = 3721;
	exports$1.ER_UNABLE_TO_COLLECT_LOG_STATUS = 3722;
	exports$1.ER_RESERVED_TABLESPACE_NAME = 3723;
	exports$1.ER_UNABLE_TO_SET_OPTION = 3724;
	exports$1.ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL = 3725;
	exports$1.ER_SRS_NOT_GEOGRAPHIC = 3726;
	exports$1.ER_POLYGON_TOO_LARGE = 3727;
	exports$1.ER_SPATIAL_UNIQUE_INDEX = 3728;
	exports$1.ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX = 3729;
	exports$1.ER_FK_CANNOT_DROP_PARENT = 3730;
	exports$1.ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE = 3731;
	exports$1.ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE = 3732;
	exports$1.ER_FK_CANNOT_USE_VIRTUAL_COLUMN = 3733;
	exports$1.ER_FK_NO_COLUMN_PARENT = 3734;
	exports$1.ER_CANT_SET_ERROR_SUPPRESSION_LIST = 3735;
	exports$1.ER_SRS_GEOGCS_INVALID_AXES = 3736;
	exports$1.ER_SRS_INVALID_SEMI_MAJOR_AXIS = 3737;
	exports$1.ER_SRS_INVALID_INVERSE_FLATTENING = 3738;
	exports$1.ER_SRS_INVALID_ANGULAR_UNIT = 3739;
	exports$1.ER_SRS_INVALID_PRIME_MERIDIAN = 3740;
	exports$1.ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED = 3741;
	exports$1.ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED = 3742;
	exports$1.ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84 = 3743;
	exports$1.ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84 = 3744;
	exports$1.ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT = 3745;
	exports$1.ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3746;
	exports$1.ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3747;
	exports$1.ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR = 3748;
	exports$1.ER_XA_CANT_CREATE_MDL_BACKUP = 3749;
	exports$1.ER_TABLE_WITHOUT_PK = 3750;
	exports$1.ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX = 3751;
	exports$1.ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX = 3752;
	exports$1.ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION = 3753;
	exports$1.ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT = 3754;
	exports$1.ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX = 3755;
	exports$1.ER_FUNCTIONAL_INDEX_PRIMARY_KEY = 3756;
	exports$1.ER_FUNCTIONAL_INDEX_ON_LOB = 3757;
	exports$1.ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED = 3758;
	exports$1.ER_FULLTEXT_FUNCTIONAL_INDEX = 3759;
	exports$1.ER_SPATIAL_FUNCTIONAL_INDEX = 3760;
	exports$1.ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX = 3761;
	exports$1.ER_FUNCTIONAL_INDEX_ON_FIELD = 3762;
	exports$1.ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED = 3763;
	exports$1.ER_GENERATED_COLUMN_ROW_VALUE = 3764;
	exports$1.ER_GENERATED_COLUMN_VARIABLES = 3765;
	exports$1.ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE = 3766;
	exports$1.ER_DEFAULT_VAL_GENERATED_NON_PRIOR = 3767;
	exports$1.ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC = 3768;
	exports$1.ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED = 3769;
	exports$1.ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED = 3770;
	exports$1.ER_DEFAULT_VAL_GENERATED_ROW_VALUE = 3771;
	exports$1.ER_DEFAULT_VAL_GENERATED_VARIABLES = 3772;
	exports$1.ER_DEFAULT_AS_VAL_GENERATED = 3773;
	exports$1.ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED = 3774;
	exports$1.ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION = 3775;
	exports$1.ER_FK_CANNOT_CHANGE_ENGINE = 3776;
	exports$1.ER_WARN_DEPRECATED_USER_SET_EXPR = 3777;
	exports$1.ER_WARN_DEPRECATED_UTF8MB3_COLLATION = 3778;
	exports$1.ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX = 3779;
	exports$1.ER_FK_INCOMPATIBLE_COLUMNS = 3780;
	exports$1.ER_GR_HOLD_WAIT_TIMEOUT = 3781;
	exports$1.ER_GR_HOLD_KILLED = 3782;
	exports$1.ER_GR_HOLD_MEMBER_STATUS_ERROR = 3783;
	exports$1.ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY = 3784;
	exports$1.ER_RPL_ENCRYPTION_KEY_NOT_FOUND = 3785;
	exports$1.ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY = 3786;
	exports$1.ER_RPL_ENCRYPTION_HEADER_ERROR = 3787;
	exports$1.ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS = 3788;
	exports$1.ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED = 3789;
	exports$1.ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY = 3790;
	exports$1.ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY = 3791;
	exports$1.ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY = 3792;
	exports$1.ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION = 3793;
	exports$1.ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED = 3794;
	exports$1.ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE = 3795;
	exports$1.ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED = 3796;
	exports$1.ER_GRP_TRX_CONSISTENCY_BEFORE = 3797;
	exports$1.ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN = 3798;
	exports$1.ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED = 3799;
	exports$1.ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED = 3800;
	exports$1.ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT = 3801;
	exports$1.ER_PAGE_TRACKING_NOT_STARTED = 3802;
	exports$1.ER_PAGE_TRACKING_RANGE_NOT_TRACKED = 3803;
	exports$1.ER_PAGE_TRACKING_CANNOT_PURGE = 3804;
	exports$1.ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY = 3805;
	exports$1.ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION = 3806;
	exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY = 3807;
	exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS = 3808;
	exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG = 3809;
	exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS = 3810;
	exports$1.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY = 3811;
	exports$1.ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT = 3812;
	exports$1.ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN = 3813;
	exports$1.ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED = 3814;
	exports$1.ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED = 3815;
	exports$1.ER_CHECK_CONSTRAINT_VARIABLES = 3816;
	exports$1.ER_CHECK_CONSTRAINT_ROW_VALUE = 3817;
	exports$1.ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN = 3818;
	exports$1.ER_CHECK_CONSTRAINT_VIOLATED = 3819;
	exports$1.ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN = 3820;
	exports$1.ER_CHECK_CONSTRAINT_NOT_FOUND = 3821;
	exports$1.ER_CHECK_CONSTRAINT_DUP_NAME = 3822;
	exports$1.ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN = 3823;
	exports$1.WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB = 3824;
	exports$1.ER_INVALID_ENCRYPTION_REQUEST = 3825;
	exports$1.ER_CANNOT_SET_TABLE_ENCRYPTION = 3826;
	exports$1.ER_CANNOT_SET_DATABASE_ENCRYPTION = 3827;
	exports$1.ER_CANNOT_SET_TABLESPACE_ENCRYPTION = 3828;
	exports$1.ER_TABLESPACE_CANNOT_BE_ENCRYPTED = 3829;
	exports$1.ER_TABLESPACE_CANNOT_BE_DECRYPTED = 3830;
	exports$1.ER_TABLESPACE_TYPE_UNKNOWN = 3831;
	exports$1.ER_TARGET_TABLESPACE_UNENCRYPTED = 3832;
	exports$1.ER_CANNOT_USE_ENCRYPTION_CLAUSE = 3833;
	exports$1.ER_INVALID_MULTIPLE_CLAUSES = 3834;
	exports$1.ER_UNSUPPORTED_USE_OF_GRANT_AS = 3835;
	exports$1.ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS = 3836;
	exports$1.ER_DEPENDENT_BY_FUNCTIONAL_INDEX = 3837;
	exports$1.ER_PLUGIN_NOT_EARLY = 3838;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH = 3839;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT = 3840;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID = 3841;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND = 3842;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY = 3843;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR = 3844;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH = 3845;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS = 3846;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE = 3847;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE = 3848;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE = 3849;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_FAILED = 3850;
	exports$1.ER_INNODB_REDO_LOG_ARCHIVE_SESSION = 3851;
	exports$1.ER_STD_REGEX_ERROR = 3852;
	exports$1.ER_INVALID_JSON_TYPE = 3853;
	exports$1.ER_CANNOT_CONVERT_STRING = 3854;
	exports$1.ER_DEPENDENT_BY_PARTITION_FUNC = 3855;
	exports$1.ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT = 3856;
	exports$1.ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP = 3857;
	exports$1.ER_WARN_DEPRECATED_FLOAT_DIGITS = 3858;
	exports$1.ER_WARN_DEPRECATED_FLOAT_UNSIGNED = 3859;
	exports$1.ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH = 3860;
	exports$1.ER_WARN_DEPRECATED_ZEROFILL = 3861;
	exports$1.ER_CLONE_DONOR = 3862;
	exports$1.ER_CLONE_PROTOCOL = 3863;
	exports$1.ER_CLONE_DONOR_VERSION = 3864;
	exports$1.ER_CLONE_OS = 3865;
	exports$1.ER_CLONE_PLATFORM = 3866;
	exports$1.ER_CLONE_CHARSET = 3867;
	exports$1.ER_CLONE_CONFIG = 3868;
	exports$1.ER_CLONE_SYS_CONFIG = 3869;
	exports$1.ER_CLONE_PLUGIN_MATCH = 3870;
	exports$1.ER_CLONE_LOOPBACK = 3871;
	exports$1.ER_CLONE_ENCRYPTION = 3872;
	exports$1.ER_CLONE_DISK_SPACE = 3873;
	exports$1.ER_CLONE_IN_PROGRESS = 3874;
	exports$1.ER_CLONE_DISALLOWED = 3875;
	exports$1.ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER = 3876;
	exports$1.ER_SECONDARY_ENGINE_PLUGIN = 3877;
	exports$1.ER_SECOND_PASSWORD_CANNOT_BE_EMPTY = 3878;
	exports$1.ER_DB_ACCESS_DENIED = 3879;
	exports$1.ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES = 3880;
	exports$1.ER_DA_RPL_GTID_TABLE_CANNOT_OPEN = 3881;
	exports$1.ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT = 3882;
	exports$1.ER_DA_PLUGIN_INSTALL_ERROR = 3883;
	exports$1.ER_NO_SESSION_TEMP = 3884;
	exports$1.ER_DA_UNKNOWN_ERROR_NUMBER = 3885;
	exports$1.ER_COLUMN_CHANGE_SIZE = 3886;
	exports$1.ER_REGEXP_INVALID_CAPTURE_GROUP_NAME = 3887;
	exports$1.ER_DA_SSL_LIBRARY_ERROR = 3888;
	exports$1.ER_SECONDARY_ENGINE = 3889;
	exports$1.ER_SECONDARY_ENGINE_DDL = 3890;
	exports$1.ER_INCORRECT_CURRENT_PASSWORD = 3891;
	exports$1.ER_MISSING_CURRENT_PASSWORD = 3892;
	exports$1.ER_CURRENT_PASSWORD_NOT_REQUIRED = 3893;
	exports$1.ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE = 3894;
	exports$1.ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED = 3895;
	exports$1.ER_PARTIAL_REVOKES_EXIST = 3896;
	exports$1.ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE = 3897;
	exports$1.ER_XA_REPLICATION_FILTERS = 3898;
	exports$1.ER_UNSUPPORTED_SQL_MODE = 3899;
	exports$1.ER_REGEXP_INVALID_FLAG = 3900;
	exports$1.ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS = 3901;
	exports$1.ER_UNIT_NOT_FOUND = 3902;
	exports$1.ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX = 3903;
	exports$1.ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX = 3904;
	exports$1.ER_EXCEEDED_MV_KEYS_NUM = 3905;
	exports$1.ER_EXCEEDED_MV_KEYS_SPACE = 3906;
	exports$1.ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG = 3907;
	exports$1.ER_WRONG_MVI_VALUE = 3908;
	exports$1.ER_WARN_FUNC_INDEX_NOT_APPLICABLE = 3909;
	exports$1.ER_GRP_RPL_UDF_ERROR = 3910;
	exports$1.ER_UPDATE_GTID_PURGED_WITH_GR = 3911;
	exports$1.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3912;
	exports$1.ER_TABLE_NAME_CAUSES_TOO_LONG_PATH = 3913;
	exports$1.ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE = 3914;
	exports$1.ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED = 3915;
	exports$1.ER_DA_GRP_RPL_STARTED_AUTO_REJOIN = 3916;
	exports$1.ER_SYSVAR_CHANGE_DURING_QUERY = 3917;
	exports$1.ER_GLOBSTAT_CHANGE_DURING_QUERY = 3918;
	exports$1.ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE = 3919;
	exports$1.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3920;
	exports$1.ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT = 3921;
	exports$1.ER_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3922;
	exports$1.ER_WRONG_COMPRESSION_LEVEL_CLIENT = 3923;
	exports$1.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT = 3924;
	exports$1.ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS = 3925;
	exports$1.ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST = 3926;
	exports$1.ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT = 3927;
	exports$1.ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV = 3928;
	exports$1.ER_WARN_DA_PRIVILEGE_NOT_REGISTERED = 3929;
	exports$1.ER_CLIENT_KEYRING_UDF_KEY_INVALID = 3930;
	exports$1.ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID = 3931;
	exports$1.ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG = 3932;
	exports$1.ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG = 3933;
	exports$1.ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT = 3934;
	exports$1.ER_DA_UDF_INVALID_CHARSET_SPECIFIED = 3935;
	exports$1.ER_DA_UDF_INVALID_CHARSET = 3936;
	exports$1.ER_DA_UDF_INVALID_COLLATION = 3937;
	exports$1.ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE = 3938;
	exports$1.ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME = 3939;
	exports$1.ER_CONSTRAINT_NOT_FOUND = 3940;
	exports$1.ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED = 3941;
	exports$1.ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS = 3942;
	exports$1.ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT = 3943;
	exports$1.ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT = 3944;
	exports$1.ER_REQUIRE_ROW_FORMAT_INVALID_VALUE = 3945;
	exports$1.ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY = 3946;
	exports$1.ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST = 3947;
	exports$1.ER_CLIENT_LOCAL_FILES_DISABLED = 3948;
	exports$1.ER_IMP_INCOMPATIBLE_CFG_VERSION = 3949;
	exports$1.ER_DA_OOM = 3950;
	exports$1.ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET = 3951;
	exports$1.ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET = 3952;
	exports$1.ER_MULTIPLE_INTO_CLAUSES = 3953;
	exports$1.ER_MISPLACED_INTO = 3954;
	exports$1.ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK = 3955;
	exports$1.ER_WARN_DEPRECATED_YEAR_UNSIGNED = 3956;
	exports$1.ER_CLONE_NETWORK_PACKET = 3957;
	exports$1.ER_SDI_OPERATION_FAILED_MISSING_RECORD = 3958;
	exports$1.ER_DEPENDENT_BY_CHECK_CONSTRAINT = 3959;
	exports$1.ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP = 3960;
	exports$1.ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY = 3961;
	exports$1.ER_WARN_DEPRECATED_INNER_INTO = 3962;
	exports$1.ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL = 3963;
	exports$1.ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS = 3964;
	exports$1.ER_WARN_DEPRECATED_FOUND_ROWS = 3965;
	exports$1.ER_MISSING_JSON_VALUE = 3966;
	exports$1.ER_MULTIPLE_JSON_VALUES = 3967;
	exports$1.ER_HOSTNAME_TOO_LONG = 3968;
	exports$1.ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY = 3969;
	exports$1.ER_GROUP_REPLICATION_USER_EMPTY_MSG = 3970;
	exports$1.ER_GROUP_REPLICATION_USER_MANDATORY_MSG = 3971;
	exports$1.ER_GROUP_REPLICATION_PASSWORD_LENGTH = 3972;
	exports$1.ER_SUBQUERY_TRANSFORM_REJECTED = 3973;
	exports$1.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT = 3974;
	exports$1.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID = 3975;
	exports$1.ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART = 3976;
	exports$1.ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION = 3977;
	exports$1.ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT = 3978;
	exports$1.ER_NOT_ALLOWED_WITH_START_TRANSACTION = 3979;
	exports$1.ER_INVALID_JSON_ATTRIBUTE = 3980;
	exports$1.ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED = 3981;
	exports$1.ER_INVALID_USER_ATTRIBUTE_JSON = 3982;
	exports$1.ER_INNODB_REDO_DISABLED = 3983;
	exports$1.ER_INNODB_REDO_ARCHIVING_ENABLED = 3984;
	exports$1.ER_MDL_OUT_OF_RESOURCES = 3985;
	exports$1.ER_IMPLICIT_COMPARISON_FOR_JSON = 3986;
	exports$1.ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET = 3987;
	exports$1.ER_IMPOSSIBLE_STRING_CONVERSION = 3988;
	exports$1.ER_SCHEMA_READ_ONLY = 3989;
	exports$1.ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF = 3990;
	exports$1.ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF = 3991;
	exports$1.ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF = 3992;
	exports$1.ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF = 3993;
	exports$1.ER_INVALID_PARAMETER_USE = 3994;
	exports$1.ER_CHARACTER_SET_MISMATCH = 3995;
	exports$1.ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED = 3996;
	exports$1.ER_INVALID_TIME_ZONE_INTERVAL = 3997;
	exports$1.ER_INVALID_CAST = 3998;
	exports$1.ER_HYPERGRAPH_NOT_SUPPORTED_YET = 3999;
	exports$1.ER_WARN_HYPERGRAPH_EXPERIMENTAL = 4000;
	exports$1.ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED = 4001;
	exports$1.ER_DA_ERROR_LOG_TABLE_DISABLED = 4002;
	exports$1.ER_DA_ERROR_LOG_MULTIPLE_FILTERS = 4003;
	exports$1.ER_DA_CANT_OPEN_ERROR_LOG = 4004;
	exports$1.ER_USER_REFERENCED_AS_DEFINER = 4005;
	exports$1.ER_CANNOT_USER_REFERENCED_AS_DEFINER = 4006;
	exports$1.ER_REGEX_NUMBER_TOO_BIG = 4007;
	exports$1.ER_SPVAR_NONINTEGER_TYPE = 4008;
	exports$1.WARN_UNSUPPORTED_ACL_TABLES_READ = 4009;
	exports$1.ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL = 4010;
	exports$1.ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT = 4011;
	exports$1.ER_STARTING_REPLICA_MONITOR_IO_THREAD = 4012;
	exports$1.ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON = 4013;
	exports$1.ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION = 4014;
	exports$1.ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON = 4015;
	exports$1.ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON = 4016;
	exports$1.ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID = 4017;
	exports$1.ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS = 4018;
	exports$1.ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID = 4019;
	exports$1.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME = 4020;
	exports$1.ER_CANT_USE_SAME_UUID_AS_GROUP_NAME = 4021;
	exports$1.ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING = 4022;
	exports$1.ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE = 4023;
	exports$1.ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE = 4024;
	exports$1.ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE = 4025;
	exports$1.ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE = 4026;
	exports$1.ER_ROLE_GRANTED_TO_ITSELF = 4027;
	exports$1.ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN = 4028;
	exports$1.ER_INNODB_COMPRESSION_FAILURE = 4029;
	exports$1.ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE = 4030;
	exports$1.ER_CLIENT_INTERACTION_TIMEOUT = 4031;
	exports$1.ER_INVALID_CAST_TO_GEOMETRY = 4032;
	exports$1.ER_INVALID_CAST_POLYGON_RING_DIRECTION = 4033;
	exports$1.ER_GIS_DIFFERENT_SRIDS_AGGREGATION = 4034;
	exports$1.ER_RELOAD_KEYRING_FAILURE = 4035;
	exports$1.ER_SDI_GET_KEYS_INVALID_TABLESPACE = 4036;
	exports$1.ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE = 4037;
	exports$1.ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI = 4038;
	exports$1.ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID = 4039;
	exports$1.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID = 4040;
	exports$1.ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE = 4041;
	exports$1.ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS = 4042;
	exports$1.ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE = 4043;
	exports$1.ER_KERBEROS_CREATE_USER = 4044;
	exports$1.ER_INSTALL_PLUGIN_CONFLICT_CLIENT = 4045;
	exports$1.ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED = 4046;
	exports$1.ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED = 4047;
	exports$1.ER_INVALID_ASSIGNMENT_TARGET = 4048;
	exports$1.ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY = 4049;
	exports$1.ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION = 4050;
	exports$1.ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON = 4051;
	exports$1.ER_INVALID_MFA_PLUGIN_SPECIFIED = 4052;
	exports$1.ER_IDENTIFIED_BY_UNSUPPORTED = 4053;
	exports$1.ER_INVALID_PLUGIN_FOR_REGISTRATION = 4054;
	exports$1.ER_PLUGIN_REQUIRES_REGISTRATION = 4055;
	exports$1.ER_MFA_METHOD_EXISTS = 4056;
	exports$1.ER_MFA_METHOD_NOT_EXISTS = 4057;
	exports$1.ER_AUTHENTICATION_POLICY_MISMATCH = 4058;
	exports$1.ER_PLUGIN_REGISTRATION_DONE = 4059;
	exports$1.ER_INVALID_USER_FOR_REGISTRATION = 4060;
	exports$1.ER_USER_REGISTRATION_FAILED = 4061;
	exports$1.ER_MFA_METHODS_INVALID_ORDER = 4062;
	exports$1.ER_MFA_METHODS_IDENTICAL = 4063;
	exports$1.ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER = 4064;
	exports$1.ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY = 4065;
	exports$1.ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY = 4066;
	exports$1.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY = 4067;
	exports$1.ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS = 4068;
	exports$1.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS = 4069;
	exports$1.ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON = 4070;
	exports$1.ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON = 4071;
	exports$1.ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS = 4072;
	exports$1.ER_DA_SSL_FIPS_MODE_ERROR = 4073;
	exports$1.ER_VALUE_OUT_OF_RANGE = 4074;
	exports$1.ER_FULLTEXT_WITH_ROLLUP = 4075;
	exports$1.ER_REGEXP_MISSING_RESOURCE = 4076;
	exports$1.ER_WARN_REGEXP_USING_DEFAULT = 4077;
	exports$1.ER_REGEXP_MISSING_FILE = 4078;
	exports$1.ER_WARN_DEPRECATED_COLLATION = 4079;
	exports$1.ER_CONCURRENT_PROCEDURE_USAGE = 4080;
	exports$1.ER_DA_GLOBAL_CONN_LIMIT = 4081;
	exports$1.ER_DA_CONN_LIMIT = 4082;
	exports$1.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT = 4083;
	exports$1.ER_WARN_SF_UDF_NAME_COLLISION = 4084;
	exports$1.ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK = 4085;
	exports$1.ER_TOO_MANY_WINDOWS = 4086;
	exports$1.ER_MYSQLBACKUP_CLIENT_MSG = 4087;
	exports$1.ER_COMMENT_CONTAINS_INVALID_STRING = 4088;
	exports$1.ER_DEFINITION_CONTAINS_INVALID_STRING = 4089;
	exports$1.ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT = 4090;
	exports$1.ER_XA_TEMP_TABLE = 4091;
	exports$1.ER_INNODB_MAX_ROW_VERSION = 4092;
	exports$1.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE = 4093;
	exports$1.ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING = 4094;
	exports$1.ER_WARN_DEPRECATED_DATETIME_DELIMITER = 4095;
	exports$1.ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER = 4096;
	exports$1.ER_CANNOT_PERSIST_SENSITIVE_VARIABLES = 4097;
	exports$1.ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES = 4098;
	exports$1.ER_WARN_TRG_ALREADY_EXISTS = 4099;
	exports$1.ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE = 4100;
	exports$1.ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION = 4101;
	exports$1.ER_SET_PASSWORD_AUTH_PLUGIN_ERROR = 4102;
	exports$1.ER_REDUCED_DBLWR_FILE_CORRUPTED = 4103;
	exports$1.ER_REDUCED_DBLWR_PAGE_FOUND = 4104;
	exports$1.ER_SRS_INVALID_LATITUDE_OF_ORIGIN = 4105;
	exports$1.ER_SRS_INVALID_LONGITUDE_OF_ORIGIN = 4106;
	exports$1.ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT = 4107;
	exports$1.ER_GIPK_COLUMN_EXISTS = 4108;
	exports$1.ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS = 4109;
	exports$1.ER_GIPK_COLUMN_ALTER_NOT_ALLOWED = 4110;
	exports$1.ER_DROP_PK_COLUMN_TO_DROP_GIPK = 4111;
	exports$1.ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR = 4112;
	exports$1.ER_DA_EXPIRE_LOGS_DAYS_IGNORED = 4113;
	exports$1.ER_CTE_RECURSIVE_NOT_UNION = 4114;
	exports$1.ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX = 4115;
	exports$1.ER_COMMAND_SERVICE_BACKEND_FAILED = 4116;
	exports$1.ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS = 4117;
	exports$1.ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE = 4118;
	exports$1.ER_WARN_DEPRECATED_IDENT = 4119;
	exports$1.ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED = 4120;
	exports$1.ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT = 4121;
	exports$1.ER_BAD_TIMESTAMP_FORMAT = 4122;
	exports$1.ER_SHAPE_PRIDICTION_UDF = 4123;
	exports$1.ER_SRS_INVALID_HEIGHT = 4124;
	exports$1.ER_SRS_INVALID_SCALING = 4125;
	exports$1.ER_SRS_INVALID_ZONE_WIDTH = 4126;
	exports$1.ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A = 4127;
	exports$1.ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION = 4128;
	exports$1.ER_TABLE_NOT_EMPTY = 4129;
	exports$1.ER_TABLE_NO_PRIMARY_KEY = 4130;
	exports$1.ER_TABLE_IN_SHARED_TABLESPACE = 4131;
	exports$1.ER_INDEX_OTHER_THAN_PK = 4132;
	exports$1.ER_LOAD_BULK_DATA_UNSORTED = 4133;
	exports$1.ER_BULK_EXECUTOR_ERROR = 4134;
	exports$1.ER_BULK_READER_LIBCURL_INIT_FAILED = 4135;
	exports$1.ER_BULK_READER_LIBCURL_ERROR = 4136;
	exports$1.ER_BULK_READER_SERVER_ERROR = 4137;
	exports$1.ER_BULK_READER_COMMUNICATION_ERROR = 4138;
	exports$1.ER_BULK_LOAD_DATA_FAILED = 4139;
	exports$1.ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER = 4140;
	exports$1.ER_BULK_LOADER_COMPONENT_ERROR = 4141;
	exports$1.ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE = 4142;
	exports$1.ER_BULK_PARSER_MISSING_ENCLOSED_BY = 4143;
	exports$1.ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED = 4144;
	exports$1.ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED = 4145;
	exports$1.ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT = 4146;
	exports$1.ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR = 4147;
	exports$1.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY = 4148;
	exports$1.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE = 4149;
	exports$1.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR = 4150;
	exports$1.ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE = 4151;
	exports$1.ER_LOAD_BULK_DATA_FAILED = 4152;
	exports$1.ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD = 4153;
	exports$1.ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL = 4154;
	exports$1.ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR = 4155;
	exports$1.ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE = 4156;
	exports$1.ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE = 4157;
	exports$1.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS = 4158;
	exports$1.ER_CANT_SET_PERSISTED = 4159;
	exports$1.ER_INSTALL_COMPONENT_SET_NULL_VALUE = 4160;
	exports$1.ER_INSTALL_COMPONENT_SET_UNUSED_VALUE = 4161;
	exports$1.ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS = 4162;

	// Lookup-by-number table
	exports$1[1] = 'EE_CANTCREATEFILE';
	exports$1[2] = 'EE_READ';
	exports$1[3] = 'EE_WRITE';
	exports$1[4] = 'EE_BADCLOSE';
	exports$1[5] = 'EE_OUTOFMEMORY';
	exports$1[6] = 'EE_DELETE';
	exports$1[7] = 'EE_LINK';
	exports$1[9] = 'EE_EOFERR';
	exports$1[10] = 'EE_CANTLOCK';
	exports$1[11] = 'EE_CANTUNLOCK';
	exports$1[12] = 'EE_DIR';
	exports$1[13] = 'EE_STAT';
	exports$1[14] = 'EE_CANT_CHSIZE';
	exports$1[15] = 'EE_CANT_OPEN_STREAM';
	exports$1[16] = 'EE_GETWD';
	exports$1[17] = 'EE_SETWD';
	exports$1[18] = 'EE_LINK_WARNING';
	exports$1[19] = 'EE_OPEN_WARNING';
	exports$1[20] = 'EE_DISK_FULL';
	exports$1[21] = 'EE_CANT_MKDIR';
	exports$1[22] = 'EE_UNKNOWN_CHARSET';
	exports$1[23] = 'EE_OUT_OF_FILERESOURCES';
	exports$1[24] = 'EE_CANT_READLINK';
	exports$1[25] = 'EE_CANT_SYMLINK';
	exports$1[26] = 'EE_REALPATH';
	exports$1[27] = 'EE_SYNC';
	exports$1[28] = 'EE_UNKNOWN_COLLATION';
	exports$1[29] = 'EE_FILENOTFOUND';
	exports$1[30] = 'EE_FILE_NOT_CLOSED';
	exports$1[31] = 'EE_CHANGE_OWNERSHIP';
	exports$1[32] = 'EE_CHANGE_PERMISSIONS';
	exports$1[33] = 'EE_CANT_SEEK';
	exports$1[34] = 'EE_CAPACITY_EXCEEDED';
	exports$1[35] = 'EE_DISK_FULL_WITH_RETRY_MSG';
	exports$1[36] = 'EE_FAILED_TO_CREATE_TIMER';
	exports$1[37] = 'EE_FAILED_TO_DELETE_TIMER';
	exports$1[38] = 'EE_FAILED_TO_CREATE_TIMER_QUEUE';
	exports$1[39] = 'EE_FAILED_TO_START_TIMER_NOTIFY_THREAD';
	exports$1[40] = 'EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT';
	exports$1[41] = 'EE_EXITING_TIMER_NOTIFY_THREAD';
	exports$1[42] = 'EE_WIN_LIBRARY_LOAD_FAILED';
	exports$1[43] = 'EE_WIN_RUN_TIME_ERROR_CHECK';
	exports$1[44] = 'EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE';
	exports$1[45] = 'EE_FAILED_TO_KILL_ALL_THREADS';
	exports$1[46] = 'EE_FAILED_TO_CREATE_IO_COMPLETION_PORT';
	exports$1[47] = 'EE_FAILED_TO_OPEN_DEFAULTS_FILE';
	exports$1[48] = 'EE_FAILED_TO_HANDLE_DEFAULTS_FILE';
	exports$1[49] = 'EE_WRONG_DIRECTIVE_IN_CONFIG_FILE';
	exports$1[50] = 'EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION';
	exports$1[51] = 'EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE';
	exports$1[52] = 'EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE';
	exports$1[53] = 'EE_CONFIG_FILE_PERMISSION_ERROR';
	exports$1[54] = 'EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE';
	exports$1[55] = 'EE_USING_DISABLED_OPTION';
	exports$1[56] = 'EE_USING_DISABLED_SHORT_OPTION';
	exports$1[57] = 'EE_USING_PASSWORD_ON_CLI_IS_INSECURE';
	exports$1[58] = 'EE_UNKNOWN_SUFFIX_FOR_VARIABLE';
	exports$1[59] = 'EE_SSL_ERROR_FROM_FILE';
	exports$1[60] = 'EE_SSL_ERROR';
	exports$1[61] = 'EE_NET_SEND_ERROR_IN_BOOTSTRAP';
	exports$1[62] = 'EE_PACKETS_OUT_OF_ORDER';
	exports$1[63] = 'EE_UNKNOWN_PROTOCOL_OPTION';
	exports$1[64] = 'EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY';
	exports$1[65] = 'EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT';
	exports$1[66] = 'EE_DEBUG_INFO';
	exports$1[67] = 'EE_UNKNOWN_VARIABLE';
	exports$1[68] = 'EE_UNKNOWN_OPTION';
	exports$1[69] = 'EE_UNKNOWN_SHORT_OPTION';
	exports$1[70] = 'EE_OPTION_WITHOUT_ARGUMENT';
	exports$1[71] = 'EE_OPTION_REQUIRES_ARGUMENT';
	exports$1[72] = 'EE_SHORT_OPTION_REQUIRES_ARGUMENT';
	exports$1[73] = 'EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE';
	exports$1[74] = 'EE_OPTION_WITH_EMPTY_VALUE';
	exports$1[75] = 'EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION';
	exports$1[76] = 'EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION';
	exports$1[77] = 'EE_FAILED_TO_SET_OPTION_VALUE';
	exports$1[78] = 'EE_INCORRECT_INT_VALUE_FOR_OPTION';
	exports$1[79] = 'EE_INCORRECT_UINT_VALUE_FOR_OPTION';
	exports$1[80] = 'EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION';
	exports$1[81] = 'EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION';
	exports$1[82] = 'EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION';
	exports$1[83] = 'EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION';
	exports$1[84] = 'EE_INVALID_DECIMAL_VALUE_FOR_OPTION';
	exports$1[85] = 'EE_COLLATION_PARSER_ERROR';
	exports$1[86] = 'EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR';
	exports$1[87] = 'EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR';
	exports$1[88] = 'EE_SHIFT_CHAR_OUT_OF_RANGE';
	exports$1[89] = 'EE_RESET_CHAR_OUT_OF_RANGE';
	exports$1[90] = 'EE_UNKNOWN_LDML_TAG';
	exports$1[91] = 'EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR';
	exports$1[92] = 'EE_FAILED_PROCESSING_DIRECTIVE';
	exports$1[93] = 'EE_PTHREAD_KILL_FAILED';
	exports$1[120] = 'HA_ERR_KEY_NOT_FOUND';
	exports$1[121] = 'HA_ERR_FOUND_DUPP_KEY';
	exports$1[122] = 'HA_ERR_INTERNAL_ERROR';
	exports$1[123] = 'HA_ERR_RECORD_CHANGED';
	exports$1[124] = 'HA_ERR_WRONG_INDEX';
	exports$1[125] = 'HA_ERR_ROLLED_BACK';
	exports$1[126] = 'HA_ERR_CRASHED';
	exports$1[127] = 'HA_ERR_WRONG_IN_RECORD';
	exports$1[128] = 'HA_ERR_OUT_OF_MEM';
	exports$1[130] = 'HA_ERR_NOT_A_TABLE';
	exports$1[131] = 'HA_ERR_WRONG_COMMAND';
	exports$1[132] = 'HA_ERR_OLD_FILE';
	exports$1[133] = 'HA_ERR_NO_ACTIVE_RECORD';
	exports$1[134] = 'HA_ERR_RECORD_DELETED';
	exports$1[135] = 'HA_ERR_RECORD_FILE_FULL';
	exports$1[136] = 'HA_ERR_INDEX_FILE_FULL';
	exports$1[137] = 'HA_ERR_END_OF_FILE';
	exports$1[138] = 'HA_ERR_UNSUPPORTED';
	exports$1[139] = 'HA_ERR_TOO_BIG_ROW';
	exports$1[140] = 'HA_WRONG_CREATE_OPTION';
	exports$1[141] = 'HA_ERR_FOUND_DUPP_UNIQUE';
	exports$1[142] = 'HA_ERR_UNKNOWN_CHARSET';
	exports$1[143] = 'HA_ERR_WRONG_MRG_TABLE_DEF';
	exports$1[144] = 'HA_ERR_CRASHED_ON_REPAIR';
	exports$1[145] = 'HA_ERR_CRASHED_ON_USAGE';
	exports$1[146] = 'HA_ERR_LOCK_WAIT_TIMEOUT';
	exports$1[147] = 'HA_ERR_LOCK_TABLE_FULL';
	exports$1[148] = 'HA_ERR_READ_ONLY_TRANSACTION';
	exports$1[149] = 'HA_ERR_LOCK_DEADLOCK';
	exports$1[150] = 'HA_ERR_CANNOT_ADD_FOREIGN';
	exports$1[151] = 'HA_ERR_NO_REFERENCED_ROW';
	exports$1[152] = 'HA_ERR_ROW_IS_REFERENCED';
	exports$1[153] = 'HA_ERR_NO_SAVEPOINT';
	exports$1[154] = 'HA_ERR_NON_UNIQUE_BLOCK_SIZE';
	exports$1[155] = 'HA_ERR_NO_SUCH_TABLE';
	exports$1[156] = 'HA_ERR_TABLE_EXIST';
	exports$1[157] = 'HA_ERR_NO_CONNECTION';
	exports$1[158] = 'HA_ERR_NULL_IN_SPATIAL';
	exports$1[159] = 'HA_ERR_TABLE_DEF_CHANGED';
	exports$1[160] = 'HA_ERR_NO_PARTITION_FOUND';
	exports$1[161] = 'HA_ERR_RBR_LOGGING_FAILED';
	exports$1[162] = 'HA_ERR_DROP_INDEX_FK';
	exports$1[163] = 'HA_ERR_FOREIGN_DUPLICATE_KEY';
	exports$1[164] = 'HA_ERR_TABLE_NEEDS_UPGRADE';
	exports$1[165] = 'HA_ERR_TABLE_READONLY';
	exports$1[166] = 'HA_ERR_AUTOINC_READ_FAILED';
	exports$1[167] = 'HA_ERR_AUTOINC_ERANGE';
	exports$1[168] = 'HA_ERR_GENERIC';
	exports$1[169] = 'HA_ERR_RECORD_IS_THE_SAME';
	exports$1[170] = 'HA_ERR_LOGGING_IMPOSSIBLE';
	exports$1[171] = 'HA_ERR_CORRUPT_EVENT';
	exports$1[172] = 'HA_ERR_NEW_FILE';
	exports$1[173] = 'HA_ERR_ROWS_EVENT_APPLY';
	exports$1[174] = 'HA_ERR_INITIALIZATION';
	exports$1[175] = 'HA_ERR_FILE_TOO_SHORT';
	exports$1[176] = 'HA_ERR_WRONG_CRC';
	exports$1[177] = 'HA_ERR_TOO_MANY_CONCURRENT_TRXS';
	exports$1[178] = 'HA_ERR_NOT_IN_LOCK_PARTITIONS';
	exports$1[179] = 'HA_ERR_INDEX_COL_TOO_LONG';
	exports$1[180] = 'HA_ERR_INDEX_CORRUPT';
	exports$1[181] = 'HA_ERR_UNDO_REC_TOO_BIG';
	exports$1[182] = 'HA_FTS_INVALID_DOCID';
	exports$1[183] = 'HA_ERR_TABLE_IN_FK_CHECK';
	exports$1[184] = 'HA_ERR_TABLESPACE_EXISTS';
	exports$1[185] = 'HA_ERR_TOO_MANY_FIELDS';
	exports$1[186] = 'HA_ERR_ROW_IN_WRONG_PARTITION';
	exports$1[187] = 'HA_ERR_INNODB_READ_ONLY';
	exports$1[188] = 'HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT';
	exports$1[189] = 'HA_ERR_TEMP_FILE_WRITE_FAILURE';
	exports$1[190] = 'HA_ERR_INNODB_FORCED_RECOVERY';
	exports$1[191] = 'HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE';
	exports$1[192] = 'HA_ERR_FK_DEPTH_EXCEEDED';
	exports$1[193] = 'HA_MISSING_CREATE_OPTION';
	exports$1[194] = 'HA_ERR_SE_OUT_OF_MEMORY';
	exports$1[195] = 'HA_ERR_TABLE_CORRUPT';
	exports$1[196] = 'HA_ERR_QUERY_INTERRUPTED';
	exports$1[197] = 'HA_ERR_TABLESPACE_MISSING';
	exports$1[198] = 'HA_ERR_TABLESPACE_IS_NOT_EMPTY';
	exports$1[199] = 'HA_ERR_WRONG_FILE_NAME';
	exports$1[200] = 'HA_ERR_NOT_ALLOWED_COMMAND';
	exports$1[201] = 'HA_ERR_COMPUTE_FAILED';
	exports$1[202] = 'HA_ERR_ROW_FORMAT_CHANGED';
	exports$1[203] = 'HA_ERR_NO_WAIT_LOCK';
	exports$1[204] = 'HA_ERR_DISK_FULL_NOWAIT';
	exports$1[205] = 'HA_ERR_NO_SESSION_TEMP';
	exports$1[206] = 'HA_ERR_WRONG_TABLE_NAME';
	exports$1[207] = 'HA_ERR_TOO_LONG_PATH';
	exports$1[208] = 'HA_ERR_SAMPLING_INIT_FAILED';
	exports$1[209] = 'HA_ERR_FTS_TOO_MANY_NESTED_EXP';
	exports$1[1000] = 'ER_HASHCHK';
	exports$1[1001] = 'ER_NISAMCHK';
	exports$1[1002] = 'ER_NO';
	exports$1[1003] = 'ER_YES';
	exports$1[1004] = 'ER_CANT_CREATE_FILE';
	exports$1[1005] = 'ER_CANT_CREATE_TABLE';
	exports$1[1006] = 'ER_CANT_CREATE_DB';
	exports$1[1007] = 'ER_DB_CREATE_EXISTS';
	exports$1[1008] = 'ER_DB_DROP_EXISTS';
	exports$1[1009] = 'ER_DB_DROP_DELETE';
	exports$1[1010] = 'ER_DB_DROP_RMDIR';
	exports$1[1011] = 'ER_CANT_DELETE_FILE';
	exports$1[1012] = 'ER_CANT_FIND_SYSTEM_REC';
	exports$1[1013] = 'ER_CANT_GET_STAT';
	exports$1[1014] = 'ER_CANT_GET_WD';
	exports$1[1015] = 'ER_CANT_LOCK';
	exports$1[1016] = 'ER_CANT_OPEN_FILE';
	exports$1[1017] = 'ER_FILE_NOT_FOUND';
	exports$1[1018] = 'ER_CANT_READ_DIR';
	exports$1[1019] = 'ER_CANT_SET_WD';
	exports$1[1020] = 'ER_CHECKREAD';
	exports$1[1021] = 'ER_DISK_FULL';
	exports$1[1022] = 'ER_DUP_KEY';
	exports$1[1023] = 'ER_ERROR_ON_CLOSE';
	exports$1[1024] = 'ER_ERROR_ON_READ';
	exports$1[1025] = 'ER_ERROR_ON_RENAME';
	exports$1[1026] = 'ER_ERROR_ON_WRITE';
	exports$1[1027] = 'ER_FILE_USED';
	exports$1[1028] = 'ER_FILSORT_ABORT';
	exports$1[1029] = 'ER_FORM_NOT_FOUND';
	exports$1[1030] = 'ER_GET_ERRNO';
	exports$1[1031] = 'ER_ILLEGAL_HA';
	exports$1[1032] = 'ER_KEY_NOT_FOUND';
	exports$1[1033] = 'ER_NOT_FORM_FILE';
	exports$1[1034] = 'ER_NOT_KEYFILE';
	exports$1[1035] = 'ER_OLD_KEYFILE';
	exports$1[1036] = 'ER_OPEN_AS_READONLY';
	exports$1[1037] = 'ER_OUTOFMEMORY';
	exports$1[1038] = 'ER_OUT_OF_SORTMEMORY';
	exports$1[1039] = 'ER_UNEXPECTED_EOF';
	exports$1[1040] = 'ER_CON_COUNT_ERROR';
	exports$1[1041] = 'ER_OUT_OF_RESOURCES';
	exports$1[1042] = 'ER_BAD_HOST_ERROR';
	exports$1[1043] = 'ER_HANDSHAKE_ERROR';
	exports$1[1044] = 'ER_DBACCESS_DENIED_ERROR';
	exports$1[1045] = 'ER_ACCESS_DENIED_ERROR';
	exports$1[1046] = 'ER_NO_DB_ERROR';
	exports$1[1047] = 'ER_UNKNOWN_COM_ERROR';
	exports$1[1048] = 'ER_BAD_NULL_ERROR';
	exports$1[1049] = 'ER_BAD_DB_ERROR';
	exports$1[1050] = 'ER_TABLE_EXISTS_ERROR';
	exports$1[1051] = 'ER_BAD_TABLE_ERROR';
	exports$1[1052] = 'ER_NON_UNIQ_ERROR';
	exports$1[1053] = 'ER_SERVER_SHUTDOWN';
	exports$1[1054] = 'ER_BAD_FIELD_ERROR';
	exports$1[1055] = 'ER_WRONG_FIELD_WITH_GROUP';
	exports$1[1056] = 'ER_WRONG_GROUP_FIELD';
	exports$1[1057] = 'ER_WRONG_SUM_SELECT';
	exports$1[1058] = 'ER_WRONG_VALUE_COUNT';
	exports$1[1059] = 'ER_TOO_LONG_IDENT';
	exports$1[1060] = 'ER_DUP_FIELDNAME';
	exports$1[1061] = 'ER_DUP_KEYNAME';
	exports$1[1062] = 'ER_DUP_ENTRY';
	exports$1[1063] = 'ER_WRONG_FIELD_SPEC';
	exports$1[1064] = 'ER_PARSE_ERROR';
	exports$1[1065] = 'ER_EMPTY_QUERY';
	exports$1[1066] = 'ER_NONUNIQ_TABLE';
	exports$1[1067] = 'ER_INVALID_DEFAULT';
	exports$1[1068] = 'ER_MULTIPLE_PRI_KEY';
	exports$1[1069] = 'ER_TOO_MANY_KEYS';
	exports$1[1070] = 'ER_TOO_MANY_KEY_PARTS';
	exports$1[1071] = 'ER_TOO_LONG_KEY';
	exports$1[1072] = 'ER_KEY_COLUMN_DOES_NOT_EXITS';
	exports$1[1073] = 'ER_BLOB_USED_AS_KEY';
	exports$1[1074] = 'ER_TOO_BIG_FIELDLENGTH';
	exports$1[1075] = 'ER_WRONG_AUTO_KEY';
	exports$1[1076] = 'ER_READY';
	exports$1[1077] = 'ER_NORMAL_SHUTDOWN';
	exports$1[1078] = 'ER_GOT_SIGNAL';
	exports$1[1079] = 'ER_SHUTDOWN_COMPLETE';
	exports$1[1080] = 'ER_FORCING_CLOSE';
	exports$1[1081] = 'ER_IPSOCK_ERROR';
	exports$1[1082] = 'ER_NO_SUCH_INDEX';
	exports$1[1083] = 'ER_WRONG_FIELD_TERMINATORS';
	exports$1[1084] = 'ER_BLOBS_AND_NO_TERMINATED';
	exports$1[1085] = 'ER_TEXTFILE_NOT_READABLE';
	exports$1[1086] = 'ER_FILE_EXISTS_ERROR';
	exports$1[1087] = 'ER_LOAD_INFO';
	exports$1[1088] = 'ER_ALTER_INFO';
	exports$1[1089] = 'ER_WRONG_SUB_KEY';
	exports$1[1090] = 'ER_CANT_REMOVE_ALL_FIELDS';
	exports$1[1091] = 'ER_CANT_DROP_FIELD_OR_KEY';
	exports$1[1092] = 'ER_INSERT_INFO';
	exports$1[1093] = 'ER_UPDATE_TABLE_USED';
	exports$1[1094] = 'ER_NO_SUCH_THREAD';
	exports$1[1095] = 'ER_KILL_DENIED_ERROR';
	exports$1[1096] = 'ER_NO_TABLES_USED';
	exports$1[1097] = 'ER_TOO_BIG_SET';
	exports$1[1098] = 'ER_NO_UNIQUE_LOGFILE';
	exports$1[1099] = 'ER_TABLE_NOT_LOCKED_FOR_WRITE';
	exports$1[1100] = 'ER_TABLE_NOT_LOCKED';
	exports$1[1101] = 'ER_BLOB_CANT_HAVE_DEFAULT';
	exports$1[1102] = 'ER_WRONG_DB_NAME';
	exports$1[1103] = 'ER_WRONG_TABLE_NAME';
	exports$1[1104] = 'ER_TOO_BIG_SELECT';
	exports$1[1105] = 'ER_UNKNOWN_ERROR';
	exports$1[1106] = 'ER_UNKNOWN_PROCEDURE';
	exports$1[1107] = 'ER_WRONG_PARAMCOUNT_TO_PROCEDURE';
	exports$1[1108] = 'ER_WRONG_PARAMETERS_TO_PROCEDURE';
	exports$1[1109] = 'ER_UNKNOWN_TABLE';
	exports$1[1110] = 'ER_FIELD_SPECIFIED_TWICE';
	exports$1[1111] = 'ER_INVALID_GROUP_FUNC_USE';
	exports$1[1112] = 'ER_UNSUPPORTED_EXTENSION';
	exports$1[1113] = 'ER_TABLE_MUST_HAVE_COLUMNS';
	exports$1[1114] = 'ER_RECORD_FILE_FULL';
	exports$1[1115] = 'ER_UNKNOWN_CHARACTER_SET';
	exports$1[1116] = 'ER_TOO_MANY_TABLES';
	exports$1[1117] = 'ER_TOO_MANY_FIELDS';
	exports$1[1118] = 'ER_TOO_BIG_ROWSIZE';
	exports$1[1119] = 'ER_STACK_OVERRUN';
	exports$1[1120] = 'ER_WRONG_OUTER_JOIN';
	exports$1[1121] = 'ER_NULL_COLUMN_IN_INDEX';
	exports$1[1122] = 'ER_CANT_FIND_UDF';
	exports$1[1123] = 'ER_CANT_INITIALIZE_UDF';
	exports$1[1124] = 'ER_UDF_NO_PATHS';
	exports$1[1125] = 'ER_UDF_EXISTS';
	exports$1[1126] = 'ER_CANT_OPEN_LIBRARY';
	exports$1[1127] = 'ER_CANT_FIND_DL_ENTRY';
	exports$1[1128] = 'ER_FUNCTION_NOT_DEFINED';
	exports$1[1129] = 'ER_HOST_IS_BLOCKED';
	exports$1[1130] = 'ER_HOST_NOT_PRIVILEGED';
	exports$1[1131] = 'ER_PASSWORD_ANONYMOUS_USER';
	exports$1[1132] = 'ER_PASSWORD_NOT_ALLOWED';
	exports$1[1133] = 'ER_PASSWORD_NO_MATCH';
	exports$1[1134] = 'ER_UPDATE_INFO';
	exports$1[1135] = 'ER_CANT_CREATE_THREAD';
	exports$1[1136] = 'ER_WRONG_VALUE_COUNT_ON_ROW';
	exports$1[1137] = 'ER_CANT_REOPEN_TABLE';
	exports$1[1138] = 'ER_INVALID_USE_OF_NULL';
	exports$1[1139] = 'ER_REGEXP_ERROR';
	exports$1[1140] = 'ER_MIX_OF_GROUP_FUNC_AND_FIELDS';
	exports$1[1141] = 'ER_NONEXISTING_GRANT';
	exports$1[1142] = 'ER_TABLEACCESS_DENIED_ERROR';
	exports$1[1143] = 'ER_COLUMNACCESS_DENIED_ERROR';
	exports$1[1144] = 'ER_ILLEGAL_GRANT_FOR_TABLE';
	exports$1[1145] = 'ER_GRANT_WRONG_HOST_OR_USER';
	exports$1[1146] = 'ER_NO_SUCH_TABLE';
	exports$1[1147] = 'ER_NONEXISTING_TABLE_GRANT';
	exports$1[1148] = 'ER_NOT_ALLOWED_COMMAND';
	exports$1[1149] = 'ER_SYNTAX_ERROR';
	exports$1[1150] = 'ER_UNUSED1';
	exports$1[1151] = 'ER_UNUSED2';
	exports$1[1152] = 'ER_ABORTING_CONNECTION';
	exports$1[1153] = 'ER_NET_PACKET_TOO_LARGE';
	exports$1[1154] = 'ER_NET_READ_ERROR_FROM_PIPE';
	exports$1[1155] = 'ER_NET_FCNTL_ERROR';
	exports$1[1156] = 'ER_NET_PACKETS_OUT_OF_ORDER';
	exports$1[1157] = 'ER_NET_UNCOMPRESS_ERROR';
	exports$1[1158] = 'ER_NET_READ_ERROR';
	exports$1[1159] = 'ER_NET_READ_INTERRUPTED';
	exports$1[1160] = 'ER_NET_ERROR_ON_WRITE';
	exports$1[1161] = 'ER_NET_WRITE_INTERRUPTED';
	exports$1[1162] = 'ER_TOO_LONG_STRING';
	exports$1[1163] = 'ER_TABLE_CANT_HANDLE_BLOB';
	exports$1[1164] = 'ER_TABLE_CANT_HANDLE_AUTO_INCREMENT';
	exports$1[1165] = 'ER_UNUSED3';
	exports$1[1166] = 'ER_WRONG_COLUMN_NAME';
	exports$1[1167] = 'ER_WRONG_KEY_COLUMN';
	exports$1[1168] = 'ER_WRONG_MRG_TABLE';
	exports$1[1169] = 'ER_DUP_UNIQUE';
	exports$1[1170] = 'ER_BLOB_KEY_WITHOUT_LENGTH';
	exports$1[1171] = 'ER_PRIMARY_CANT_HAVE_NULL';
	exports$1[1172] = 'ER_TOO_MANY_ROWS';
	exports$1[1173] = 'ER_REQUIRES_PRIMARY_KEY';
	exports$1[1174] = 'ER_NO_RAID_COMPILED';
	exports$1[1175] = 'ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE';
	exports$1[1176] = 'ER_KEY_DOES_NOT_EXITS';
	exports$1[1177] = 'ER_CHECK_NO_SUCH_TABLE';
	exports$1[1178] = 'ER_CHECK_NOT_IMPLEMENTED';
	exports$1[1179] = 'ER_CANT_DO_THIS_DURING_AN_TRANSACTION';
	exports$1[1180] = 'ER_ERROR_DURING_COMMIT';
	exports$1[1181] = 'ER_ERROR_DURING_ROLLBACK';
	exports$1[1182] = 'ER_ERROR_DURING_FLUSH_LOGS';
	exports$1[1183] = 'ER_ERROR_DURING_CHECKPOINT';
	exports$1[1184] = 'ER_NEW_ABORTING_CONNECTION';
	exports$1[1185] = 'ER_DUMP_NOT_IMPLEMENTED';
	exports$1[1186] = 'ER_FLUSH_MASTER_BINLOG_CLOSED';
	exports$1[1187] = 'ER_INDEX_REBUILD';
	exports$1[1188] = 'ER_SOURCE';
	exports$1[1189] = 'ER_SOURCE_NET_READ';
	exports$1[1190] = 'ER_SOURCE_NET_WRITE';
	exports$1[1191] = 'ER_FT_MATCHING_KEY_NOT_FOUND';
	exports$1[1192] = 'ER_LOCK_OR_ACTIVE_TRANSACTION';
	exports$1[1193] = 'ER_UNKNOWN_SYSTEM_VARIABLE';
	exports$1[1194] = 'ER_CRASHED_ON_USAGE';
	exports$1[1195] = 'ER_CRASHED_ON_REPAIR';
	exports$1[1196] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK';
	exports$1[1197] = 'ER_TRANS_CACHE_FULL';
	exports$1[1198] = 'ER_SLAVE_MUST_STOP';
	exports$1[1199] = 'ER_REPLICA_NOT_RUNNING';
	exports$1[1200] = 'ER_BAD_REPLICA';
	exports$1[1201] = 'ER_CONNECTION_METADATA';
	exports$1[1202] = 'ER_REPLICA_THREAD';
	exports$1[1203] = 'ER_TOO_MANY_USER_CONNECTIONS';
	exports$1[1204] = 'ER_SET_CONSTANTS_ONLY';
	exports$1[1205] = 'ER_LOCK_WAIT_TIMEOUT';
	exports$1[1206] = 'ER_LOCK_TABLE_FULL';
	exports$1[1207] = 'ER_READ_ONLY_TRANSACTION';
	exports$1[1208] = 'ER_DROP_DB_WITH_READ_LOCK';
	exports$1[1209] = 'ER_CREATE_DB_WITH_READ_LOCK';
	exports$1[1210] = 'ER_WRONG_ARGUMENTS';
	exports$1[1211] = 'ER_NO_PERMISSION_TO_CREATE_USER';
	exports$1[1212] = 'ER_UNION_TABLES_IN_DIFFERENT_DIR';
	exports$1[1213] = 'ER_LOCK_DEADLOCK';
	exports$1[1214] = 'ER_TABLE_CANT_HANDLE_FT';
	exports$1[1215] = 'ER_CANNOT_ADD_FOREIGN';
	exports$1[1216] = 'ER_NO_REFERENCED_ROW';
	exports$1[1217] = 'ER_ROW_IS_REFERENCED';
	exports$1[1218] = 'ER_CONNECT_TO_SOURCE';
	exports$1[1219] = 'ER_QUERY_ON_MASTER';
	exports$1[1220] = 'ER_ERROR_WHEN_EXECUTING_COMMAND';
	exports$1[1221] = 'ER_WRONG_USAGE';
	exports$1[1222] = 'ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT';
	exports$1[1223] = 'ER_CANT_UPDATE_WITH_READLOCK';
	exports$1[1224] = 'ER_MIXING_NOT_ALLOWED';
	exports$1[1225] = 'ER_DUP_ARGUMENT';
	exports$1[1226] = 'ER_USER_LIMIT_REACHED';
	exports$1[1227] = 'ER_SPECIFIC_ACCESS_DENIED_ERROR';
	exports$1[1228] = 'ER_LOCAL_VARIABLE';
	exports$1[1229] = 'ER_GLOBAL_VARIABLE';
	exports$1[1230] = 'ER_NO_DEFAULT';
	exports$1[1231] = 'ER_WRONG_VALUE_FOR_VAR';
	exports$1[1232] = 'ER_WRONG_TYPE_FOR_VAR';
	exports$1[1233] = 'ER_VAR_CANT_BE_READ';
	exports$1[1234] = 'ER_CANT_USE_OPTION_HERE';
	exports$1[1235] = 'ER_NOT_SUPPORTED_YET';
	exports$1[1236] = 'ER_SOURCE_FATAL_ERROR_READING_BINLOG';
	exports$1[1237] = 'ER_REPLICA_IGNORED_TABLE';
	exports$1[1238] = 'ER_INCORRECT_GLOBAL_LOCAL_VAR';
	exports$1[1239] = 'ER_WRONG_FK_DEF';
	exports$1[1240] = 'ER_KEY_REF_DO_NOT_MATCH_TABLE_REF';
	exports$1[1241] = 'ER_OPERAND_COLUMNS';
	exports$1[1242] = 'ER_SUBQUERY_NO_1_ROW';
	exports$1[1243] = 'ER_UNKNOWN_STMT_HANDLER';
	exports$1[1244] = 'ER_CORRUPT_HELP_DB';
	exports$1[1245] = 'ER_CYCLIC_REFERENCE';
	exports$1[1246] = 'ER_AUTO_CONVERT';
	exports$1[1247] = 'ER_ILLEGAL_REFERENCE';
	exports$1[1248] = 'ER_DERIVED_MUST_HAVE_ALIAS';
	exports$1[1249] = 'ER_SELECT_REDUCED';
	exports$1[1250] = 'ER_TABLENAME_NOT_ALLOWED_HERE';
	exports$1[1251] = 'ER_NOT_SUPPORTED_AUTH_MODE';
	exports$1[1252] = 'ER_SPATIAL_CANT_HAVE_NULL';
	exports$1[1253] = 'ER_COLLATION_CHARSET_MISMATCH';
	exports$1[1254] = 'ER_SLAVE_WAS_RUNNING';
	exports$1[1255] = 'ER_SLAVE_WAS_NOT_RUNNING';
	exports$1[1256] = 'ER_TOO_BIG_FOR_UNCOMPRESS';
	exports$1[1257] = 'ER_ZLIB_Z_MEM_ERROR';
	exports$1[1258] = 'ER_ZLIB_Z_BUF_ERROR';
	exports$1[1259] = 'ER_ZLIB_Z_DATA_ERROR';
	exports$1[1260] = 'ER_CUT_VALUE_GROUP_CONCAT';
	exports$1[1261] = 'ER_WARN_TOO_FEW_RECORDS';
	exports$1[1262] = 'ER_WARN_TOO_MANY_RECORDS';
	exports$1[1263] = 'ER_WARN_NULL_TO_NOTNULL';
	exports$1[1264] = 'ER_WARN_DATA_OUT_OF_RANGE';
	exports$1[1265] = 'WARN_DATA_TRUNCATED';
	exports$1[1266] = 'ER_WARN_USING_OTHER_HANDLER';
	exports$1[1267] = 'ER_CANT_AGGREGATE_2COLLATIONS';
	exports$1[1268] = 'ER_DROP_USER';
	exports$1[1269] = 'ER_REVOKE_GRANTS';
	exports$1[1270] = 'ER_CANT_AGGREGATE_3COLLATIONS';
	exports$1[1271] = 'ER_CANT_AGGREGATE_NCOLLATIONS';
	exports$1[1272] = 'ER_VARIABLE_IS_NOT_STRUCT';
	exports$1[1273] = 'ER_UNKNOWN_COLLATION';
	exports$1[1274] = 'ER_REPLICA_IGNORED_SSL_PARAMS';
	exports$1[1275] = 'ER_SERVER_IS_IN_SECURE_AUTH_MODE';
	exports$1[1276] = 'ER_WARN_FIELD_RESOLVED';
	exports$1[1277] = 'ER_BAD_REPLICA_UNTIL_COND';
	exports$1[1278] = 'ER_MISSING_SKIP_REPLICA';
	exports$1[1279] = 'ER_UNTIL_COND_IGNORED';
	exports$1[1280] = 'ER_WRONG_NAME_FOR_INDEX';
	exports$1[1281] = 'ER_WRONG_NAME_FOR_CATALOG';
	exports$1[1282] = 'ER_WARN_QC_RESIZE';
	exports$1[1283] = 'ER_BAD_FT_COLUMN';
	exports$1[1284] = 'ER_UNKNOWN_KEY_CACHE';
	exports$1[1285] = 'ER_WARN_HOSTNAME_WONT_WORK';
	exports$1[1286] = 'ER_UNKNOWN_STORAGE_ENGINE';
	exports$1[1287] = 'ER_WARN_DEPRECATED_SYNTAX';
	exports$1[1288] = 'ER_NON_UPDATABLE_TABLE';
	exports$1[1289] = 'ER_FEATURE_DISABLED';
	exports$1[1290] = 'ER_OPTION_PREVENTS_STATEMENT';
	exports$1[1291] = 'ER_DUPLICATED_VALUE_IN_TYPE';
	exports$1[1292] = 'ER_TRUNCATED_WRONG_VALUE';
	exports$1[1293] = 'ER_TOO_MUCH_AUTO_TIMESTAMP_COLS';
	exports$1[1294] = 'ER_INVALID_ON_UPDATE';
	exports$1[1295] = 'ER_UNSUPPORTED_PS';
	exports$1[1296] = 'ER_GET_ERRMSG';
	exports$1[1297] = 'ER_GET_TEMPORARY_ERRMSG';
	exports$1[1298] = 'ER_UNKNOWN_TIME_ZONE';
	exports$1[1299] = 'ER_WARN_INVALID_TIMESTAMP';
	exports$1[1300] = 'ER_INVALID_CHARACTER_STRING';
	exports$1[1301] = 'ER_WARN_ALLOWED_PACKET_OVERFLOWED';
	exports$1[1302] = 'ER_CONFLICTING_DECLARATIONS';
	exports$1[1303] = 'ER_SP_NO_RECURSIVE_CREATE';
	exports$1[1304] = 'ER_SP_ALREADY_EXISTS';
	exports$1[1305] = 'ER_SP_DOES_NOT_EXIST';
	exports$1[1306] = 'ER_SP_DROP_FAILED';
	exports$1[1307] = 'ER_SP_STORE_FAILED';
	exports$1[1308] = 'ER_SP_LILABEL_MISMATCH';
	exports$1[1309] = 'ER_SP_LABEL_REDEFINE';
	exports$1[1310] = 'ER_SP_LABEL_MISMATCH';
	exports$1[1311] = 'ER_SP_UNINIT_VAR';
	exports$1[1312] = 'ER_SP_BADSELECT';
	exports$1[1313] = 'ER_SP_BADRETURN';
	exports$1[1314] = 'ER_SP_BADSTATEMENT';
	exports$1[1315] = 'ER_UPDATE_LOG_DEPRECATED_IGNORED';
	exports$1[1316] = 'ER_UPDATE_LOG_DEPRECATED_TRANSLATED';
	exports$1[1317] = 'ER_QUERY_INTERRUPTED';
	exports$1[1318] = 'ER_SP_WRONG_NO_OF_ARGS';
	exports$1[1319] = 'ER_SP_COND_MISMATCH';
	exports$1[1320] = 'ER_SP_NORETURN';
	exports$1[1321] = 'ER_SP_NORETURNEND';
	exports$1[1322] = 'ER_SP_BAD_CURSOR_QUERY';
	exports$1[1323] = 'ER_SP_BAD_CURSOR_SELECT';
	exports$1[1324] = 'ER_SP_CURSOR_MISMATCH';
	exports$1[1325] = 'ER_SP_CURSOR_ALREADY_OPEN';
	exports$1[1326] = 'ER_SP_CURSOR_NOT_OPEN';
	exports$1[1327] = 'ER_SP_UNDECLARED_VAR';
	exports$1[1328] = 'ER_SP_WRONG_NO_OF_FETCH_ARGS';
	exports$1[1329] = 'ER_SP_FETCH_NO_DATA';
	exports$1[1330] = 'ER_SP_DUP_PARAM';
	exports$1[1331] = 'ER_SP_DUP_VAR';
	exports$1[1332] = 'ER_SP_DUP_COND';
	exports$1[1333] = 'ER_SP_DUP_CURS';
	exports$1[1334] = 'ER_SP_CANT_ALTER';
	exports$1[1335] = 'ER_SP_SUBSELECT_NYI';
	exports$1[1336] = 'ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG';
	exports$1[1337] = 'ER_SP_VARCOND_AFTER_CURSHNDLR';
	exports$1[1338] = 'ER_SP_CURSOR_AFTER_HANDLER';
	exports$1[1339] = 'ER_SP_CASE_NOT_FOUND';
	exports$1[1340] = 'ER_FPARSER_TOO_BIG_FILE';
	exports$1[1341] = 'ER_FPARSER_BAD_HEADER';
	exports$1[1342] = 'ER_FPARSER_EOF_IN_COMMENT';
	exports$1[1343] = 'ER_FPARSER_ERROR_IN_PARAMETER';
	exports$1[1344] = 'ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER';
	exports$1[1345] = 'ER_VIEW_NO_EXPLAIN';
	exports$1[1346] = 'ER_FRM_UNKNOWN_TYPE';
	exports$1[1347] = 'ER_WRONG_OBJECT';
	exports$1[1348] = 'ER_NONUPDATEABLE_COLUMN';
	exports$1[1349] = 'ER_VIEW_SELECT_DERIVED';
	exports$1[1350] = 'ER_VIEW_SELECT_CLAUSE';
	exports$1[1351] = 'ER_VIEW_SELECT_VARIABLE';
	exports$1[1352] = 'ER_VIEW_SELECT_TMPTABLE';
	exports$1[1353] = 'ER_VIEW_WRONG_LIST';
	exports$1[1354] = 'ER_WARN_VIEW_MERGE';
	exports$1[1355] = 'ER_WARN_VIEW_WITHOUT_KEY';
	exports$1[1356] = 'ER_VIEW_INVALID';
	exports$1[1357] = 'ER_SP_NO_DROP_SP';
	exports$1[1358] = 'ER_SP_GOTO_IN_HNDLR';
	exports$1[1359] = 'ER_TRG_ALREADY_EXISTS';
	exports$1[1360] = 'ER_TRG_DOES_NOT_EXIST';
	exports$1[1361] = 'ER_TRG_ON_VIEW_OR_TEMP_TABLE';
	exports$1[1362] = 'ER_TRG_CANT_CHANGE_ROW';
	exports$1[1363] = 'ER_TRG_NO_SUCH_ROW_IN_TRG';
	exports$1[1364] = 'ER_NO_DEFAULT_FOR_FIELD';
	exports$1[1365] = 'ER_DIVISION_BY_ZERO';
	exports$1[1366] = 'ER_TRUNCATED_WRONG_VALUE_FOR_FIELD';
	exports$1[1367] = 'ER_ILLEGAL_VALUE_FOR_TYPE';
	exports$1[1368] = 'ER_VIEW_NONUPD_CHECK';
	exports$1[1369] = 'ER_VIEW_CHECK_FAILED';
	exports$1[1370] = 'ER_PROCACCESS_DENIED_ERROR';
	exports$1[1371] = 'ER_RELAY_LOG_FAIL';
	exports$1[1372] = 'ER_PASSWD_LENGTH';
	exports$1[1373] = 'ER_UNKNOWN_TARGET_BINLOG';
	exports$1[1374] = 'ER_IO_ERR_LOG_INDEX_READ';
	exports$1[1375] = 'ER_BINLOG_PURGE_PROHIBITED';
	exports$1[1376] = 'ER_FSEEK_FAIL';
	exports$1[1377] = 'ER_BINLOG_PURGE_FATAL_ERR';
	exports$1[1378] = 'ER_LOG_IN_USE';
	exports$1[1379] = 'ER_LOG_PURGE_UNKNOWN_ERR';
	exports$1[1380] = 'ER_RELAY_LOG_INIT';
	exports$1[1381] = 'ER_NO_BINARY_LOGGING';
	exports$1[1382] = 'ER_RESERVED_SYNTAX';
	exports$1[1383] = 'ER_WSAS_FAILED';
	exports$1[1384] = 'ER_DIFF_GROUPS_PROC';
	exports$1[1385] = 'ER_NO_GROUP_FOR_PROC';
	exports$1[1386] = 'ER_ORDER_WITH_PROC';
	exports$1[1387] = 'ER_LOGGING_PROHIBIT_CHANGING_OF';
	exports$1[1388] = 'ER_NO_FILE_MAPPING';
	exports$1[1389] = 'ER_WRONG_MAGIC';
	exports$1[1390] = 'ER_PS_MANY_PARAM';
	exports$1[1391] = 'ER_KEY_PART_0';
	exports$1[1392] = 'ER_VIEW_CHECKSUM';
	exports$1[1393] = 'ER_VIEW_MULTIUPDATE';
	exports$1[1394] = 'ER_VIEW_NO_INSERT_FIELD_LIST';
	exports$1[1395] = 'ER_VIEW_DELETE_MERGE_VIEW';
	exports$1[1396] = 'ER_CANNOT_USER';
	exports$1[1397] = 'ER_XAER_NOTA';
	exports$1[1398] = 'ER_XAER_INVAL';
	exports$1[1399] = 'ER_XAER_RMFAIL';
	exports$1[1400] = 'ER_XAER_OUTSIDE';
	exports$1[1401] = 'ER_XAER_RMERR';
	exports$1[1402] = 'ER_XA_RBROLLBACK';
	exports$1[1403] = 'ER_NONEXISTING_PROC_GRANT';
	exports$1[1404] = 'ER_PROC_AUTO_GRANT_FAIL';
	exports$1[1405] = 'ER_PROC_AUTO_REVOKE_FAIL';
	exports$1[1406] = 'ER_DATA_TOO_LONG';
	exports$1[1407] = 'ER_SP_BAD_SQLSTATE';
	exports$1[1408] = 'ER_STARTUP';
	exports$1[1409] = 'ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR';
	exports$1[1410] = 'ER_CANT_CREATE_USER_WITH_GRANT';
	exports$1[1411] = 'ER_WRONG_VALUE_FOR_TYPE';
	exports$1[1412] = 'ER_TABLE_DEF_CHANGED';
	exports$1[1413] = 'ER_SP_DUP_HANDLER';
	exports$1[1414] = 'ER_SP_NOT_VAR_ARG';
	exports$1[1415] = 'ER_SP_NO_RETSET';
	exports$1[1416] = 'ER_CANT_CREATE_GEOMETRY_OBJECT';
	exports$1[1417] = 'ER_FAILED_ROUTINE_BREAK_BINLOG';
	exports$1[1418] = 'ER_BINLOG_UNSAFE_ROUTINE';
	exports$1[1419] = 'ER_BINLOG_CREATE_ROUTINE_NEED_SUPER';
	exports$1[1420] = 'ER_EXEC_STMT_WITH_OPEN_CURSOR';
	exports$1[1421] = 'ER_STMT_HAS_NO_OPEN_CURSOR';
	exports$1[1422] = 'ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG';
	exports$1[1423] = 'ER_NO_DEFAULT_FOR_VIEW_FIELD';
	exports$1[1424] = 'ER_SP_NO_RECURSION';
	exports$1[1425] = 'ER_TOO_BIG_SCALE';
	exports$1[1426] = 'ER_TOO_BIG_PRECISION';
	exports$1[1427] = 'ER_M_BIGGER_THAN_D';
	exports$1[1428] = 'ER_WRONG_LOCK_OF_SYSTEM_TABLE';
	exports$1[1429] = 'ER_CONNECT_TO_FOREIGN_DATA_SOURCE';
	exports$1[1430] = 'ER_QUERY_ON_FOREIGN_DATA_SOURCE';
	exports$1[1431] = 'ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST';
	exports$1[1432] = 'ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE';
	exports$1[1433] = 'ER_FOREIGN_DATA_STRING_INVALID';
	exports$1[1434] = 'ER_CANT_CREATE_FEDERATED_TABLE';
	exports$1[1435] = 'ER_TRG_IN_WRONG_SCHEMA';
	exports$1[1436] = 'ER_STACK_OVERRUN_NEED_MORE';
	exports$1[1437] = 'ER_TOO_LONG_BODY';
	exports$1[1438] = 'ER_WARN_CANT_DROP_DEFAULT_KEYCACHE';
	exports$1[1439] = 'ER_TOO_BIG_DISPLAYWIDTH';
	exports$1[1440] = 'ER_XAER_DUPID';
	exports$1[1441] = 'ER_DATETIME_FUNCTION_OVERFLOW';
	exports$1[1442] = 'ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG';
	exports$1[1443] = 'ER_VIEW_PREVENT_UPDATE';
	exports$1[1444] = 'ER_PS_NO_RECURSION';
	exports$1[1445] = 'ER_SP_CANT_SET_AUTOCOMMIT';
	exports$1[1446] = 'ER_MALFORMED_DEFINER';
	exports$1[1447] = 'ER_VIEW_FRM_NO_USER';
	exports$1[1448] = 'ER_VIEW_OTHER_USER';
	exports$1[1449] = 'ER_NO_SUCH_USER';
	exports$1[1450] = 'ER_FORBID_SCHEMA_CHANGE';
	exports$1[1451] = 'ER_ROW_IS_REFERENCED_2';
	exports$1[1452] = 'ER_NO_REFERENCED_ROW_2';
	exports$1[1453] = 'ER_SP_BAD_VAR_SHADOW';
	exports$1[1454] = 'ER_TRG_NO_DEFINER';
	exports$1[1455] = 'ER_OLD_FILE_FORMAT';
	exports$1[1456] = 'ER_SP_RECURSION_LIMIT';
	exports$1[1457] = 'ER_SP_PROC_TABLE_CORRUPT';
	exports$1[1458] = 'ER_SP_WRONG_NAME';
	exports$1[1459] = 'ER_TABLE_NEEDS_UPGRADE';
	exports$1[1460] = 'ER_SP_NO_AGGREGATE';
	exports$1[1461] = 'ER_MAX_PREPARED_STMT_COUNT_REACHED';
	exports$1[1462] = 'ER_VIEW_RECURSIVE';
	exports$1[1463] = 'ER_NON_GROUPING_FIELD_USED';
	exports$1[1464] = 'ER_TABLE_CANT_HANDLE_SPKEYS';
	exports$1[1465] = 'ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA';
	exports$1[1466] = 'ER_REMOVED_SPACES';
	exports$1[1467] = 'ER_AUTOINC_READ_FAILED';
	exports$1[1468] = 'ER_USERNAME';
	exports$1[1469] = 'ER_HOSTNAME';
	exports$1[1470] = 'ER_WRONG_STRING_LENGTH';
	exports$1[1471] = 'ER_NON_INSERTABLE_TABLE';
	exports$1[1472] = 'ER_ADMIN_WRONG_MRG_TABLE';
	exports$1[1473] = 'ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT';
	exports$1[1474] = 'ER_NAME_BECOMES_EMPTY';
	exports$1[1475] = 'ER_AMBIGUOUS_FIELD_TERM';
	exports$1[1476] = 'ER_FOREIGN_SERVER_EXISTS';
	exports$1[1477] = 'ER_FOREIGN_SERVER_DOESNT_EXIST';
	exports$1[1478] = 'ER_ILLEGAL_HA_CREATE_OPTION';
	exports$1[1479] = 'ER_PARTITION_REQUIRES_VALUES_ERROR';
	exports$1[1480] = 'ER_PARTITION_WRONG_VALUES_ERROR';
	exports$1[1481] = 'ER_PARTITION_MAXVALUE_ERROR';
	exports$1[1482] = 'ER_PARTITION_SUBPARTITION_ERROR';
	exports$1[1483] = 'ER_PARTITION_SUBPART_MIX_ERROR';
	exports$1[1484] = 'ER_PARTITION_WRONG_NO_PART_ERROR';
	exports$1[1485] = 'ER_PARTITION_WRONG_NO_SUBPART_ERROR';
	exports$1[1486] = 'ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR';
	exports$1[1487] = 'ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR';
	exports$1[1488] = 'ER_FIELD_NOT_FOUND_PART_ERROR';
	exports$1[1489] = 'ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR';
	exports$1[1490] = 'ER_INCONSISTENT_PARTITION_INFO_ERROR';
	exports$1[1491] = 'ER_PARTITION_FUNC_NOT_ALLOWED_ERROR';
	exports$1[1492] = 'ER_PARTITIONS_MUST_BE_DEFINED_ERROR';
	exports$1[1493] = 'ER_RANGE_NOT_INCREASING_ERROR';
	exports$1[1494] = 'ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR';
	exports$1[1495] = 'ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR';
	exports$1[1496] = 'ER_PARTITION_ENTRY_ERROR';
	exports$1[1497] = 'ER_MIX_HANDLER_ERROR';
	exports$1[1498] = 'ER_PARTITION_NOT_DEFINED_ERROR';
	exports$1[1499] = 'ER_TOO_MANY_PARTITIONS_ERROR';
	exports$1[1500] = 'ER_SUBPARTITION_ERROR';
	exports$1[1501] = 'ER_CANT_CREATE_HANDLER_FILE';
	exports$1[1502] = 'ER_BLOB_FIELD_IN_PART_FUNC_ERROR';
	exports$1[1503] = 'ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF';
	exports$1[1504] = 'ER_NO_PARTS_ERROR';
	exports$1[1505] = 'ER_PARTITION_MGMT_ON_NONPARTITIONED';
	exports$1[1506] = 'ER_FOREIGN_KEY_ON_PARTITIONED';
	exports$1[1507] = 'ER_DROP_PARTITION_NON_EXISTENT';
	exports$1[1508] = 'ER_DROP_LAST_PARTITION';
	exports$1[1509] = 'ER_COALESCE_ONLY_ON_HASH_PARTITION';
	exports$1[1510] = 'ER_REORG_HASH_ONLY_ON_SAME_NO';
	exports$1[1511] = 'ER_REORG_NO_PARAM_ERROR';
	exports$1[1512] = 'ER_ONLY_ON_RANGE_LIST_PARTITION';
	exports$1[1513] = 'ER_ADD_PARTITION_SUBPART_ERROR';
	exports$1[1514] = 'ER_ADD_PARTITION_NO_NEW_PARTITION';
	exports$1[1515] = 'ER_COALESCE_PARTITION_NO_PARTITION';
	exports$1[1516] = 'ER_REORG_PARTITION_NOT_EXIST';
	exports$1[1517] = 'ER_SAME_NAME_PARTITION';
	exports$1[1518] = 'ER_NO_BINLOG_ERROR';
	exports$1[1519] = 'ER_CONSECUTIVE_REORG_PARTITIONS';
	exports$1[1520] = 'ER_REORG_OUTSIDE_RANGE';
	exports$1[1521] = 'ER_PARTITION_FUNCTION_FAILURE';
	exports$1[1522] = 'ER_PART_STATE_ERROR';
	exports$1[1523] = 'ER_LIMITED_PART_RANGE';
	exports$1[1524] = 'ER_PLUGIN_IS_NOT_LOADED';
	exports$1[1525] = 'ER_WRONG_VALUE';
	exports$1[1526] = 'ER_NO_PARTITION_FOR_GIVEN_VALUE';
	exports$1[1527] = 'ER_FILEGROUP_OPTION_ONLY_ONCE';
	exports$1[1528] = 'ER_CREATE_FILEGROUP_FAILED';
	exports$1[1529] = 'ER_DROP_FILEGROUP_FAILED';
	exports$1[1530] = 'ER_TABLESPACE_AUTO_EXTEND_ERROR';
	exports$1[1531] = 'ER_WRONG_SIZE_NUMBER';
	exports$1[1532] = 'ER_SIZE_OVERFLOW_ERROR';
	exports$1[1533] = 'ER_ALTER_FILEGROUP_FAILED';
	exports$1[1534] = 'ER_BINLOG_ROW_LOGGING_FAILED';
	exports$1[1535] = 'ER_BINLOG_ROW_WRONG_TABLE_DEF';
	exports$1[1536] = 'ER_BINLOG_ROW_RBR_TO_SBR';
	exports$1[1537] = 'ER_EVENT_ALREADY_EXISTS';
	exports$1[1538] = 'ER_EVENT_STORE_FAILED';
	exports$1[1539] = 'ER_EVENT_DOES_NOT_EXIST';
	exports$1[1540] = 'ER_EVENT_CANT_ALTER';
	exports$1[1541] = 'ER_EVENT_DROP_FAILED';
	exports$1[1542] = 'ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG';
	exports$1[1543] = 'ER_EVENT_ENDS_BEFORE_STARTS';
	exports$1[1544] = 'ER_EVENT_EXEC_TIME_IN_THE_PAST';
	exports$1[1545] = 'ER_EVENT_OPEN_TABLE_FAILED';
	exports$1[1546] = 'ER_EVENT_NEITHER_M_EXPR_NOR_M_AT';
	exports$1[1547] = 'ER_COL_COUNT_DOESNT_MATCH_CORRUPTED';
	exports$1[1548] = 'ER_CANNOT_LOAD_FROM_TABLE';
	exports$1[1549] = 'ER_EVENT_CANNOT_DELETE';
	exports$1[1550] = 'ER_EVENT_COMPILE_ERROR';
	exports$1[1551] = 'ER_EVENT_SAME_NAME';
	exports$1[1552] = 'ER_EVENT_DATA_TOO_LONG';
	exports$1[1553] = 'ER_DROP_INDEX_FK';
	exports$1[1554] = 'ER_WARN_DEPRECATED_SYNTAX_WITH_VER';
	exports$1[1555] = 'ER_CANT_WRITE_LOCK_LOG_TABLE';
	exports$1[1556] = 'ER_CANT_LOCK_LOG_TABLE';
	exports$1[1557] = 'ER_FOREIGN_DUPLICATE_KEY';
	exports$1[1558] = 'ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE';
	exports$1[1559] = 'ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR';
	exports$1[1560] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT';
	exports$1[1561] = 'ER_NDB_CANT_SWITCH_BINLOG_FORMAT';
	exports$1[1562] = 'ER_PARTITION_NO_TEMPORARY';
	exports$1[1563] = 'ER_PARTITION_CONST_DOMAIN_ERROR';
	exports$1[1564] = 'ER_PARTITION_FUNCTION_IS_NOT_ALLOWED';
	exports$1[1565] = 'ER_DDL_LOG_ERROR';
	exports$1[1566] = 'ER_NULL_IN_VALUES_LESS_THAN';
	exports$1[1567] = 'ER_WRONG_PARTITION_NAME';
	exports$1[1568] = 'ER_CANT_CHANGE_TX_CHARACTERISTICS';
	exports$1[1569] = 'ER_DUP_ENTRY_AUTOINCREMENT_CASE';
	exports$1[1570] = 'ER_EVENT_MODIFY_QUEUE_ERROR';
	exports$1[1571] = 'ER_EVENT_SET_VAR_ERROR';
	exports$1[1572] = 'ER_PARTITION_MERGE_ERROR';
	exports$1[1573] = 'ER_CANT_ACTIVATE_LOG';
	exports$1[1574] = 'ER_RBR_NOT_AVAILABLE';
	exports$1[1575] = 'ER_BASE64_DECODE_ERROR';
	exports$1[1576] = 'ER_EVENT_RECURSION_FORBIDDEN';
	exports$1[1577] = 'ER_EVENTS_DB_ERROR';
	exports$1[1578] = 'ER_ONLY_INTEGERS_ALLOWED';
	exports$1[1579] = 'ER_UNSUPORTED_LOG_ENGINE';
	exports$1[1580] = 'ER_BAD_LOG_STATEMENT';
	exports$1[1581] = 'ER_CANT_RENAME_LOG_TABLE';
	exports$1[1582] = 'ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT';
	exports$1[1583] = 'ER_WRONG_PARAMETERS_TO_NATIVE_FCT';
	exports$1[1584] = 'ER_WRONG_PARAMETERS_TO_STORED_FCT';
	exports$1[1585] = 'ER_NATIVE_FCT_NAME_COLLISION';
	exports$1[1586] = 'ER_DUP_ENTRY_WITH_KEY_NAME';
	exports$1[1587] = 'ER_BINLOG_PURGE_EMFILE';
	exports$1[1588] = 'ER_EVENT_CANNOT_CREATE_IN_THE_PAST';
	exports$1[1589] = 'ER_EVENT_CANNOT_ALTER_IN_THE_PAST';
	exports$1[1590] = 'ER_SLAVE_INCIDENT';
	exports$1[1591] = 'ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT';
	exports$1[1592] = 'ER_BINLOG_UNSAFE_STATEMENT';
	exports$1[1593] = 'ER_BINLOG_FATAL_ERROR';
	exports$1[1594] = 'ER_SLAVE_RELAY_LOG_READ_FAILURE';
	exports$1[1595] = 'ER_SLAVE_RELAY_LOG_WRITE_FAILURE';
	exports$1[1596] = 'ER_SLAVE_CREATE_EVENT_FAILURE';
	exports$1[1597] = 'ER_SLAVE_MASTER_COM_FAILURE';
	exports$1[1598] = 'ER_BINLOG_LOGGING_IMPOSSIBLE';
	exports$1[1599] = 'ER_VIEW_NO_CREATION_CTX';
	exports$1[1600] = 'ER_VIEW_INVALID_CREATION_CTX';
	exports$1[1601] = 'ER_SR_INVALID_CREATION_CTX';
	exports$1[1602] = 'ER_TRG_CORRUPTED_FILE';
	exports$1[1603] = 'ER_TRG_NO_CREATION_CTX';
	exports$1[1604] = 'ER_TRG_INVALID_CREATION_CTX';
	exports$1[1605] = 'ER_EVENT_INVALID_CREATION_CTX';
	exports$1[1606] = 'ER_TRG_CANT_OPEN_TABLE';
	exports$1[1607] = 'ER_CANT_CREATE_SROUTINE';
	exports$1[1608] = 'ER_NEVER_USED';
	exports$1[1609] = 'ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT';
	exports$1[1610] = 'ER_REPLICA_CORRUPT_EVENT';
	exports$1[1611] = 'ER_LOAD_DATA_INVALID_COLUMN';
	exports$1[1612] = 'ER_LOG_PURGE_NO_FILE';
	exports$1[1613] = 'ER_XA_RBTIMEOUT';
	exports$1[1614] = 'ER_XA_RBDEADLOCK';
	exports$1[1615] = 'ER_NEED_REPREPARE';
	exports$1[1616] = 'ER_DELAYED_NOT_SUPPORTED';
	exports$1[1617] = 'WARN_NO_CONNECTION_METADATA';
	exports$1[1618] = 'WARN_OPTION_IGNORED';
	exports$1[1619] = 'ER_PLUGIN_DELETE_BUILTIN';
	exports$1[1620] = 'WARN_PLUGIN_BUSY';
	exports$1[1621] = 'ER_VARIABLE_IS_READONLY';
	exports$1[1622] = 'ER_WARN_ENGINE_TRANSACTION_ROLLBACK';
	exports$1[1623] = 'ER_SLAVE_HEARTBEAT_FAILURE';
	exports$1[1624] = 'ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE';
	exports$1[1625] = 'ER_NDB_REPLICATION_SCHEMA_ERROR';
	exports$1[1626] = 'ER_CONFLICT_FN_PARSE_ERROR';
	exports$1[1627] = 'ER_EXCEPTIONS_WRITE_ERROR';
	exports$1[1628] = 'ER_TOO_LONG_TABLE_COMMENT';
	exports$1[1629] = 'ER_TOO_LONG_FIELD_COMMENT';
	exports$1[1630] = 'ER_FUNC_INEXISTENT_NAME_COLLISION';
	exports$1[1631] = 'ER_DATABASE_NAME';
	exports$1[1632] = 'ER_TABLE_NAME';
	exports$1[1633] = 'ER_PARTITION_NAME';
	exports$1[1634] = 'ER_SUBPARTITION_NAME';
	exports$1[1635] = 'ER_TEMPORARY_NAME';
	exports$1[1636] = 'ER_RENAMED_NAME';
	exports$1[1637] = 'ER_TOO_MANY_CONCURRENT_TRXS';
	exports$1[1638] = 'WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED';
	exports$1[1639] = 'ER_DEBUG_SYNC_TIMEOUT';
	exports$1[1640] = 'ER_DEBUG_SYNC_HIT_LIMIT';
	exports$1[1641] = 'ER_DUP_SIGNAL_SET';
	exports$1[1642] = 'ER_SIGNAL_WARN';
	exports$1[1643] = 'ER_SIGNAL_NOT_FOUND';
	exports$1[1644] = 'ER_SIGNAL_EXCEPTION';
	exports$1[1645] = 'ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER';
	exports$1[1646] = 'ER_SIGNAL_BAD_CONDITION_TYPE';
	exports$1[1647] = 'WARN_COND_ITEM_TRUNCATED';
	exports$1[1648] = 'ER_COND_ITEM_TOO_LONG';
	exports$1[1649] = 'ER_UNKNOWN_LOCALE';
	exports$1[1650] = 'ER_REPLICA_IGNORE_SERVER_IDS';
	exports$1[1651] = 'ER_QUERY_CACHE_DISABLED';
	exports$1[1652] = 'ER_SAME_NAME_PARTITION_FIELD';
	exports$1[1653] = 'ER_PARTITION_COLUMN_LIST_ERROR';
	exports$1[1654] = 'ER_WRONG_TYPE_COLUMN_VALUE_ERROR';
	exports$1[1655] = 'ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR';
	exports$1[1656] = 'ER_MAXVALUE_IN_VALUES_IN';
	exports$1[1657] = 'ER_TOO_MANY_VALUES_ERROR';
	exports$1[1658] = 'ER_ROW_SINGLE_PARTITION_FIELD_ERROR';
	exports$1[1659] = 'ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD';
	exports$1[1660] = 'ER_PARTITION_FIELDS_TOO_LONG';
	exports$1[1661] = 'ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE';
	exports$1[1662] = 'ER_BINLOG_ROW_MODE_AND_STMT_ENGINE';
	exports$1[1663] = 'ER_BINLOG_UNSAFE_AND_STMT_ENGINE';
	exports$1[1664] = 'ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE';
	exports$1[1665] = 'ER_BINLOG_STMT_MODE_AND_ROW_ENGINE';
	exports$1[1666] = 'ER_BINLOG_ROW_INJECTION_AND_STMT_MODE';
	exports$1[1667] = 'ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE';
	exports$1[1668] = 'ER_BINLOG_UNSAFE_LIMIT';
	exports$1[1669] = 'ER_UNUSED4';
	exports$1[1670] = 'ER_BINLOG_UNSAFE_SYSTEM_TABLE';
	exports$1[1671] = 'ER_BINLOG_UNSAFE_AUTOINC_COLUMNS';
	exports$1[1672] = 'ER_BINLOG_UNSAFE_UDF';
	exports$1[1673] = 'ER_BINLOG_UNSAFE_SYSTEM_VARIABLE';
	exports$1[1674] = 'ER_BINLOG_UNSAFE_SYSTEM_FUNCTION';
	exports$1[1675] = 'ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS';
	exports$1[1676] = 'ER_MESSAGE_AND_STATEMENT';
	exports$1[1677] = 'ER_SLAVE_CONVERSION_FAILED';
	exports$1[1678] = 'ER_REPLICA_CANT_CREATE_CONVERSION';
	exports$1[1679] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT';
	exports$1[1680] = 'ER_PATH_LENGTH';
	exports$1[1681] = 'ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT';
	exports$1[1682] = 'ER_WRONG_NATIVE_TABLE_STRUCTURE';
	exports$1[1683] = 'ER_WRONG_PERFSCHEMA_USAGE';
	exports$1[1684] = 'ER_WARN_I_S_SKIPPED_TABLE';
	exports$1[1685] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT';
	exports$1[1686] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT';
	exports$1[1687] = 'ER_SPATIAL_MUST_HAVE_GEOM_COL';
	exports$1[1688] = 'ER_TOO_LONG_INDEX_COMMENT';
	exports$1[1689] = 'ER_LOCK_ABORTED';
	exports$1[1690] = 'ER_DATA_OUT_OF_RANGE';
	exports$1[1691] = 'ER_WRONG_SPVAR_TYPE_IN_LIMIT';
	exports$1[1692] = 'ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE';
	exports$1[1693] = 'ER_BINLOG_UNSAFE_MIXED_STATEMENT';
	exports$1[1694] = 'ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN';
	exports$1[1695] = 'ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN';
	exports$1[1696] = 'ER_FAILED_READ_FROM_PAR_FILE';
	exports$1[1697] = 'ER_VALUES_IS_NOT_INT_TYPE_ERROR';
	exports$1[1698] = 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR';
	exports$1[1699] = 'ER_SET_PASSWORD_AUTH_PLUGIN';
	exports$1[1700] = 'ER_GRANT_PLUGIN_USER_EXISTS';
	exports$1[1701] = 'ER_TRUNCATE_ILLEGAL_FK';
	exports$1[1702] = 'ER_PLUGIN_IS_PERMANENT';
	exports$1[1703] = 'ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN';
	exports$1[1704] = 'ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX';
	exports$1[1705] = 'ER_STMT_CACHE_FULL';
	exports$1[1706] = 'ER_MULTI_UPDATE_KEY_CONFLICT';
	exports$1[1707] = 'ER_TABLE_NEEDS_REBUILD';
	exports$1[1708] = 'WARN_OPTION_BELOW_LIMIT';
	exports$1[1709] = 'ER_INDEX_COLUMN_TOO_LONG';
	exports$1[1710] = 'ER_ERROR_IN_TRIGGER_BODY';
	exports$1[1711] = 'ER_ERROR_IN_UNKNOWN_TRIGGER_BODY';
	exports$1[1712] = 'ER_INDEX_CORRUPT';
	exports$1[1713] = 'ER_UNDO_RECORD_TOO_BIG';
	exports$1[1714] = 'ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT';
	exports$1[1715] = 'ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE';
	exports$1[1716] = 'ER_BINLOG_UNSAFE_REPLACE_SELECT';
	exports$1[1717] = 'ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT';
	exports$1[1718] = 'ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT';
	exports$1[1719] = 'ER_BINLOG_UNSAFE_UPDATE_IGNORE';
	exports$1[1720] = 'ER_PLUGIN_NO_UNINSTALL';
	exports$1[1721] = 'ER_PLUGIN_NO_INSTALL';
	exports$1[1722] = 'ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT';
	exports$1[1723] = 'ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC';
	exports$1[1724] = 'ER_BINLOG_UNSAFE_INSERT_TWO_KEYS';
	exports$1[1725] = 'ER_TABLE_IN_FK_CHECK';
	exports$1[1726] = 'ER_UNSUPPORTED_ENGINE';
	exports$1[1727] = 'ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST';
	exports$1[1728] = 'ER_CANNOT_LOAD_FROM_TABLE_V2';
	exports$1[1729] = 'ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE';
	exports$1[1730] = 'ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT';
	exports$1[1731] = 'ER_PARTITION_EXCHANGE_DIFFERENT_OPTION';
	exports$1[1732] = 'ER_PARTITION_EXCHANGE_PART_TABLE';
	exports$1[1733] = 'ER_PARTITION_EXCHANGE_TEMP_TABLE';
	exports$1[1734] = 'ER_PARTITION_INSTEAD_OF_SUBPARTITION';
	exports$1[1735] = 'ER_UNKNOWN_PARTITION';
	exports$1[1736] = 'ER_TABLES_DIFFERENT_METADATA';
	exports$1[1737] = 'ER_ROW_DOES_NOT_MATCH_PARTITION';
	exports$1[1738] = 'ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX';
	exports$1[1739] = 'ER_WARN_INDEX_NOT_APPLICABLE';
	exports$1[1740] = 'ER_PARTITION_EXCHANGE_FOREIGN_KEY';
	exports$1[1741] = 'ER_NO_SUCH_KEY_VALUE';
	exports$1[1742] = 'ER_RPL_INFO_DATA_TOO_LONG';
	exports$1[1743] = 'ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE';
	exports$1[1744] = 'ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE';
	exports$1[1745] = 'ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX';
	exports$1[1746] = 'ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT';
	exports$1[1747] = 'ER_PARTITION_CLAUSE_ON_NONPARTITIONED';
	exports$1[1748] = 'ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET';
	exports$1[1749] = 'ER_NO_SUCH_PARTITION';
	exports$1[1750] = 'ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE';
	exports$1[1751] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE';
	exports$1[1752] = 'ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE';
	exports$1[1753] = 'ER_MTA_FEATURE_IS_NOT_SUPPORTED';
	exports$1[1754] = 'ER_MTA_UPDATED_DBS_GREATER_MAX';
	exports$1[1755] = 'ER_MTA_CANT_PARALLEL';
	exports$1[1756] = 'ER_MTA_INCONSISTENT_DATA';
	exports$1[1757] = 'ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING';
	exports$1[1758] = 'ER_DA_INVALID_CONDITION_NUMBER';
	exports$1[1759] = 'ER_INSECURE_PLAIN_TEXT';
	exports$1[1760] = 'ER_INSECURE_CHANGE_SOURCE';
	exports$1[1761] = 'ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO';
	exports$1[1762] = 'ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO';
	exports$1[1763] = 'ER_SQLTHREAD_WITH_SECURE_REPLICA';
	exports$1[1764] = 'ER_TABLE_HAS_NO_FT';
	exports$1[1765] = 'ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER';
	exports$1[1766] = 'ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION';
	exports$1[1767] = 'ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST';
	exports$1[1768] = 'ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION';
	exports$1[1769] = 'ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION';
	exports$1[1770] = 'ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL';
	exports$1[1771] = 'ER_SKIPPING_LOGGED_TRANSACTION';
	exports$1[1772] = 'ER_MALFORMED_GTID_SET_SPECIFICATION';
	exports$1[1773] = 'ER_MALFORMED_GTID_SET_ENCODING';
	exports$1[1774] = 'ER_MALFORMED_GTID_SPECIFICATION';
	exports$1[1775] = 'ER_GNO_EXHAUSTED';
	exports$1[1776] = 'ER_BAD_REPLICA_AUTO_POSITION';
	exports$1[1777] = 'ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF';
	exports$1[1778] = 'ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET';
	exports$1[1779] = 'ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON';
	exports$1[1780] = 'ER_GTID_MODE_REQUIRES_BINLOG';
	exports$1[1781] = 'ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF';
	exports$1[1782] = 'ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON';
	exports$1[1783] = 'ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF';
	exports$1[1784] = 'ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF';
	exports$1[1785] = 'ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE';
	exports$1[1786] = 'ER_GTID_UNSAFE_CREATE_SELECT';
	exports$1[1787] = 'ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION';
	exports$1[1788] = 'ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME';
	exports$1[1789] = 'ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS';
	exports$1[1790] = 'ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID';
	exports$1[1791] = 'ER_UNKNOWN_EXPLAIN_FORMAT';
	exports$1[1792] = 'ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION';
	exports$1[1793] = 'ER_TOO_LONG_TABLE_PARTITION_COMMENT';
	exports$1[1794] = 'ER_REPLICA_CONFIGURATION';
	exports$1[1795] = 'ER_INNODB_FT_LIMIT';
	exports$1[1796] = 'ER_INNODB_NO_FT_TEMP_TABLE';
	exports$1[1797] = 'ER_INNODB_FT_WRONG_DOCID_COLUMN';
	exports$1[1798] = 'ER_INNODB_FT_WRONG_DOCID_INDEX';
	exports$1[1799] = 'ER_INNODB_ONLINE_LOG_TOO_BIG';
	exports$1[1800] = 'ER_UNKNOWN_ALTER_ALGORITHM';
	exports$1[1801] = 'ER_UNKNOWN_ALTER_LOCK';
	exports$1[1802] = 'ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS';
	exports$1[1803] = 'ER_MTA_RECOVERY_FAILURE';
	exports$1[1804] = 'ER_MTA_RESET_WORKERS';
	exports$1[1805] = 'ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2';
	exports$1[1806] = 'ER_REPLICA_SILENT_RETRY_TRANSACTION';
	exports$1[1807] = 'ER_DISCARD_FK_CHECKS_RUNNING';
	exports$1[1808] = 'ER_TABLE_SCHEMA_MISMATCH';
	exports$1[1809] = 'ER_TABLE_IN_SYSTEM_TABLESPACE';
	exports$1[1810] = 'ER_IO_READ_ERROR';
	exports$1[1811] = 'ER_IO_WRITE_ERROR';
	exports$1[1812] = 'ER_TABLESPACE_MISSING';
	exports$1[1813] = 'ER_TABLESPACE_EXISTS';
	exports$1[1814] = 'ER_TABLESPACE_DISCARDED';
	exports$1[1815] = 'ER_INTERNAL_ERROR';
	exports$1[1816] = 'ER_INNODB_IMPORT_ERROR';
	exports$1[1817] = 'ER_INNODB_INDEX_CORRUPT';
	exports$1[1818] = 'ER_INVALID_YEAR_COLUMN_LENGTH';
	exports$1[1819] = 'ER_NOT_VALID_PASSWORD';
	exports$1[1820] = 'ER_MUST_CHANGE_PASSWORD';
	exports$1[1821] = 'ER_FK_NO_INDEX_CHILD';
	exports$1[1822] = 'ER_FK_NO_INDEX_PARENT';
	exports$1[1823] = 'ER_FK_FAIL_ADD_SYSTEM';
	exports$1[1824] = 'ER_FK_CANNOT_OPEN_PARENT';
	exports$1[1825] = 'ER_FK_INCORRECT_OPTION';
	exports$1[1826] = 'ER_FK_DUP_NAME';
	exports$1[1827] = 'ER_PASSWORD_FORMAT';
	exports$1[1828] = 'ER_FK_COLUMN_CANNOT_DROP';
	exports$1[1829] = 'ER_FK_COLUMN_CANNOT_DROP_CHILD';
	exports$1[1830] = 'ER_FK_COLUMN_NOT_NULL';
	exports$1[1831] = 'ER_DUP_INDEX';
	exports$1[1832] = 'ER_FK_COLUMN_CANNOT_CHANGE';
	exports$1[1833] = 'ER_FK_COLUMN_CANNOT_CHANGE_CHILD';
	exports$1[1834] = 'ER_UNUSED5';
	exports$1[1835] = 'ER_MALFORMED_PACKET';
	exports$1[1836] = 'ER_READ_ONLY_MODE';
	exports$1[1837] = 'ER_GTID_NEXT_TYPE_UNDEFINED_GTID';
	exports$1[1838] = 'ER_VARIABLE_NOT_SETTABLE_IN_SP';
	exports$1[1839] = 'ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF';
	exports$1[1840] = 'ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY';
	exports$1[1841] = 'ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY';
	exports$1[1842] = 'ER_GTID_PURGED_WAS_CHANGED';
	exports$1[1843] = 'ER_GTID_EXECUTED_WAS_CHANGED';
	exports$1[1844] = 'ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES';
	exports$1[1845] = 'ER_ALTER_OPERATION_NOT_SUPPORTED';
	exports$1[1846] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON';
	exports$1[1847] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY';
	exports$1[1848] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION';
	exports$1[1849] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME';
	exports$1[1850] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE';
	exports$1[1851] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK';
	exports$1[1852] = 'ER_UNUSED6';
	exports$1[1853] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK';
	exports$1[1854] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC';
	exports$1[1855] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS';
	exports$1[1856] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS';
	exports$1[1857] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS';
	exports$1[1858] = 'ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE';
	exports$1[1859] = 'ER_DUP_UNKNOWN_IN_INDEX';
	exports$1[1860] = 'ER_IDENT_CAUSES_TOO_LONG_PATH';
	exports$1[1861] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL';
	exports$1[1862] = 'ER_MUST_CHANGE_PASSWORD_LOGIN';
	exports$1[1863] = 'ER_ROW_IN_WRONG_PARTITION';
	exports$1[1864] = 'ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX';
	exports$1[1865] = 'ER_INNODB_NO_FT_USES_PARSER';
	exports$1[1866] = 'ER_BINLOG_LOGICAL_CORRUPTION';
	exports$1[1867] = 'ER_WARN_PURGE_LOG_IN_USE';
	exports$1[1868] = 'ER_WARN_PURGE_LOG_IS_ACTIVE';
	exports$1[1869] = 'ER_AUTO_INCREMENT_CONFLICT';
	exports$1[1870] = 'WARN_ON_BLOCKHOLE_IN_RBR';
	exports$1[1871] = 'ER_REPLICA_CM_INIT_REPOSITORY';
	exports$1[1872] = 'ER_REPLICA_AM_INIT_REPOSITORY';
	exports$1[1873] = 'ER_ACCESS_DENIED_CHANGE_USER_ERROR';
	exports$1[1874] = 'ER_INNODB_READ_ONLY';
	exports$1[1875] = 'ER_STOP_REPLICA_SQL_THREAD_TIMEOUT';
	exports$1[1876] = 'ER_STOP_REPLICA_IO_THREAD_TIMEOUT';
	exports$1[1877] = 'ER_TABLE_CORRUPT';
	exports$1[1878] = 'ER_TEMP_FILE_WRITE_FAILURE';
	exports$1[1879] = 'ER_INNODB_FT_AUX_NOT_HEX_ID';
	exports$1[1880] = 'ER_OLD_TEMPORALS_UPGRADED';
	exports$1[1881] = 'ER_INNODB_FORCED_RECOVERY';
	exports$1[1882] = 'ER_AES_INVALID_IV';
	exports$1[1883] = 'ER_PLUGIN_CANNOT_BE_UNINSTALLED';
	exports$1[1884] = 'ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID';
	exports$1[1885] = 'ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE';
	exports$1[1886] = 'ER_MISSING_KEY';
	exports$1[1887] = 'WARN_NAMED_PIPE_ACCESS_EVERYONE';
	exports$1[3000] = 'ER_FILE_CORRUPT';
	exports$1[3001] = 'ER_ERROR_ON_SOURCE';
	exports$1[3002] = 'ER_INCONSISTENT_ERROR';
	exports$1[3003] = 'ER_STORAGE_ENGINE_NOT_LOADED';
	exports$1[3004] = 'ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER';
	exports$1[3005] = 'ER_WARN_LEGACY_SYNTAX_CONVERTED';
	exports$1[3006] = 'ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN';
	exports$1[3007] = 'ER_CANNOT_DISCARD_TEMPORARY_TABLE';
	exports$1[3008] = 'ER_FK_DEPTH_EXCEEDED';
	exports$1[3009] = 'ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2';
	exports$1[3010] = 'ER_WARN_TRIGGER_DOESNT_HAVE_CREATED';
	exports$1[3011] = 'ER_REFERENCED_TRG_DOES_NOT_EXIST';
	exports$1[3012] = 'ER_EXPLAIN_NOT_SUPPORTED';
	exports$1[3013] = 'ER_INVALID_FIELD_SIZE';
	exports$1[3014] = 'ER_MISSING_HA_CREATE_OPTION';
	exports$1[3015] = 'ER_ENGINE_OUT_OF_MEMORY';
	exports$1[3016] = 'ER_PASSWORD_EXPIRE_ANONYMOUS_USER';
	exports$1[3017] = 'ER_REPLICA_SQL_THREAD_MUST_STOP';
	exports$1[3018] = 'ER_NO_FT_MATERIALIZED_SUBQUERY';
	exports$1[3019] = 'ER_INNODB_UNDO_LOG_FULL';
	exports$1[3020] = 'ER_INVALID_ARGUMENT_FOR_LOGARITHM';
	exports$1[3021] = 'ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP';
	exports$1[3022] = 'ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO';
	exports$1[3023] = 'ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS';
	exports$1[3024] = 'ER_QUERY_TIMEOUT';
	exports$1[3025] = 'ER_NON_RO_SELECT_DISABLE_TIMER';
	exports$1[3026] = 'ER_DUP_LIST_ENTRY';
	exports$1[3027] = 'ER_SQL_MODE_NO_EFFECT';
	exports$1[3028] = 'ER_AGGREGATE_ORDER_FOR_UNION';
	exports$1[3029] = 'ER_AGGREGATE_ORDER_NON_AGG_QUERY';
	exports$1[3030] = 'ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR';
	exports$1[3031] = 'ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER';
	exports$1[3032] = 'ER_SERVER_OFFLINE_MODE';
	exports$1[3033] = 'ER_GIS_DIFFERENT_SRIDS';
	exports$1[3034] = 'ER_GIS_UNSUPPORTED_ARGUMENT';
	exports$1[3035] = 'ER_GIS_UNKNOWN_ERROR';
	exports$1[3036] = 'ER_GIS_UNKNOWN_EXCEPTION';
	exports$1[3037] = 'ER_GIS_INVALID_DATA';
	exports$1[3038] = 'ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION';
	exports$1[3039] = 'ER_BOOST_GEOMETRY_CENTROID_EXCEPTION';
	exports$1[3040] = 'ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION';
	exports$1[3041] = 'ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION';
	exports$1[3042] = 'ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION';
	exports$1[3043] = 'ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION';
	exports$1[3044] = 'ER_STD_BAD_ALLOC_ERROR';
	exports$1[3045] = 'ER_STD_DOMAIN_ERROR';
	exports$1[3046] = 'ER_STD_LENGTH_ERROR';
	exports$1[3047] = 'ER_STD_INVALID_ARGUMENT';
	exports$1[3048] = 'ER_STD_OUT_OF_RANGE_ERROR';
	exports$1[3049] = 'ER_STD_OVERFLOW_ERROR';
	exports$1[3050] = 'ER_STD_RANGE_ERROR';
	exports$1[3051] = 'ER_STD_UNDERFLOW_ERROR';
	exports$1[3052] = 'ER_STD_LOGIC_ERROR';
	exports$1[3053] = 'ER_STD_RUNTIME_ERROR';
	exports$1[3054] = 'ER_STD_UNKNOWN_EXCEPTION';
	exports$1[3055] = 'ER_GIS_DATA_WRONG_ENDIANESS';
	exports$1[3056] = 'ER_CHANGE_SOURCE_PASSWORD_LENGTH';
	exports$1[3057] = 'ER_USER_LOCK_WRONG_NAME';
	exports$1[3058] = 'ER_USER_LOCK_DEADLOCK';
	exports$1[3059] = 'ER_REPLACE_INACCESSIBLE_ROWS';
	exports$1[3060] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS';
	exports$1[3061] = 'ER_ILLEGAL_USER_VAR';
	exports$1[3062] = 'ER_GTID_MODE_OFF';
	exports$1[3063] = 'ER_UNSUPPORTED_BY_REPLICATION_THREAD';
	exports$1[3064] = 'ER_INCORRECT_TYPE';
	exports$1[3065] = 'ER_FIELD_IN_ORDER_NOT_SELECT';
	exports$1[3066] = 'ER_AGGREGATE_IN_ORDER_NOT_SELECT';
	exports$1[3067] = 'ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN';
	exports$1[3068] = 'ER_NET_OK_PACKET_TOO_LARGE';
	exports$1[3069] = 'ER_INVALID_JSON_DATA';
	exports$1[3070] = 'ER_INVALID_GEOJSON_MISSING_MEMBER';
	exports$1[3071] = 'ER_INVALID_GEOJSON_WRONG_TYPE';
	exports$1[3072] = 'ER_INVALID_GEOJSON_UNSPECIFIED';
	exports$1[3073] = 'ER_DIMENSION_UNSUPPORTED';
	exports$1[3074] = 'ER_REPLICA_CHANNEL_DOES_NOT_EXIST';
	exports$1[3075] = 'ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT';
	exports$1[3076] = 'ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG';
	exports$1[3077] = 'ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY';
	exports$1[3078] = 'ER_SLAVE_CHANNEL_DELETE';
	exports$1[3079] = 'ER_REPLICA_MULTIPLE_CHANNELS_CMD';
	exports$1[3080] = 'ER_REPLICA_MAX_CHANNELS_EXCEEDED';
	exports$1[3081] = 'ER_REPLICA_CHANNEL_MUST_STOP';
	exports$1[3082] = 'ER_REPLICA_CHANNEL_NOT_RUNNING';
	exports$1[3083] = 'ER_REPLICA_CHANNEL_WAS_RUNNING';
	exports$1[3084] = 'ER_REPLICA_CHANNEL_WAS_NOT_RUNNING';
	exports$1[3085] = 'ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP';
	exports$1[3086] = 'ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER';
	exports$1[3087] = 'ER_WRONG_FIELD_WITH_GROUP_V2';
	exports$1[3088] = 'ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2';
	exports$1[3089] = 'ER_WARN_DEPRECATED_SYSVAR_UPDATE';
	exports$1[3090] = 'ER_WARN_DEPRECATED_SQLMODE';
	exports$1[3091] = 'ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID';
	exports$1[3092] = 'ER_GROUP_REPLICATION_CONFIGURATION';
	exports$1[3093] = 'ER_GROUP_REPLICATION_RUNNING';
	exports$1[3094] = 'ER_GROUP_REPLICATION_APPLIER_INIT_ERROR';
	exports$1[3095] = 'ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT';
	exports$1[3096] = 'ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR';
	exports$1[3097] = 'ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR';
	exports$1[3098] = 'ER_BEFORE_DML_VALIDATION_ERROR';
	exports$1[3099] = 'ER_PREVENTS_VARIABLE_WITHOUT_RBR';
	exports$1[3100] = 'ER_RUN_HOOK_ERROR';
	exports$1[3101] = 'ER_TRANSACTION_ROLLBACK_DURING_COMMIT';
	exports$1[3102] = 'ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED';
	exports$1[3103] = 'ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN';
	exports$1[3104] = 'ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN';
	exports$1[3105] = 'ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN';
	exports$1[3106] = 'ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN';
	exports$1[3107] = 'ER_GENERATED_COLUMN_NON_PRIOR';
	exports$1[3108] = 'ER_DEPENDENT_BY_GENERATED_COLUMN';
	exports$1[3109] = 'ER_GENERATED_COLUMN_REF_AUTO_INC';
	exports$1[3110] = 'ER_FEATURE_NOT_AVAILABLE';
	exports$1[3111] = 'ER_CANT_SET_GTID_MODE';
	exports$1[3112] = 'ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF';
	exports$1[3113] = 'ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION';
	exports$1[3114] = 'ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON';
	exports$1[3115] = 'ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF';
	exports$1[3116] =
	  'ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX';
	exports$1[3117] =
	  'ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX';
	exports$1[3118] = 'ER_ACCOUNT_HAS_BEEN_LOCKED';
	exports$1[3119] = 'ER_WRONG_TABLESPACE_NAME';
	exports$1[3120] = 'ER_TABLESPACE_IS_NOT_EMPTY';
	exports$1[3121] = 'ER_WRONG_FILE_NAME';
	exports$1[3122] = 'ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION';
	exports$1[3123] = 'ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR';
	exports$1[3124] = 'ER_WARN_BAD_MAX_EXECUTION_TIME';
	exports$1[3125] = 'ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME';
	exports$1[3126] = 'ER_WARN_CONFLICTING_HINT';
	exports$1[3127] = 'ER_WARN_UNKNOWN_QB_NAME';
	exports$1[3128] = 'ER_UNRESOLVED_HINT_NAME';
	exports$1[3129] = 'ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE';
	exports$1[3130] = 'ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED';
	exports$1[3131] = 'ER_LOCKING_SERVICE_WRONG_NAME';
	exports$1[3132] = 'ER_LOCKING_SERVICE_DEADLOCK';
	exports$1[3133] = 'ER_LOCKING_SERVICE_TIMEOUT';
	exports$1[3134] = 'ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED';
	exports$1[3135] = 'ER_SQL_MODE_MERGED';
	exports$1[3136] = 'ER_VTOKEN_PLUGIN_TOKEN_MISMATCH';
	exports$1[3137] = 'ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND';
	exports$1[3138] = 'ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID';
	exports$1[3139] = 'ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED';
	exports$1[3140] = 'ER_INVALID_JSON_TEXT';
	exports$1[3141] = 'ER_INVALID_JSON_TEXT_IN_PARAM';
	exports$1[3142] = 'ER_INVALID_JSON_BINARY_DATA';
	exports$1[3143] = 'ER_INVALID_JSON_PATH';
	exports$1[3144] = 'ER_INVALID_JSON_CHARSET';
	exports$1[3145] = 'ER_INVALID_JSON_CHARSET_IN_FUNCTION';
	exports$1[3146] = 'ER_INVALID_TYPE_FOR_JSON';
	exports$1[3147] = 'ER_INVALID_CAST_TO_JSON';
	exports$1[3148] = 'ER_INVALID_JSON_PATH_CHARSET';
	exports$1[3149] = 'ER_INVALID_JSON_PATH_WILDCARD';
	exports$1[3150] = 'ER_JSON_VALUE_TOO_BIG';
	exports$1[3151] = 'ER_JSON_KEY_TOO_BIG';
	exports$1[3152] = 'ER_JSON_USED_AS_KEY';
	exports$1[3153] = 'ER_JSON_VACUOUS_PATH';
	exports$1[3154] = 'ER_JSON_BAD_ONE_OR_ALL_ARG';
	exports$1[3155] = 'ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE';
	exports$1[3156] = 'ER_INVALID_JSON_VALUE_FOR_CAST';
	exports$1[3157] = 'ER_JSON_DOCUMENT_TOO_DEEP';
	exports$1[3158] = 'ER_JSON_DOCUMENT_NULL_KEY';
	exports$1[3159] = 'ER_SECURE_TRANSPORT_REQUIRED';
	exports$1[3160] = 'ER_NO_SECURE_TRANSPORTS_CONFIGURED';
	exports$1[3161] = 'ER_DISABLED_STORAGE_ENGINE';
	exports$1[3162] = 'ER_USER_DOES_NOT_EXIST';
	exports$1[3163] = 'ER_USER_ALREADY_EXISTS';
	exports$1[3164] = 'ER_AUDIT_API_ABORT';
	exports$1[3165] = 'ER_INVALID_JSON_PATH_ARRAY_CELL';
	exports$1[3166] = 'ER_BUFPOOL_RESIZE_INPROGRESS';
	exports$1[3167] = 'ER_FEATURE_DISABLED_SEE_DOC';
	exports$1[3168] = 'ER_SERVER_ISNT_AVAILABLE';
	exports$1[3169] = 'ER_SESSION_WAS_KILLED';
	exports$1[3170] = 'ER_CAPACITY_EXCEEDED';
	exports$1[3171] = 'ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER';
	exports$1[3172] = 'ER_TABLE_NEEDS_UPG_PART';
	exports$1[3173] = 'ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID';
	exports$1[3174] = 'ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL';
	exports$1[3175] = 'ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT';
	exports$1[3176] = 'ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE';
	exports$1[3177] = 'ER_LOCK_REFUSED_BY_ENGINE';
	exports$1[3178] = 'ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN';
	exports$1[3179] = 'ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE';
	exports$1[3180] = 'ER_MASTER_KEY_ROTATION_ERROR_BY_SE';
	exports$1[3181] = 'ER_MASTER_KEY_ROTATION_BINLOG_FAILED';
	exports$1[3182] = 'ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE';
	exports$1[3183] = 'ER_TABLESPACE_CANNOT_ENCRYPT';
	exports$1[3184] = 'ER_INVALID_ENCRYPTION_OPTION';
	exports$1[3185] = 'ER_CANNOT_FIND_KEY_IN_KEYRING';
	exports$1[3186] = 'ER_CAPACITY_EXCEEDED_IN_PARSER';
	exports$1[3187] = 'ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE';
	exports$1[3188] = 'ER_KEYRING_UDF_KEYRING_SERVICE_ERROR';
	exports$1[3189] = 'ER_USER_COLUMN_OLD_LENGTH';
	exports$1[3190] = 'ER_CANT_RESET_SOURCE';
	exports$1[3191] = 'ER_GROUP_REPLICATION_MAX_GROUP_SIZE';
	exports$1[3192] = 'ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED';
	exports$1[3193] = 'ER_TABLE_REFERENCED';
	exports$1[3194] = 'ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE';
	exports$1[3195] = 'ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO';
	exports$1[3196] = 'ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID';
	exports$1[3197] = 'ER_XA_RETRY';
	exports$1[3198] = 'ER_KEYRING_AWS_UDF_AWS_KMS_ERROR';
	exports$1[3199] = 'ER_BINLOG_UNSAFE_XA';
	exports$1[3200] = 'ER_UDF_ERROR';
	exports$1[3201] = 'ER_KEYRING_MIGRATION_FAILURE';
	exports$1[3202] = 'ER_KEYRING_ACCESS_DENIED_ERROR';
	exports$1[3203] = 'ER_KEYRING_MIGRATION_STATUS';
	exports$1[3204] = 'ER_PLUGIN_FAILED_TO_OPEN_TABLES';
	exports$1[3205] = 'ER_PLUGIN_FAILED_TO_OPEN_TABLE';
	exports$1[3206] = 'ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED';
	exports$1[3207] = 'ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET';
	exports$1[3208] = 'ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY';
	exports$1[3209] = 'ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED';
	exports$1[3210] = 'ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED';
	exports$1[3211] = 'ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE';
	exports$1[3212] = 'ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED';
	exports$1[3213] = 'ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS';
	exports$1[3214] = 'ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE';
	exports$1[3215] = 'ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT';
	exports$1[3216] = 'ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED';
	exports$1[3217] = 'ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE';
	exports$1[3218] = 'ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE';
	exports$1[3219] = 'ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR';
	exports$1[3220] = 'ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY';
	exports$1[3221] = 'ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY';
	exports$1[3222] = 'ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS';
	exports$1[3223] = 'ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC';
	exports$1[3224] = 'ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER';
	exports$1[3225] = 'ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER';
	exports$1[3226] = 'WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP';
	exports$1[3227] = 'ER_XA_REPLICATION_FILTERS';
	exports$1[3228] = 'ER_CANT_OPEN_ERROR_LOG';
	exports$1[3229] = 'ER_GROUPING_ON_TIMESTAMP_IN_DST';
	exports$1[3230] = 'ER_CANT_START_SERVER_NAMED_PIPE';
	exports$1[3231] = 'ER_WRITE_SET_EXCEEDS_LIMIT';
	exports$1[3232] = 'ER_DEPRECATED_TLS_VERSION_SESSION_57';
	exports$1[3233] = 'ER_WARN_DEPRECATED_TLS_VERSION_57';
	exports$1[3234] = 'ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE';
	exports$1[3235] = 'ER_AES_INVALID_KDF_NAME';
	exports$1[3236] = 'ER_AES_INVALID_KDF_ITERATIONS';
	exports$1[3237] = 'WARN_AES_KEY_SIZE';
	exports$1[3238] = 'ER_AES_INVALID_KDF_OPTION_SIZE';
	exports$1[3500] = 'ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE';
	exports$1[3501] = 'ER_ACL_OPERATION_FAILED';
	exports$1[3502] = 'ER_UNSUPPORTED_INDEX_ALGORITHM';
	exports$1[3503] = 'ER_NO_SUCH_DB';
	exports$1[3504] = 'ER_TOO_BIG_ENUM';
	exports$1[3505] = 'ER_TOO_LONG_SET_ENUM_VALUE';
	exports$1[3506] = 'ER_INVALID_DD_OBJECT';
	exports$1[3507] = 'ER_UPDATING_DD_TABLE';
	exports$1[3508] = 'ER_INVALID_DD_OBJECT_ID';
	exports$1[3509] = 'ER_INVALID_DD_OBJECT_NAME';
	exports$1[3510] = 'ER_TABLESPACE_MISSING_WITH_NAME';
	exports$1[3511] = 'ER_TOO_LONG_ROUTINE_COMMENT';
	exports$1[3512] = 'ER_SP_LOAD_FAILED';
	exports$1[3513] = 'ER_INVALID_BITWISE_OPERANDS_SIZE';
	exports$1[3514] = 'ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE';
	exports$1[3515] = 'ER_WARN_UNSUPPORTED_HINT';
	exports$1[3516] = 'ER_UNEXPECTED_GEOMETRY_TYPE';
	exports$1[3517] = 'ER_SRS_PARSE_ERROR';
	exports$1[3518] = 'ER_SRS_PROJ_PARAMETER_MISSING';
	exports$1[3519] = 'ER_WARN_SRS_NOT_FOUND';
	exports$1[3520] = 'ER_SRS_NOT_CARTESIAN';
	exports$1[3521] = 'ER_SRS_NOT_CARTESIAN_UNDEFINED';
	exports$1[3522] = 'ER_PK_INDEX_CANT_BE_INVISIBLE';
	exports$1[3523] = 'ER_UNKNOWN_AUTHID';
	exports$1[3524] = 'ER_FAILED_ROLE_GRANT';
	exports$1[3525] = 'ER_OPEN_ROLE_TABLES';
	exports$1[3526] = 'ER_FAILED_DEFAULT_ROLES';
	exports$1[3527] = 'ER_COMPONENTS_NO_SCHEME';
	exports$1[3528] = 'ER_COMPONENTS_NO_SCHEME_SERVICE';
	exports$1[3529] = 'ER_COMPONENTS_CANT_LOAD';
	exports$1[3530] = 'ER_ROLE_NOT_GRANTED';
	exports$1[3531] = 'ER_FAILED_REVOKE_ROLE';
	exports$1[3532] = 'ER_RENAME_ROLE';
	exports$1[3533] = 'ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION';
	exports$1[3534] = 'ER_COMPONENTS_CANT_SATISFY_DEPENDENCY';
	exports$1[3535] = 'ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION';
	exports$1[3536] = 'ER_COMPONENTS_LOAD_CANT_INITIALIZE';
	exports$1[3537] = 'ER_COMPONENTS_UNLOAD_NOT_LOADED';
	exports$1[3538] = 'ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE';
	exports$1[3539] = 'ER_COMPONENTS_CANT_RELEASE_SERVICE';
	exports$1[3540] = 'ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE';
	exports$1[3541] = 'ER_COMPONENTS_CANT_UNLOAD';
	exports$1[3542] = 'ER_WARN_UNLOAD_THE_NOT_PERSISTED';
	exports$1[3543] = 'ER_COMPONENT_TABLE_INCORRECT';
	exports$1[3544] = 'ER_COMPONENT_MANIPULATE_ROW_FAILED';
	exports$1[3545] = 'ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP';
	exports$1[3546] = 'ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS';
	exports$1[3547] = 'ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES';
	exports$1[3548] = 'ER_SRS_NOT_FOUND';
	exports$1[3549] = 'ER_VARIABLE_NOT_PERSISTED';
	exports$1[3550] = 'ER_IS_QUERY_INVALID_CLAUSE';
	exports$1[3551] = 'ER_UNABLE_TO_STORE_STATISTICS';
	exports$1[3552] = 'ER_NO_SYSTEM_SCHEMA_ACCESS';
	exports$1[3553] = 'ER_NO_SYSTEM_TABLESPACE_ACCESS';
	exports$1[3554] = 'ER_NO_SYSTEM_TABLE_ACCESS';
	exports$1[3555] = 'ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE';
	exports$1[3556] = 'ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE';
	exports$1[3557] = 'ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE';
	exports$1[3558] = 'ER_INVALID_OPTION_KEY';
	exports$1[3559] = 'ER_INVALID_OPTION_VALUE';
	exports$1[3560] = 'ER_INVALID_OPTION_KEY_VALUE_PAIR';
	exports$1[3561] = 'ER_INVALID_OPTION_START_CHARACTER';
	exports$1[3562] = 'ER_INVALID_OPTION_END_CHARACTER';
	exports$1[3563] = 'ER_INVALID_OPTION_CHARACTERS';
	exports$1[3564] = 'ER_DUPLICATE_OPTION_KEY';
	exports$1[3565] = 'ER_WARN_SRS_NOT_FOUND_AXIS_ORDER';
	exports$1[3566] = 'ER_NO_ACCESS_TO_NATIVE_FCT';
	exports$1[3567] = 'ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE';
	exports$1[3568] = 'ER_UNRESOLVED_TABLE_LOCK';
	exports$1[3569] = 'ER_DUPLICATE_TABLE_LOCK';
	exports$1[3570] = 'ER_BINLOG_UNSAFE_SKIP_LOCKED';
	exports$1[3571] = 'ER_BINLOG_UNSAFE_NOWAIT';
	exports$1[3572] = 'ER_LOCK_NOWAIT';
	exports$1[3573] = 'ER_CTE_RECURSIVE_REQUIRES_UNION';
	exports$1[3574] = 'ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST';
	exports$1[3575] = 'ER_CTE_RECURSIVE_FORBIDS_AGGREGATION';
	exports$1[3576] = 'ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER';
	exports$1[3577] = 'ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE';
	exports$1[3578] = 'ER_SWITCH_TMP_ENGINE';
	exports$1[3579] = 'ER_WINDOW_NO_SUCH_WINDOW';
	exports$1[3580] = 'ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH';
	exports$1[3581] = 'ER_WINDOW_NO_CHILD_PARTITIONING';
	exports$1[3582] = 'ER_WINDOW_NO_INHERIT_FRAME';
	exports$1[3583] = 'ER_WINDOW_NO_REDEFINE_ORDER_BY';
	exports$1[3584] = 'ER_WINDOW_FRAME_START_ILLEGAL';
	exports$1[3585] = 'ER_WINDOW_FRAME_END_ILLEGAL';
	exports$1[3586] = 'ER_WINDOW_FRAME_ILLEGAL';
	exports$1[3587] = 'ER_WINDOW_RANGE_FRAME_ORDER_TYPE';
	exports$1[3588] = 'ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE';
	exports$1[3589] = 'ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE';
	exports$1[3590] = 'ER_WINDOW_RANGE_BOUND_NOT_CONSTANT';
	exports$1[3591] = 'ER_WINDOW_DUPLICATE_NAME';
	exports$1[3592] = 'ER_WINDOW_ILLEGAL_ORDER_BY';
	exports$1[3593] = 'ER_WINDOW_INVALID_WINDOW_FUNC_USE';
	exports$1[3594] = 'ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE';
	exports$1[3595] = 'ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC';
	exports$1[3596] = 'ER_WINDOW_ROWS_INTERVAL_USE';
	exports$1[3597] = 'ER_WINDOW_NO_GROUP_ORDER';
	exports$1[3598] = 'ER_WINDOW_EXPLAIN_JSON';
	exports$1[3599] = 'ER_WINDOW_FUNCTION_IGNORES_FRAME';
	exports$1[3600] = 'ER_WL9236_NOW';
	exports$1[3601] = 'ER_INVALID_NO_OF_ARGS';
	exports$1[3602] = 'ER_FIELD_IN_GROUPING_NOT_GROUP_BY';
	exports$1[3603] = 'ER_TOO_LONG_TABLESPACE_COMMENT';
	exports$1[3604] = 'ER_ENGINE_CANT_DROP_TABLE';
	exports$1[3605] = 'ER_ENGINE_CANT_DROP_MISSING_TABLE';
	exports$1[3606] = 'ER_TABLESPACE_DUP_FILENAME';
	exports$1[3607] = 'ER_DB_DROP_RMDIR2';
	exports$1[3608] = 'ER_IMP_NO_FILES_MATCHED';
	exports$1[3609] = 'ER_IMP_SCHEMA_DOES_NOT_EXIST';
	exports$1[3610] = 'ER_IMP_TABLE_ALREADY_EXISTS';
	exports$1[3611] = 'ER_IMP_INCOMPATIBLE_MYSQLD_VERSION';
	exports$1[3612] = 'ER_IMP_INCOMPATIBLE_DD_VERSION';
	exports$1[3613] = 'ER_IMP_INCOMPATIBLE_SDI_VERSION';
	exports$1[3614] = 'ER_WARN_INVALID_HINT';
	exports$1[3615] = 'ER_VAR_DOES_NOT_EXIST';
	exports$1[3616] = 'ER_LONGITUDE_OUT_OF_RANGE';
	exports$1[3617] = 'ER_LATITUDE_OUT_OF_RANGE';
	exports$1[3618] = 'ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS';
	exports$1[3619] = 'ER_ILLEGAL_PRIVILEGE_LEVEL';
	exports$1[3620] = 'ER_NO_SYSTEM_VIEW_ACCESS';
	exports$1[3621] = 'ER_COMPONENT_FILTER_FLABBERGASTED';
	exports$1[3622] = 'ER_PART_EXPR_TOO_LONG';
	exports$1[3623] = 'ER_UDF_DROP_DYNAMICALLY_REGISTERED';
	exports$1[3624] = 'ER_UNABLE_TO_STORE_COLUMN_STATISTICS';
	exports$1[3625] = 'ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS';
	exports$1[3626] = 'ER_UNABLE_TO_DROP_COLUMN_STATISTICS';
	exports$1[3627] = 'ER_UNABLE_TO_BUILD_HISTOGRAM';
	exports$1[3628] = 'ER_MANDATORY_ROLE';
	exports$1[3629] = 'ER_MISSING_TABLESPACE_FILE';
	exports$1[3630] = 'ER_PERSIST_ONLY_ACCESS_DENIED_ERROR';
	exports$1[3631] = 'ER_CMD_NEED_SUPER';
	exports$1[3632] = 'ER_PATH_IN_DATADIR';
	exports$1[3633] = 'ER_CLONE_DDL_IN_PROGRESS';
	exports$1[3634] = 'ER_CLONE_TOO_MANY_CONCURRENT_CLONES';
	exports$1[3635] = 'ER_APPLIER_LOG_EVENT_VALIDATION_ERROR';
	exports$1[3636] = 'ER_CTE_MAX_RECURSION_DEPTH';
	exports$1[3637] = 'ER_NOT_HINT_UPDATABLE_VARIABLE';
	exports$1[3638] = 'ER_CREDENTIALS_CONTRADICT_TO_HISTORY';
	exports$1[3639] = 'ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID';
	exports$1[3640] = 'ER_CLIENT_DOES_NOT_SUPPORT';
	exports$1[3641] = 'ER_I_S_SKIPPED_TABLESPACE';
	exports$1[3642] = 'ER_TABLESPACE_ENGINE_MISMATCH';
	exports$1[3643] = 'ER_WRONG_SRID_FOR_COLUMN';
	exports$1[3644] = 'ER_CANNOT_ALTER_SRID_DUE_TO_INDEX';
	exports$1[3645] = 'ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED';
	exports$1[3646] = 'ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED';
	exports$1[3647] = 'ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES';
	exports$1[3648] = 'ER_COULD_NOT_APPLY_JSON_DIFF';
	exports$1[3649] = 'ER_CORRUPTED_JSON_DIFF';
	exports$1[3650] = 'ER_RESOURCE_GROUP_EXISTS';
	exports$1[3651] = 'ER_RESOURCE_GROUP_NOT_EXISTS';
	exports$1[3652] = 'ER_INVALID_VCPU_ID';
	exports$1[3653] = 'ER_INVALID_VCPU_RANGE';
	exports$1[3654] = 'ER_INVALID_THREAD_PRIORITY';
	exports$1[3655] = 'ER_DISALLOWED_OPERATION';
	exports$1[3656] = 'ER_RESOURCE_GROUP_BUSY';
	exports$1[3657] = 'ER_RESOURCE_GROUP_DISABLED';
	exports$1[3658] = 'ER_FEATURE_UNSUPPORTED';
	exports$1[3659] = 'ER_ATTRIBUTE_IGNORED';
	exports$1[3660] = 'ER_INVALID_THREAD_ID';
	exports$1[3661] = 'ER_RESOURCE_GROUP_BIND_FAILED';
	exports$1[3662] = 'ER_INVALID_USE_OF_FORCE_OPTION';
	exports$1[3663] = 'ER_GROUP_REPLICATION_COMMAND_FAILURE';
	exports$1[3664] = 'ER_SDI_OPERATION_FAILED';
	exports$1[3665] = 'ER_MISSING_JSON_TABLE_VALUE';
	exports$1[3666] = 'ER_WRONG_JSON_TABLE_VALUE';
	exports$1[3667] = 'ER_TF_MUST_HAVE_ALIAS';
	exports$1[3668] = 'ER_TF_FORBIDDEN_JOIN_TYPE';
	exports$1[3669] = 'ER_JT_VALUE_OUT_OF_RANGE';
	exports$1[3670] = 'ER_JT_MAX_NESTED_PATH';
	exports$1[3671] = 'ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD';
	exports$1[3672] = 'ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL';
	exports$1[3673] = 'ER_BAD_NULL_ERROR_NOT_IGNORED';
	exports$1[3674] = 'WARN_USELESS_SPATIAL_INDEX';
	exports$1[3675] = 'ER_DISK_FULL_NOWAIT';
	exports$1[3676] = 'ER_PARSE_ERROR_IN_DIGEST_FN';
	exports$1[3677] = 'ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN';
	exports$1[3678] = 'ER_SCHEMA_DIR_EXISTS';
	exports$1[3679] = 'ER_SCHEMA_DIR_MISSING';
	exports$1[3680] = 'ER_SCHEMA_DIR_CREATE_FAILED';
	exports$1[3681] = 'ER_SCHEMA_DIR_UNKNOWN';
	exports$1[3682] = 'ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326';
	exports$1[3683] = 'ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER';
	exports$1[3684] = 'ER_REGEXP_BUFFER_OVERFLOW';
	exports$1[3685] = 'ER_REGEXP_ILLEGAL_ARGUMENT';
	exports$1[3686] = 'ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR';
	exports$1[3687] = 'ER_REGEXP_INTERNAL_ERROR';
	exports$1[3688] = 'ER_REGEXP_RULE_SYNTAX';
	exports$1[3689] = 'ER_REGEXP_BAD_ESCAPE_SEQUENCE';
	exports$1[3690] = 'ER_REGEXP_UNIMPLEMENTED';
	exports$1[3691] = 'ER_REGEXP_MISMATCHED_PAREN';
	exports$1[3692] = 'ER_REGEXP_BAD_INTERVAL';
	exports$1[3693] = 'ER_REGEXP_MAX_LT_MIN';
	exports$1[3694] = 'ER_REGEXP_INVALID_BACK_REF';
	exports$1[3695] = 'ER_REGEXP_LOOK_BEHIND_LIMIT';
	exports$1[3696] = 'ER_REGEXP_MISSING_CLOSE_BRACKET';
	exports$1[3697] = 'ER_REGEXP_INVALID_RANGE';
	exports$1[3698] = 'ER_REGEXP_STACK_OVERFLOW';
	exports$1[3699] = 'ER_REGEXP_TIME_OUT';
	exports$1[3700] = 'ER_REGEXP_PATTERN_TOO_BIG';
	exports$1[3701] = 'ER_CANT_SET_ERROR_LOG_SERVICE';
	exports$1[3702] = 'ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE';
	exports$1[3703] = 'ER_COMPONENT_FILTER_DIAGNOSTICS';
	exports$1[3704] = 'ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS';
	exports$1[3705] = 'ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS';
	exports$1[3706] = 'ER_NONPOSITIVE_RADIUS';
	exports$1[3707] = 'ER_RESTART_SERVER_FAILED';
	exports$1[3708] = 'ER_SRS_MISSING_MANDATORY_ATTRIBUTE';
	exports$1[3709] = 'ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS';
	exports$1[3710] = 'ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE';
	exports$1[3711] = 'ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE';
	exports$1[3712] = 'ER_SRS_ID_ALREADY_EXISTS';
	exports$1[3713] = 'ER_WARN_SRS_ID_ALREADY_EXISTS';
	exports$1[3714] = 'ER_CANT_MODIFY_SRID_0';
	exports$1[3715] = 'ER_WARN_RESERVED_SRID_RANGE';
	exports$1[3716] = 'ER_CANT_MODIFY_SRS_USED_BY_COLUMN';
	exports$1[3717] = 'ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE';
	exports$1[3718] = 'ER_SRS_ATTRIBUTE_STRING_TOO_LONG';
	exports$1[3719] = 'ER_DEPRECATED_UTF8_ALIAS';
	exports$1[3720] = 'ER_DEPRECATED_NATIONAL';
	exports$1[3721] = 'ER_INVALID_DEFAULT_UTF8MB4_COLLATION';
	exports$1[3722] = 'ER_UNABLE_TO_COLLECT_LOG_STATUS';
	exports$1[3723] = 'ER_RESERVED_TABLESPACE_NAME';
	exports$1[3724] = 'ER_UNABLE_TO_SET_OPTION';
	exports$1[3725] = 'ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL';
	exports$1[3726] = 'ER_SRS_NOT_GEOGRAPHIC';
	exports$1[3727] = 'ER_POLYGON_TOO_LARGE';
	exports$1[3728] = 'ER_SPATIAL_UNIQUE_INDEX';
	exports$1[3729] = 'ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX';
	exports$1[3730] = 'ER_FK_CANNOT_DROP_PARENT';
	exports$1[3731] = 'ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE';
	exports$1[3732] = 'ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE';
	exports$1[3733] = 'ER_FK_CANNOT_USE_VIRTUAL_COLUMN';
	exports$1[3734] = 'ER_FK_NO_COLUMN_PARENT';
	exports$1[3735] = 'ER_CANT_SET_ERROR_SUPPRESSION_LIST';
	exports$1[3736] = 'ER_SRS_GEOGCS_INVALID_AXES';
	exports$1[3737] = 'ER_SRS_INVALID_SEMI_MAJOR_AXIS';
	exports$1[3738] = 'ER_SRS_INVALID_INVERSE_FLATTENING';
	exports$1[3739] = 'ER_SRS_INVALID_ANGULAR_UNIT';
	exports$1[3740] = 'ER_SRS_INVALID_PRIME_MERIDIAN';
	exports$1[3741] = 'ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED';
	exports$1[3742] = 'ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED';
	exports$1[3743] = 'ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84';
	exports$1[3744] = 'ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84';
	exports$1[3745] = 'ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT';
	exports$1[3746] = 'ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT';
	exports$1[3747] = 'ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT';
	exports$1[3748] = 'ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR';
	exports$1[3749] = 'ER_XA_CANT_CREATE_MDL_BACKUP';
	exports$1[3750] = 'ER_TABLE_WITHOUT_PK';
	exports$1[3751] = 'ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX';
	exports$1[3752] = 'ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX';
	exports$1[3753] = 'ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION';
	exports$1[3754] = 'ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT';
	exports$1[3755] = 'ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX';
	exports$1[3756] = 'ER_FUNCTIONAL_INDEX_PRIMARY_KEY';
	exports$1[3757] = 'ER_FUNCTIONAL_INDEX_ON_LOB';
	exports$1[3758] = 'ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED';
	exports$1[3759] = 'ER_FULLTEXT_FUNCTIONAL_INDEX';
	exports$1[3760] = 'ER_SPATIAL_FUNCTIONAL_INDEX';
	exports$1[3761] = 'ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX';
	exports$1[3762] = 'ER_FUNCTIONAL_INDEX_ON_FIELD';
	exports$1[3763] = 'ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED';
	exports$1[3764] = 'ER_GENERATED_COLUMN_ROW_VALUE';
	exports$1[3765] = 'ER_GENERATED_COLUMN_VARIABLES';
	exports$1[3766] = 'ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE';
	exports$1[3767] = 'ER_DEFAULT_VAL_GENERATED_NON_PRIOR';
	exports$1[3768] = 'ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC';
	exports$1[3769] = 'ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED';
	exports$1[3770] = 'ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED';
	exports$1[3771] = 'ER_DEFAULT_VAL_GENERATED_ROW_VALUE';
	exports$1[3772] = 'ER_DEFAULT_VAL_GENERATED_VARIABLES';
	exports$1[3773] = 'ER_DEFAULT_AS_VAL_GENERATED';
	exports$1[3774] = 'ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED';
	exports$1[3775] = 'ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION';
	exports$1[3776] = 'ER_FK_CANNOT_CHANGE_ENGINE';
	exports$1[3777] = 'ER_WARN_DEPRECATED_USER_SET_EXPR';
	exports$1[3778] = 'ER_WARN_DEPRECATED_UTF8MB3_COLLATION';
	exports$1[3779] = 'ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX';
	exports$1[3780] = 'ER_FK_INCOMPATIBLE_COLUMNS';
	exports$1[3781] = 'ER_GR_HOLD_WAIT_TIMEOUT';
	exports$1[3782] = 'ER_GR_HOLD_KILLED';
	exports$1[3783] = 'ER_GR_HOLD_MEMBER_STATUS_ERROR';
	exports$1[3784] = 'ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY';
	exports$1[3785] = 'ER_RPL_ENCRYPTION_KEY_NOT_FOUND';
	exports$1[3786] = 'ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY';
	exports$1[3787] = 'ER_RPL_ENCRYPTION_HEADER_ERROR';
	exports$1[3788] = 'ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS';
	exports$1[3789] = 'ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED';
	exports$1[3790] = 'ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY';
	exports$1[3791] = 'ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY';
	exports$1[3792] = 'ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY';
	exports$1[3793] = 'ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION';
	exports$1[3794] = 'ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED';
	exports$1[3795] = 'ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE';
	exports$1[3796] = 'ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED';
	exports$1[3797] = 'ER_GRP_TRX_CONSISTENCY_BEFORE';
	exports$1[3798] = 'ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN';
	exports$1[3799] = 'ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED';
	exports$1[3800] = 'ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED';
	exports$1[3801] = 'ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT';
	exports$1[3802] = 'ER_PAGE_TRACKING_NOT_STARTED';
	exports$1[3803] = 'ER_PAGE_TRACKING_RANGE_NOT_TRACKED';
	exports$1[3804] = 'ER_PAGE_TRACKING_CANNOT_PURGE';
	exports$1[3805] = 'ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY';
	exports$1[3806] = 'ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION';
	exports$1[3807] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY';
	exports$1[3808] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS';
	exports$1[3809] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG';
	exports$1[3810] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS';
	exports$1[3811] = 'ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY';
	exports$1[3812] = 'ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT';
	exports$1[3813] = 'ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN';
	exports$1[3814] = 'ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED';
	exports$1[3815] = 'ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED';
	exports$1[3816] = 'ER_CHECK_CONSTRAINT_VARIABLES';
	exports$1[3817] = 'ER_CHECK_CONSTRAINT_ROW_VALUE';
	exports$1[3818] = 'ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN';
	exports$1[3819] = 'ER_CHECK_CONSTRAINT_VIOLATED';
	exports$1[3820] = 'ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN';
	exports$1[3821] = 'ER_CHECK_CONSTRAINT_NOT_FOUND';
	exports$1[3822] = 'ER_CHECK_CONSTRAINT_DUP_NAME';
	exports$1[3823] = 'ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN';
	exports$1[3824] = 'WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB';
	exports$1[3825] = 'ER_INVALID_ENCRYPTION_REQUEST';
	exports$1[3826] = 'ER_CANNOT_SET_TABLE_ENCRYPTION';
	exports$1[3827] = 'ER_CANNOT_SET_DATABASE_ENCRYPTION';
	exports$1[3828] = 'ER_CANNOT_SET_TABLESPACE_ENCRYPTION';
	exports$1[3829] = 'ER_TABLESPACE_CANNOT_BE_ENCRYPTED';
	exports$1[3830] = 'ER_TABLESPACE_CANNOT_BE_DECRYPTED';
	exports$1[3831] = 'ER_TABLESPACE_TYPE_UNKNOWN';
	exports$1[3832] = 'ER_TARGET_TABLESPACE_UNENCRYPTED';
	exports$1[3833] = 'ER_CANNOT_USE_ENCRYPTION_CLAUSE';
	exports$1[3834] = 'ER_INVALID_MULTIPLE_CLAUSES';
	exports$1[3835] = 'ER_UNSUPPORTED_USE_OF_GRANT_AS';
	exports$1[3836] = 'ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS';
	exports$1[3837] = 'ER_DEPENDENT_BY_FUNCTIONAL_INDEX';
	exports$1[3838] = 'ER_PLUGIN_NOT_EARLY';
	exports$1[3839] = 'ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH';
	exports$1[3840] = 'ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT';
	exports$1[3841] = 'ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID';
	exports$1[3842] = 'ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND';
	exports$1[3843] = 'ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY';
	exports$1[3844] = 'ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR';
	exports$1[3845] = 'ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH';
	exports$1[3846] = 'ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS';
	exports$1[3847] = 'ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE';
	exports$1[3848] = 'ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE';
	exports$1[3849] = 'ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE';
	exports$1[3850] = 'ER_INNODB_REDO_LOG_ARCHIVE_FAILED';
	exports$1[3851] = 'ER_INNODB_REDO_LOG_ARCHIVE_SESSION';
	exports$1[3852] = 'ER_STD_REGEX_ERROR';
	exports$1[3853] = 'ER_INVALID_JSON_TYPE';
	exports$1[3854] = 'ER_CANNOT_CONVERT_STRING';
	exports$1[3855] = 'ER_DEPENDENT_BY_PARTITION_FUNC';
	exports$1[3856] = 'ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT';
	exports$1[3857] = 'ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP';
	exports$1[3858] = 'ER_WARN_DEPRECATED_FLOAT_DIGITS';
	exports$1[3859] = 'ER_WARN_DEPRECATED_FLOAT_UNSIGNED';
	exports$1[3860] = 'ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH';
	exports$1[3861] = 'ER_WARN_DEPRECATED_ZEROFILL';
	exports$1[3862] = 'ER_CLONE_DONOR';
	exports$1[3863] = 'ER_CLONE_PROTOCOL';
	exports$1[3864] = 'ER_CLONE_DONOR_VERSION';
	exports$1[3865] = 'ER_CLONE_OS';
	exports$1[3866] = 'ER_CLONE_PLATFORM';
	exports$1[3867] = 'ER_CLONE_CHARSET';
	exports$1[3868] = 'ER_CLONE_CONFIG';
	exports$1[3869] = 'ER_CLONE_SYS_CONFIG';
	exports$1[3870] = 'ER_CLONE_PLUGIN_MATCH';
	exports$1[3871] = 'ER_CLONE_LOOPBACK';
	exports$1[3872] = 'ER_CLONE_ENCRYPTION';
	exports$1[3873] = 'ER_CLONE_DISK_SPACE';
	exports$1[3874] = 'ER_CLONE_IN_PROGRESS';
	exports$1[3875] = 'ER_CLONE_DISALLOWED';
	exports$1[3876] = 'ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER';
	exports$1[3877] = 'ER_SECONDARY_ENGINE_PLUGIN';
	exports$1[3878] = 'ER_SECOND_PASSWORD_CANNOT_BE_EMPTY';
	exports$1[3879] = 'ER_DB_ACCESS_DENIED';
	exports$1[3880] = 'ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES';
	exports$1[3881] = 'ER_DA_RPL_GTID_TABLE_CANNOT_OPEN';
	exports$1[3882] = 'ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT';
	exports$1[3883] = 'ER_DA_PLUGIN_INSTALL_ERROR';
	exports$1[3884] = 'ER_NO_SESSION_TEMP';
	exports$1[3885] = 'ER_DA_UNKNOWN_ERROR_NUMBER';
	exports$1[3886] = 'ER_COLUMN_CHANGE_SIZE';
	exports$1[3887] = 'ER_REGEXP_INVALID_CAPTURE_GROUP_NAME';
	exports$1[3888] = 'ER_DA_SSL_LIBRARY_ERROR';
	exports$1[3889] = 'ER_SECONDARY_ENGINE';
	exports$1[3890] = 'ER_SECONDARY_ENGINE_DDL';
	exports$1[3891] = 'ER_INCORRECT_CURRENT_PASSWORD';
	exports$1[3892] = 'ER_MISSING_CURRENT_PASSWORD';
	exports$1[3893] = 'ER_CURRENT_PASSWORD_NOT_REQUIRED';
	exports$1[3894] = 'ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE';
	exports$1[3895] = 'ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED';
	exports$1[3896] = 'ER_PARTIAL_REVOKES_EXIST';
	exports$1[3897] = 'ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE';
	exports$1[3898] = 'ER_XA_REPLICATION_FILTERS';
	exports$1[3899] = 'ER_UNSUPPORTED_SQL_MODE';
	exports$1[3900] = 'ER_REGEXP_INVALID_FLAG';
	exports$1[3901] = 'ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS';
	exports$1[3902] = 'ER_UNIT_NOT_FOUND';
	exports$1[3903] = 'ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX';
	exports$1[3904] = 'ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX';
	exports$1[3905] = 'ER_EXCEEDED_MV_KEYS_NUM';
	exports$1[3906] = 'ER_EXCEEDED_MV_KEYS_SPACE';
	exports$1[3907] = 'ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG';
	exports$1[3908] = 'ER_WRONG_MVI_VALUE';
	exports$1[3909] = 'ER_WARN_FUNC_INDEX_NOT_APPLICABLE';
	exports$1[3910] = 'ER_GRP_RPL_UDF_ERROR';
	exports$1[3911] = 'ER_UPDATE_GTID_PURGED_WITH_GR';
	exports$1[3912] = 'ER_GROUPING_ON_TIMESTAMP_IN_DST';
	exports$1[3913] = 'ER_TABLE_NAME_CAUSES_TOO_LONG_PATH';
	exports$1[3914] = 'ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE';
	exports$1[3915] = 'ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED';
	exports$1[3916] = 'ER_DA_GRP_RPL_STARTED_AUTO_REJOIN';
	exports$1[3917] = 'ER_SYSVAR_CHANGE_DURING_QUERY';
	exports$1[3918] = 'ER_GLOBSTAT_CHANGE_DURING_QUERY';
	exports$1[3919] = 'ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE';
	exports$1[3920] = 'ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT';
	exports$1[3921] = 'ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT';
	exports$1[3922] = 'ER_WRONG_COMPRESSION_ALGORITHM_CLIENT';
	exports$1[3923] = 'ER_WRONG_COMPRESSION_LEVEL_CLIENT';
	exports$1[3924] = 'ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT';
	exports$1[3925] = 'ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS';
	exports$1[3926] = 'ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST';
	exports$1[3927] = 'ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT';
	exports$1[3928] = 'ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV';
	exports$1[3929] = 'ER_WARN_DA_PRIVILEGE_NOT_REGISTERED';
	exports$1[3930] = 'ER_CLIENT_KEYRING_UDF_KEY_INVALID';
	exports$1[3931] = 'ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID';
	exports$1[3932] = 'ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG';
	exports$1[3933] = 'ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG';
	exports$1[3934] = 'ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT';
	exports$1[3935] = 'ER_DA_UDF_INVALID_CHARSET_SPECIFIED';
	exports$1[3936] = 'ER_DA_UDF_INVALID_CHARSET';
	exports$1[3937] = 'ER_DA_UDF_INVALID_COLLATION';
	exports$1[3938] = 'ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE';
	exports$1[3939] = 'ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME';
	exports$1[3940] = 'ER_CONSTRAINT_NOT_FOUND';
	exports$1[3941] = 'ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED';
	exports$1[3942] = 'ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS';
	exports$1[3943] = 'ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT';
	exports$1[3944] = 'ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT';
	exports$1[3945] = 'ER_REQUIRE_ROW_FORMAT_INVALID_VALUE';
	exports$1[3946] = 'ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY';
	exports$1[3947] = 'ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST';
	exports$1[3948] = 'ER_CLIENT_LOCAL_FILES_DISABLED';
	exports$1[3949] = 'ER_IMP_INCOMPATIBLE_CFG_VERSION';
	exports$1[3950] = 'ER_DA_OOM';
	exports$1[3951] = 'ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET';
	exports$1[3952] = 'ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET';
	exports$1[3953] = 'ER_MULTIPLE_INTO_CLAUSES';
	exports$1[3954] = 'ER_MISPLACED_INTO';
	exports$1[3955] =
	  'ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK';
	exports$1[3956] = 'ER_WARN_DEPRECATED_YEAR_UNSIGNED';
	exports$1[3957] = 'ER_CLONE_NETWORK_PACKET';
	exports$1[3958] = 'ER_SDI_OPERATION_FAILED_MISSING_RECORD';
	exports$1[3959] = 'ER_DEPENDENT_BY_CHECK_CONSTRAINT';
	exports$1[3960] = 'ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP';
	exports$1[3961] = 'ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY';
	exports$1[3962] = 'ER_WARN_DEPRECATED_INNER_INTO';
	exports$1[3963] = 'ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL';
	exports$1[3964] = 'ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS';
	exports$1[3965] = 'ER_WARN_DEPRECATED_FOUND_ROWS';
	exports$1[3966] = 'ER_MISSING_JSON_VALUE';
	exports$1[3967] = 'ER_MULTIPLE_JSON_VALUES';
	exports$1[3968] = 'ER_HOSTNAME_TOO_LONG';
	exports$1[3969] = 'ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY';
	exports$1[3970] = 'ER_GROUP_REPLICATION_USER_EMPTY_MSG';
	exports$1[3971] = 'ER_GROUP_REPLICATION_USER_MANDATORY_MSG';
	exports$1[3972] = 'ER_GROUP_REPLICATION_PASSWORD_LENGTH';
	exports$1[3973] = 'ER_SUBQUERY_TRANSFORM_REJECTED';
	exports$1[3974] = 'ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT';
	exports$1[3975] = 'ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID';
	exports$1[3976] = 'ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART';
	exports$1[3977] = 'ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION';
	exports$1[3978] = 'ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT';
	exports$1[3979] = 'ER_NOT_ALLOWED_WITH_START_TRANSACTION';
	exports$1[3980] = 'ER_INVALID_JSON_ATTRIBUTE';
	exports$1[3981] = 'ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED';
	exports$1[3982] = 'ER_INVALID_USER_ATTRIBUTE_JSON';
	exports$1[3983] = 'ER_INNODB_REDO_DISABLED';
	exports$1[3984] = 'ER_INNODB_REDO_ARCHIVING_ENABLED';
	exports$1[3985] = 'ER_MDL_OUT_OF_RESOURCES';
	exports$1[3986] = 'ER_IMPLICIT_COMPARISON_FOR_JSON';
	exports$1[3987] = 'ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET';
	exports$1[3988] = 'ER_IMPOSSIBLE_STRING_CONVERSION';
	exports$1[3989] = 'ER_SCHEMA_READ_ONLY';
	exports$1[3990] = 'ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF';
	exports$1[3991] = 'ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF';
	exports$1[3992] = 'ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF';
	exports$1[3993] = 'ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF';
	exports$1[3994] = 'ER_INVALID_PARAMETER_USE';
	exports$1[3995] = 'ER_CHARACTER_SET_MISMATCH';
	exports$1[3996] = 'ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED';
	exports$1[3997] = 'ER_INVALID_TIME_ZONE_INTERVAL';
	exports$1[3998] = 'ER_INVALID_CAST';
	exports$1[3999] = 'ER_HYPERGRAPH_NOT_SUPPORTED_YET';
	exports$1[4000] = 'ER_WARN_HYPERGRAPH_EXPERIMENTAL';
	exports$1[4001] = 'ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED';
	exports$1[4002] = 'ER_DA_ERROR_LOG_TABLE_DISABLED';
	exports$1[4003] = 'ER_DA_ERROR_LOG_MULTIPLE_FILTERS';
	exports$1[4004] = 'ER_DA_CANT_OPEN_ERROR_LOG';
	exports$1[4005] = 'ER_USER_REFERENCED_AS_DEFINER';
	exports$1[4006] = 'ER_CANNOT_USER_REFERENCED_AS_DEFINER';
	exports$1[4007] = 'ER_REGEX_NUMBER_TOO_BIG';
	exports$1[4008] = 'ER_SPVAR_NONINTEGER_TYPE';
	exports$1[4009] = 'WARN_UNSUPPORTED_ACL_TABLES_READ';
	exports$1[4010] = 'ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL';
	exports$1[4011] = 'ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT';
	exports$1[4012] = 'ER_STARTING_REPLICA_MONITOR_IO_THREAD';
	exports$1[4013] = 'ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON';
	exports$1[4014] = 'ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION';
	exports$1[4015] =
	  'ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON';
	exports$1[4016] = 'ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON';
	exports$1[4017] =
	  'ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID';
	exports$1[4018] =
	  'ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS';
	exports$1[4019] = 'ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID';
	exports$1[4020] = 'ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME';
	exports$1[4021] = 'ER_CANT_USE_SAME_UUID_AS_GROUP_NAME';
	exports$1[4022] = 'ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING';
	exports$1[4023] = 'ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE';
	exports$1[4024] = 'ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE';
	exports$1[4025] = 'ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE';
	exports$1[4026] = 'ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE';
	exports$1[4027] = 'ER_ROLE_GRANTED_TO_ITSELF';
	exports$1[4028] = 'ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN';
	exports$1[4029] = 'ER_INNODB_COMPRESSION_FAILURE';
	exports$1[4030] = 'ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE';
	exports$1[4031] = 'ER_CLIENT_INTERACTION_TIMEOUT';
	exports$1[4032] = 'ER_INVALID_CAST_TO_GEOMETRY';
	exports$1[4033] = 'ER_INVALID_CAST_POLYGON_RING_DIRECTION';
	exports$1[4034] = 'ER_GIS_DIFFERENT_SRIDS_AGGREGATION';
	exports$1[4035] = 'ER_RELOAD_KEYRING_FAILURE';
	exports$1[4036] = 'ER_SDI_GET_KEYS_INVALID_TABLESPACE';
	exports$1[4037] = 'ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE';
	exports$1[4038] = 'ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI';
	exports$1[4039] = 'ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID';
	exports$1[4040] = 'ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID';
	exports$1[4041] = 'ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE';
	exports$1[4042] = 'ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS';
	exports$1[4043] = 'ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE';
	exports$1[4044] = 'ER_KERBEROS_CREATE_USER';
	exports$1[4045] = 'ER_INSTALL_PLUGIN_CONFLICT_CLIENT';
	exports$1[4046] = 'ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED';
	exports$1[4047] = 'ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED';
	exports$1[4048] = 'ER_INVALID_ASSIGNMENT_TARGET';
	exports$1[4049] = 'ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY';
	exports$1[4050] = 'ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION';
	exports$1[4051] = 'ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON';
	exports$1[4052] = 'ER_INVALID_MFA_PLUGIN_SPECIFIED';
	exports$1[4053] = 'ER_IDENTIFIED_BY_UNSUPPORTED';
	exports$1[4054] = 'ER_INVALID_PLUGIN_FOR_REGISTRATION';
	exports$1[4055] = 'ER_PLUGIN_REQUIRES_REGISTRATION';
	exports$1[4056] = 'ER_MFA_METHOD_EXISTS';
	exports$1[4057] = 'ER_MFA_METHOD_NOT_EXISTS';
	exports$1[4058] = 'ER_AUTHENTICATION_POLICY_MISMATCH';
	exports$1[4059] = 'ER_PLUGIN_REGISTRATION_DONE';
	exports$1[4060] = 'ER_INVALID_USER_FOR_REGISTRATION';
	exports$1[4061] = 'ER_USER_REGISTRATION_FAILED';
	exports$1[4062] = 'ER_MFA_METHODS_INVALID_ORDER';
	exports$1[4063] = 'ER_MFA_METHODS_IDENTICAL';
	exports$1[4064] = 'ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER';
	exports$1[4065] = 'ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY';
	exports$1[4066] =
	  'ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY';
	exports$1[4067] =
	  'ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY';
	exports$1[4068] = 'ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS';
	exports$1[4069] = 'ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS';
	exports$1[4070] = 'ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON';
	exports$1[4071] = 'ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON';
	exports$1[4072] = 'ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS';
	exports$1[4073] = 'ER_DA_SSL_FIPS_MODE_ERROR';
	exports$1[4074] = 'ER_VALUE_OUT_OF_RANGE';
	exports$1[4075] = 'ER_FULLTEXT_WITH_ROLLUP';
	exports$1[4076] = 'ER_REGEXP_MISSING_RESOURCE';
	exports$1[4077] = 'ER_WARN_REGEXP_USING_DEFAULT';
	exports$1[4078] = 'ER_REGEXP_MISSING_FILE';
	exports$1[4079] = 'ER_WARN_DEPRECATED_COLLATION';
	exports$1[4080] = 'ER_CONCURRENT_PROCEDURE_USAGE';
	exports$1[4081] = 'ER_DA_GLOBAL_CONN_LIMIT';
	exports$1[4082] = 'ER_DA_CONN_LIMIT';
	exports$1[4083] = 'ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT';
	exports$1[4084] = 'ER_WARN_SF_UDF_NAME_COLLISION';
	exports$1[4085] = 'ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK';
	exports$1[4086] = 'ER_TOO_MANY_WINDOWS';
	exports$1[4087] = 'ER_MYSQLBACKUP_CLIENT_MSG';
	exports$1[4088] = 'ER_COMMENT_CONTAINS_INVALID_STRING';
	exports$1[4089] = 'ER_DEFINITION_CONTAINS_INVALID_STRING';
	exports$1[4090] = 'ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT';
	exports$1[4091] = 'ER_XA_TEMP_TABLE';
	exports$1[4092] = 'ER_INNODB_MAX_ROW_VERSION';
	exports$1[4093] = 'ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE';
	exports$1[4094] = 'ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING';
	exports$1[4095] = 'ER_WARN_DEPRECATED_DATETIME_DELIMITER';
	exports$1[4096] = 'ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER';
	exports$1[4097] = 'ER_CANNOT_PERSIST_SENSITIVE_VARIABLES';
	exports$1[4098] = 'ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES';
	exports$1[4099] = 'ER_WARN_TRG_ALREADY_EXISTS';
	exports$1[4100] = 'ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE';
	exports$1[4101] = 'ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION';
	exports$1[4102] = 'ER_SET_PASSWORD_AUTH_PLUGIN_ERROR';
	exports$1[4103] = 'ER_REDUCED_DBLWR_FILE_CORRUPTED';
	exports$1[4104] = 'ER_REDUCED_DBLWR_PAGE_FOUND';
	exports$1[4105] = 'ER_SRS_INVALID_LATITUDE_OF_ORIGIN';
	exports$1[4106] = 'ER_SRS_INVALID_LONGITUDE_OF_ORIGIN';
	exports$1[4107] = 'ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT';
	exports$1[4108] = 'ER_GIPK_COLUMN_EXISTS';
	exports$1[4109] = 'ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS';
	exports$1[4110] = 'ER_GIPK_COLUMN_ALTER_NOT_ALLOWED';
	exports$1[4111] = 'ER_DROP_PK_COLUMN_TO_DROP_GIPK';
	exports$1[4112] = 'ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR';
	exports$1[4113] = 'ER_DA_EXPIRE_LOGS_DAYS_IGNORED';
	exports$1[4114] = 'ER_CTE_RECURSIVE_NOT_UNION';
	exports$1[4115] = 'ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX';
	exports$1[4116] = 'ER_COMMAND_SERVICE_BACKEND_FAILED';
	exports$1[4117] = 'ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS';
	exports$1[4118] = 'ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE';
	exports$1[4119] = 'ER_WARN_DEPRECATED_IDENT';
	exports$1[4120] = 'ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED';
	exports$1[4121] = 'ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT';
	exports$1[4122] = 'ER_BAD_TIMESTAMP_FORMAT';
	exports$1[4123] = 'ER_SHAPE_PRIDICTION_UDF';
	exports$1[4124] = 'ER_SRS_INVALID_HEIGHT';
	exports$1[4125] = 'ER_SRS_INVALID_SCALING';
	exports$1[4126] = 'ER_SRS_INVALID_ZONE_WIDTH';
	exports$1[4127] = 'ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A';
	exports$1[4128] = 'ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION';
	exports$1[4129] = 'ER_TABLE_NOT_EMPTY';
	exports$1[4130] = 'ER_TABLE_NO_PRIMARY_KEY';
	exports$1[4131] = 'ER_TABLE_IN_SHARED_TABLESPACE';
	exports$1[4132] = 'ER_INDEX_OTHER_THAN_PK';
	exports$1[4133] = 'ER_LOAD_BULK_DATA_UNSORTED';
	exports$1[4134] = 'ER_BULK_EXECUTOR_ERROR';
	exports$1[4135] = 'ER_BULK_READER_LIBCURL_INIT_FAILED';
	exports$1[4136] = 'ER_BULK_READER_LIBCURL_ERROR';
	exports$1[4137] = 'ER_BULK_READER_SERVER_ERROR';
	exports$1[4138] = 'ER_BULK_READER_COMMUNICATION_ERROR';
	exports$1[4139] = 'ER_BULK_LOAD_DATA_FAILED';
	exports$1[4140] = 'ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER';
	exports$1[4141] = 'ER_BULK_LOADER_COMPONENT_ERROR';
	exports$1[4142] = 'ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE';
	exports$1[4143] = 'ER_BULK_PARSER_MISSING_ENCLOSED_BY';
	exports$1[4144] = 'ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED';
	exports$1[4145] = 'ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED';
	exports$1[4146] = 'ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT';
	exports$1[4147] = 'ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR';
	exports$1[4148] = 'ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY';
	exports$1[4149] = 'ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE';
	exports$1[4150] = 'ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR';
	exports$1[4151] = 'ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE';
	exports$1[4152] = 'ER_LOAD_BULK_DATA_FAILED';
	exports$1[4153] = 'ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD';
	exports$1[4154] = 'ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL';
	exports$1[4155] = 'ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR';
	exports$1[4156] = 'ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE';
	exports$1[4157] = 'ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE';
	exports$1[4158] = 'ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS';
	exports$1[4159] = 'ER_CANT_SET_PERSISTED';
	exports$1[4160] = 'ER_INSTALL_COMPONENT_SET_NULL_VALUE';
	exports$1[4161] = 'ER_INSTALL_COMPONENT_SET_UNUSED_VALUE';
	exports$1[4162] = 'ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS'; 
} (errors));

/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

// WebAssembly optimizations to do native i64 multiplication and divide
var wasm = null;
try {
  wasm = new WebAssembly.Instance(
    new WebAssembly.Module(
      new Uint8Array([
        // \0asm
        0, 97, 115, 109,
        // version 1
        1, 0, 0, 0,

        // section "type"
        1, 13, 2,
        // 0, () => i32
        96, 0, 1, 127,
        // 1, (i32, i32, i32, i32) => i32
        96, 4, 127, 127, 127, 127, 1, 127,

        // section "function"
        3, 7, 6,
        // 0, type 0
        0,
        // 1, type 1
        1,
        // 2, type 1
        1,
        // 3, type 1
        1,
        // 4, type 1
        1,
        // 5, type 1
        1,

        // section "global"
        6, 6, 1,
        // 0, "high", mutable i32
        127, 1, 65, 0, 11,

        // section "export"
        7, 50, 6,
        // 0, "mul"
        3, 109, 117, 108, 0, 1,
        // 1, "div_s"
        5, 100, 105, 118, 95, 115, 0, 2,
        // 2, "div_u"
        5, 100, 105, 118, 95, 117, 0, 3,
        // 3, "rem_s"
        5, 114, 101, 109, 95, 115, 0, 4,
        // 4, "rem_u"
        5, 114, 101, 109, 95, 117, 0, 5,
        // 5, "get_high"
        8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,

        // section "code"
        10, 191, 1, 6,
        // 0, "get_high"
        4, 0, 35, 0, 11,
        // 1, "mul"
        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
        3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
        167, 11,
        // 2, "div_s"
        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
        3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
        167, 11,
        // 3, "div_u"
        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
        3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
        167, 11,
        // 4, "rem_s"
        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
        3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
        167, 11,
        // 5, "rem_u"
        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
        3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
        167, 11,
      ]),
    ),
    {},
  ).exports;
} catch {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long$1(low, high, unsigned) {
  /**
   * The low 32 bits as a signed value.
   * @type {number}
   */
  this.low = low | 0;

  /**
   * The high 32 bits as a signed value.
   * @type {number}
   */
  this.high = high | 0;

  /**
   * Whether unsigned or not.
   * @type {boolean}
   */
  this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long$1.prototype.__isLong__;

Object.defineProperty(Long$1.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}

/**
 * @function
 * @param {*} value number
 * @returns {number}
 * @inner
 */
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long$1.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if ((cache = 0 <= value && value < 256)) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache) UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if ((cache = -128 <= value && value < 128)) {
      cachedObj = INT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache) INT_CACHE[value] = obj;
    return obj;
  }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long$1.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
  if (isNaN(value)) return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0) return UZERO;
    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }
  if (value < 0) return fromNumber(-value, unsigned).neg();
  return fromBits(
    value % TWO_PWR_32_DBL | 0,
    (value / TWO_PWR_32_DBL) | 0,
    unsigned,
  );
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long$1.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
  return new Long$1(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long$1.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
  if (str.length === 0) throw Error("empty string");
  if (typeof unsigned === "number") {
    // For goog.math.long compatibility
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (
    str === "NaN" ||
    str === "Infinity" ||
    str === "+Infinity" ||
    str === "-Infinity"
  )
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");

  var p;
  if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = fromNumber(pow_dbl(radix, 8));

  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i),
      value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long$1.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
  if (typeof val === "number") return fromNumber(val, unsigned);
  if (typeof val === "string") return fromString(val, unsigned);
  // Throws for non-objects, converts non-instanceof Long:
  return fromBits(
    val.low,
    val.high,
    typeof unsigned === "boolean" ? unsigned : val.unsigned,
  );
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long$1.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long$1.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long$1.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long$1.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long$1.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long$1.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xffffffff | 0, 0x7fffffff | 0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long$1.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xffffffff | 0, 0xffffffff | 0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long$1.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long$1.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long$1.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @this {!Long}
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative()) {
    // Unsigned Longs are never negative
    if (this.eq(MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = fromNumber(radix),
        div = this.div(radixLong),
        rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else return "-" + this.neg().toString(radix);
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
    rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower),
      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
      digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero()) return digits + result;
    else {
      while (digits.length < 6) digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    // Unsigned Longs are never negative
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--) if ((val & (1 << bit)) != 0) break;
  return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long can be safely represented as a JavaScript number.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isSafeInteger = function isSafeInteger() {
  // 2^53-1 is the maximum safe value
  var top11Bits = this.high >> 21;
  // [0, 2^53-1]
  if (!top11Bits) return true;
  // > 2^53-1
  if (this.unsigned) return false;
  // [-2^53, -1] except -2^53
  return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
};

/**
 * Tests if this Long's value equals zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive or zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
  if (!isLong(other)) other = fromValue(other);
  if (
    this.unsigned !== other.unsigned &&
    this.high >>> 31 === 1 &&
    other.high >>> 31 === 1
  )
    return false;
  return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.eq(other)) return 0;
  var thisNeg = this.isNegative(),
    otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) return -1;
  if (!thisNeg && otherNeg) return 1;
  // At this point the sign bits are the same
  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
  // Both are positive if at least one is unsigned
  return other.high >>> 0 > this.high >>> 0 ||
    (other.high === this.high && other.low >>> 0 > this.low >>> 0)
    ? -1
    : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @this {!Long}
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
  return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|bigint|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
  if (!isLong(addend)) addend = fromValue(addend);

  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high >>> 16;
  var a32 = this.high & 0xffff;
  var a16 = this.low >>> 16;
  var a00 = this.low & 0xffff;

  var b48 = addend.high >>> 16;
  var b32 = addend.high & 0xffff;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 0xffff;

  var c48 = 0,
    c32 = 0,
    c16 = 0,
    c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xffff;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xffff;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xffff;
  c48 += a48 + b48;
  c48 &= 0xffff;
  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|bigint|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|bigint|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|bigint|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero()) return this;
  if (!isLong(multiplier)) multiplier = fromValue(multiplier);

  // use wasm support if present
  if (wasm) {
    var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;

  if (this.isNegative()) {
    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
    else return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();

  // If both longs are small, use float multiplication
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high >>> 16;
  var a32 = this.high & 0xffff;
  var a16 = this.low >>> 16;
  var a00 = this.low & 0xffff;

  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 0xffff;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 0xffff;

  var c48 = 0,
    c32 = 0,
    c16 = 0,
    c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xffff;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xffff;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xffff;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xffff;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xffff;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xffff;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xffff;
  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|bigint|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @this {!Long}
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (divisor.isZero()) throw Error("division by zero");

  // use wasm support if present
  if (wasm) {
    // guard against signed division overflow: the largest
    // negative number / -1 would be 1 larger than the largest
    // positive number, due to two's complement.
    if (
      !this.unsigned &&
      this.high === -2147483648 &&
      divisor.low === -1 &&
      divisor.high === -1
    ) {
      // be consistent with non-wasm code path
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high,
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  if (this.isZero()) return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    // This section is only relevant for signed longs and is derived from the
    // closure library as a whole.
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
      else if (divisor.eq(MIN_VALUE)) return ONE;
      else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative()) return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    // The algorithm below has not been made for unsigned longs. It's therefore
    // required to take special care of the MSB prior to running it.
    if (!divisor.unsigned) divisor = divisor.toUnsigned();
    if (divisor.gt(this)) return UZERO;
    if (divisor.gt(this.shru(1)))
      // 15 >>> 1 = 7 ; with divisor = 8 ; true
      return UONE;
    res = UZERO;
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  rem = this;
  while (rem.gte(divisor)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2),
      delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
      // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      approxRes = fromNumber(approx),
      approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero()) approxRes = ONE;

    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @this {!Long}
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);

  // use wasm support if present
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high,
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @this {!Long}
 * @returns {!Long}
 */
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns count leading zeros of this Long.
 * @this {!Long}
 * @returns {!number}
 */
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};

/**
 * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
 * @function
 * @param {!Long}
 * @returns {!number}
 */
LongPrototype.clz = LongPrototype.countLeadingZeros;

/**
 * Returns count trailing zeros of this Long.
 * @this {!Long}
 * @returns {!number}
 */
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};

/**
 * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
 * @function
 * @param {!Long}
 * @returns {!number}
 */
LongPrototype.ctz = LongPrototype.countTrailingZeros;

/**
 * Returns the bitwise AND of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low << numBits,
      (this.high << numBits) | (this.low >>> (32 - numBits)),
      this.unsigned,
    );
  else return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      (this.low >>> numBits) | (this.high << (32 - numBits)),
      this.high >> numBits,
      this.unsigned,
    );
  else
    return fromBits(
      this.high >> (numBits - 32),
      this.high >= 0 ? 0 : -1,
      this.unsigned,
    );
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32)
    return fromBits(
      (this.low >>> numBits) | (this.high << (32 - numBits)),
      this.high >>> numBits,
      this.unsigned,
    );
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits rotated to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(
      (this.low << numBits) | (this.high >>> b),
      (this.high << numBits) | (this.low >>> b),
      this.unsigned,
    );
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(
    (this.high << numBits) | (this.low >>> b),
    (this.low << numBits) | (this.high >>> b),
    this.unsigned,
  );
};
/**
 * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotl = LongPrototype.rotateLeft;

/**
 * Returns this Long with bits rotated to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(
      (this.high << b) | (this.low >>> numBits),
      (this.low << b) | (this.high >>> numBits),
      this.unsigned,
    );
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(
    (this.low << b) | (this.high >>> numBits),
    (this.high << b) | (this.low >>> numBits),
    this.unsigned,
  );
};
/**
 * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotr = LongPrototype.rotateRight;

/**
 * Converts this Long to signed.
 * @this {!Long}
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned) return this;
  return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @this {!Long}
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned) return this;
  return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @this {!Long}
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high,
    lo = this.low;
  return [
    lo & 0xff,
    (lo >>> 8) & 0xff,
    (lo >>> 16) & 0xff,
    lo >>> 24,
    hi & 0xff,
    (hi >>> 8) & 0xff,
    (hi >>> 16) & 0xff,
    hi >>> 24,
  ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high,
    lo = this.low;
  return [
    hi >>> 24,
    (hi >>> 16) & 0xff,
    (hi >>> 8) & 0xff,
    hi & 0xff,
    lo >>> 24,
    (lo >>> 16) & 0xff,
    (lo >>> 8) & 0xff,
    lo & 0xff,
  ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long$1.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le
    ? Long$1.fromBytesLE(bytes, unsigned)
    : Long$1.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long$1.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long$1(
    bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),
    bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),
    unsigned,
  );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long$1.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long$1(
    (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],
    (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],
    unsigned,
  );
};

// Support conversion to/from BigInt where available
if (typeof BigInt === "function") {
  /**
   * Returns a Long representing the given big integer.
   * @function
   * @param {number} value The big integer value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long$1.fromBigInt = function fromBigInt(value, unsigned) {
    var lowBits = Number(BigInt.asIntN(32, value));
    var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
    return fromBits(lowBits, highBits, unsigned);
  };

  // Override
  Long$1.fromValue = function fromValueWithBigInt(value, unsigned) {
    if (typeof value === "bigint") return Long$1.fromBigInt(value, unsigned);
    return fromValue(value, unsigned);
  };

  /**
   * Converts the Long to its big integer representation.
   * @this {!Long}
   * @returns {bigint}
   */
  LongPrototype.toBigInt = function toBigInt() {
    var lowBigInt = BigInt(this.low >>> 0);
    var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
    return (highBigInt << BigInt(32)) | lowBigInt;
  };
}

var string = {};

var lib$2 = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var buffer = require$$0$3;
var Buffer$1 = buffer.Buffer;

var safer = {};

var key$1;

for (key$1 in buffer) {
  if (!buffer.hasOwnProperty(key$1)) continue
  if (key$1 === 'SlowBuffer' || key$1 === 'Buffer') continue
  safer[key$1] = buffer[key$1];
}

var Safer = safer.Buffer = {};
for (key$1 in Buffer$1) {
  if (!Buffer$1.hasOwnProperty(key$1)) continue
  if (key$1 === 'allocUnsafe' || key$1 === 'allocUnsafeSlow') continue
  Safer[key$1] = Buffer$1[key$1];
}

safer.Buffer.prototype = Buffer$1.prototype;

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer$1(value, encodingOrOffset, length)
  };
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer$1(size);
    if (!fill || fill.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
    return buf
  };
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}

var safer_1 = safer;

var bomHandling = {};

var BOMChar = "\uFEFF";

bomHandling.PrependBOM = PrependBOMWrapper;
function PrependBOMWrapper (encoder, options) {
  this.encoder = encoder;
  this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function (str) {
  if (this.addBOM) {
    str = BOMChar + str;
    this.addBOM = false;
  }

  return this.encoder.write(str)
};

PrependBOMWrapper.prototype.end = function () {
  return this.encoder.end()
};

// ------------------------------------------------------------------------------

bomHandling.StripBOM = StripBOMWrapper;
function StripBOMWrapper (decoder, options) {
  this.decoder = decoder;
  this.pass = false;
  this.options = options || {};
}

StripBOMWrapper.prototype.write = function (buf) {
  var res = this.decoder.write(buf);
  if (this.pass || !res) { return res }

  if (res[0] === BOMChar) {
    res = res.slice(1);
    if (typeof this.options.stripBOM === "function") { this.options.stripBOM(); }
  }

  this.pass = true;
  return res
};

StripBOMWrapper.prototype.end = function () {
  return this.decoder.end()
};

var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;

function mergeModules (target, module) {
  for (var key in module) {
    if (hasOwn(module, key)) {
      target[key] = module[key];
    }
  }
}

var mergeExports = mergeModules;

var encodings = {};

const require$$1$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(string_decoder);

var internal;
var hasRequiredInternal;

function requireInternal () {
	if (hasRequiredInternal) return internal;
	hasRequiredInternal = 1;
	var Buffer = safer_1.Buffer;

	// Export Node.js internal encodings.

	internal = {
	  // Encodings
	  utf8: { type: "_internal", bomAware: true },
	  cesu8: { type: "_internal", bomAware: true },
	  unicode11utf8: "utf8",

	  ucs2: { type: "_internal", bomAware: true },
	  utf16le: "ucs2",

	  binary: { type: "_internal" },
	  base64: { type: "_internal" },
	  hex: { type: "_internal" },

	  // Codec.
	  _internal: InternalCodec
	};

	// ------------------------------------------------------------------------------

	function InternalCodec (codecOptions, iconv) {
	  this.enc = codecOptions.encodingName;
	  this.bomAware = codecOptions.bomAware;

	  if (this.enc === "base64") { this.encoder = InternalEncoderBase64; } else if (this.enc === "utf8") { this.encoder = InternalEncoderUtf8; } else if (this.enc === "cesu8") {
	    this.enc = "utf8"; // Use utf8 for decoding.
	    this.encoder = InternalEncoderCesu8;

	    // Add decoder for versions of Node not supporting CESU-8
	    if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "") {
	      this.decoder = InternalDecoderCesu8;
	      this.defaultCharUnicode = iconv.defaultCharUnicode;
	    }
	  }
	}

	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;

	// ------------------------------------------------------------------------------

	// We use node.js internal decoder. Its signature is the same as ours.
	var StringDecoder = require$$1$1.StringDecoder;

	function InternalDecoder (options, codec) {
	  this.decoder = new StringDecoder(codec.enc);
	}

	InternalDecoder.prototype.write = function (buf) {
	  if (!Buffer.isBuffer(buf)) {
	    buf = Buffer.from(buf);
	  }

	  return this.decoder.write(buf)
	};

	InternalDecoder.prototype.end = function () {
	  return this.decoder.end()
	};

	// ------------------------------------------------------------------------------
	// Encoder is mostly trivial

	function InternalEncoder (options, codec) {
	  this.enc = codec.enc;
	}

	InternalEncoder.prototype.write = function (str) {
	  return Buffer.from(str, this.enc)
	};

	InternalEncoder.prototype.end = function () {
	};

	// ------------------------------------------------------------------------------
	// Except base64 encoder, which must keep its state.

	function InternalEncoderBase64 (options, codec) {
	  this.prevStr = "";
	}

	InternalEncoderBase64.prototype.write = function (str) {
	  str = this.prevStr + str;
	  var completeQuads = str.length - (str.length % 4);
	  this.prevStr = str.slice(completeQuads);
	  str = str.slice(0, completeQuads);

	  return Buffer.from(str, "base64")
	};

	InternalEncoderBase64.prototype.end = function () {
	  return Buffer.from(this.prevStr, "base64")
	};

	// ------------------------------------------------------------------------------
	// CESU-8 encoder is also special.

	function InternalEncoderCesu8 (options, codec) {
	}

	InternalEncoderCesu8.prototype.write = function (str) {
	  var buf = Buffer.alloc(str.length * 3); var bufIdx = 0;
	  for (var i = 0; i < str.length; i++) {
	    var charCode = str.charCodeAt(i);
	    // Naive implementation, but it works because CESU-8 is especially easy
	    // to convert from UTF-16 (which all JS strings are encoded in).
	    if (charCode < 0x80) { buf[bufIdx++] = charCode; } else if (charCode < 0x800) {
	      buf[bufIdx++] = 0xC0 + (charCode >>> 6);
	      buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	    } else { // charCode will always be < 0x10000 in javascript.
	      buf[bufIdx++] = 0xE0 + (charCode >>> 12);
	      buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
	      buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	    }
	  }
	  return buf.slice(0, bufIdx)
	};

	InternalEncoderCesu8.prototype.end = function () {
	};

	// ------------------------------------------------------------------------------
	// CESU-8 decoder is not implemented in Node v4.0+

	function InternalDecoderCesu8 (options, codec) {
	  this.acc = 0;
	  this.contBytes = 0;
	  this.accBytes = 0;
	  this.defaultCharUnicode = codec.defaultCharUnicode;
	}

	InternalDecoderCesu8.prototype.write = function (buf) {
	  var acc = this.acc; var contBytes = this.contBytes; var accBytes = this.accBytes;
	  var res = "";
	  for (var i = 0; i < buf.length; i++) {
	    var curByte = buf[i];
	    if ((curByte & 0xC0) !== 0x80) { // Leading byte
	      if (contBytes > 0) { // Previous code is invalid
	        res += this.defaultCharUnicode;
	        contBytes = 0;
	      }

	      if (curByte < 0x80) { // Single-byte code
	        res += String.fromCharCode(curByte);
	      } else if (curByte < 0xE0) { // Two-byte code
	        acc = curByte & 0x1F;
	        contBytes = 1; accBytes = 1;
	      } else if (curByte < 0xF0) { // Three-byte code
	        acc = curByte & 0x0F;
	        contBytes = 2; accBytes = 1;
	      } else { // Four or more are not supported for CESU-8.
	        res += this.defaultCharUnicode;
	      }
	    } else { // Continuation byte
	      if (contBytes > 0) { // We're waiting for it.
	        acc = (acc << 6) | (curByte & 0x3f);
	        contBytes--; accBytes++;
	        if (contBytes === 0) {
	          // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
	          if (accBytes === 2 && acc < 0x80 && acc > 0) {
	            res += this.defaultCharUnicode;
	          } else if (accBytes === 3 && acc < 0x800) {
	            res += this.defaultCharUnicode;
	          } else {
	            // Actually add character.
	            res += String.fromCharCode(acc);
	          }
	        }
	      } else { // Unexpected continuation byte
	        res += this.defaultCharUnicode;
	      }
	    }
	  }
	  this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
	  return res
	};

	InternalDecoderCesu8.prototype.end = function () {
	  var res = 0;
	  if (this.contBytes > 0) { res += this.defaultCharUnicode; }
	  return res
	};

	// ------------------------------------------------------------------------------
	// check the chunk boundaries for surrogate pair

	function InternalEncoderUtf8 (options, codec) {
	  this.highSurrogate = "";
	}

	InternalEncoderUtf8.prototype.write = function (str) {
	  if (this.highSurrogate) {
	    str = this.highSurrogate + str;
	    this.highSurrogate = "";
	  }

	  if (str.length > 0) {
	    var charCode = str.charCodeAt(str.length - 1);
	    if (charCode >= 0xd800 && charCode < 0xdc00) {
	      this.highSurrogate = str[str.length - 1];
	      str = str.slice(0, str.length - 1);
	    }
	  }

	  return Buffer.from(str, this.enc)
	};

	InternalEncoderUtf8.prototype.end = function () {
	  if (this.highSurrogate) {
	    var str = this.highSurrogate;
	    this.highSurrogate = "";
	    return Buffer.from(str, this.enc)
	  }
	};
	return internal;
}

var utf32 = {};

var hasRequiredUtf32;

function requireUtf32 () {
	if (hasRequiredUtf32) return utf32;
	hasRequiredUtf32 = 1;

	var Buffer = safer_1.Buffer;

	// == UTF32-LE/BE codec. ==========================================================

	utf32._utf32 = Utf32Codec;

	function Utf32Codec (codecOptions, iconv) {
	  this.iconv = iconv;
	  this.bomAware = true;
	  this.isLE = codecOptions.isLE;
	}

	utf32.utf32le = { type: "_utf32", isLE: true };
	utf32.utf32be = { type: "_utf32", isLE: false };

	// Aliases
	utf32.ucs4le = "utf32le";
	utf32.ucs4be = "utf32be";

	Utf32Codec.prototype.encoder = Utf32Encoder;
	Utf32Codec.prototype.decoder = Utf32Decoder;

	// -- Encoding

	function Utf32Encoder (options, codec) {
	  this.isLE = codec.isLE;
	  this.highSurrogate = 0;
	}

	Utf32Encoder.prototype.write = function (str) {
	  var src = Buffer.from(str, "ucs2");
	  var dst = Buffer.alloc(src.length * 2);
	  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
	  var offset = 0;

	  for (var i = 0; i < src.length; i += 2) {
	    var code = src.readUInt16LE(i);
	    var isHighSurrogate = (code >= 0xD800 && code < 0xDC00);
	    var isLowSurrogate = (code >= 0xDC00 && code < 0xE000);

	    if (this.highSurrogate) {
	      if (isHighSurrogate || !isLowSurrogate) {
	        // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
	        // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
	        // (technically wrong, but expected by some applications, like Windows file names).
	        write32.call(dst, this.highSurrogate, offset);
	        offset += 4;
	      } else {
	        // Create 32-bit value from high and low surrogates;
	        var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000;

	        write32.call(dst, codepoint, offset);
	        offset += 4;
	        this.highSurrogate = 0;

	        continue
	      }
	    }

	    if (isHighSurrogate) { this.highSurrogate = code; } else {
	      // Even if the current character is a low surrogate, with no previous high surrogate, we'll
	      // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
	      // unpaired high surrogates.
	      write32.call(dst, code, offset);
	      offset += 4;
	      this.highSurrogate = 0;
	    }
	  }

	  if (offset < dst.length) { dst = dst.slice(0, offset); }

	  return dst
	};

	Utf32Encoder.prototype.end = function () {
	  // Treat any leftover high surrogate as a semi-valid independent character.
	  if (!this.highSurrogate) { return }

	  var buf = Buffer.alloc(4);

	  if (this.isLE) { buf.writeUInt32LE(this.highSurrogate, 0); } else { buf.writeUInt32BE(this.highSurrogate, 0); }

	  this.highSurrogate = 0;

	  return buf
	};

	// -- Decoding

	function Utf32Decoder (options, codec) {
	  this.isLE = codec.isLE;
	  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
	  this.overflow = [];
	}

	Utf32Decoder.prototype.write = function (src) {
	  if (src.length === 0) { return "" }

	  var i = 0;
	  var codepoint = 0;
	  var dst = Buffer.alloc(src.length + 4);
	  var offset = 0;
	  var isLE = this.isLE;
	  var overflow = this.overflow;
	  var badChar = this.badChar;

	  if (overflow.length > 0) {
	    for (; i < src.length && overflow.length < 4; i++) { overflow.push(src[i]); }

	    if (overflow.length === 4) {
	      // NOTE: codepoint is a signed int32 and can be negative.
	      // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
	      if (isLE) {
	        codepoint = overflow[i] | (overflow[i + 1] << 8) | (overflow[i + 2] << 16) | (overflow[i + 3] << 24);
	      } else {
	        codepoint = overflow[i + 3] | (overflow[i + 2] << 8) | (overflow[i + 1] << 16) | (overflow[i] << 24);
	      }
	      overflow.length = 0;

	      offset = _writeCodepoint(dst, offset, codepoint, badChar);
	    }
	  }

	  // Main loop. Should be as optimized as possible.
	  for (; i < src.length - 3; i += 4) {
	    // NOTE: codepoint is a signed int32 and can be negative.
	    if (isLE) {
	      codepoint = src[i] | (src[i + 1] << 8) | (src[i + 2] << 16) | (src[i + 3] << 24);
	    } else {
	      codepoint = src[i + 3] | (src[i + 2] << 8) | (src[i + 1] << 16) | (src[i] << 24);
	    }
	    offset = _writeCodepoint(dst, offset, codepoint, badChar);
	  }

	  // Keep overflowing bytes.
	  for (; i < src.length; i++) {
	    overflow.push(src[i]);
	  }

	  return dst.slice(0, offset).toString("ucs2")
	};

	function _writeCodepoint (dst, offset, codepoint, badChar) {
	  // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
	  if (codepoint < 0 || codepoint > 0x10FFFF) {
	    // Not a valid Unicode codepoint
	    codepoint = badChar;
	  }

	  // Ephemeral Planes: Write high surrogate.
	  if (codepoint >= 0x10000) {
	    codepoint -= 0x10000;

	    var high = 0xD800 | (codepoint >> 10);
	    dst[offset++] = high & 0xff;
	    dst[offset++] = high >> 8;

	    // Low surrogate is written below.
	    var codepoint = 0xDC00 | (codepoint & 0x3FF);
	  }

	  // Write BMP char or low surrogate.
	  dst[offset++] = codepoint & 0xff;
	  dst[offset++] = codepoint >> 8;

	  return offset
	}
	Utf32Decoder.prototype.end = function () {
	  this.overflow.length = 0;
	};

	// == UTF-32 Auto codec =============================================================
	// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
	// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
	// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

	// Encoder prepends BOM (which can be overridden with (addBOM: false}).

	utf32.utf32 = Utf32AutoCodec;
	utf32.ucs4 = "utf32";

	function Utf32AutoCodec (options, iconv) {
	  this.iconv = iconv;
	}

	Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
	Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

	// -- Encoding

	function Utf32AutoEncoder (options, codec) {
	  options = options || {};

	  if (options.addBOM === undefined) {
	    options.addBOM = true;
	  }

	  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
	}

	Utf32AutoEncoder.prototype.write = function (str) {
	  return this.encoder.write(str)
	};

	Utf32AutoEncoder.prototype.end = function () {
	  return this.encoder.end()
	};

	// -- Decoding

	function Utf32AutoDecoder (options, codec) {
	  this.decoder = null;
	  this.initialBufs = [];
	  this.initialBufsLen = 0;
	  this.options = options || {};
	  this.iconv = codec.iconv;
	}

	Utf32AutoDecoder.prototype.write = function (buf) {
	  if (!this.decoder) {
	    // Codec is not chosen yet. Accumulate initial bytes.
	    this.initialBufs.push(buf);
	    this.initialBufsLen += buf.length;

	    if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)
	    { return "" }

	    // We have enough bytes -> detect endianness.
	    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
	    this.decoder = this.iconv.getDecoder(encoding, this.options);

	    var resStr = "";
	    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]); }

	    this.initialBufs.length = this.initialBufsLen = 0;
	    return resStr
	  }

	  return this.decoder.write(buf)
	};

	Utf32AutoDecoder.prototype.end = function () {
	  if (!this.decoder) {
	    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
	    this.decoder = this.iconv.getDecoder(encoding, this.options);

	    var resStr = "";
	    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]); }

	    var trail = this.decoder.end();
	    if (trail) { resStr += trail; }

	    this.initialBufs.length = this.initialBufsLen = 0;
	    return resStr
	  }

	  return this.decoder.end()
	};

	function detectEncoding (bufs, defaultEncoding) {
	  var b = [];
	  var charsProcessed = 0;
	  var invalidLE = 0; var invalidBE = 0;   // Number of invalid chars when decoded as LE or BE.
	  var bmpCharsLE = 0; var bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.

	  outerLoop:
	  for (var i = 0; i < bufs.length; i++) {
	    var buf = bufs[i];
	    for (var j = 0; j < buf.length; j++) {
	      b.push(buf[j]);
	      if (b.length === 4) {
	        if (charsProcessed === 0) {
	          // Check BOM first.
	          if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {
	            return "utf-32le"
	          }
	          if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {
	            return "utf-32be"
	          }
	        }

	        if (b[0] !== 0 || b[1] > 0x10) invalidBE++;
	        if (b[3] !== 0 || b[2] > 0x10) invalidLE++;

	        if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
	        if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;

	        b.length = 0;
	        charsProcessed++;

	        if (charsProcessed >= 100) {
	          break outerLoop
	        }
	      }
	    }
	  }

	  // Make decisions.
	  if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be"
	  if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le"

	  // Couldn't decide (likely all zeros or not enough data).
	  return defaultEncoding || "utf-32le"
	}
	return utf32;
}

var utf16 = {};

var hasRequiredUtf16;

function requireUtf16 () {
	if (hasRequiredUtf16) return utf16;
	hasRequiredUtf16 = 1;
	var Buffer = safer_1.Buffer;

	// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

	// == UTF16-BE codec. ==========================================================

	utf16.utf16be = Utf16BECodec;
	function Utf16BECodec () {
	}

	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;

	// -- Encoding

	function Utf16BEEncoder () {
	}

	Utf16BEEncoder.prototype.write = function (str) {
	  var buf = Buffer.from(str, "ucs2");
	  for (var i = 0; i < buf.length; i += 2) {
	    var tmp = buf[i]; buf[i] = buf[i + 1]; buf[i + 1] = tmp;
	  }
	  return buf
	};

	Utf16BEEncoder.prototype.end = function () {
	};

	// -- Decoding

	function Utf16BEDecoder () {
	  this.overflowByte = -1;
	}

	Utf16BEDecoder.prototype.write = function (buf) {
	  if (buf.length == 0) { return "" }

	  var buf2 = Buffer.alloc(buf.length + 1);
	  var i = 0; var j = 0;

	  if (this.overflowByte !== -1) {
	    buf2[0] = buf[0];
	    buf2[1] = this.overflowByte;
	    i = 1; j = 2;
	  }

	  for (; i < buf.length - 1; i += 2, j += 2) {
	    buf2[j] = buf[i + 1];
	    buf2[j + 1] = buf[i];
	  }

	  this.overflowByte = (i == buf.length - 1) ? buf[buf.length - 1] : -1;

	  return buf2.slice(0, j).toString("ucs2")
	};

	Utf16BEDecoder.prototype.end = function () {
	  this.overflowByte = -1;
	};

	// == UTF-16 codec =============================================================
	// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
	// Defaults to UTF-16LE, as it's prevalent and default in Node.
	// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
	// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

	// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

	utf16.utf16 = Utf16Codec;
	function Utf16Codec (codecOptions, iconv) {
	  this.iconv = iconv;
	}

	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;

	// -- Encoding (pass-through)

	function Utf16Encoder (options, codec) {
	  options = options || {};
	  if (options.addBOM === undefined) { options.addBOM = true; }
	  this.encoder = codec.iconv.getEncoder("utf-16le", options);
	}

	Utf16Encoder.prototype.write = function (str) {
	  return this.encoder.write(str)
	};

	Utf16Encoder.prototype.end = function () {
	  return this.encoder.end()
	};

	// -- Decoding

	function Utf16Decoder (options, codec) {
	  this.decoder = null;
	  this.initialBufs = [];
	  this.initialBufsLen = 0;

	  this.options = options || {};
	  this.iconv = codec.iconv;
	}

	Utf16Decoder.prototype.write = function (buf) {
	  if (!this.decoder) {
	    // Codec is not chosen yet. Accumulate initial bytes.
	    this.initialBufs.push(buf);
	    this.initialBufsLen += buf.length;

	    if (this.initialBufsLen < 16) // We need more bytes to use space heuristic (see below)
	    { return "" }

	    // We have enough bytes -> detect endianness.
	    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
	    this.decoder = this.iconv.getDecoder(encoding, this.options);

	    var resStr = "";
	    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]); }

	    this.initialBufs.length = this.initialBufsLen = 0;
	    return resStr
	  }

	  return this.decoder.write(buf)
	};

	Utf16Decoder.prototype.end = function () {
	  if (!this.decoder) {
	    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
	    this.decoder = this.iconv.getDecoder(encoding, this.options);

	    var resStr = "";
	    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]); }

	    var trail = this.decoder.end();
	    if (trail) { resStr += trail; }

	    this.initialBufs.length = this.initialBufsLen = 0;
	    return resStr
	  }
	  return this.decoder.end()
	};

	function detectEncoding (bufs, defaultEncoding) {
	  var b = [];
	  var charsProcessed = 0;
	  // Number of ASCII chars when decoded as LE or BE.
	  var asciiCharsLE = 0;
	  var asciiCharsBE = 0;

	  outerLoop:
	  for (var i = 0; i < bufs.length; i++) {
	    var buf = bufs[i];
	    for (var j = 0; j < buf.length; j++) {
	      b.push(buf[j]);
	      if (b.length === 2) {
	        if (charsProcessed === 0) {
	          // Check BOM first.
	          if (b[0] === 0xFF && b[1] === 0xFE) return "utf-16le"
	          if (b[0] === 0xFE && b[1] === 0xFF) return "utf-16be"
	        }

	        if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
	        if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;

	        b.length = 0;
	        charsProcessed++;

	        if (charsProcessed >= 100) {
	          break outerLoop
	        }
	      }
	    }
	  }

	  // Make decisions.
	  // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
	  // So, we count ASCII as if it was LE or BE, and decide from that.
	  if (asciiCharsBE > asciiCharsLE) return "utf-16be"
	  if (asciiCharsBE < asciiCharsLE) return "utf-16le"

	  // Couldn't decide (likely all zeros or not enough data).
	  return defaultEncoding || "utf-16le"
	}
	return utf16;
}

var utf7 = {};

var hasRequiredUtf7;

function requireUtf7 () {
	if (hasRequiredUtf7) return utf7;
	hasRequiredUtf7 = 1;
	var Buffer = safer_1.Buffer;

	// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
	// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

	utf7.utf7 = Utf7Codec;
	utf7.unicode11utf7 = "utf7"; // Alias UNICODE-1-1-UTF-7
	function Utf7Codec (codecOptions, iconv) {
	  this.iconv = iconv;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;

	// -- Encoding

	// Why scape ()?./?
	// eslint-disable-next-line no-useless-escape
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

	function Utf7Encoder (options, codec) {
	  this.iconv = codec.iconv;
	}

	Utf7Encoder.prototype.write = function (str) {
	  // Naive implementation.
	  // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
	  return Buffer.from(str.replace(nonDirectChars, function (chunk) {
	    return "+" + (chunk === "+"
	      ? ""
	      : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) +
	            "-"
	  }.bind(this)))
	};

	Utf7Encoder.prototype.end = function () {
	};

	// -- Decoding

	function Utf7Decoder (options, codec) {
	  this.iconv = codec.iconv;
	  this.inBase64 = false;
	  this.base64Accum = "";
	}

	// Why scape /?
	// eslint-disable-next-line no-useless-escape
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++) { base64Chars[i] = base64Regex.test(String.fromCharCode(i)); }

	var plusChar = "+".charCodeAt(0);
	var minusChar = "-".charCodeAt(0);
	var andChar = "&".charCodeAt(0);

	Utf7Decoder.prototype.write = function (buf) {
	  var res = ""; var lastI = 0;
	  var inBase64 = this.inBase64;
	  var base64Accum = this.base64Accum;

	  // The decoder is more involved as we must handle chunks in stream.

	  for (var i = 0; i < buf.length; i++) {
	    if (!inBase64) { // We're in direct mode.
	      // Write direct chars until '+'
	      if (buf[i] == plusChar) {
	        res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	        lastI = i + 1;
	        inBase64 = true;
	      }
	    } else { // We decode base64.
	      if (!base64Chars[buf[i]]) { // Base64 ended.
	        if (i == lastI && buf[i] == minusChar) { // "+-" -> "+"
	          res += "+";
	        } else {
	          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
	          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
	        }

	        if (buf[i] != minusChar) // Minus is absorbed after base64.
	        { i--; }

	        lastI = i + 1;
	        inBase64 = false;
	        base64Accum = "";
	      }
	    }
	  }

	  if (!inBase64) {
	    res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	  } else {
	    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");

	    var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	    base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	    b64str = b64str.slice(0, canBeDecoded);

	    res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
	  }

	  this.inBase64 = inBase64;
	  this.base64Accum = base64Accum;

	  return res
	};

	Utf7Decoder.prototype.end = function () {
	  var res = "";
	  if (this.inBase64 && this.base64Accum.length > 0) { res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be"); }

	  this.inBase64 = false;
	  this.base64Accum = "";
	  return res
	};

	// UTF-7-IMAP codec.
	// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
	// Differences:
	//  * Base64 part is started by "&" instead of "+"
	//  * Direct characters are 0x20-0x7E, except "&" (0x26)
	//  * In Base64, "," is used instead of "/"
	//  * Base64 must not be used to represent direct characters.
	//  * No implicit shift back from Base64 (should always end with '-')
	//  * String must end in non-shifted position.
	//  * "-&" while in base64 is not allowed.

	utf7.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec (codecOptions, iconv) {
	  this.iconv = iconv;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;

	// -- Encoding

	function Utf7IMAPEncoder (options, codec) {
	  this.iconv = codec.iconv;
	  this.inBase64 = false;
	  this.base64Accum = Buffer.alloc(6);
	  this.base64AccumIdx = 0;
	}

	Utf7IMAPEncoder.prototype.write = function (str) {
	  var inBase64 = this.inBase64;
	  var base64Accum = this.base64Accum;
	  var base64AccumIdx = this.base64AccumIdx;
	  var buf = Buffer.alloc(str.length * 5 + 10); var bufIdx = 0;

	  for (var i = 0; i < str.length; i++) {
	    var uChar = str.charCodeAt(i);
	    if (uChar >= 0x20 && uChar <= 0x7E) { // Direct character or '&'.
	      if (inBase64) {
	        if (base64AccumIdx > 0) {
	          bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
	          base64AccumIdx = 0;
	        }

	        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	        inBase64 = false;
	      }

	      if (!inBase64) {
	        buf[bufIdx++] = uChar; // Write direct character

	        if (uChar === andChar)  // Ampersand -> '&-'
	        { buf[bufIdx++] = minusChar; }
	      }
	    } else { // Non-direct character
	      if (!inBase64) {
	        buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
	        inBase64 = true;
	      }
	      if (inBase64) {
	        base64Accum[base64AccumIdx++] = uChar >> 8;
	        base64Accum[base64AccumIdx++] = uChar & 0xFF;

	        if (base64AccumIdx == base64Accum.length) {
	          bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
	          base64AccumIdx = 0;
	        }
	      }
	    }
	  }

	  this.inBase64 = inBase64;
	  this.base64AccumIdx = base64AccumIdx;

	  return buf.slice(0, bufIdx)
	};

	Utf7IMAPEncoder.prototype.end = function () {
	  var buf = Buffer.alloc(10); var bufIdx = 0;
	  if (this.inBase64) {
	    if (this.base64AccumIdx > 0) {
	      bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
	      this.base64AccumIdx = 0;
	    }

	    buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	    this.inBase64 = false;
	  }

	  return buf.slice(0, bufIdx)
	};

	// -- Decoding

	function Utf7IMAPDecoder (options, codec) {
	  this.iconv = codec.iconv;
	  this.inBase64 = false;
	  this.base64Accum = "";
	}

	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[",".charCodeAt(0)] = true;

	Utf7IMAPDecoder.prototype.write = function (buf) {
	  var res = ""; var lastI = 0;
	  var inBase64 = this.inBase64;
	  var base64Accum = this.base64Accum;

	  // The decoder is more involved as we must handle chunks in stream.
	  // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

	  for (var i = 0; i < buf.length; i++) {
	    if (!inBase64) { // We're in direct mode.
	      // Write direct chars until '&'
	      if (buf[i] == andChar) {
	        res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	        lastI = i + 1;
	        inBase64 = true;
	      }
	    } else { // We decode base64.
	      if (!base64IMAPChars[buf[i]]) { // Base64 ended.
	        if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
	          res += "&";
	        } else {
	          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, "/");
	          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
	        }

	        if (buf[i] != minusChar) // Minus may be absorbed after base64.
	        { i--; }

	        lastI = i + 1;
	        inBase64 = false;
	        base64Accum = "";
	      }
	    }
	  }

	  if (!inBase64) {
	    res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	  } else {
	    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");

	    var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	    base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	    b64str = b64str.slice(0, canBeDecoded);

	    res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
	  }

	  this.inBase64 = inBase64;
	  this.base64Accum = base64Accum;

	  return res
	};

	Utf7IMAPDecoder.prototype.end = function () {
	  var res = "";
	  if (this.inBase64 && this.base64Accum.length > 0) { res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be"); }

	  this.inBase64 = false;
	  this.base64Accum = "";
	  return res
	};
	return utf7;
}

var sbcsCodec = {};

var hasRequiredSbcsCodec;

function requireSbcsCodec () {
	if (hasRequiredSbcsCodec) return sbcsCodec;
	hasRequiredSbcsCodec = 1;
	var Buffer = safer_1.Buffer;

	// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
	// correspond to encoded bytes (if 128 - then lower half is ASCII).

	sbcsCodec._sbcs = SBCSCodec;
	function SBCSCodec (codecOptions, iconv) {
	  if (!codecOptions) {
	    throw new Error("SBCS codec is called without the data.")
	  }

	  // Prepare char buffer for decoding.
	  if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)) {
	    throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)")
	  }

	  if (codecOptions.chars.length === 128) {
	    var asciiString = "";
	    for (var i = 0; i < 128; i++) {
	      asciiString += String.fromCharCode(i);
	    }
	    codecOptions.chars = asciiString + codecOptions.chars;
	  }

	  this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2");

	  // Encoding buffer.
	  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

	  for (var i = 0; i < codecOptions.chars.length; i++) {
	    encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
	  }

	  this.encodeBuf = encodeBuf;
	}

	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;

	function SBCSEncoder (options, codec) {
	  this.encodeBuf = codec.encodeBuf;
	}

	SBCSEncoder.prototype.write = function (str) {
	  var buf = Buffer.alloc(str.length);
	  for (var i = 0; i < str.length; i++) {
	    buf[i] = this.encodeBuf[str.charCodeAt(i)];
	  }

	  return buf
	};

	SBCSEncoder.prototype.end = function () {
	};

	function SBCSDecoder (options, codec) {
	  this.decodeBuf = codec.decodeBuf;
	}

	SBCSDecoder.prototype.write = function (buf) {
	  // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
	  var decodeBuf = this.decodeBuf;
	  var newBuf = Buffer.alloc(buf.length * 2);
	  var idx1 = 0; var idx2 = 0;
	  for (var i = 0; i < buf.length; i++) {
	    idx1 = buf[i] * 2; idx2 = i * 2;
	    newBuf[idx2] = decodeBuf[idx1];
	    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
	  }
	  return newBuf.toString("ucs2")
	};

	SBCSDecoder.prototype.end = function () {
	};
	return sbcsCodec;
}

var sbcsData;
var hasRequiredSbcsData;

function requireSbcsData () {
	if (hasRequiredSbcsData) return sbcsData;
	hasRequiredSbcsData = 1;

	// Manually added data to be used by sbcs codec in addition to generated one.

	sbcsData = {
	  // Not supported by iconv, not sure why.
	  10029: "maccenteuro",
	  maccenteuro: {
	    type: "_sbcs",
	    chars: ""
	  },

	  808: "cp808",
	  ibm808: "cp808",
	  cp808: {
	    type: "_sbcs",
	    chars: ""
	  },

	  mik: {
	    type: "_sbcs",
	    chars: ""
	  },

	  cp720: {
	    type: "_sbcs",
	    chars: "\x80\x81\x84\x86\x8d\x8e\x8f\x90\u0651\u0652\u064b\u064c\u064d\u064e\u064f\u0650\u00a0"
	  },

	  // Aliases of generated encodings.
	  ascii8bit: "ascii",
	  usascii: "ascii",
	  ansix34: "ascii",
	  ansix341968: "ascii",
	  ansix341986: "ascii",
	  csascii: "ascii",
	  cp367: "ascii",
	  ibm367: "ascii",
	  isoir6: "ascii",
	  iso646us: "ascii",
	  iso646irv: "ascii",
	  us: "ascii",

	  latin1: "iso88591",
	  latin2: "iso88592",
	  latin3: "iso88593",
	  latin4: "iso88594",
	  latin5: "iso88599",
	  latin6: "iso885910",
	  latin7: "iso885913",
	  latin8: "iso885914",
	  latin9: "iso885915",
	  latin10: "iso885916",

	  csisolatin1: "iso88591",
	  csisolatin2: "iso88592",
	  csisolatin3: "iso88593",
	  csisolatin4: "iso88594",
	  csisolatincyrillic: "iso88595",
	  csisolatinarabic: "iso88596",
	  csisolatingreek: "iso88597",
	  csisolatinhebrew: "iso88598",
	  csisolatin5: "iso88599",
	  csisolatin6: "iso885910",

	  l1: "iso88591",
	  l2: "iso88592",
	  l3: "iso88593",
	  l4: "iso88594",
	  l5: "iso88599",
	  l6: "iso885910",
	  l7: "iso885913",
	  l8: "iso885914",
	  l9: "iso885915",
	  l10: "iso885916",

	  isoir14: "iso646jp",
	  isoir57: "iso646cn",
	  isoir100: "iso88591",
	  isoir101: "iso88592",
	  isoir109: "iso88593",
	  isoir110: "iso88594",
	  isoir144: "iso88595",
	  isoir127: "iso88596",
	  isoir126: "iso88597",
	  isoir138: "iso88598",
	  isoir148: "iso88599",
	  isoir157: "iso885910",
	  isoir166: "tis620",
	  isoir179: "iso885913",
	  isoir199: "iso885914",
	  isoir203: "iso885915",
	  isoir226: "iso885916",

	  cp819: "iso88591",
	  ibm819: "iso88591",

	  cyrillic: "iso88595",

	  arabic: "iso88596",
	  arabic8: "iso88596",
	  ecma114: "iso88596",
	  asmo708: "iso88596",

	  greek: "iso88597",
	  greek8: "iso88597",
	  ecma118: "iso88597",
	  elot928: "iso88597",

	  hebrew: "iso88598",
	  hebrew8: "iso88598",

	  turkish: "iso88599",
	  turkish8: "iso88599",

	  thai: "iso885911",
	  thai8: "iso885911",

	  celtic: "iso885914",
	  celtic8: "iso885914",
	  isoceltic: "iso885914",

	  tis6200: "tis620",
	  tis62025291: "tis620",
	  tis62025330: "tis620",

	  10000: "macroman",
	  10006: "macgreek",
	  10007: "maccyrillic",
	  10079: "maciceland",
	  10081: "macturkish",

	  cspc8codepage437: "cp437",
	  cspc775baltic: "cp775",
	  cspc850multilingual: "cp850",
	  cspcp852: "cp852",
	  cspc862latinhebrew: "cp862",
	  cpgr: "cp869",

	  msee: "cp1250",
	  mscyrl: "cp1251",
	  msansi: "cp1252",
	  msgreek: "cp1253",
	  msturk: "cp1254",
	  mshebr: "cp1255",
	  msarab: "cp1256",
	  winbaltrim: "cp1257",

	  cp20866: "koi8r",
	  20866: "koi8r",
	  ibm878: "koi8r",
	  cskoi8r: "koi8r",

	  cp21866: "koi8u",
	  21866: "koi8u",
	  ibm1168: "koi8u",

	  strk10482002: "rk1048",

	  tcvn5712: "tcvn",
	  tcvn57121: "tcvn",

	  gb198880: "iso646cn",
	  cn: "iso646cn",

	  csiso14jisc6220ro: "iso646jp",
	  jisc62201969ro: "iso646jp",
	  jp: "iso646jp",

	  cshproman8: "hproman8",
	  r8: "hproman8",
	  roman8: "hproman8",
	  xroman8: "hproman8",
	  ibm1051: "hproman8",

	  mac: "macintosh",
	  csmacintosh: "macintosh"
	};
	return sbcsData;
}

var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;

function requireSbcsDataGenerated () {
	if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
	hasRequiredSbcsDataGenerated = 1;

	// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
	sbcsDataGenerated = {
	  "437": "cp437",
	  "737": "cp737",
	  "775": "cp775",
	  "850": "cp850",
	  "852": "cp852",
	  "855": "cp855",
	  "856": "cp856",
	  "857": "cp857",
	  "858": "cp858",
	  "860": "cp860",
	  "861": "cp861",
	  "862": "cp862",
	  "863": "cp863",
	  "864": "cp864",
	  "865": "cp865",
	  "866": "cp866",
	  "869": "cp869",
	  "874": "windows874",
	  "922": "cp922",
	  "1046": "cp1046",
	  "1124": "cp1124",
	  "1125": "cp1125",
	  "1129": "cp1129",
	  "1133": "cp1133",
	  "1161": "cp1161",
	  "1162": "cp1162",
	  "1163": "cp1163",
	  "1250": "windows1250",
	  "1251": "windows1251",
	  "1252": "windows1252",
	  "1253": "windows1253",
	  "1254": "windows1254",
	  "1255": "windows1255",
	  "1256": "windows1256",
	  "1257": "windows1257",
	  "1258": "windows1258",
	  "28591": "iso88591",
	  "28592": "iso88592",
	  "28593": "iso88593",
	  "28594": "iso88594",
	  "28595": "iso88595",
	  "28596": "iso88596",
	  "28597": "iso88597",
	  "28598": "iso88598",
	  "28599": "iso88599",
	  "28600": "iso885910",
	  "28601": "iso885911",
	  "28603": "iso885913",
	  "28604": "iso885914",
	  "28605": "iso885915",
	  "28606": "iso885916",
	  "windows874": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win874": "windows874",
	  "cp874": "windows874",
	  "windows1250": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1250": "windows1250",
	  "cp1250": "windows1250",
	  "windows1251": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1251": "windows1251",
	  "cp1251": "windows1251",
	  "windows1252": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1252": "windows1252",
	  "cp1252": "windows1252",
	  "windows1253": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1253": "windows1253",
	  "cp1253": "windows1253",
	  "windows1254": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1254": "windows1254",
	  "cp1254": "windows1254",
	  "windows1255": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1255": "windows1255",
	  "cp1255": "windows1255",
	  "windows1256": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1256": "windows1256",
	  "cp1256": "windows1256",
	  "windows1257": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1257": "windows1257",
	  "cp1257": "windows1257",
	  "windows1258": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1258": "windows1258",
	  "cp1258": "windows1258",
	  "iso88591": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28591": "iso88591",
	  "iso88592": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28592": "iso88592",
	  "iso88593": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28593": "iso88593",
	  "iso88594": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28594": "iso88594",
	  "iso88595": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28595": "iso88595",
	  "iso88596": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28596": "iso88596",
	  "iso88597": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28597": "iso88597",
	  "iso88598": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28598": "iso88598",
	  "iso88599": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28599": "iso88599",
	  "iso885910": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28600": "iso885910",
	  "iso885911": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28601": "iso885911",
	  "iso885913": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28603": "iso885913",
	  "iso885914": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28604": "iso885914",
	  "iso885915": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28605": "iso885915",
	  "iso885916": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28606": "iso885916",
	  "cp437": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm437": "cp437",
	  "csibm437": "cp437",
	  "cp737": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm737": "cp737",
	  "csibm737": "cp737",
	  "cp775": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm775": "cp775",
	  "csibm775": "cp775",
	  "cp850": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm850": "cp850",
	  "csibm850": "cp850",
	  "cp852": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm852": "cp852",
	  "csibm852": "cp852",
	  "cp855": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm855": "cp855",
	  "csibm855": "cp855",
	  "cp856": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm856": "cp856",
	  "csibm856": "cp856",
	  "cp857": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm857": "cp857",
	  "csibm857": "cp857",
	  "cp858": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm858": "cp858",
	  "csibm858": "cp858",
	  "cp860": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm860": "cp860",
	  "csibm860": "cp860",
	  "cp861": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm861": "cp861",
	  "csibm861": "cp861",
	  "cp862": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm862": "cp862",
	  "csibm862": "cp862",
	  "cp863": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm863": "cp863",
	  "csibm863": "cp863",
	  "cp864": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "ibm864": "cp864",
	  "csibm864": "cp864",
	  "cp865": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm865": "cp865",
	  "csibm865": "cp865",
	  "cp866": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm866": "cp866",
	  "csibm866": "cp866",
	  "cp869": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm869": "cp869",
	  "csibm869": "cp869",
	  "cp922": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm922": "cp922",
	  "csibm922": "cp922",
	  "cp1046": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1046": "cp1046",
	  "csibm1046": "cp1046",
	  "cp1124": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1124": "cp1124",
	  "csibm1124": "cp1124",
	  "cp1125": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1125": "cp1125",
	  "csibm1125": "cp1125",
	  "cp1129": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1129": "cp1129",
	  "csibm1129": "cp1129",
	  "cp1133": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1133": "cp1133",
	  "csibm1133": "cp1133",
	  "cp1161": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1161": "cp1161",
	  "csibm1161": "cp1161",
	  "cp1162": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1162": "cp1162",
	  "csibm1162": "cp1162",
	  "cp1163": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1163": "cp1163",
	  "csibm1163": "cp1163",
	  "maccroatian": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maccyrillic": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macgreek": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maciceland": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macroman": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macromania": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macthai": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macturkish": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macukraine": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8r": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8u": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8ru": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8t": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "armscii8": {
	    "type": "_sbcs",
	    "chars": ")(.,-"
	  },
	  "rk1048": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tcvn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "georgianacademy": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "georgianps": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "pt154": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "viscii": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "iso646cn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "iso646jp": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "hproman8": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macintosh": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ascii": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tis620": {
	    "type": "_sbcs",
	    "chars": ""
	  }
	};
	return sbcsDataGenerated;
}

var dbcsCodec = {};

var hasRequiredDbcsCodec;

function requireDbcsCodec () {
	if (hasRequiredDbcsCodec) return dbcsCodec;
	hasRequiredDbcsCodec = 1;
	var Buffer = safer_1.Buffer;

	// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
	// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
	// To save memory and loading time, we read table files only when requested.

	dbcsCodec._dbcs = DBCSCodec;

	var UNASSIGNED = -1;
	var GB18030_CODE = -2;
	var SEQ_START = -10;
	var NODE_START = -1e3;
	var UNASSIGNED_NODE = new Array(0x100);
	var DEF_CHAR = -1;

	for (var i = 0; i < 0x100; i++) { UNASSIGNED_NODE[i] = UNASSIGNED; }

	// Class DBCSCodec reads and initializes mapping tables.
	function DBCSCodec (codecOptions, iconv) {
	  this.encodingName = codecOptions.encodingName;
	  if (!codecOptions) { throw new Error("DBCS codec is called without the data.") }
	  if (!codecOptions.table) { throw new Error("Encoding '" + this.encodingName + "' has no data.") }

	  // Load tables.
	  var mappingTable = codecOptions.table();

	  // Decode tables: MBCS -> Unicode.

	  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
	  // Trie root is decodeTables[0].
	  // Values: >=  0 -> unicode character code. can be > 0xFFFF
	  //         == UNASSIGNED -> unknown/unassigned sequence.
	  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
	  //         <= NODE_START -> index of the next node in our trie to process next byte.
	  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
	  this.decodeTables = [];
	  this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

	  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here.
	  this.decodeTableSeq = [];

	  // Actual mapping tables consist of chunks. Use them to fill up decode tables.
	  for (var i = 0; i < mappingTable.length; i++) { this._addDecodeChunk(mappingTable[i]); }

	  // Load & create GB18030 tables when needed.
	  if (typeof codecOptions.gb18030 === "function") {
	    this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

	    // Add GB18030 common decode nodes.
	    var commonThirdByteNodeIdx = this.decodeTables.length;
	    this.decodeTables.push(UNASSIGNED_NODE.slice(0));

	    var commonFourthByteNodeIdx = this.decodeTables.length;
	    this.decodeTables.push(UNASSIGNED_NODE.slice(0));

	    // Fill out the tree
	    var firstByteNode = this.decodeTables[0];
	    for (var i = 0x81; i <= 0xFE; i++) {
	      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
	      for (var j = 0x30; j <= 0x39; j++) {
	        if (secondByteNode[j] === UNASSIGNED) {
	          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
	        } else if (secondByteNode[j] > NODE_START) {
	          throw new Error("gb18030 decode tables conflict at byte 2")
	        }

	        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
	        for (var k = 0x81; k <= 0xFE; k++) {
	          if (thirdByteNode[k] === UNASSIGNED) {
	            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
	          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
	            continue
	          } else if (thirdByteNode[k] > NODE_START) {
	            throw new Error("gb18030 decode tables conflict at byte 3")
	          }

	          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
	          for (var l = 0x30; l <= 0x39; l++) {
	            if (fourthByteNode[l] === UNASSIGNED) { fourthByteNode[l] = GB18030_CODE; }
	          }
	        }
	      }
	    }
	  }

	  this.defaultCharUnicode = iconv.defaultCharUnicode;

	  // Encode tables: Unicode -> DBCS.

	  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
	  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
	  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
	  //         == UNASSIGNED -> no conversion found. Output a default char.
	  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
	  this.encodeTable = [];

	  // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
	  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
	  // means end of sequence (needed when one sequence is a strict subsequence of another).
	  // Objects are kept separately from encodeTable to increase performance.
	  this.encodeTableSeq = [];

	  // Some chars can be decoded, but need not be encoded.
	  var skipEncodeChars = {};
	  if (codecOptions.encodeSkipVals) {
	    for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
	      var val = codecOptions.encodeSkipVals[i];
	      if (typeof val === "number") { skipEncodeChars[val] = true; } else {
	        for (var j = val.from; j <= val.to; j++) { skipEncodeChars[j] = true; }
	      }
	    }
	  }

	  // Use decode trie to recursively fill out encode tables.
	  this._fillEncodeTable(0, 0, skipEncodeChars);

	  // Add more encoding pairs when needed.
	  if (codecOptions.encodeAdd) {
	    for (var uChar in codecOptions.encodeAdd) {
	      if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) { this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]); }
	    }
	  }

	  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
	  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
	  if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
	}

	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;

	// Decoder helpers
	DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
	  var bytes = [];
	  for (; addr > 0; addr >>>= 8) { bytes.push(addr & 0xFF); }
	  if (bytes.length == 0) { bytes.push(0); }

	  var node = this.decodeTables[0];
	  for (var i = bytes.length - 1; i > 0; i--) { // Traverse nodes deeper into the trie.
	    var val = node[bytes[i]];

	    if (val == UNASSIGNED) { // Create new node.
	      node[bytes[i]] = NODE_START - this.decodeTables.length;
	      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
	    } else if (val <= NODE_START) { // Existing node.
	      node = this.decodeTables[NODE_START - val];
	    } else { throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16)) }
	  }
	  return node
	};

	DBCSCodec.prototype._addDecodeChunk = function (chunk) {
	  // First element of chunk is the hex mbcs code where we start.
	  var curAddr = parseInt(chunk[0], 16);

	  // Choose the decoding node where we'll write our chars.
	  var writeTable = this._getDecodeTrieNode(curAddr);
	  curAddr = curAddr & 0xFF;

	  // Write all other elements of the chunk to the table.
	  for (var k = 1; k < chunk.length; k++) {
	    var part = chunk[k];
	    if (typeof part === "string") { // String, write as-is.
	      for (var l = 0; l < part.length;) {
	        var code = part.charCodeAt(l++);
	        if (code >= 0xD800 && code < 0xDC00) { // Decode surrogate
	          var codeTrail = part.charCodeAt(l++);
	          if (codeTrail >= 0xDC00 && codeTrail < 0xE000) { writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00); } else { throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]) }
	        } else if (code > 0x0FF0 && code <= 0x0FFF) { // Character sequence (our own encoding used)
	          var len = 0xFFF - code + 2;
	          var seq = [];
	          for (var m = 0; m < len; m++) { seq.push(part.charCodeAt(l++)); } // Simple variation: don't support surrogates or subsequences in seq.

	          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
	          this.decodeTableSeq.push(seq);
	        } else { writeTable[curAddr++] = code; } // Basic char
	      }
	    } else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
	      var charCode = writeTable[curAddr - 1] + 1;
	      for (var l = 0; l < part; l++) { writeTable[curAddr++] = charCode++; }
	    } else { throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]) }
	  }
	  if (curAddr > 0xFF) { throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr) }
	};

	// Encoder helpers
	DBCSCodec.prototype._getEncodeBucket = function (uCode) {
	  var high = uCode >> 8; // This could be > 0xFF because of astral characters.
	  if (this.encodeTable[high] === undefined) {
	    this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
	  } // Create bucket on demand.
	  return this.encodeTable[high]
	};

	DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
	  var bucket = this._getEncodeBucket(uCode);
	  var low = uCode & 0xFF;
	  if (bucket[low] <= SEQ_START) { this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; } // There's already a sequence, set a single-char subsequence of it.
	  else if (bucket[low] == UNASSIGNED) { bucket[low] = dbcsCode; }
	};

	DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
	  // Get the root of character tree according to first character of the sequence.
	  var uCode = seq[0];
	  var bucket = this._getEncodeBucket(uCode);
	  var low = uCode & 0xFF;

	  var node;
	  if (bucket[low] <= SEQ_START) {
	    // There's already a sequence with  - use it.
	    node = this.encodeTableSeq[SEQ_START - bucket[low]];
	  } else {
	    // There was no sequence object - allocate a new one.
	    node = {};
	    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
	    bucket[low] = SEQ_START - this.encodeTableSeq.length;
	    this.encodeTableSeq.push(node);
	  }

	  // Traverse the character tree, allocating new nodes as needed.
	  for (var j = 1; j < seq.length - 1; j++) {
	    var oldVal = node[uCode];
	    if (typeof oldVal === "object") { node = oldVal; } else {
	      node = node[uCode] = {};
	      if (oldVal !== undefined) { node[DEF_CHAR] = oldVal; }
	    }
	  }

	  // Set the leaf to given dbcsCode.
	  uCode = seq[seq.length - 1];
	  node[uCode] = dbcsCode;
	};

	DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
	  var node = this.decodeTables[nodeIdx];
	  var hasValues = false;
	  var subNodeEmpty = {};
	  for (var i = 0; i < 0x100; i++) {
	    var uCode = node[i];
	    var mbCode = prefix + i;
	    if (skipEncodeChars[mbCode]) { continue }

	    if (uCode >= 0) {
	      this._setEncodeChar(uCode, mbCode);
	      hasValues = true;
	    } else if (uCode <= NODE_START) {
	      var subNodeIdx = NODE_START - uCode;
	      if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).
	        var newPrefix = (mbCode << 8) >>> 0;  // NOTE: '>>> 0' keeps 32-bit num positive.
	        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) { hasValues = true; } else { subNodeEmpty[subNodeIdx] = true; }
	      }
	    } else if (uCode <= SEQ_START) {
	      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
	      hasValues = true;
	    }
	  }
	  return hasValues
	};

	// == Encoder ==================================================================

	function DBCSEncoder (options, codec) {
	  // Encoder state
	  this.leadSurrogate = -1;
	  this.seqObj = undefined;

	  // Static data
	  this.encodeTable = codec.encodeTable;
	  this.encodeTableSeq = codec.encodeTableSeq;
	  this.defaultCharSingleByte = codec.defCharSB;
	  this.gb18030 = codec.gb18030;
	}

	DBCSEncoder.prototype.write = function (str) {
	  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3));
	  var leadSurrogate = this.leadSurrogate;
	  var seqObj = this.seqObj;
	  var nextChar = -1;
	  var i = 0; var j = 0;

	  while (true) {
	    // 0. Get next character.
	    if (nextChar === -1) {
	      if (i == str.length) break
	      var uCode = str.charCodeAt(i++);
	    } else {
	      var uCode = nextChar;
	      nextChar = -1;
	    }

	    // 1. Handle surrogates.
	    if (uCode >= 0xD800 && uCode < 0xE000) { // Char is one of surrogates.
	      if (uCode < 0xDC00) { // We've got lead surrogate.
	        if (leadSurrogate === -1) {
	          leadSurrogate = uCode;
	          continue
	        } else {
	          leadSurrogate = uCode;
	          // Double lead surrogate found.
	          uCode = UNASSIGNED;
	        }
	      } else { // We've got trail surrogate.
	        if (leadSurrogate !== -1) {
	          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
	          leadSurrogate = -1;
	        } else {
	          // Incomplete surrogate pair - only trail surrogate found.
	          uCode = UNASSIGNED;
	        }
	      }
	    } else if (leadSurrogate !== -1) {
	      // Incomplete surrogate pair - only lead surrogate found.
	      nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
	      leadSurrogate = -1;
	    }

	    // 2. Convert uCode character.
	    var dbcsCode = UNASSIGNED;
	    if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
	      var resCode = seqObj[uCode];
	      if (typeof resCode === "object") { // Sequence continues.
	        seqObj = resCode;
	        continue
	      } else if (typeof resCode === "number") { // Sequence finished. Write it.
	        dbcsCode = resCode;
	      } else if (resCode == undefined) { // Current character is not part of the sequence.
	        // Try default character for this sequence
	        resCode = seqObj[DEF_CHAR];
	        if (resCode !== undefined) {
	          dbcsCode = resCode; // Found. Write it.
	          nextChar = uCode; // Current character will be written too in the next iteration.
	        }
	      }
	      seqObj = undefined;
	    } else if (uCode >= 0) {  // Regular character
	      var subtable = this.encodeTable[uCode >> 8];
	      if (subtable !== undefined) { dbcsCode = subtable[uCode & 0xFF]; }

	      if (dbcsCode <= SEQ_START) { // Sequence start
	        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
	        continue
	      }

	      if (dbcsCode == UNASSIGNED && this.gb18030) {
	        // Use GB18030 algorithm to find character(s) to write.
	        var idx = findIdx(this.gb18030.uChars, uCode);
	        if (idx != -1) {
	          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
	          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
	          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
	          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
	          newBuf[j++] = 0x30 + dbcsCode;
	          continue
	        }
	      }
	    }

	    // 3. Write dbcsCode character.
	    if (dbcsCode === UNASSIGNED) { dbcsCode = this.defaultCharSingleByte; }

	    if (dbcsCode < 0x100) {
	      newBuf[j++] = dbcsCode;
	    } else if (dbcsCode < 0x10000) {
	      newBuf[j++] = dbcsCode >> 8;   // high byte
	      newBuf[j++] = dbcsCode & 0xFF; // low byte
	    } else if (dbcsCode < 0x1000000) {
	      newBuf[j++] = dbcsCode >> 16;
	      newBuf[j++] = (dbcsCode >> 8) & 0xFF;
	      newBuf[j++] = dbcsCode & 0xFF;
	    } else {
	      newBuf[j++] = dbcsCode >>> 24;
	      newBuf[j++] = (dbcsCode >>> 16) & 0xFF;
	      newBuf[j++] = (dbcsCode >>> 8) & 0xFF;
	      newBuf[j++] = dbcsCode & 0xFF;
	    }
	  }

	  this.seqObj = seqObj;
	  this.leadSurrogate = leadSurrogate;
	  return newBuf.slice(0, j)
	};

	DBCSEncoder.prototype.end = function () {
	  if (this.leadSurrogate === -1 && this.seqObj === undefined) { return } // All clean. Most often case.

	  var newBuf = Buffer.alloc(10); var j = 0;

	  if (this.seqObj) { // We're in the sequence.
	    var dbcsCode = this.seqObj[DEF_CHAR];
	    if (dbcsCode !== undefined) { // Write beginning of the sequence.
	      if (dbcsCode < 0x100) {
	        newBuf[j++] = dbcsCode;
	      } else {
	        newBuf[j++] = dbcsCode >> 8;   // high byte
	        newBuf[j++] = dbcsCode & 0xFF; // low byte
	      }
	    }
	    this.seqObj = undefined;
	  }

	  if (this.leadSurrogate !== -1) {
	    // Incomplete surrogate pair - only lead surrogate found.
	    newBuf[j++] = this.defaultCharSingleByte;
	    this.leadSurrogate = -1;
	  }

	  return newBuf.slice(0, j)
	};

	// Export for testing
	DBCSEncoder.prototype.findIdx = findIdx;

	// == Decoder ==================================================================

	function DBCSDecoder (options, codec) {
	  // Decoder state
	  this.nodeIdx = 0;
	  this.prevBytes = [];

	  // Static data
	  this.decodeTables = codec.decodeTables;
	  this.decodeTableSeq = codec.decodeTableSeq;
	  this.defaultCharUnicode = codec.defaultCharUnicode;
	  this.gb18030 = codec.gb18030;
	}

	DBCSDecoder.prototype.write = function (buf) {
	  var newBuf = Buffer.alloc(buf.length * 2);
	  var nodeIdx = this.nodeIdx;
	  var prevBytes = this.prevBytes; var prevOffset = this.prevBytes.length;
	  var seqStart = -this.prevBytes.length; // idx of the start of current parsed sequence.
	  var uCode;

	  for (var i = 0, j = 0; i < buf.length; i++) {
	    var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset];

	    // Lookup in current trie node.
	    var uCode = this.decodeTables[nodeIdx][curByte];

	    if (uCode >= 0) ; else if (uCode === UNASSIGNED) { // Unknown char.
	      // TODO: Callback with seq.
	      uCode = this.defaultCharUnicode.charCodeAt(0);
	      i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
	    } else if (uCode === GB18030_CODE) {
	      if (i >= 3) {
	        var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);
	      } else {
	        var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 +
	                          (((i - 2 >= 0) ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 +
	                          (((i - 1 >= 0) ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 +
	                          (curByte - 0x30);
	      }
	      var idx = findIdx(this.gb18030.gbChars, ptr);
	      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
	    } else if (uCode <= NODE_START) { // Go to next trie node.
	      nodeIdx = NODE_START - uCode;
	      continue
	    } else if (uCode <= SEQ_START) { // Output a sequence of chars.
	      var seq = this.decodeTableSeq[SEQ_START - uCode];
	      for (var k = 0; k < seq.length - 1; k++) {
	        uCode = seq[k];
	        newBuf[j++] = uCode & 0xFF;
	        newBuf[j++] = uCode >> 8;
	      }
	      uCode = seq[seq.length - 1];
	    } else { throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte) }

	    // Write the character to buffer, handling higher planes using surrogate pair.
	    if (uCode >= 0x10000) {
	      uCode -= 0x10000;
	      var uCodeLead = 0xD800 | (uCode >> 10);
	      newBuf[j++] = uCodeLead & 0xFF;
	      newBuf[j++] = uCodeLead >> 8;

	      uCode = 0xDC00 | (uCode & 0x3FF);
	    }
	    newBuf[j++] = uCode & 0xFF;
	    newBuf[j++] = uCode >> 8;

	    // Reset trie node.
	    nodeIdx = 0; seqStart = i + 1;
	  }

	  this.nodeIdx = nodeIdx;
	  this.prevBytes = (seqStart >= 0)
	    ? Array.prototype.slice.call(buf, seqStart)
	    : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));

	  return newBuf.slice(0, j).toString("ucs2")
	};

	DBCSDecoder.prototype.end = function () {
	  var ret = "";

	  // Try to parse all remaining chars.
	  while (this.prevBytes.length > 0) {
	    // Skip 1 character in the buffer.
	    ret += this.defaultCharUnicode;
	    var bytesArr = this.prevBytes.slice(1);

	    // Parse remaining as usual.
	    this.prevBytes = [];
	    this.nodeIdx = 0;
	    if (bytesArr.length > 0) { ret += this.write(bytesArr); }
	  }

	  this.prevBytes = [];
	  this.nodeIdx = 0;
	  return ret
	};

	// Binary search for GB18030. Returns largest i such that table[i] <= val.
	function findIdx (table, val) {
	  if (table[0] > val) { return -1 }

	  var l = 0; var r = table.length;
	  while (l < r - 1) { // always table[l] <= val < table[r]
	    var mid = l + ((r - l + 1) >> 1);
	    if (table[mid] <= val) { l = mid; } else { r = mid; }
	  }
	  return l
	}
	return dbcsCodec;
}

const require$$0 = [
	[
		"0",
		"\u0000",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	[
		"8180",
		""
	],
	[
		"81b8",
		""
	],
	[
		"81c8",
		""
	],
	[
		"81da",
		""
	],
	[
		"81f0",
		""
	],
	[
		"81fc",
		""
	],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	[
		"849f",
		""
	],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	[
		"875f",
		""
	],
	[
		"877e",
		""
	],
	[
		"8780",
		"",
		4,
		""
	],
	[
		"889f",
		""
	],
	[
		"8940",
		""
	],
	[
		"8980",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a80",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b80",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8c80",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d80",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8e80",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8f80",
		""
	],
	[
		"9040",
		""
	],
	[
		"9080",
		""
	],
	[
		"9140",
		""
	],
	[
		"9180",
		""
	],
	[
		"9240",
		""
	],
	[
		"9280",
		""
	],
	[
		"9340",
		""
	],
	[
		"9380",
		""
	],
	[
		"9440",
		""
	],
	[
		"9480",
		""
	],
	[
		"9540",
		""
	],
	[
		"9580",
		""
	],
	[
		"9640",
		""
	],
	[
		"9680",
		""
	],
	[
		"9740",
		""
	],
	[
		"9780",
		""
	],
	[
		"9840",
		""
	],
	[
		"989f",
		""
	],
	[
		"9940",
		""
	],
	[
		"9980",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9a80",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b80",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9c80",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9d80",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9e80",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f80",
		""
	],
	[
		"e040",
		""
	],
	[
		"e080",
		""
	],
	[
		"e140",
		""
	],
	[
		"e180",
		""
	],
	[
		"e240",
		""
	],
	[
		"e280",
		""
	],
	[
		"e340",
		""
	],
	[
		"e380",
		""
	],
	[
		"e440",
		""
	],
	[
		"e480",
		""
	],
	[
		"e540",
		""
	],
	[
		"e580",
		""
	],
	[
		"e640",
		""
	],
	[
		"e680",
		""
	],
	[
		"e740",
		""
	],
	[
		"e780",
		""
	],
	[
		"e840",
		""
	],
	[
		"e880",
		""
	],
	[
		"e940",
		""
	],
	[
		"e980",
		""
	],
	[
		"ea40",
		""
	],
	[
		"ea80",
		""
	],
	[
		"ed40",
		""
	],
	[
		"ed80",
		""
	],
	[
		"ee40",
		""
	],
	[
		"ee80",
		""
	],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	[
		"f940",
		""
	],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	[
		"fa80",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fb80",
		""
	],
	[
		"fc40",
		""
	]
];

const require$$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8ea1",
		"",
		62
	],
	[
		"a1a1",
		"",
		9,
		""
	],
	[
		"a2a1",
		""
	],
	[
		"a2ba",
		""
	],
	[
		"a2ca",
		""
	],
	[
		"a2dc",
		""
	],
	[
		"a2f2",
		""
	],
	[
		"a2fe",
		""
	],
	[
		"a3b0",
		"",
		9
	],
	[
		"a3c1",
		"",
		25
	],
	[
		"a3e1",
		"",
		25
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a8a1",
		""
	],
	[
		"ada1",
		"",
		19,
		"",
		9
	],
	[
		"adc0",
		""
	],
	[
		"addf",
		"",
		4,
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bda1",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fcf1",
		"",
		9,
		""
	],
	[
		"8fa2af",
		""
	],
	[
		"8fa2c2",
		""
	],
	[
		"8fa2eb",
		""
	],
	[
		"8fa6e1",
		""
	],
	[
		"8fa6e7",
		""
	],
	[
		"8fa6e9",
		""
	],
	[
		"8fa6ec",
		""
	],
	[
		"8fa6f1",
		""
	],
	[
		"8fa7c2",
		"",
		10,
		""
	],
	[
		"8fa7f2",
		"",
		10,
		""
	],
	[
		"8fa9a1",
		""
	],
	[
		"8fa9a4",
		""
	],
	[
		"8fa9a6",
		""
	],
	[
		"8fa9a8",
		""
	],
	[
		"8fa9ab",
		""
	],
	[
		"8fa9af",
		""
	],
	[
		"8fa9c1",
		""
	],
	[
		"8faaa1",
		""
	],
	[
		"8faaba",
		""
	],
	[
		"8faba1",
		""
	],
	[
		"8fabbd",
		""
	],
	[
		"8fabc5",
		""
	],
	[
		"8fb0a1",
		""
	],
	[
		"8fb1a1",
		""
	],
	[
		"8fb2a1",
		"",
		4,
		""
	],
	[
		"8fb3a1",
		""
	],
	[
		"8fb4a1",
		""
	],
	[
		"8fb5a1",
		""
	],
	[
		"8fb6a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fb7a1",
		"",
		4,
		""
	],
	[
		"8fb8a1",
		""
	],
	[
		"8fb9a1",
		""
	],
	[
		"8fbaa1",
		"",
		4,
		""
	],
	[
		"8fbba1",
		""
	],
	[
		"8fbca1",
		"",
		4,
		""
	],
	[
		"8fbda1",
		"",
		4,
		""
	],
	[
		"8fbea1",
		"",
		4,
		""
	],
	[
		"8fbfa1",
		""
	],
	[
		"8fc0a1",
		""
	],
	[
		"8fc1a1",
		""
	],
	[
		"8fc2a1",
		""
	],
	[
		"8fc3a1",
		"",
		4,
		""
	],
	[
		"8fc4a1",
		""
	],
	[
		"8fc5a1",
		""
	],
	[
		"8fc6a1",
		""
	],
	[
		"8fc7a1",
		""
	],
	[
		"8fc8a1",
		""
	],
	[
		"8fc9a1",
		"",
		4,
		"",
		4,
		""
	],
	[
		"8fcaa1",
		""
	],
	[
		"8fcba1",
		""
	],
	[
		"8fcca1",
		"",
		9,
		""
	],
	[
		"8fcda1",
		"",
		5,
		""
	],
	[
		"8fcea1",
		"",
		6,
		""
	],
	[
		"8fcfa1",
		""
	],
	[
		"8fd0a1",
		""
	],
	[
		"8fd1a1",
		""
	],
	[
		"8fd2a1",
		"",
		5
	],
	[
		"8fd3a1",
		""
	],
	[
		"8fd4a1",
		"",
		4,
		""
	],
	[
		"8fd5a1",
		""
	],
	[
		"8fd6a1",
		""
	],
	[
		"8fd7a1",
		""
	],
	[
		"8fd8a1",
		""
	],
	[
		"8fd9a1",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8fdaa1",
		"",
		4,
		""
	],
	[
		"8fdba1",
		"",
		6,
		""
	],
	[
		"8fdca1",
		"",
		4,
		""
	],
	[
		"8fdda1",
		"",
		4,
		""
	],
	[
		"8fdea1",
		"",
		4,
		""
	],
	[
		"8fdfa1",
		""
	],
	[
		"8fe0a1",
		""
	],
	[
		"8fe1a1",
		"",
		4,
		""
	],
	[
		"8fe2a1",
		""
	],
	[
		"8fe3a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fe4a1",
		"",
		4,
		""
	],
	[
		"8fe5a1",
		"",
		4,
		""
	],
	[
		"8fe6a1",
		""
	],
	[
		"8fe7a1",
		""
	],
	[
		"8fe8a1",
		"",
		4,
		""
	],
	[
		"8fe9a1",
		"",
		4
	],
	[
		"8feaa1",
		"",
		4,
		""
	],
	[
		"8feba1",
		"",
		4,
		""
	],
	[
		"8feca1",
		""
	],
	[
		"8feda1",
		"",
		4,
		"",
		4,
		""
	]
];

const require$$2 = [
	[
		"0",
		"\u0000",
		127,
		""
	],
	[
		"8140",
		"",
		5,
		"",
		9,
		"",
		6,
		""
	],
	[
		"8180",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8240",
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		11
	],
	[
		"8280",
		"",
		10,
		"",
		4,
		"",
		7,
		"",
		5,
		"",
		8,
		"",
		20,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8340",
		"",
		17,
		"",
		5,
		"",
		10,
		"",
		4,
		"",
		9,
		""
	],
	[
		"8380",
		"",
		5,
		"",
		13,
		"",
		28,
		"",
		4,
		"",
		4,
		"",
		5
	],
	[
		"8440",
		"",
		5,
		"",
		5,
		""
	],
	[
		"8480",
		"",
		9,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		5,
		"",
		10,
		"",
		7,
		""
	],
	[
		"8540",
		"",
		9,
		""
	],
	[
		"8580",
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		""
	],
	[
		"8640",
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8680",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8740",
		"",
		7,
		"",
		11,
		"",
		4,
		"",
		4
	],
	[
		"8780",
		"",
		7,
		"",
		6,
		"",
		14,
		"",
		10,
		"",
		6,
		"",
		12,
		"",
		8,
		"",
		5,
		"",
		6
	],
	[
		"8840",
		"",
		9,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8880",
		"",
		4,
		"",
		6,
		"",
		8,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		7
	],
	[
		"8940",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		16,
		""
	],
	[
		"8980",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		17,
		"",
		10,
		"",
		13,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"8a40",
		"",
		4,
		"",
		12,
		""
	],
	[
		"8a80",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		9,
		"",
		5
	],
	[
		"8b40",
		"",
		8,
		"",
		17,
		"",
		6,
		"",
		13,
		""
	],
	[
		"8b80",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		22,
		"",
		11,
		"",
		25,
		"",
		7,
		"",
		6
	],
	[
		"8c40",
		"",
		7,
		""
	],
	[
		"8c80",
		"",
		8,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		4
	],
	[
		"8d40",
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		9,
		"",
		4
	],
	[
		"8d80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		10,
		"",
		12,
		"",
		21,
		""
	],
	[
		"8e40",
		"",
		21,
		"",
		12,
		"",
		6,
		"",
		12,
		""
	],
	[
		"8e80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		4,
		"",
		6
	],
	[
		"8f40",
		"",
		5,
		"",
		11,
		"",
		8,
		""
	],
	[
		"8f80",
		"",
		6,
		"",
		14,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9040",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9080",
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		18,
		"",
		6
	],
	[
		"9140",
		"",
		6,
		"",
		6,
		"",
		18,
		"",
		4,
		""
	],
	[
		"9180",
		"",
		6,
		"",
		8,
		"",
		9,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		16,
		"",
		13,
		"",
		8,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9280",
		"",
		5,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9340",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9380",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		9,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9440",
		"",
		24,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		8
	],
	[
		"9480",
		"",
		4,
		"",
		4,
		"",
		14,
		"",
		7,
		"",
		7,
		""
	],
	[
		"9540",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9580",
		"",
		4,
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		25,
		"",
		7,
		"",
		5,
		""
	],
	[
		"9640",
		"",
		5,
		"",
		4,
		""
	],
	[
		"9680",
		"",
		7,
		"",
		9,
		"",
		7,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		5
	],
	[
		"9740",
		"",
		7,
		"",
		8,
		"",
		7,
		"",
		9,
		""
	],
	[
		"9780",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		9,
		"",
		4,
		"",
		11,
		"",
		7,
		"",
		16,
		""
	],
	[
		"9840",
		"",
		4,
		"",
		5,
		"",
		9,
		""
	],
	[
		"9880",
		"",
		7,
		"",
		5,
		"",
		11,
		"",
		9,
		"",
		9,
		"",
		11,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9940",
		"",
		4,
		"",
		10,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		7,
		"",
		5
	],
	[
		"9980",
		"",
		114,
		"",
		6
	],
	[
		"9a40",
		"",
		11,
		"",
		7,
		"",
		13,
		""
	],
	[
		"9a80",
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"9b40",
		"",
		4,
		""
	],
	[
		"9b80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9c40",
		"",
		7,
		""
	],
	[
		"9c80",
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		14,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"9d40",
		"",
		7,
		"",
		4,
		"",
		9,
		"",
		6,
		""
	],
	[
		"9d80",
		"",
		9,
		"",
		5,
		"",
		6,
		"",
		12,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		10,
		""
	],
	[
		"9e40",
		"",
		7,
		"",
		32,
		"",
		7,
		"",
		6,
		"",
		6
	],
	[
		"9e80",
		"",
		9,
		"",
		17,
		"",
		13,
		"",
		11,
		"",
		12,
		"",
		12,
		""
	],
	[
		"9f40",
		"",
		6,
		"",
		10,
		"",
		4,
		"",
		10,
		"",
		7,
		""
	],
	[
		"9f80",
		"",
		13,
		"",
		12,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		8,
		"",
		9,
		"",
		4
	],
	[
		"a040",
		"",
		9,
		"",
		5,
		"",
		9,
		"",
		11,
		"",
		19
	],
	[
		"a080",
		"",
		9,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		11,
		"",
		6,
		""
	],
	[
		"a1a1",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9
	],
	[
		"a2b1",
		"",
		19,
		"",
		19,
		"",
		9
	],
	[
		"a2e5",
		"",
		9
	],
	[
		"a2f1",
		"",
		11
	],
	[
		"a3a1",
		"",
		88,
		""
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a6e0",
		""
	],
	[
		"a6ee",
		""
	],
	[
		"a6f4",
		""
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a840",
		"",
		35,
		"",
		6
	],
	[
		"a880",
		"",
		7,
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a8bd",
		""
	],
	[
		"a8c0",
		""
	],
	[
		"a8c5",
		"",
		36
	],
	[
		"a940",
		"",
		8,
		""
	],
	[
		"a959",
		""
	],
	[
		"a95c",
		""
	],
	[
		"a960",
		"",
		9,
		"",
		8
	],
	[
		"a980",
		"",
		4,
		""
	],
	[
		"a996",
		""
	],
	[
		"a9a4",
		"",
		75
	],
	[
		"aa40",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"aa80",
		"",
		7,
		"",
		10,
		""
	],
	[
		"ab40",
		"",
		11,
		"",
		4,
		"",
		5,
		"",
		4
	],
	[
		"ab80",
		"",
		6,
		"",
		4
	],
	[
		"ac40",
		"",
		10,
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11
	],
	[
		"ac80",
		"",
		6,
		"",
		12,
		"",
		4,
		""
	],
	[
		"ad40",
		"",
		10,
		"",
		7,
		"",
		15,
		"",
		12
	],
	[
		"ad80",
		"",
		9,
		"",
		8,
		"",
		6,
		""
	],
	[
		"ae40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"ae80",
		"",
		7,
		"",
		6,
		"",
		4,
		""
	],
	[
		"af40",
		"",
		4,
		""
	],
	[
		"af80",
		""
	],
	[
		"b040",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		7,
		""
	],
	[
		"b080",
		"",
		7,
		"",
		8,
		"",
		9,
		""
	],
	[
		"b140",
		"",
		4,
		"",
		7,
		"",
		10,
		""
	],
	[
		"b180",
		"",
		4,
		"",
		7,
		"",
		7,
		""
	],
	[
		"b240",
		"",
		11,
		"",
		5,
		"",
		11,
		"",
		4
	],
	[
		"b280",
		"",
		12,
		"",
		8,
		"",
		4,
		""
	],
	[
		"b340",
		"",
		5,
		""
	],
	[
		"b380",
		"",
		11,
		"",
		7,
		"",
		6,
		""
	],
	[
		"b440",
		"",
		7,
		"",
		9
	],
	[
		"b480",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"b540",
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		8,
		""
	],
	[
		"b580",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b640",
		"",
		6,
		"",
		11,
		"",
		10,
		"",
		4,
		"",
		5,
		""
	],
	[
		"b680",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b740",
		"",
		14,
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		16
	],
	[
		"b780",
		"",
		6,
		""
	],
	[
		"b840",
		"",
		4,
		"",
		10,
		"",
		10,
		"",
		9,
		"",
		5,
		""
	],
	[
		"b880",
		"",
		4,
		""
	],
	[
		"b940",
		"",
		5,
		"",
		10,
		"",
		6,
		""
	],
	[
		"b980",
		"",
		7,
		""
	],
	[
		"ba40",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		5,
		""
	],
	[
		"ba80",
		"",
		4,
		"",
		5,
		"",
		12,
		"",
		5,
		""
	],
	[
		"bb40",
		"",
		9,
		"",
		36,
		"",
		5,
		"",
		9
	],
	[
		"bb80",
		"",
		6,
		"",
		4,
		""
	],
	[
		"bc40",
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		13,
		"",
		5
	],
	[
		"bc80",
		"",
		14,
		"",
		6,
		""
	],
	[
		"bd40",
		"",
		54,
		"",
		7
	],
	[
		"bd80",
		"",
		32,
		""
	],
	[
		"be40",
		"",
		12,
		"",
		6,
		"",
		42
	],
	[
		"be80",
		"",
		32,
		""
	],
	[
		"bf40",
		"",
		62
	],
	[
		"bf80",
		"",
		4,
		"",
		4,
		"",
		21,
		""
	],
	[
		"c040",
		"",
		35,
		"",
		23,
		""
	],
	[
		"c080",
		"",
		6,
		"",
		9,
		""
	],
	[
		"c140",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c180",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c280",
		"",
		13,
		"",
		5,
		"",
		11,
		""
	],
	[
		"c340",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c380",
		"",
		12,
		"",
		4,
		""
	],
	[
		"c440",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"c480",
		"",
		7,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c540",
		"",
		14,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c580",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c640",
		""
	],
	[
		"c680",
		"",
		4,
		"",
		9,
		""
	],
	[
		"c740",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"c780",
		""
	],
	[
		"c840",
		"",
		4,
		"",
		5,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c880",
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"c940",
		"",
		4,
		"",
		7,
		"",
		12,
		""
	],
	[
		"c980",
		"",
		4,
		"",
		4,
		"",
		10,
		""
	],
	[
		"ca40",
		"",
		8,
		"",
		8,
		"",
		9,
		"",
		4,
		"",
		10
	],
	[
		"ca80",
		"",
		4,
		"",
		8,
		""
	],
	[
		"cb40",
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cb80",
		"",
		5,
		"",
		6,
		"",
		14,
		""
	],
	[
		"cc40",
		"",
		4,
		"",
		10,
		"",
		15,
		"",
		13,
		""
	],
	[
		"cc80",
		"",
		11,
		"",
		4,
		"",
		7,
		""
	],
	[
		"cd40",
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		""
	],
	[
		"cd80",
		""
	],
	[
		"ce40",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"ce80",
		"",
		4,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cf40",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		9
	],
	[
		"cf80",
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"d040",
		"",
		13,
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"d080",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"d140",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"d180",
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"d240",
		"",
		8,
		"",
		24,
		"",
		5,
		"",
		19,
		""
	],
	[
		"d280",
		"",
		26,
		""
	],
	[
		"d340",
		"",
		30,
		"",
		6
	],
	[
		"d380",
		"",
		4,
		"",
		5,
		"",
		21,
		""
	],
	[
		"d440",
		"",
		31,
		"",
		8,
		"",
		21
	],
	[
		"d480",
		"",
		25,
		"",
		6,
		""
	],
	[
		"d540",
		"",
		7,
		"",
		7,
		"",
		46
	],
	[
		"d580",
		"",
		32,
		""
	],
	[
		"d640",
		"",
		34,
		"",
		27
	],
	[
		"d680",
		"",
		30,
		""
	],
	[
		"d740",
		"",
		31,
		"",
		4,
		"",
		25
	],
	[
		"d780",
		"",
		24,
		""
	],
	[
		"d840",
		"",
		8,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"d880",
		"",
		6,
		"",
		20,
		""
	],
	[
		"d940",
		"",
		62
	],
	[
		"d980",
		"",
		32,
		""
	],
	[
		"da40",
		"",
		14,
		"",
		8,
		"",
		4,
		"",
		9,
		""
	],
	[
		"da80",
		"",
		12,
		""
	],
	[
		"db40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"db80",
		"",
		4,
		"",
		5,
		"",
		11,
		""
	],
	[
		"dc40",
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		11,
		"",
		6,
		"",
		7
	],
	[
		"dc80",
		"",
		10,
		"",
		21,
		""
	],
	[
		"dd40",
		"",
		62
	],
	[
		"dd80",
		"",
		32,
		""
	],
	[
		"de40",
		"",
		32,
		""
	],
	[
		"de80",
		"",
		4,
		""
	],
	[
		"df40",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"df80",
		"",
		4,
		""
	],
	[
		"e040",
		"",
		19,
		""
	],
	[
		"e080",
		"",
		10,
		"",
		6,
		"",
		8,
		""
	],
	[
		"e140",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		""
	],
	[
		"e180",
		"",
		10,
		"",
		9,
		"",
		8,
		""
	],
	[
		"e240",
		"",
		62
	],
	[
		"e280",
		"",
		32,
		"",
		5,
		""
	],
	[
		"e340",
		"",
		45,
		"",
		16
	],
	[
		"e380",
		"",
		7,
		"",
		24,
		""
	],
	[
		"e440",
		"",
		5,
		"",
		24,
		"",
		31
	],
	[
		"e480",
		"",
		32,
		""
	],
	[
		"e540",
		"",
		51,
		"",
		10
	],
	[
		"e580",
		"",
		31,
		""
	],
	[
		"e640",
		"",
		34,
		"",
		27
	],
	[
		"e680",
		"",
		29,
		""
	],
	[
		"e740",
		"",
		7,
		"",
		54
	],
	[
		"e780",
		"",
		32,
		"",
		6,
		"",
		4,
		""
	],
	[
		"e840",
		"",
		14,
		"",
		43,
		""
	],
	[
		"e880",
		"",
		20,
		""
	],
	[
		"e940",
		"",
		7,
		"",
		42
	],
	[
		"e980",
		"",
		32,
		""
	],
	[
		"ea40",
		"",
		27,
		"",
		6,
		""
	],
	[
		"ea80",
		"",
		4,
		"",
		12,
		""
	],
	[
		"eb40",
		"",
		9,
		"",
		7,
		"",
		9,
		"",
		6,
		""
	],
	[
		"eb80",
		"",
		4,
		""
	],
	[
		"ec40",
		"",
		8,
		"",
		4,
		"",
		18,
		"",
		7
	],
	[
		"ec80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ed40",
		"",
		6,
		"",
		46
	],
	[
		"ed80",
		"",
		4,
		"",
		23,
		""
	],
	[
		"ee40",
		"",
		62
	],
	[
		"ee80",
		"",
		32,
		"",
		4,
		"",
		6,
		""
	],
	[
		"ef40",
		"",
		5,
		"",
		37,
		"",
		4
	],
	[
		"ef80",
		"",
		30,
		"",
		4,
		"",
		8,
		""
	],
	[
		"f040",
		"",
		4,
		"",
		28,
		"",
		26
	],
	[
		"f080",
		"",
		9,
		"",
		12,
		"",
		4,
		"",
		6,
		""
	],
	[
		"f140",
		"",
		10,
		"",
		47
	],
	[
		"f180",
		"",
		32,
		""
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		32,
		""
	],
	[
		"f340",
		"",
		17,
		"",
		6,
		"",
		4,
		""
	],
	[
		"f380",
		"",
		8,
		"",
		6,
		""
	],
	[
		"f440",
		"",
		5,
		"",
		10,
		"",
		10,
		"",
		7,
		"",
		5
	],
	[
		"f480",
		"",
		32,
		""
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		32,
		""
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		32,
		"",
		5,
		"",
		5,
		"",
		4,
		"",
		7,
		""
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		4,
		"",
		4,
		""
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		32
	],
	[
		"f940",
		"",
		62
	],
	[
		"f980",
		"",
		32
	],
	[
		"fa40",
		"",
		62
	],
	[
		"fa80",
		"",
		32
	],
	[
		"fb40",
		"",
		27,
		"",
		9,
		""
	],
	[
		"fb80",
		"",
		5,
		"",
		8,
		"",
		5,
		""
	],
	[
		"fc40",
		"",
		8,
		"",
		4,
		"",
		8,
		"",
		6
	],
	[
		"fc80",
		"",
		4,
		"",
		5,
		"",
		8,
		""
	],
	[
		"fd40",
		"",
		4,
		"",
		4,
		"",
		10,
		"",
		38
	],
	[
		"fd80",
		"",
		5,
		"",
		11,
		"",
		4,
		""
	],
	[
		"fe40",
		""
	]
];

const require$$3$1 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	[
		"a2e3",
		""
	],
	[
		"a2ef",
		""
	],
	[
		"a2fd",
		""
	],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	[
		"a6ec",
		""
	],
	[
		"a6f3",
		""
	],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	[
		"a8bc",
		""
	],
	[
		"a8bf",
		""
	],
	[
		"a8c1",
		""
	],
	[
		"a8ea",
		"",
		20
	],
	[
		"a958",
		""
	],
	[
		"a95b",
		""
	],
	[
		"a95d",
		""
	],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	[
		"fe50",
		""
	],
	[
		"fe80",
		"",
		6,
		"",
		93
	],
	[
		"8135f437",
		""
	]
];

var uChars = [
	128,
	165,
	169,
	178,
	184,
	216,
	226,
	235,
	238,
	244,
	248,
	251,
	253,
	258,
	276,
	284,
	300,
	325,
	329,
	334,
	364,
	463,
	465,
	467,
	469,
	471,
	473,
	475,
	477,
	506,
	594,
	610,
	712,
	716,
	730,
	930,
	938,
	962,
	970,
	1026,
	1104,
	1106,
	8209,
	8215,
	8218,
	8222,
	8231,
	8241,
	8244,
	8246,
	8252,
	8365,
	8452,
	8454,
	8458,
	8471,
	8482,
	8556,
	8570,
	8596,
	8602,
	8713,
	8720,
	8722,
	8726,
	8731,
	8737,
	8740,
	8742,
	8748,
	8751,
	8760,
	8766,
	8777,
	8781,
	8787,
	8802,
	8808,
	8816,
	8854,
	8858,
	8870,
	8896,
	8979,
	9322,
	9372,
	9548,
	9588,
	9616,
	9622,
	9634,
	9652,
	9662,
	9672,
	9676,
	9680,
	9702,
	9735,
	9738,
	9793,
	9795,
	11906,
	11909,
	11913,
	11917,
	11928,
	11944,
	11947,
	11951,
	11956,
	11960,
	11964,
	11979,
	12284,
	12292,
	12312,
	12319,
	12330,
	12351,
	12436,
	12447,
	12535,
	12543,
	12586,
	12842,
	12850,
	12964,
	13200,
	13215,
	13218,
	13253,
	13263,
	13267,
	13270,
	13384,
	13428,
	13727,
	13839,
	13851,
	14617,
	14703,
	14801,
	14816,
	14964,
	15183,
	15471,
	15585,
	16471,
	16736,
	17208,
	17325,
	17330,
	17374,
	17623,
	17997,
	18018,
	18212,
	18218,
	18301,
	18318,
	18760,
	18811,
	18814,
	18820,
	18823,
	18844,
	18848,
	18872,
	19576,
	19620,
	19738,
	19887,
	40870,
	59244,
	59336,
	59367,
	59413,
	59417,
	59423,
	59431,
	59437,
	59443,
	59452,
	59460,
	59478,
	59493,
	63789,
	63866,
	63894,
	63976,
	63986,
	64016,
	64018,
	64021,
	64025,
	64034,
	64037,
	64042,
	65074,
	65093,
	65107,
	65112,
	65127,
	65132,
	65375,
	65510,
	65536
];
var gbChars = [
	0,
	36,
	38,
	45,
	50,
	81,
	89,
	95,
	96,
	100,
	103,
	104,
	105,
	109,
	126,
	133,
	148,
	172,
	175,
	179,
	208,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	341,
	428,
	443,
	544,
	545,
	558,
	741,
	742,
	749,
	750,
	805,
	819,
	820,
	7922,
	7924,
	7925,
	7927,
	7934,
	7943,
	7944,
	7945,
	7950,
	8062,
	8148,
	8149,
	8152,
	8164,
	8174,
	8236,
	8240,
	8262,
	8264,
	8374,
	8380,
	8381,
	8384,
	8388,
	8390,
	8392,
	8393,
	8394,
	8396,
	8401,
	8406,
	8416,
	8419,
	8424,
	8437,
	8439,
	8445,
	8482,
	8485,
	8496,
	8521,
	8603,
	8936,
	8946,
	9046,
	9050,
	9063,
	9066,
	9076,
	9092,
	9100,
	9108,
	9111,
	9113,
	9131,
	9162,
	9164,
	9218,
	9219,
	11329,
	11331,
	11334,
	11336,
	11346,
	11361,
	11363,
	11366,
	11370,
	11372,
	11375,
	11389,
	11682,
	11686,
	11687,
	11692,
	11694,
	11714,
	11716,
	11723,
	11725,
	11730,
	11736,
	11982,
	11989,
	12102,
	12336,
	12348,
	12350,
	12384,
	12393,
	12395,
	12397,
	12510,
	12553,
	12851,
	12962,
	12973,
	13738,
	13823,
	13919,
	13933,
	14080,
	14298,
	14585,
	14698,
	15583,
	15847,
	16318,
	16434,
	16438,
	16481,
	16729,
	17102,
	17122,
	17315,
	17320,
	17402,
	17418,
	17859,
	17909,
	17911,
	17915,
	17916,
	17936,
	17939,
	17961,
	18664,
	18703,
	18814,
	18962,
	19043,
	33469,
	33470,
	33471,
	33484,
	33485,
	33490,
	33497,
	33501,
	33505,
	33513,
	33520,
	33536,
	33550,
	37845,
	37921,
	37948,
	38029,
	38038,
	38064,
	38065,
	38066,
	38069,
	38075,
	38076,
	38078,
	39108,
	39109,
	39113,
	39114,
	39115,
	39116,
	39265,
	39394,
	189000
];
const require$$4 = {
	uChars: uChars,
	gbChars: gbChars
};

const require$$5 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8141",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8161",
		"",
		9,
		"",
		5,
		""
	],
	[
		"8181",
		"",
		18,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8241",
		"",
		7,
		"",
		5
	],
	[
		"8261",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8281",
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		17,
		"",
		7,
		"",
		6,
		"",
		7,
		"",
		18
	],
	[
		"8341",
		"",
		5,
		"",
		5,
		"",
		7
	],
	[
		"8361",
		"",
		18,
		""
	],
	[
		"8381",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		46,
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8441",
		"",
		5,
		"",
		8
	],
	[
		"8461",
		"",
		18
	],
	[
		"8481",
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		18,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8541",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4
	],
	[
		"8561",
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8581",
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		29,
		"",
		6,
		"",
		5,
		""
	],
	[
		"8641",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8661",
		"",
		6,
		"",
		10
	],
	[
		"8681",
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		22,
		"",
		4,
		""
	],
	[
		"8741",
		"",
		9,
		"",
		15
	],
	[
		"8761",
		"",
		18,
		""
	],
	[
		"8781",
		"",
		5,
		"",
		7,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		4
	],
	[
		"8841",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"8861",
		"",
		4,
		""
	],
	[
		"8881",
		"",
		15,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		54,
		""
	],
	[
		"8941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8961",
		"",
		10,
		"",
		5,
		""
	],
	[
		"8981",
		"",
		21,
		"",
		18,
		"",
		18,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		15
	],
	[
		"8a41",
		"",
		10,
		"",
		6,
		""
	],
	[
		"8a61",
		"",
		4,
		"",
		18,
		""
	],
	[
		"8a81",
		"",
		4,
		"",
		19,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8b41",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8b61",
		"",
		6,
		"",
		8
	],
	[
		"8b81",
		"",
		52,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		18
	],
	[
		"8c41",
		"",
		15,
		"",
		4
	],
	[
		"8c61",
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"8c81",
		"",
		12,
		"",
		26,
		"",
		50,
		"",
		5,
		"",
		16
	],
	[
		"8d41",
		"",
		16,
		"",
		8
	],
	[
		"8d61",
		"",
		17,
		""
	],
	[
		"8d81",
		"",
		4,
		"",
		33,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		9,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8e41",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8e61",
		"",
		4,
		"",
		19
	],
	[
		"8e81",
		"",
		13,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		11,
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"8f41",
		"",
		7,
		"",
		17
	],
	[
		"8f61",
		"",
		7,
		"",
		6,
		"",
		4
	],
	[
		"8f81",
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		5
	],
	[
		"9041",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9061",
		"",
		5,
		"",
		15
	],
	[
		"9081",
		"",
		12,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		11,
		"",
		33,
		""
	],
	[
		"9141",
		"",
		6,
		"",
		5
	],
	[
		"9161",
		"",
		9,
		"",
		5
	],
	[
		"9181",
		"",
		20,
		"",
		4,
		"",
		5,
		"",
		14,
		"",
		33,
		"",
		7,
		"",
		5,
		"",
		6
	],
	[
		"9241",
		"",
		7,
		"",
		4,
		""
	],
	[
		"9261",
		"",
		7,
		"",
		7,
		"",
		4
	],
	[
		"9281",
		"",
		21,
		"",
		18,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		35,
		""
	],
	[
		"9341",
		"",
		4,
		""
	],
	[
		"9361",
		"",
		6,
		"",
		8
	],
	[
		"9381",
		"",
		37,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		22,
		""
	],
	[
		"9441",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"9461",
		"",
		5,
		"",
		6,
		"",
		12
	],
	[
		"9481",
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		24
	],
	[
		"9541",
		"",
		11,
		"",
		5,
		""
	],
	[
		"9561",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9581",
		"",
		6,
		"",
		35,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		13,
		"",
		14
	],
	[
		"9641",
		"",
		23,
		""
	],
	[
		"9661",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"9681",
		"",
		10,
		"",
		5,
		"",
		13,
		"",
		33,
		"",
		6,
		"",
		44
	],
	[
		"9741",
		"",
		16,
		"",
		8
	],
	[
		"9761",
		"",
		17,
		"",
		7
	],
	[
		"9781",
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		89,
		""
	],
	[
		"9841",
		"",
		16,
		"",
		5,
		""
	],
	[
		"9861",
		"",
		6,
		"",
		15
	],
	[
		"9881",
		"",
		21,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9961",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9981",
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9a41",
		"",
		16
	],
	[
		"9a61",
		"",
		6,
		"",
		6,
		""
	],
	[
		"9a81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		33,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9b41",
		"",
		6,
		"",
		8
	],
	[
		"9b61",
		"",
		17,
		"",
		7
	],
	[
		"9b81",
		"",
		25,
		"",
		4,
		"",
		5,
		"",
		50,
		"",
		22,
		""
	],
	[
		"9c41",
		"",
		4,
		"",
		5,
		"",
		5
	],
	[
		"9c61",
		"",
		8,
		"",
		6,
		"",
		9
	],
	[
		"9c81",
		"",
		8,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		12
	],
	[
		"9d41",
		"",
		13,
		"",
		8
	],
	[
		"9d61",
		"",
		25
	],
	[
		"9d81",
		"",
		8,
		"",
		5,
		"",
		9,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9e41",
		"",
		7,
		"",
		9,
		""
	],
	[
		"9e61",
		"",
		4,
		"",
		6,
		""
	],
	[
		"9e81",
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9f41",
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9f61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9f81",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"a041",
		"",
		5,
		"",
		6,
		""
	],
	[
		"a061",
		"",
		5,
		"",
		13
	],
	[
		"a081",
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		"",
		4,
		"",
		5,
		"",
		7,
		""
	],
	[
		"a141",
		"",
		18,
		""
	],
	[
		"a161",
		"",
		6,
		"",
		5,
		""
	],
	[
		"a181",
		"",
		14,
		"",
		5,
		"",
		4,
		"",
		9,
		""
	],
	[
		"a241",
		"",
		5,
		"",
		18
	],
	[
		"a261",
		"",
		6,
		"",
		18
	],
	[
		"a281",
		"",
		7,
		"",
		6,
		"",
		7,
		""
	],
	[
		"a341",
		"",
		6,
		"",
		10,
		""
	],
	[
		"a361",
		"",
		6,
		"",
		16
	],
	[
		"a381",
		"",
		16,
		"",
		4,
		"",
		58,
		"",
		32,
		""
	],
	[
		"a441",
		"",
		5,
		""
	],
	[
		"a461",
		"",
		5,
		"",
		12
	],
	[
		"a481",
		"",
		28,
		"",
		93
	],
	[
		"a541",
		"",
		4,
		"",
		6,
		"",
		5,
		""
	],
	[
		"a561",
		"",
		17,
		"",
		5,
		""
	],
	[
		"a581",
		"",
		16,
		"",
		14,
		"",
		9
	],
	[
		"a5b0",
		"",
		9
	],
	[
		"a5c1",
		"",
		16,
		"",
		6
	],
	[
		"a5e1",
		"",
		16,
		"",
		6
	],
	[
		"a641",
		"",
		19,
		""
	],
	[
		"a661",
		"",
		5,
		"",
		5,
		"",
		6
	],
	[
		"a681",
		"",
		6,
		"",
		18,
		"",
		7
	],
	[
		"a741",
		"",
		4,
		"",
		6,
		"",
		7
	],
	[
		"a761",
		"",
		22,
		""
	],
	[
		"a781",
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		9,
		"",
		9,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"a841",
		"",
		10,
		"",
		14
	],
	[
		"a861",
		"",
		18,
		"",
		6
	],
	[
		"a881",
		"",
		19,
		"",
		11,
		""
	],
	[
		"a8a6",
		""
	],
	[
		"a8a8",
		""
	],
	[
		"a8b1",
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"a941",
		"",
		14,
		"",
		10
	],
	[
		"a961",
		"",
		18
	],
	[
		"a981",
		"",
		14,
		"",
		6,
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"aa41",
		"",
		6,
		"",
		4,
		""
	],
	[
		"aa61",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"aa81",
		"",
		29,
		"",
		82
	],
	[
		"ab41",
		"",
		6,
		"",
		5,
		""
	],
	[
		"ab61",
		"",
		6,
		"",
		5,
		"",
		5
	],
	[
		"ab81",
		"",
		8,
		"",
		6,
		"",
		12,
		"",
		85
	],
	[
		"ac41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ac61",
		"",
		11,
		"",
		4
	],
	[
		"ac81",
		"",
		28,
		"",
		5,
		"",
		25
	],
	[
		"acd1",
		"",
		5,
		"",
		25
	],
	[
		"ad41",
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"ad61",
		"",
		6,
		"",
		10,
		""
	],
	[
		"ad81",
		"",
		5,
		"",
		18,
		""
	],
	[
		"ae41",
		"",
		5,
		"",
		16
	],
	[
		"ae61",
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"ae81",
		"",
		6,
		"",
		5,
		""
	],
	[
		"af41",
		"",
		19
	],
	[
		"af61",
		"",
		13,
		"",
		5,
		""
	],
	[
		"af81",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b041",
		"",
		5,
		"",
		5,
		"",
		12
	],
	[
		"b061",
		"",
		5,
		"",
		19
	],
	[
		"b081",
		"",
		13,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"b141",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b161",
		"",
		6,
		"",
		5,
		"",
		11
	],
	[
		"b181",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b241",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b261",
		"",
		18,
		"",
		5,
		""
	],
	[
		"b281",
		"",
		5,
		"",
		18,
		"",
		6,
		""
	],
	[
		"b341",
		"",
		19,
		""
	],
	[
		"b361",
		"",
		5,
		"",
		5,
		"",
		5
	],
	[
		"b381",
		"",
		5,
		"",
		5,
		"",
		19,
		"",
		4,
		""
	],
	[
		"b441",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"b461",
		"",
		6,
		"",
		10,
		""
	],
	[
		"b481",
		"",
		6,
		"",
		18,
		"",
		4,
		"",
		4,
		""
	],
	[
		"b541",
		"",
		14,
		"",
		5
	],
	[
		"b561",
		"",
		5,
		"",
		5,
		"",
		4
	],
	[
		"b581",
		"",
		6,
		"",
		5,
		"",
		11,
		""
	],
	[
		"b641",
		"",
		7,
		"",
		17
	],
	[
		"b661",
		"",
		15,
		""
	],
	[
		"b681",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b741",
		"",
		13,
		"",
		6,
		""
	],
	[
		"b761",
		"",
		20,
		""
	],
	[
		"b781",
		"",
		6,
		"",
		14,
		""
	],
	[
		"b841",
		"",
		7,
		"",
		17
	],
	[
		"b861",
		"",
		8,
		"",
		13
	],
	[
		"b881",
		"",
		5,
		"",
		24,
		"",
		4,
		""
	],
	[
		"b941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b961",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b981",
		"",
		22,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ba41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ba61",
		"",
		5,
		"",
		4,
		"",
		5
	],
	[
		"ba81",
		"",
		6,
		"",
		9,
		""
	],
	[
		"bb41",
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bb61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"bb81",
		"",
		31,
		""
	],
	[
		"bc41",
		"",
		17,
		""
	],
	[
		"bc61",
		"",
		5,
		"",
		6,
		""
	],
	[
		"bc81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bd41",
		"",
		7,
		"",
		7,
		""
	],
	[
		"bd61",
		"",
		5,
		"",
		13
	],
	[
		"bd81",
		"",
		5,
		"",
		25,
		""
	],
	[
		"be41",
		"",
		7,
		"",
		14
	],
	[
		"be61",
		"",
		7,
		"",
		7,
		""
	],
	[
		"be81",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		8,
		"",
		6,
		""
	],
	[
		"bf41",
		"",
		10,
		"",
		14
	],
	[
		"bf61",
		"",
		18,
		""
	],
	[
		"bf81",
		"",
		5,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"c041",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"c061",
		"",
		25
	],
	[
		"c081",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c141",
		"",
		5,
		"",
		6,
		""
	],
	[
		"c161",
		"",
		19,
		""
	],
	[
		"c181",
		"",
		31,
		""
	],
	[
		"c241",
		"",
		4,
		"",
		5,
		""
	],
	[
		"c261",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c281",
		"",
		5,
		"",
		7,
		"",
		9,
		""
	],
	[
		"c341",
		"",
		4
	],
	[
		"c361",
		"",
		4,
		"",
		5,
		"",
		11
	],
	[
		"c381",
		"",
		5,
		"",
		7,
		"",
		5,
		""
	],
	[
		"c441",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c461",
		"",
		5,
		"",
		4
	],
	[
		"c481",
		"",
		5,
		"",
		11,
		""
	],
	[
		"c541",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c561",
		"",
		6,
		"",
		5,
		"",
		4
	],
	[
		"c581",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c641",
		"",
		6,
		"",
		5
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"d2a1",
		"",
		4,
		"",
		5,
		"",
		10,
		"",
		7,
		"",
		5,
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fda1",
		""
	]
];

const require$$6 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"a140",
		""
	],
	[
		"a1a1",
		"",
		4,
		""
	],
	[
		"a240",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9,
		"",
		9,
		"",
		8,
		"",
		25,
		"",
		21
	],
	[
		"a340",
		"",
		16,
		"",
		6,
		"",
		16,
		"",
		6,
		"",
		10
	],
	[
		"a3a1",
		"",
		25,
		""
	],
	[
		"a3e1",
		""
	],
	[
		"a440",
		""
	],
	[
		"a4a1",
		""
	],
	[
		"a540",
		""
	],
	[
		"a5a1",
		""
	],
	[
		"a640",
		""
	],
	[
		"a6a1",
		""
	],
	[
		"a740",
		""
	],
	[
		"a7a1",
		""
	],
	[
		"a840",
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a940",
		""
	],
	[
		"a9a1",
		""
	],
	[
		"aa40",
		""
	],
	[
		"aaa1",
		""
	],
	[
		"ab40",
		""
	],
	[
		"aba1",
		""
	],
	[
		"ac40",
		""
	],
	[
		"aca1",
		""
	],
	[
		"ad40",
		""
	],
	[
		"ada1",
		""
	],
	[
		"ae40",
		""
	],
	[
		"aea1",
		""
	],
	[
		"af40",
		""
	],
	[
		"afa1",
		""
	],
	[
		"b040",
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b140",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b240",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b340",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b440",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b540",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b640",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b740",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b840",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b940",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"ba40",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bb40",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bc40",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bd40",
		""
	],
	[
		"bda1",
		""
	],
	[
		"be40",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bf40",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c040",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c140",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c240",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c340",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c440",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c540",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c640",
		""
	],
	[
		"c940",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"ca40",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cb40",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cc40",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cd40",
		""
	],
	[
		"cda1",
		""
	],
	[
		"ce40",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cf40",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d040",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d140",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d240",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d340",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d440",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d540",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d640",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d740",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d840",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d940",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"da40",
		""
	],
	[
		"daa1",
		""
	],
	[
		"db40",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dc40",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dd40",
		""
	],
	[
		"dda1",
		""
	],
	[
		"de40",
		""
	],
	[
		"dea1",
		""
	],
	[
		"df40",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e040",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e140",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e240",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e340",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e440",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e540",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e640",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e740",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e840",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e940",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"ea40",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eb40",
		""
	],
	[
		"eba1",
		""
	],
	[
		"ec40",
		""
	],
	[
		"eca1",
		""
	],
	[
		"ed40",
		""
	],
	[
		"eda1",
		""
	],
	[
		"ee40",
		""
	],
	[
		"eea1",
		""
	],
	[
		"ef40",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f040",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f140",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f240",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f340",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f440",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f540",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f640",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f740",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f840",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f940",
		""
	],
	[
		"f9a1",
		""
	]
];

const require$$7 = [
	[
		"8740",
		""
	],
	[
		"8767",
		""
	],
	[
		"87a1",
		""
	],
	[
		"8840",
		"",
		4,
		""
	],
	[
		"88a1",
		""
	],
	[
		"8940",
		""
	],
	[
		"8943",
		""
	],
	[
		"8946",
		""
	],
	[
		"894c",
		""
	],
	[
		"89a1",
		""
	],
	[
		"89ab",
		""
	],
	[
		"89b0",
		""
	],
	[
		"89b5",
		""
	],
	[
		"89c1",
		""
	],
	[
		"89c5",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a43",
		""
	],
	[
		"8a64",
		""
	],
	[
		"8a76",
		""
	],
	[
		"8aa1",
		""
	],
	[
		"8aac",
		""
	],
	[
		"8ab2",
		""
	],
	[
		"8abb",
		""
	],
	[
		"8ac9",
		""
	],
	[
		"8ace",
		""
	],
	[
		"8adf",
		""
	],
	[
		"8af6",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b55",
		""
	],
	[
		"8ba1",
		""
	],
	[
		"8bde",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8ca1",
		""
	],
	[
		"8ca7",
		""
	],
	[
		"8cc9",
		""
	],
	[
		"8cce",
		""
	],
	[
		"8ce6",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d42",
		""
	],
	[
		"8da1",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8ea1",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8fa1",
		""
	],
	[
		"9040",
		""
	],
	[
		"90a1",
		""
	],
	[
		"9140",
		""
	],
	[
		"91a1",
		""
	],
	[
		"9240",
		""
	],
	[
		"92a1",
		""
	],
	[
		"9340",
		""
	],
	[
		"93a1",
		""
	],
	[
		"9440",
		""
	],
	[
		"94a1",
		""
	],
	[
		"9540",
		""
	],
	[
		"95a1",
		""
	],
	[
		"9640",
		""
	],
	[
		"96a1",
		""
	],
	[
		"9740",
		""
	],
	[
		"97a1",
		""
	],
	[
		"9840",
		""
	],
	[
		"98a1",
		""
	],
	[
		"9940",
		""
	],
	[
		"99a1",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9aa1",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b62",
		""
	],
	[
		"9ba1",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9ca1",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9da1",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9ea1",
		""
	],
	[
		"9ead",
		""
	],
	[
		"9ec5",
		""
	],
	[
		"9ef5",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f4f",
		""
	],
	[
		"9fa1",
		""
	],
	[
		"9fae",
		""
	],
	[
		"9fb2",
		""
	],
	[
		"9fc1",
		""
	],
	[
		"9fc9",
		""
	],
	[
		"9fdb",
		""
	],
	[
		"9fe7",
		""
	],
	[
		"9feb",
		""
	],
	[
		"9ff0",
		""
	],
	[
		"a040",
		""
	],
	[
		"a055",
		""
	],
	[
		"a058",
		""
	],
	[
		"a05b",
		""
	],
	[
		"a063",
		""
	],
	[
		"a073",
		""
	],
	[
		"a0a1",
		""
	],
	[
		"a0a6",
		""
	],
	[
		"a0ae",
		""
	],
	[
		"a0b0",
		""
	],
	[
		"a0d4",
		""
	],
	[
		"a0e2",
		""
	],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c8cd",
		""
	],
	[
		"c8f5",
		""
	],
	[
		"f9fe",
		""
	],
	[
		"fa40",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fc40",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fd40",
		""
	],
	[
		"fda1",
		""
	],
	[
		"fe40",
		""
	],
	[
		"fea1",
		""
	]
];

var dbcsData;
var hasRequiredDbcsData;

function requireDbcsData () {
	if (hasRequiredDbcsData) return dbcsData;
	hasRequiredDbcsData = 1;

	// Description of supported double byte encodings and aliases.
	// Tables are not require()-d until they are needed to speed up library load.
	// require()-s are direct to support Browserify.

	dbcsData = {

	  // == Japanese/ShiftJIS ====================================================
	  // All japanese encodings are based on JIS X set of standards:
	  // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
	  // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes.
	  //              Has several variations in 1978, 1983, 1990 and 1997.
	  // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
	  // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
	  //              2 planes, first is superset of 0208, second - revised 0212.
	  //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

	  // Byte encodings are:
	  //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
	  //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
	  //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
	  //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
	  //               0x00-0x7F       - lower part of 0201
	  //               0x8E, 0xA1-0xDF - upper part of 0201
	  //               (0xA1-0xFE)x2   - 0208 plane (94x94).
	  //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
	  //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
	  //               Used as-is in ISO2022 family.
	  //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII,
	  //                0201-1976 Roman, 0208-1978, 0208-1983.
	  //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
	  //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
	  //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
	  //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
	  //
	  // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
	  //
	  // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

	  shiftjis: {
	    type: "_dbcs",
	    table: function () { return require$$0 },
	    encodeAdd: { "\u00a5": 0x5C, "\u203E": 0x7E },
	    encodeSkipVals: [{ from: 0xED40, to: 0xF940 }]
	  },
	  csshiftjis: "shiftjis",
	  mskanji: "shiftjis",
	  sjis: "shiftjis",
	  windows31j: "shiftjis",
	  ms31j: "shiftjis",
	  xsjis: "shiftjis",
	  windows932: "shiftjis",
	  ms932: "shiftjis",
	  932: "shiftjis",
	  cp932: "shiftjis",

	  eucjp: {
	    type: "_dbcs",
	    table: function () { return require$$1 },
	    encodeAdd: { "\u00a5": 0x5C, "\u203E": 0x7E }
	  },

	  // TODO: KDDI extension to Shift_JIS
	  // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
	  // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

	  // == Chinese/GBK ==========================================================
	  // http://en.wikipedia.org/wiki/GBK
	  // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

	  // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
	  gb2312: "cp936",
	  gb231280: "cp936",
	  gb23121980: "cp936",
	  csgb2312: "cp936",
	  csiso58gb231280: "cp936",
	  euccn: "cp936",

	  // Microsoft's CP936 is a subset and approximation of GBK.
	  windows936: "cp936",
	  ms936: "cp936",
	  936: "cp936",
	  cp936: {
	    type: "_dbcs",
	    table: function () { return require$$2 }
	  },

	  // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
	  gbk: {
	    type: "_dbcs",
	    table: function () { return require$$2.concat(require$$3$1) }
	  },
	  xgbk: "gbk",
	  isoir58: "gbk",

	  // GB18030 is an algorithmic extension of GBK.
	  // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
	  // http://icu-project.org/docs/papers/gb18030.html
	  // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
	  // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
	  gb18030: {
	    type: "_dbcs",
	    table: function () { return require$$2.concat(require$$3$1) },
	    gb18030: function () { return require$$4 },
	    encodeSkipVals: [0x80],
	    encodeAdd: { "": 0xA2E3 }
	  },

	  chinese: "gb18030",

	  // == Korean ===============================================================
	  // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
	  windows949: "cp949",
	  ms949: "cp949",
	  949: "cp949",
	  cp949: {
	    type: "_dbcs",
	    table: function () { return require$$5 }
	  },

	  cseuckr: "cp949",
	  csksc56011987: "cp949",
	  euckr: "cp949",
	  isoir149: "cp949",
	  korean: "cp949",
	  ksc56011987: "cp949",
	  ksc56011989: "cp949",
	  ksc5601: "cp949",

	  // == Big5/Taiwan/Hong Kong ================================================
	  // There are lots of tables for Big5 and cp950. Please see the following links for history:
	  // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
	  // Variations, in roughly number of defined chars:
	  //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
	  //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
	  //  * Big5-2003 (Taiwan standard) almost superset of cp950.
	  //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
	  //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard.
	  //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
	  //    Plus, it has 4 combining sequences.
	  //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
	  //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
	  //    Implementations are not consistent within browsers; sometimes labeled as just big5.
	  //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
	  //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
	  //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
	  //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
	  //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
	  //
	  // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
	  // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

	  windows950: "cp950",
	  ms950: "cp950",
	  950: "cp950",
	  cp950: {
	    type: "_dbcs",
	    table: function () { return require$$6 }
	  },

	  // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
	  big5: "big5hkscs",
	  big5hkscs: {
	    type: "_dbcs",
	    table: function () { return require$$6.concat(require$$7) },
	    encodeSkipVals: [
	      // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
	      // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
	      // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
	      0x8e69, 0x8e6f, 0x8e7e, 0x8eab, 0x8eb4, 0x8ecd, 0x8ed0, 0x8f57, 0x8f69, 0x8f6e, 0x8fcb, 0x8ffe,
	      0x906d, 0x907a, 0x90c4, 0x90dc, 0x90f1, 0x91bf, 0x92af, 0x92b0, 0x92b1, 0x92b2, 0x92d1, 0x9447, 0x94ca,
	      0x95d9, 0x96fc, 0x9975, 0x9b76, 0x9b78, 0x9b7b, 0x9bc6, 0x9bde, 0x9bec, 0x9bf6, 0x9c42, 0x9c53, 0x9c62,
	      0x9c68, 0x9c6b, 0x9c77, 0x9cbc, 0x9cbd, 0x9cd0, 0x9d57, 0x9d5a, 0x9dc4, 0x9def, 0x9dfb, 0x9ea9, 0x9eef,
	      0x9efd, 0x9f60, 0x9fcb, 0xa077, 0xa0dc, 0xa0df, 0x8fcc, 0x92c8, 0x9644, 0x96ed,

	      // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
	      0xa2a4, 0xa2a5, 0xa2a7, 0xa2a6, 0xa2cc, 0xa2ce
	    ]
	  },

	  cnbig5: "big5hkscs",
	  csbig5: "big5hkscs",
	  xxbig5: "big5hkscs"
	};
	return dbcsData;
}

var hasRequiredEncodings;

function requireEncodings () {
	if (hasRequiredEncodings) return encodings;
	hasRequiredEncodings = 1;
	(function (exports$1) {

		var mergeModules = mergeExports;

		// Update this array if you add/rename/remove files in this directory.
		// We support Browserify by skipping automatic module discovery and requiring modules directly.
		var modules = [
		  /*@__PURE__*/ requireInternal(),
		  /*@__PURE__*/ requireUtf32(),
		  /*@__PURE__*/ requireUtf16(),
		  /*@__PURE__*/ requireUtf7(),
		  /*@__PURE__*/ requireSbcsCodec(),
		  /*@__PURE__*/ requireSbcsData(),
		  /*@__PURE__*/ requireSbcsDataGenerated(),
		  /*@__PURE__*/ requireDbcsCodec(),
		  /*@__PURE__*/ requireDbcsData()
		];

		// Put all encoding/alias/codec definitions to single object and export it.
		for (var i = 0; i < modules.length; i++) {
		  var module = modules[i];
		  mergeModules(exports$1, module);
		} 
	} (encodings));
	return encodings;
}

var streams;
var hasRequiredStreams;

function requireStreams () {
	if (hasRequiredStreams) return streams;
	hasRequiredStreams = 1;

	var Buffer = safer_1.Buffer;

	// NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments),
	// we opt to dependency-inject it instead of creating a hard dependency.
	streams = function (streamModule) {
	  var Transform = streamModule.Transform;

	  // == Encoder stream =======================================================

	  function IconvLiteEncoderStream (conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
	    Transform.call(this, options);
	  }

	  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteEncoderStream }
	  });

	  IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
	    if (typeof chunk !== "string") {
	      return done(new Error("Iconv encoding stream needs strings as its input."))
	    }

	    try {
	      var res = this.conv.write(chunk);
	      if (res && res.length) this.push(res);
	      done();
	    } catch (e) {
	      done(e);
	    }
	  };

	  IconvLiteEncoderStream.prototype._flush = function (done) {
	    try {
	      var res = this.conv.end();
	      if (res && res.length) this.push(res);
	      done();
	    } catch (e) {
	      done(e);
	    }
	  };

	  IconvLiteEncoderStream.prototype.collect = function (cb) {
	    var chunks = [];
	    this.on("error", cb);
	    this.on("data", function (chunk) { chunks.push(chunk); });
	    this.on("end", function () {
	      cb(null, Buffer.concat(chunks));
	    });
	    return this
	  };

	  // == Decoder stream =======================================================

	  function IconvLiteDecoderStream (conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.encoding = this.encoding = "utf8"; // We output strings.
	    Transform.call(this, options);
	  }

	  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteDecoderStream }
	  });

	  IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
	    if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array)) { return done(new Error("Iconv decoding stream needs buffers as its input.")) }
	    try {
	      var res = this.conv.write(chunk);
	      if (res && res.length) this.push(res, this.encoding);
	      done();
	    } catch (e) {
	      done(e);
	    }
	  };

	  IconvLiteDecoderStream.prototype._flush = function (done) {
	    try {
	      var res = this.conv.end();
	      if (res && res.length) this.push(res, this.encoding);
	      done();
	    } catch (e) {
	      done(e);
	    }
	  };

	  IconvLiteDecoderStream.prototype.collect = function (cb) {
	    var res = "";
	    this.on("error", cb);
	    this.on("data", function (chunk) { res += chunk; });
	    this.on("end", function () {
	      cb(null, res);
	    });
	    return this
	  };

	  return {
	    IconvLiteEncoderStream: IconvLiteEncoderStream,
	    IconvLiteDecoderStream: IconvLiteDecoderStream
	  }
	};
	return streams;
}

(function (module) {

	var Buffer = safer_1.Buffer;

	var bomHandling$1 = bomHandling;
	var mergeModules = mergeExports;
	var iconv = module.exports;

	// All codecs and aliases are kept here, keyed by encoding name/alias.
	// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
	// Cannot initialize with { __proto__: null } because Boolean({ __proto__: null }) === true
	iconv.encodings = null;

	// Characters emitted in case of error.
	iconv.defaultCharUnicode = "";
	iconv.defaultCharSingleByte = "?";

	// Public API.
	iconv.encode = function encode (str, encoding, options) {
	  str = "" + (str || ""); // Ensure string.

	  var encoder = iconv.getEncoder(encoding, options);

	  var res = encoder.write(str);
	  var trail = encoder.end();

	  return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res
	};

	iconv.decode = function decode (buf, encoding, options) {
	  if (typeof buf === "string") {
	    if (!iconv.skipDecodeWarning) {
	      console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
	      iconv.skipDecodeWarning = true;
	    }

	    buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
	  }

	  var decoder = iconv.getDecoder(encoding, options);

	  var res = decoder.write(buf);
	  var trail = decoder.end();

	  return trail ? (res + trail) : res
	};

	iconv.encodingExists = function encodingExists (enc) {
	  try {
	    iconv.getCodec(enc);
	    return true
	  } catch (e) {
	    return false
	  }
	};

	// Legacy aliases to convert functions
	iconv.toEncoding = iconv.encode;
	iconv.fromEncoding = iconv.decode;

	// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
	iconv._codecDataCache = { __proto__: null };

	iconv.getCodec = function getCodec (encoding) {
	  if (!iconv.encodings) {
	    var raw = /*@__PURE__*/ requireEncodings();
	    // TODO: In future versions when old nodejs support is removed can use object.assign
	    iconv.encodings = { __proto__: null }; // Initialize as empty object.
	    mergeModules(iconv.encodings, raw);
	  }

	  // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
	  var enc = iconv._canonicalizeEncoding(encoding);

	  // Traverse iconv.encodings to find actual codec.
	  var codecOptions = {};
	  while (true) {
	    var codec = iconv._codecDataCache[enc];

	    if (codec) { return codec }

	    var codecDef = iconv.encodings[enc];

	    switch (typeof codecDef) {
	      case "string": // Direct alias to other encoding.
	        enc = codecDef;
	        break

	      case "object": // Alias with options. Can be layered.
	        for (var key in codecDef) { codecOptions[key] = codecDef[key]; }

	        if (!codecOptions.encodingName) { codecOptions.encodingName = enc; }

	        enc = codecDef.type;
	        break

	      case "function": // Codec itself.
	        if (!codecOptions.encodingName) { codecOptions.encodingName = enc; }

	        // The codec function must load all tables and return object with .encoder and .decoder methods.
	        // It'll be called only once (for each different options object).
	        //
	        codec = new codecDef(codecOptions, iconv);

	        iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
	        return codec

	      default:
	        throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')")
	    }
	  }
	};

	iconv._canonicalizeEncoding = function (encoding) {
	  // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
	  return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "")
	};

	iconv.getEncoder = function getEncoder (encoding, options) {
	  var codec = iconv.getCodec(encoding);
	  var encoder = new codec.encoder(options, codec);

	  if (codec.bomAware && options && options.addBOM) { encoder = new bomHandling$1.PrependBOM(encoder, options); }

	  return encoder
	};

	iconv.getDecoder = function getDecoder (encoding, options) {
	  var codec = iconv.getCodec(encoding);
	  var decoder = new codec.decoder(options, codec);

	  if (codec.bomAware && !(options && options.stripBOM === false)) { decoder = new bomHandling$1.StripBOM(decoder, options); }

	  return decoder
	};

	// Streaming API
	// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
	// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
	// If you would like to enable it explicitly, please add the following code to your app:
	// > iconv.enableStreamingAPI(require('stream'));
	iconv.enableStreamingAPI = function enableStreamingAPI (streamModule) {
	  if (iconv.supportsStreams) { return }

	  // Dependency-inject stream module to create IconvLite stream classes.
	  var streams = /*@__PURE__*/ requireStreams()(streamModule);

	  // Not public API yet, but expose the stream classes.
	  iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
	  iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;

	  // Streaming API.
	  iconv.encodeStream = function encodeStream (encoding, options) {
	    return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options)
	  };

	  iconv.decodeStream = function decodeStream (encoding, options) {
	    return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options)
	  };

	  iconv.supportsStreams = true;
	};

	// Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
	var streamModule;
	try {
	  streamModule = require("stream");
	} catch (e) {}

	if (streamModule && streamModule.Transform) {
	  iconv.enableStreamingAPI(streamModule);
	} else {
	  // In rare cases where 'stream' module is not available by default, throw a helpful exception.
	  iconv.encodeStream = iconv.decodeStream = function () {
	    throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.")
	  };
	}
} (lib$2));

var libExports = lib$2.exports;

const Iconv = libExports;
const { createLRU: createLRU$1 } = require$$7$1;

const decoderCache = createLRU$1({
  max: 500,
});

string.decode = function (buffer, encoding, start, end, options) {
  if (Buffer.isEncoding(encoding)) {
    return buffer.toString(encoding, start, end);
  }

  // Optimize for common case: encoding="short_string", options=undefined.
  let decoder;
  if (!options) {
    decoder = decoderCache.get(encoding);
    if (!decoder) {
      decoder = Iconv.getDecoder(encoding);
      decoderCache.set(encoding, decoder);
    }
  } else {
    const decoderArgs = { encoding, options };
    const decoderKey = JSON.stringify(decoderArgs);
    decoder = decoderCache.get(decoderKey);
    if (!decoder) {
      decoder = Iconv.getDecoder(decoderArgs.encoding, decoderArgs.options);
      decoderCache.set(decoderKey, decoder);
    }
  }

  const res = decoder.write(buffer.slice(start, end));
  const trail = decoder.end();

  return trail ? res + trail : res;
};

string.encode = function (string, encoding, options) {
  if (Buffer.isEncoding(encoding)) {
    return Buffer.from(string, encoding);
  }

  const encoder = Iconv.getEncoder(encoding, options || {});

  const res = encoder.write(string);
  const trail = encoder.end();

  return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
};

var types = {exports: {}};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types.exports;
	hasRequiredTypes = 1;

	types.exports = {
	  0x00: 'DECIMAL', // aka DECIMAL
	  0x01: 'TINY', // aka TINYINT, 1 byte
	  0x02: 'SHORT', // aka SMALLINT, 2 bytes
	  0x03: 'LONG', // aka INT, 4 bytes
	  0x04: 'FLOAT', // aka FLOAT, 4-8 bytes
	  0x05: 'DOUBLE', // aka DOUBLE, 8 bytes
	  0x06: 'NULL', // NULL (used for prepared statements, I think)
	  0x07: 'TIMESTAMP', // aka TIMESTAMP
	  0x08: 'LONGLONG', // aka BIGINT, 8 bytes
	  0x09: 'INT24', // aka MEDIUMINT, 3 bytes
	  0x0a: 'DATE', // aka DATE
	  0x0b: 'TIME', // aka TIME
	  0x0c: 'DATETIME', // aka DATETIME
	  0x0d: 'YEAR', // aka YEAR, 1 byte (don't ask)
	  0x0e: 'NEWDATE', // aka ?
	  0x0f: 'VARCHAR', // aka VARCHAR (?)
	  0x10: 'BIT', // aka BIT, 1-8 byte
	  0xf5: 'JSON',
	  0xf6: 'NEWDECIMAL', // aka DECIMAL
	  0xf7: 'ENUM', // aka ENUM
	  0xf8: 'SET', // aka SET
	  0xf9: 'TINY_BLOB', // aka TINYBLOB, TINYTEXT
	  0xfa: 'MEDIUM_BLOB', // aka MEDIUMBLOB, MEDIUMTEXT
	  0xfb: 'LONG_BLOB', // aka LONGBLOG, LONGTEXT
	  0xfc: 'BLOB', // aka BLOB, TEXT
	  0xfd: 'VAR_STRING', // aka VARCHAR, VARBINARY
	  0xfe: 'STRING', // aka CHAR, BINARY
	  0xff: 'GEOMETRY', // aka GEOMETRY
	};

	// Manually extracted from mysql-5.5.23/include/mysql_com.h
	// some more info here: http://dev.mysql.com/doc/refman/5.5/en/c-api-prepared-statement-type-codes.html
	types.exports.DECIMAL = 0x00; // aka DECIMAL (http://dev.mysql.com/doc/refman/5.0/en/precision-math-decimal-changes.html)
	types.exports.TINY = 0x01; // aka TINYINT, 1 byte
	types.exports.SHORT = 0x02; // aka SMALLINT, 2 bytes
	types.exports.LONG = 0x03; // aka INT, 4 bytes
	types.exports.FLOAT = 0x04; // aka FLOAT, 4-8 bytes
	types.exports.DOUBLE = 0x05; // aka DOUBLE, 8 bytes
	types.exports.NULL = 0x06; // NULL (used for prepared statements, I think)
	types.exports.TIMESTAMP = 0x07; // aka TIMESTAMP
	types.exports.LONGLONG = 0x08; // aka BIGINT, 8 bytes
	types.exports.INT24 = 0x09; // aka MEDIUMINT, 3 bytes
	types.exports.DATE = 0x0a; // aka DATE
	types.exports.TIME = 0x0b; // aka TIME
	types.exports.DATETIME = 0x0c; // aka DATETIME
	types.exports.YEAR = 0x0d; // aka YEAR, 1 byte (don't ask)
	types.exports.NEWDATE = 0x0e; // aka ?
	types.exports.VARCHAR = 0x0f; // aka VARCHAR (?)
	types.exports.BIT = 0x10; // aka BIT, 1-8 byte
	types.exports.VECTOR = 0xf2;
	types.exports.JSON = 0xf5;
	types.exports.NEWDECIMAL = 0xf6; // aka DECIMAL
	types.exports.ENUM = 0xf7; // aka ENUM
	types.exports.SET = 0xf8; // aka SET
	types.exports.TINY_BLOB = 0xf9; // aka TINYBLOB, TINYTEXT
	types.exports.MEDIUM_BLOB = 0xfa; // aka MEDIUMBLOB, MEDIUMTEXT
	types.exports.LONG_BLOB = 0xfb; // aka LONGBLOG, LONGTEXT
	types.exports.BLOB = 0xfc; // aka BLOB, TEXT
	types.exports.VAR_STRING = 0xfd; // aka VARCHAR, VARBINARY
	types.exports.STRING = 0xfe; // aka CHAR, BINARY
	types.exports.GEOMETRY = 0xff; // aka GEOMETRY
	return types.exports;
}

const ErrorCodeToName = errors;
const NativeBuffer = require$$0$3.Buffer;
const Long = Long$1;
const StringParser$3 = string;
const Types$6 = /*@__PURE__*/ requireTypes();
const INVALID_DATE = new Date(NaN);

// this is nearly duplicate of previous function so generated code is not slower
// due to "if (dateStrings)" branching
const pad = '000000000000';
function leftPad(num, value) {
  const s = value.toString();
  // if we don't need to pad
  if (s.length >= num) {
    return s;
  }
  return (pad + s).slice(-num);
}

// The whole reason parse* function below exist
// is because String creation is relatively expensive (at least with V8), and if we have
// a buffer with "12345" content ideally we would like to bypass intermediate
// "12345" string creation and directly build 12345 number out of
// <Buffer 31 32 33 34 35> data.
// In my benchmarks the difference is ~25M 8-digit numbers per second vs
// 4.5 M using Number(packet.readLengthCodedString())
// not used when size is close to max precision as series of *10 accumulate error
// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))
// In the futire node version if speed difference is smaller parse* functions might be removed
// don't consider them as Packet public API

const minus = '-'.charCodeAt(0);
const plus = '+'.charCodeAt(0);

// TODO: handle E notation
const dot = '.'.charCodeAt(0);
const exponent = 'e'.charCodeAt(0);
const exponentCapital = 'E'.charCodeAt(0);

let Packet$l = class Packet {
  constructor(id, buffer, start, end) {
    // hot path, enable checks when testing only
    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')
    //  throw new Error('invalid packet');
    this.sequenceId = id;
    this.numPackets = 1;
    this.buffer = buffer;
    this.start = start;
    this.offset = start + 4;
    this.end = end;
  }

  // ==============================
  // readers
  // ==============================
  reset() {
    this.offset = this.start + 4;
  }

  length() {
    return this.end - this.start;
  }

  slice() {
    return this.buffer.slice(this.start, this.end);
  }

  dump() {
    // eslint-disable-next-line no-console
    console.log(
      [this.buffer.asciiSlice(this.start, this.end)],
      this.buffer.slice(this.start, this.end),
      this.length(),
      this.sequenceId
    );
  }

  haveMoreData() {
    return this.end > this.offset;
  }

  skip(num) {
    this.offset += num;
  }

  readInt8() {
    return this.buffer[this.offset++];
  }

  readInt16() {
    this.offset += 2;
    return this.buffer.readUInt16LE(this.offset - 2);
  }

  readInt24() {
    return this.readInt16() + (this.readInt8() << 16);
  }

  readInt32() {
    this.offset += 4;
    return this.buffer.readUInt32LE(this.offset - 4);
  }

  readSInt8() {
    return this.buffer.readInt8(this.offset++);
  }

  readSInt16() {
    this.offset += 2;
    return this.buffer.readInt16LE(this.offset - 2);
  }

  readSInt32() {
    this.offset += 4;
    return this.buffer.readInt32LE(this.offset - 4);
  }

  readInt64JSNumber() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    const l = new Long(word0, word1, true);
    return l.toNumber();
  }

  readSInt64JSNumber() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    if (!(word1 & 0x80000000)) {
      return word0 + 0x100000000 * word1;
    }
    const l = new Long(word0, word1, false);
    return l.toNumber();
  }

  readInt64String() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    const res = new Long(word0, word1, true);
    return res.toString();
  }

  readSInt64String() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    const res = new Long(word0, word1, false);
    return res.toString();
  }

  readInt64() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    let res = new Long(word0, word1, true);
    const resNumber = res.toNumber();
    const resString = res.toString();
    res = resNumber.toString() === resString ? resNumber : resString;
    return res;
  }

  readSInt64() {
    const word0 = this.readInt32();
    const word1 = this.readInt32();
    let res = new Long(word0, word1, false);
    const resNumber = res.toNumber();
    const resString = res.toString();
    res = resNumber.toString() === resString ? resNumber : resString;
    return res;
  }

  isEOF() {
    return this.buffer[this.offset] === 0xfe && this.length() < 13;
  }

  eofStatusFlags() {
    return this.buffer.readInt16LE(this.offset + 3);
  }

  eofWarningCount() {
    return this.buffer.readInt16LE(this.offset + 1);
  }

  readLengthCodedNumber(bigNumberStrings, signed) {
    const byte1 = this.buffer[this.offset++];
    if (byte1 < 251) {
      return byte1;
    }
    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);
  }

  readLengthCodedNumberSigned(bigNumberStrings) {
    return this.readLengthCodedNumber(bigNumberStrings, true);
  }

  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {
    let word0, word1;
    let res;
    if (tag === 0xfb) {
      return null;
    }
    if (tag === 0xfc) {
      return this.readInt8() + (this.readInt8() << 8);
    }
    if (tag === 0xfd) {
      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);
    }
    if (tag === 0xfe) {
      // TODO: check version
      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.
      word0 = this.readInt32();
      word1 = this.readInt32();
      if (word1 === 0) {
        return word0; // don't convert to float if possible
      }
      if (word1 < 2097152) {
        // max exact float point int, 2^52 / 2^32
        return word1 * 0x100000000 + word0;
      }
      res = new Long(word0, word1, !signed); // Long need unsigned
      const resNumber = res.toNumber();
      const resString = res.toString();
      res = resNumber.toString() === resString ? resNumber : resString;
      return bigNumberStrings ? resString : res;
    }
    // eslint-disable-next-line no-console
    console.trace();
    throw new Error(`Should not reach here: ${tag}`);
  }

  readFloat() {
    const res = this.buffer.readFloatLE(this.offset);
    this.offset += 4;
    return res;
  }

  readDouble() {
    const res = this.buffer.readDoubleLE(this.offset);
    this.offset += 8;
    return res;
  }

  readBuffer(len) {
    if (typeof len === 'undefined') {
      len = this.end - this.offset;
    }
    this.offset += len;
    return this.buffer.slice(this.offset - len, this.offset);
  }

  // DATE, DATETIME and TIMESTAMP
  readDateTime(timezone) {
    if (!timezone || timezone === 'Z' || timezone === 'local') {
      const length = this.readInt8();
      if (length === 0xfb) {
        return null;
      }
      let y = 0;
      let m = 0;
      let d = 0;
      let H = 0;
      let M = 0;
      let S = 0;
      let ms = 0;
      if (length > 3) {
        y = this.readInt16();
        m = this.readInt8();
        d = this.readInt8();
      }
      if (length > 6) {
        H = this.readInt8();
        M = this.readInt8();
        S = this.readInt8();
      }
      if (length > 10) {
        ms = this.readInt32() / 1000;
      }
      // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict
      // default SQL mode used by MySQL 8.0. This means that non-standard
      // dates like '0000-00-00' become NULL. For older versions and other
      // possible MySQL flavours we still need to account for the
      // non-standard behaviour.
      if (y + m + d + H + M + S + ms === 0) {
        return INVALID_DATE;
      }
      if (timezone === 'Z') {
        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));
      }
      return new Date(y, m - 1, d, H, M, S, ms);
    }
    let str = this.readDateTimeString(6, 'T', null);
    if (str.length === 10) {
      str += 'T00:00:00';
    }
    return new Date(str + timezone);
  }

  readDateTimeString(decimals, timeSep, columnType) {
    const length = this.readInt8();
    let y = 0;
    let m = 0;
    let d = 0;
    let H = 0;
    let M = 0;
    let S = 0;
    let ms = 0;
    let str;
    if (length > 3) {
      y = this.readInt16();
      m = this.readInt8();
      d = this.readInt8();
      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');
    }
    if (length > 6) {
      H = this.readInt8();
      M = this.readInt8();
      S = this.readInt8();
      str += `${timeSep || ' '}${[
        leftPad(2, H),
        leftPad(2, M),
        leftPad(2, S),
      ].join(':')}`;
    } else if (columnType === Types$6.DATETIME) {
      str += ' 00:00:00';
    }
    if (length > 10) {
      ms = this.readInt32();
      str += '.';
      if (decimals) {
        ms = leftPad(6, ms);
        if (ms.length > decimals) {
          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here
        }
      }
      str += ms;
    }
    return str;
  }

  // TIME - value as a string, Can be negative
  readTimeString(convertTtoMs) {
    const length = this.readInt8();
    if (length === 0) {
      return '00:00:00';
    }
    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte
    let d = 0;
    let H = 0;
    let M = 0;
    let S = 0;
    let ms = 0;
    if (length > 6) {
      d = this.readInt32();
      H = this.readInt8();
      M = this.readInt8();
      S = this.readInt8();
    }
    if (length > 10) {
      ms = this.readInt32();
    }
    if (convertTtoMs) {
      H += d * 24;
      M += H * 60;
      S += M * 60;
      ms += S * 1000;
      ms *= sign;
      return ms;
    }
    // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])
    // For positive times below 24 hours, this makes it equal to ISO 8601 times
    return (
      (sign === -1 ? '-' : '') +
      [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') +
      (ms ? `.${ms}`.replace(/0+$/, '') : '')
    );
  }

  readLengthCodedString(encoding) {
    const len = this.readLengthCodedNumber();
    // TODO: check manually first byte here to avoid polymorphic return type?
    if (len === null) {
      return null;
    }
    this.offset += len;
    // TODO: Use characterSetCode to get proper encoding
    // https://github.com/sidorares/node-mysql2/pull/374
    return StringParser$3.decode(
      this.buffer,
      encoding,
      this.offset - len,
      this.offset
    );
  }

  readLengthCodedBuffer() {
    const len = this.readLengthCodedNumber();
    if (len === null) {
      return null;
    }
    return this.readBuffer(len);
  }

  readNullTerminatedString(encoding) {
    const start = this.offset;
    let end = this.offset;
    while (this.buffer[end]) {
      end = end + 1; // TODO: handle OOB check
    }
    this.offset = end + 1;
    return StringParser$3.decode(this.buffer, encoding, start, end);
  }

  // TODO reuse?
  readString(len, encoding) {
    if (typeof len === 'string' && typeof encoding === 'undefined') {
      encoding = len;
      len = undefined;
    }
    if (typeof len === 'undefined') {
      len = this.end - this.offset;
    }
    this.offset += len;
    return StringParser$3.decode(
      this.buffer,
      encoding,
      this.offset - len,
      this.offset
    );
  }

  parseInt(len, supportBigNumbers) {
    if (len === null) {
      return null;
    }
    if (len >= 14 && !supportBigNumbers) {
      const s = this.buffer.toString('ascii', this.offset, this.offset + len);
      this.offset += len;
      return Number(s);
    }
    let result = 0;
    const start = this.offset;
    const end = this.offset + len;
    let sign = 1;
    if (len === 0) {
      return 0; // TODO: assert? exception?
    }
    if (this.buffer[this.offset] === minus) {
      this.offset++;
      sign = -1;
    }
    // max precise int is 9007199254740992
    let str;
    const numDigits = end - this.offset;
    if (supportBigNumbers) {
      if (numDigits >= 15) {
        str = this.readString(end - this.offset, 'binary');
        result = parseInt(str, 10);
        if (result.toString() === str) {
          return sign * result;
        }
        return sign === -1 ? `-${str}` : str;
      }
      if (numDigits > 16) {
        str = this.readString(end - this.offset);
        return sign === -1 ? `-${str}` : str;
      }
    }
    if (this.buffer[this.offset] === plus) {
      this.offset++; // just ignore
    }
    while (this.offset < end) {
      result *= 10;
      result += this.buffer[this.offset] - 48;
      this.offset++;
    }
    const num = result * sign;
    if (!supportBigNumbers) {
      return num;
    }
    str = this.buffer.toString('ascii', start, end);
    if (num.toString() === str) {
      return num;
    }
    return str;
  }

  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER
  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be
  // different from what you would get from Number(inputNumberAsString)
  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString
  parseIntNoBigCheck(len) {
    if (len === null) {
      return null;
    }
    let result = 0;
    const end = this.offset + len;
    let sign = 1;
    if (len === 0) {
      return 0; // TODO: assert? exception?
    }
    if (this.buffer[this.offset] === minus) {
      this.offset++;
      sign = -1;
    }
    if (this.buffer[this.offset] === plus) {
      this.offset++; // just ignore
    }
    while (this.offset < end) {
      result *= 10;
      result += this.buffer[this.offset] - 48;
      this.offset++;
    }
    return result * sign;
  }

  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js
  parseGeometryValue() {
    const buffer = this.readLengthCodedBuffer();
    let offset = 4;
    if (buffer === null || !buffer.length) {
      return null;
    }
    function parseGeometry() {
      let x, y, i, j, numPoints, line;
      let result = null;
      const byteOrder = buffer.readUInt8(offset);
      offset += 1;
      const wkbType = byteOrder
        ? buffer.readUInt32LE(offset)
        : buffer.readUInt32BE(offset);
      offset += 4;
      switch (wkbType) {
        case 1: // WKBPoint
          x = byteOrder
            ? buffer.readDoubleLE(offset)
            : buffer.readDoubleBE(offset);
          offset += 8;
          y = byteOrder
            ? buffer.readDoubleLE(offset)
            : buffer.readDoubleBE(offset);
          offset += 8;
          result = { x: x, y: y };
          break;
        case 2: // WKBLineString
          numPoints = byteOrder
            ? buffer.readUInt32LE(offset)
            : buffer.readUInt32BE(offset);
          offset += 4;
          result = [];
          for (i = numPoints; i > 0; i--) {
            x = byteOrder
              ? buffer.readDoubleLE(offset)
              : buffer.readDoubleBE(offset);
            offset += 8;
            y = byteOrder
              ? buffer.readDoubleLE(offset)
              : buffer.readDoubleBE(offset);
            offset += 8;
            result.push({ x: x, y: y });
          }
          break;
        case 3: // WKBPolygon
          // eslint-disable-next-line no-case-declarations
          const numRings = byteOrder
            ? buffer.readUInt32LE(offset)
            : buffer.readUInt32BE(offset);
          offset += 4;
          result = [];
          for (i = numRings; i > 0; i--) {
            numPoints = byteOrder
              ? buffer.readUInt32LE(offset)
              : buffer.readUInt32BE(offset);
            offset += 4;
            line = [];
            for (j = numPoints; j > 0; j--) {
              x = byteOrder
                ? buffer.readDoubleLE(offset)
                : buffer.readDoubleBE(offset);
              offset += 8;
              y = byteOrder
                ? buffer.readDoubleLE(offset)
                : buffer.readDoubleBE(offset);
              offset += 8;
              line.push({ x: x, y: y });
            }
            result.push(line);
          }
          break;
        case 4: // WKBMultiPoint
        case 5: // WKBMultiLineString
        case 6: // WKBMultiPolygon
        case 7: // WKBGeometryCollection
          // eslint-disable-next-line no-case-declarations
          const num = byteOrder
            ? buffer.readUInt32LE(offset)
            : buffer.readUInt32BE(offset);
          offset += 4;
          result = [];
          for (i = num; i > 0; i--) {
            result.push(parseGeometry());
          }
          break;
      }
      return result;
    }
    return parseGeometry();
  }

  parseVector() {
    const bufLen = this.readLengthCodedNumber();
    const vectorEnd = this.offset + bufLen;
    const result = [];
    while (this.offset < vectorEnd && this.offset < this.end) {
      result.push(this.readFloat());
    }
    return result;
  }

  parseDate(timezone) {
    const strLen = this.readLengthCodedNumber();
    if (strLen === null) {
      return null;
    }
    if (strLen !== 10) {
      // we expect only YYYY-MM-DD here.
      // if for some reason it's not the case return invalid date
      return new Date(NaN);
    }
    const y = this.parseInt(4);
    this.offset++; // -
    const m = this.parseInt(2);
    this.offset++; // -
    const d = this.parseInt(2);
    if (!timezone || timezone === 'local') {
      return new Date(y, m - 1, d);
    }
    if (timezone === 'Z') {
      return new Date(Date.UTC(y, m - 1, d));
    }
    return new Date(
      `${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`
    );
  }

  parseDateTime(timezone) {
    const str = this.readLengthCodedString('binary');
    if (str === null) {
      return null;
    }
    if (!timezone || timezone === 'local') {
      return new Date(str);
    }
    return new Date(`${str}${timezone}`);
  }

  parseFloat(len) {
    if (len === null) {
      return null;
    }
    let result = 0;
    const end = this.offset + len;
    let factor = 1;
    let pastDot = false;
    let charCode = 0;
    if (len === 0) {
      return 0; // TODO: assert? exception?
    }
    if (this.buffer[this.offset] === minus) {
      this.offset++;
      factor = -1;
    }
    if (this.buffer[this.offset] === plus) {
      this.offset++; // just ignore
    }
    while (this.offset < end) {
      charCode = this.buffer[this.offset];
      if (charCode === dot) {
        pastDot = true;
        this.offset++;
      } else if (charCode === exponent || charCode === exponentCapital) {
        this.offset++;
        const exponentValue = this.parseInt(end - this.offset);
        return (result / factor) * Math.pow(10, exponentValue);
      } else {
        result *= 10;
        result += this.buffer[this.offset] - 48;
        this.offset++;
        if (pastDot) {
          factor = factor * 10;
        }
      }
    }
    return result / factor;
  }

  parseLengthCodedIntNoBigCheck() {
    return this.parseIntNoBigCheck(this.readLengthCodedNumber());
  }

  parseLengthCodedInt(supportBigNumbers) {
    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);
  }

  parseLengthCodedIntString() {
    return this.readLengthCodedString('binary');
  }

  parseLengthCodedFloat() {
    return this.parseFloat(this.readLengthCodedNumber());
  }

  peekByte() {
    return this.buffer[this.offset];
  }

  // OxFE is often used as "Alt" flag - not ok, not error.
  // For example, it's first byte of AuthSwitchRequest
  isAlt() {
    return this.peekByte() === 0xfe;
  }

  isError() {
    return this.peekByte() === 0xff;
  }

  asError(encoding) {
    this.reset();
    this.readInt8(); // fieldCount
    const errorCode = this.readInt16();
    let sqlState = '';
    if (this.buffer[this.offset] === 0x23) {
      this.skip(1);
      sqlState = this.readBuffer(5).toString();
    }
    const message = this.readString(undefined, encoding);
    const err = new Error(message);
    err.code = ErrorCodeToName[errorCode];
    err.errno = errorCode;
    err.sqlState = sqlState;
    err.sqlMessage = message;
    return err;
  }

  writeInt32(n) {
    this.buffer.writeUInt32LE(n, this.offset);
    this.offset += 4;
  }

  writeInt24(n) {
    this.writeInt8(n & 0xff);
    this.writeInt16(n >> 8);
  }

  writeInt16(n) {
    this.buffer.writeUInt16LE(n, this.offset);
    this.offset += 2;
  }

  writeInt8(n) {
    this.buffer.writeUInt8(n, this.offset);
    this.offset++;
  }

  writeDouble(n) {
    this.buffer.writeDoubleLE(n, this.offset);
    this.offset += 8;
  }

  writeBuffer(b) {
    b.copy(this.buffer, this.offset);
    this.offset += b.length;
  }

  writeNull() {
    this.buffer[this.offset] = 0xfb;
    this.offset++;
  }

  // TODO: refactor following three?
  writeNullTerminatedString(s, encoding) {
    const buf = StringParser$3.encode(s, encoding);
    this.buffer.length && buf.copy(this.buffer, this.offset);
    this.offset += buf.length;
    this.writeInt8(0);
  }

  writeString(s, encoding) {
    if (s === null) {
      this.writeInt8(0xfb);
      return;
    }
    if (s.length === 0) {
      return;
    }
    // const bytes = Buffer.byteLength(s, 'utf8');
    // this.buffer.write(s, this.offset, bytes, 'utf8');
    // this.offset += bytes;
    const buf = StringParser$3.encode(s, encoding);
    this.buffer.length && buf.copy(this.buffer, this.offset);
    this.offset += buf.length;
  }

  writeLengthCodedString(s, encoding) {
    const buf = StringParser$3.encode(s, encoding);
    this.writeLengthCodedNumber(buf.length);
    this.buffer.length && buf.copy(this.buffer, this.offset);
    this.offset += buf.length;
  }

  writeLengthCodedBuffer(b) {
    this.writeLengthCodedNumber(b.length);
    b.copy(this.buffer, this.offset);
    this.offset += b.length;
  }

  writeLengthCodedNumber(n) {
    if (n < 0xfb) {
      return this.writeInt8(n);
    }
    if (n < 0xffff) {
      this.writeInt8(0xfc);
      return this.writeInt16(n);
    }
    if (n < 0xffffff) {
      this.writeInt8(0xfd);
      return this.writeInt24(n);
    }
    if (n === null) {
      return this.writeInt8(0xfb);
    }
    // TODO: check that n is out of int precision
    this.writeInt8(0xfe);
    this.buffer.writeUInt32LE(n, this.offset);
    this.offset += 4;
    this.buffer.writeUInt32LE(n >> 32, this.offset);
    this.offset += 4;
    return this.offset;
  }

  writeDate(d, timezone) {
    this.buffer.writeUInt8(11, this.offset);
    if (!timezone || timezone === 'local') {
      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);
      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);
      this.buffer.writeUInt8(d.getDate(), this.offset + 4);
      this.buffer.writeUInt8(d.getHours(), this.offset + 5);
      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);
      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);
      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);
    } else {
      if (timezone !== 'Z') {
        const offset =
          (timezone[0] === '-' ? -1 : 1) *
          (parseInt(timezone.substring(1, 3), 10) * 60 +
            parseInt(timezone.substring(4), 10));
        if (offset !== 0) {
          d = new Date(d.getTime() + 60000 * offset);
        }
      }
      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);
      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);
      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);
      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);
      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);
      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);
      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);
    }
    this.offset += 12;
  }

  writeHeader(sequenceId) {
    const offset = this.offset;
    this.offset = 0;
    this.writeInt24(this.buffer.length - 4);
    this.writeInt8(sequenceId);
    this.offset = offset;
  }

  clone() {
    return new Packet(this.sequenceId, this.buffer, this.start, this.end);
  }

  type() {
    if (this.isEOF()) {
      return 'EOF';
    }
    if (this.isError()) {
      return 'Error';
    }
    if (this.buffer[this.offset] === 0) {
      return 'maybeOK'; // could be other packet types as well
    }
    return '';
  }

  static lengthCodedNumberLength(n) {
    if (n < 0xfb) {
      return 1;
    }
    if (n < 0xffff) {
      return 3;
    }
    if (n < 0xffffff) {
      return 5;
    }
    return 9;
  }

  static lengthCodedStringLength(str, encoding) {
    const buf = StringParser$3.encode(str, encoding);
    const slen = buf.length;
    return Packet.lengthCodedNumberLength(slen) + slen;
  }

  static MockBuffer() {
    const noop = function () {};
    const res = Buffer.alloc(0);
    for (const op in NativeBuffer.prototype) {
      if (typeof res[op] === 'function') {
        res[op] = noop;
      }
    }
    return res;
  }
};

var packet = Packet$l;

const Packet$k = packet;

const MAX_PACKET_LENGTH = 16777215;

function readPacketLength(b, off) {
  const b0 = b[off];
  const b1 = b[off + 1];
  const b2 = b[off + 2];
  if (b1 + b2 === 0) {
    return b0;
  }
  return b0 + (b1 << 8) + (b2 << 16);
}

let PacketParser$1 = class PacketParser {
  constructor(onPacket, packetHeaderLength) {
    // 4 for normal packets, 7 for comprssed protocol packets
    if (typeof packetHeaderLength === 'undefined') {
      packetHeaderLength = 4;
    }
    // array of last payload chunks
    // only used when current payload is not complete
    this.buffer = [];
    // total length of chunks on buffer
    this.bufferLength = 0;
    this.packetHeaderLength = packetHeaderLength;
    // incomplete header state: number of header bytes received
    this.headerLen = 0;
    // expected payload length
    this.length = 0;
    this.largePacketParts = [];
    this.firstPacketSequenceId = 0;
    this.onPacket = onPacket;
    this.execute = PacketParser.prototype.executeStart;
    this._flushLargePacket =
      packetHeaderLength === 7
        ? this._flushLargePacket7
        : this._flushLargePacket4;
  }

  _flushLargePacket4() {
    const numPackets = this.largePacketParts.length;
    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header
    const body = Buffer.concat(this.largePacketParts);
    const packet = new Packet$k(this.firstPacketSequenceId, body, 0, body.length);
    this.largePacketParts.length = 0;
    packet.numPackets = numPackets;
    this.onPacket(packet);
  }

  _flushLargePacket7() {
    const numPackets = this.largePacketParts.length;
    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header
    const body = Buffer.concat(this.largePacketParts);
    this.largePacketParts.length = 0;
    const packet = new Packet$k(this.firstPacketSequenceId, body, 0, body.length);
    packet.numPackets = numPackets;
    this.onPacket(packet);
  }

  executeStart(chunk) {
    let start = 0;
    const end = chunk.length;
    while (end - start >= 3) {
      this.length = readPacketLength(chunk, start);
      if (end - start >= this.length + this.packetHeaderLength) {
        // at least one full packet
        const sequenceId = chunk[start + 3];
        if (
          this.length < MAX_PACKET_LENGTH &&
          this.largePacketParts.length === 0
        ) {
          this.onPacket(
            new Packet$k(
              sequenceId,
              chunk,
              start,
              start + this.packetHeaderLength + this.length
            )
          );
        } else {
          // first large packet - remember it's id
          if (this.largePacketParts.length === 0) {
            this.firstPacketSequenceId = sequenceId;
          }
          this.largePacketParts.push(
            chunk.slice(
              start + this.packetHeaderLength,
              start + this.packetHeaderLength + this.length
            )
          );
          if (this.length < MAX_PACKET_LENGTH) {
            this._flushLargePacket();
          }
        }
        start += this.packetHeaderLength + this.length;
      } else {
        // payload is incomplete
        this.buffer = [chunk.slice(start + 3, end)];
        this.bufferLength = end - start - 3;
        this.execute = PacketParser.prototype.executePayload;
        return;
      }
    }
    if (end - start > 0) {
      // there is start of length header, but it's not full 3 bytes
      this.headerLen = end - start; // 1 or 2 bytes
      this.length = chunk[start];
      if (this.headerLen === 2) {
        this.length = chunk[start] + (chunk[start + 1] << 8);
        this.execute = PacketParser.prototype.executeHeader3;
      } else {
        this.execute = PacketParser.prototype.executeHeader2;
      }
    }
  }

  executePayload(chunk) {
    let start = 0;
    const end = chunk.length;
    const remainingPayload =
      this.length - this.bufferLength + this.packetHeaderLength - 3;
    if (end - start >= remainingPayload) {
      // last chunk for payload
      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);
      let offset = 3;
      for (let i = 0; i < this.buffer.length; ++i) {
        this.buffer[i].copy(payload, offset);
        offset += this.buffer[i].length;
      }
      chunk.copy(payload, offset, start, start + remainingPayload);
      const sequenceId = payload[3];
      if (
        this.length < MAX_PACKET_LENGTH &&
        this.largePacketParts.length === 0
      ) {
        this.onPacket(
          new Packet$k(
            sequenceId,
            payload,
            0,
            this.length + this.packetHeaderLength
          )
        );
      } else {
        // first large packet - remember it's id
        if (this.largePacketParts.length === 0) {
          this.firstPacketSequenceId = sequenceId;
        }
        this.largePacketParts.push(
          payload.slice(
            this.packetHeaderLength,
            this.packetHeaderLength + this.length
          )
        );
        if (this.length < MAX_PACKET_LENGTH) {
          this._flushLargePacket();
        }
      }
      this.buffer = [];
      this.bufferLength = 0;
      this.execute = PacketParser.prototype.executeStart;
      start += remainingPayload;
      if (end - start > 0) {
        return this.execute(chunk.slice(start, end));
      }
    } else {
      this.buffer.push(chunk);
      this.bufferLength += chunk.length;
    }
    return null;
  }

  executeHeader2(chunk) {
    this.length += chunk[0] << 8;
    if (chunk.length > 1) {
      this.length += chunk[1] << 16;
      this.execute = PacketParser.prototype.executePayload;
      return this.executePayload(chunk.slice(2));
    }
    this.execute = PacketParser.prototype.executeHeader3;

    return null;
  }

  executeHeader3(chunk) {
    this.length += chunk[0] << 16;
    this.execute = PacketParser.prototype.executePayload;
    return this.executePayload(chunk.slice(1));
  }
};

var packet_parser = PacketParser$1;

var packets = {exports: {}};

const Packet$j = packet;

class AuthNextFactor {
  constructor(opts) {
    this.pluginName = opts.pluginName;
    this.pluginData = opts.pluginData;
  }

  toPacket(encoding) {
    const length = 6 + this.pluginName.length + this.pluginData.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$j(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(0x02);
    packet.writeNullTerminatedString(this.pluginName, encoding);
    packet.writeBuffer(this.pluginData);
    return packet;
  }

  static fromPacket(packet, encoding) {
    packet.readInt8(); // marker
    const name = packet.readNullTerminatedString(encoding);
    const data = packet.readBuffer();
    return new AuthNextFactor({
      pluginName: name,
      pluginData: data,
    });
  }
}

var auth_next_factor = AuthNextFactor;

// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchRequest

const Packet$i = packet;

class AuthSwitchRequest {
  constructor(opts) {
    this.pluginName = opts.pluginName;
    this.pluginData = opts.pluginData;
  }

  toPacket() {
    const length = 6 + this.pluginName.length + this.pluginData.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$i(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(0xfe);
    // TODO: use server encoding
    packet.writeNullTerminatedString(this.pluginName, 'cesu8');
    packet.writeBuffer(this.pluginData);
    return packet;
  }

  static fromPacket(packet) {
    packet.readInt8(); // marker
    // assert marker == 0xfe?
    // TODO: use server encoding
    const name = packet.readNullTerminatedString('cesu8');
    const data = packet.readBuffer();
    return new AuthSwitchRequest({
      pluginName: name,
      pluginData: data,
    });
  }
}

var auth_switch_request = AuthSwitchRequest;

// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchRequest

const Packet$h = packet;

class AuthSwitchRequestMoreData {
  constructor(data) {
    this.data = data;
  }

  toPacket() {
    const length = 5 + this.data.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$h(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(0x01);
    packet.writeBuffer(this.data);
    return packet;
  }

  static fromPacket(packet) {
    packet.readInt8(); // marker
    const data = packet.readBuffer();
    return new AuthSwitchRequestMoreData(data);
  }

  static verifyMarker(packet) {
    return packet.peekByte() === 0x01;
  }
}

var auth_switch_request_more_data = AuthSwitchRequestMoreData;

// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchRequest

const Packet$g = packet;

class AuthSwitchResponse {
  constructor(data) {
    if (!Buffer.isBuffer(data)) {
      data = Buffer.from(data);
    }
    this.data = data;
  }

  toPacket() {
    const length = 4 + this.data.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$g(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeBuffer(this.data);
    return packet;
  }

  static fromPacket(packet) {
    const data = packet.readBuffer();
    return new AuthSwitchResponse(data);
  }
}

var auth_switch_response = AuthSwitchResponse;

const Types$5 = /*@__PURE__*/ requireTypes();
const Packet$f = packet;

const binaryReader = new Array(256);

class BinaryRow {
  constructor(columns) {
    this.columns = columns || [];
  }

  static toPacket(columns, encoding) {
    // throw new Error('Not implemented');
    const sequenceId = 0; // TODO remove, this is calculated now in connecton
    let length = 0;
    columns.forEach((val) => {
      if (val === null || typeof val === 'undefined') {
        ++length;
        return;
      }
      length += Packet$f.lengthCodedStringLength(val.toString(10), encoding);
    });

    length = length + 2;

    const buffer = Buffer.allocUnsafe(length + 4);
    const packet = new Packet$f(sequenceId, buffer, 0, length + 4);
    packet.offset = 4;

    packet.writeInt8(0);

    let bitmap = 0;
    let bitValue = 1;
    columns.forEach((parameter) => {
      if (parameter.type === Types$5.NULL) {
        bitmap += bitValue;
      }
      bitValue *= 2;
      if (bitValue === 256) {
        packet.writeInt8(bitmap);
        bitmap = 0;
        bitValue = 1;
      }
    });
    if (bitValue !== 1) {
      packet.writeInt8(bitmap);
    }

    columns.forEach((val) => {
      if (val === null) {
        packet.writeNull();
        return;
      }
      if (typeof val === 'undefined') {
        packet.writeInt8(0);
        return;
      }
      packet.writeLengthCodedString(val.toString(10), encoding);
    });
    return packet;
  }

  // TODO: complete list of types...
  static fromPacket(fields, packet) {
    const columns = new Array(fields.length);
    packet.readInt8(); // TODO check it's 0
    const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);
    // TODO: read and interpret null bitmap
    packet.skip(nullBitmapLength);
    for (let i = 0; i < columns.length; ++i) {
      columns[i] = binaryReader[fields[i].columnType].apply(packet);
    }
    return new BinaryRow(columns);
  }
}

// TODO: replace with constants.MYSQL_TYPE_*
binaryReader[Types$5.DECIMAL] = Packet$f.prototype.readLengthCodedString;
binaryReader[1] = Packet$f.prototype.readInt8; // tiny
binaryReader[2] = Packet$f.prototype.readInt16; // short
binaryReader[3] = Packet$f.prototype.readInt32; // long
binaryReader[4] = Packet$f.prototype.readFloat; // float
binaryReader[5] = Packet$f.prototype.readDouble; // double
binaryReader[6] = Packet$f.prototype.assertInvalid; // null, should be skipped vie null bitmap
binaryReader[7] = Packet$f.prototype.readTimestamp; // timestamp, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_TIMESTAMP
binaryReader[8] = Packet$f.prototype.readInt64; // long long
binaryReader[9] = Packet$f.prototype.readInt32; // int24
binaryReader[10] = Packet$f.prototype.readTimestamp; // date
binaryReader[11] = Packet$f.prototype.readTime; // time, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_TIME
binaryReader[12] = Packet$f.prototype.readDateTime; // datetime, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_DATETIME
binaryReader[13] = Packet$f.prototype.readInt16; // year
binaryReader[Types$5.VAR_STRING] = Packet$f.prototype.readLengthCodedString; // var string

var binary_row = BinaryRow;

var commands$1 = {
  QUIT: 0x01,
  INIT_DB: 0x02,
  QUERY: 0x03,
  FIELD_LIST: 0x04,
  PING: 0x0e,
  CHANGE_USER: 0x11,
  BINLOG_DUMP: 0x12,
  REGISTER_SLAVE: 0x15,
  STMT_PREPARE: 0x16,
  STMT_EXECUTE: 0x17,
  STMT_CLOSE: 0x19};

// http://dev.mysql.com/doc/internals/en/com-binlog-dump.html#packet-COM_BINLOG_DUMP

const Packet$e = packet;
const CommandCodes$4 = commands$1;

// TODO: add flag to constants
// 0x01 - BINLOG_DUMP_NON_BLOCK
// send EOF instead of blocking
let BinlogDump$2 = class BinlogDump {
  constructor(opts) {
    this.binlogPos = opts.binlogPos || 0;
    this.serverId = opts.serverId || 0;
    this.flags = opts.flags || 0;
    this.filename = opts.filename || '';
  }

  toPacket() {
    const length = 15 + Buffer.byteLength(this.filename, 'utf8'); // TODO: should be ascii?
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$e(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCodes$4.BINLOG_DUMP);
    packet.writeInt32(this.binlogPos);
    packet.writeInt16(this.flags);
    packet.writeInt32(this.serverId);
    packet.writeString(this.filename);
    return packet;
  }
};

var binlog_dump$1 = BinlogDump$2;

var client = {};

// Manually extracted from mysql-5.5.23/include/mysql_com.h
client.LONG_PASSWORD = 0x00000001; /* new more secure passwords */
client.FOUND_ROWS = 0x00000002; /* found instead of affected rows */
client.LONG_FLAG = 0x00000004; /* get all column flags */
client.CONNECT_WITH_DB = 0x00000008; /* one can specify db on connect */
client.NO_SCHEMA = 0x00000010; /* don't allow database.table.column */
client.COMPRESS = 0x00000020; /* can use compression protocol */
client.ODBC = 0x00000040; /* odbc client */
client.LOCAL_FILES = 0x00000080; /* can use LOAD DATA LOCAL */
client.IGNORE_SPACE = 0x00000100; /* ignore spaces before '' */
client.PROTOCOL_41 = 0x00000200; /* new 4.1 protocol */
client.INTERACTIVE = 0x00000400; /* this is an interactive client */
client.SSL = 0x00000800; /* switch to ssl after handshake */
client.IGNORE_SIGPIPE = 0x00001000; /* IGNORE sigpipes */
client.TRANSACTIONS = 0x00002000; /* client knows about transactions */
client.RESERVED = 0x00004000; /* old flag for 4.1 protocol  */
client.SECURE_CONNECTION = 0x00008000; /* new 4.1 authentication */
client.MULTI_STATEMENTS = 0x00010000; /* enable/disable multi-stmt support */
client.MULTI_RESULTS = 0x00020000; /* enable/disable multi-results */
client.PS_MULTI_RESULTS = 0x00040000; /* multi-results in ps-protocol */
client.PLUGIN_AUTH = 0x00080000; /* client supports plugin authentication */
client.CONNECT_ATTRS = 0x00100000; /* permits connection attributes */
client.PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x00200000; /* Understands length-encoded integer for auth response data in Protocol::HandshakeResponse41. */
client.CAN_HANDLE_EXPIRED_PASSWORDS = 0x00400000; /* Announces support for expired password extension. */
client.SESSION_TRACK = 0x00800000; /* Can set SERVER_SESSION_STATE_CHANGED in the Status Flags and send session-state change data after a OK packet. */
client.DEPRECATE_EOF = 0x01000000; /* Can send OK after a Text Resultset. */

client.SSL_VERIFY_SERVER_CERT = 0x40000000;
client.REMEMBER_OPTIONS = 0x80000000;

client.MULTI_FACTOR_AUTHENTICATION = 0x10000000; /* multi-factor authentication */

var auth_41 = {};

(function (exports$1) {

	/*
	4.1 authentication: (http://bazaar.launchpad.net/~mysql/mysql-server/5.5/view/head:/sql/password.c)

	  SERVER:  public_seed=create_random_string()
	           send(public_seed)

	  CLIENT:  recv(public_seed)
	           hash_stage1=sha1("password")
	           hash_stage2=sha1(hash_stage1)
	           reply=xor(hash_stage1, sha1(public_seed,hash_stage2)

	           // this three steps are done in scramble()

	           send(reply)


	  SERVER:  recv(reply)
	           hash_stage1=xor(reply, sha1(public_seed,hash_stage2))
	           candidate_hash2=sha1(hash_stage1)
	           check(candidate_hash2==hash_stage2)

	server stores sha1(sha1(password)) ( hash_stag2)
	*/

	const crypto = require$$3$3;

	function sha1(msg, msg1, msg2) {
	  const hash = crypto.createHash('sha1');
	  hash.update(msg);
	  if (msg1) {
	    hash.update(msg1);
	  }

	  if (msg2) {
	    hash.update(msg2);
	  }

	  return hash.digest();
	}

	function xor(a, b) {
	  const result = Buffer.allocUnsafe(a.length);
	  for (let i = 0; i < a.length; i++) {
	    result[i] = a[i] ^ b[i];
	  }
	  return result;
	}

	exports$1.xor = xor;

	function token(password, scramble1, scramble2) {
	  if (!password) {
	    return Buffer.alloc(0);
	  }
	  const stage1 = sha1(password);
	  return exports$1.calculateTokenFromPasswordSha(stage1, scramble1, scramble2);
	}

	exports$1.calculateTokenFromPasswordSha = function (
	  passwordSha,
	  scramble1,
	  scramble2
	) {
	  // we use AUTH 41 here, and we need only the bytes we just need.
	  const authPluginData1 = scramble1.slice(0, 8);
	  const authPluginData2 = scramble2.slice(0, 12);
	  const stage2 = sha1(passwordSha);
	  const stage3 = sha1(authPluginData1, authPluginData2, stage2);
	  return xor(stage3, passwordSha);
	};

	exports$1.calculateToken = token;

	exports$1.verifyToken = function (publicSeed1, publicSeed2, token, doubleSha) {
	  const hashStage1 = xor(token, sha1(publicSeed1, publicSeed2, doubleSha));
	  const candidateHash2 = sha1(hashStage1);
	  return candidateHash2.compare(doubleSha) === 0;
	};

	exports$1.doubleSha1 = function (password) {
	  return sha1(sha1(password));
	};

	function xorRotating(a, seed) {
	  const result = Buffer.allocUnsafe(a.length);
	  const seedLen = seed.length;

	  for (let i = 0; i < a.length; i++) {
	    result[i] = a[i] ^ seed[i % seedLen];
	  }
	  return result;
	}
	exports$1.xorRotating = xorRotating; 
} (auth_41));

var charset_encodings;
var hasRequiredCharset_encodings;

function requireCharset_encodings () {
	if (hasRequiredCharset_encodings) return charset_encodings;
	hasRequiredCharset_encodings = 1;

	// see tools/generate-charset-mapping.js
	// basicalliy result of "SHOW COLLATION" query

	charset_encodings = [
	  'utf8',
	  'big5',
	  'latin2',
	  'dec8',
	  'cp850',
	  'latin1',
	  'hp8',
	  'koi8r',
	  'latin1',
	  'latin2',
	  'swe7',
	  'ascii',
	  'eucjp',
	  'sjis',
	  'cp1251',
	  'latin1',
	  'hebrew',
	  'utf8',
	  'tis620',
	  'euckr',
	  'latin7',
	  'latin2',
	  'koi8u',
	  'cp1251',
	  'gb2312',
	  'greek',
	  'cp1250',
	  'latin2',
	  'gbk',
	  'cp1257',
	  'latin5',
	  'latin1',
	  'armscii8',
	  'cesu8',
	  'cp1250',
	  'ucs2',
	  'cp866',
	  'keybcs2',
	  'macintosh',
	  'macroman',
	  'cp852',
	  'latin7',
	  'latin7',
	  'macintosh',
	  'cp1250',
	  'utf8',
	  'utf8',
	  'latin1',
	  'latin1',
	  'latin1',
	  'cp1251',
	  'cp1251',
	  'cp1251',
	  'macroman',
	  'utf16',
	  'utf16',
	  'utf16-le',
	  'cp1256',
	  'cp1257',
	  'cp1257',
	  'utf32',
	  'utf32',
	  'utf16-le',
	  'binary',
	  'armscii8',
	  'ascii',
	  'cp1250',
	  'cp1256',
	  'cp866',
	  'dec8',
	  'greek',
	  'hebrew',
	  'hp8',
	  'keybcs2',
	  'koi8r',
	  'koi8u',
	  'cesu8',
	  'latin2',
	  'latin5',
	  'latin7',
	  'cp850',
	  'cp852',
	  'swe7',
	  'cesu8',
	  'big5',
	  'euckr',
	  'gb2312',
	  'gbk',
	  'sjis',
	  'tis620',
	  'ucs2',
	  'eucjp',
	  'geostd8',
	  'geostd8',
	  'latin1',
	  'cp932',
	  'cp932',
	  'eucjpms',
	  'eucjpms',
	  'cp1250',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf16',
	  'utf8',
	  'utf8',
	  'utf8',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'ucs2',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'ucs2',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf32',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'cesu8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'cesu8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'gb18030',
	  'gb18030',
	  'gb18030',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	  'utf8',
	];
	return charset_encodings;
}

const CommandCode$4 = commands$1;
const ClientConstants$7 = client;
const Packet$d = packet;
const auth41$2 = auth_41;
const CharsetToEncoding$8 = /*@__PURE__*/ requireCharset_encodings();

// https://dev.mysql.com/doc/internals/en/com-change-user.html#packet-COM_CHANGE_USER
let ChangeUser$2 = class ChangeUser {
  constructor(opts) {
    this.flags = opts.flags;
    this.user = opts.user || '';
    this.database = opts.database || '';
    this.password = opts.password || '';
    this.passwordSha1 = opts.passwordSha1;
    this.authPluginData1 = opts.authPluginData1;
    this.authPluginData2 = opts.authPluginData2;
    this.connectAttributes = opts.connectAttrinutes || {};
    let authToken;
    if (this.passwordSha1) {
      authToken = auth41$2.calculateTokenFromPasswordSha(
        this.passwordSha1,
        this.authPluginData1,
        this.authPluginData2
      );
    } else {
      authToken = auth41$2.calculateToken(
        this.password,
        this.authPluginData1,
        this.authPluginData2
      );
    }
    this.authToken = authToken;
    this.charsetNumber = opts.charsetNumber;
  }

  // TODO
  // ChangeUser.fromPacket = function(packet)
  // };
  serializeToBuffer(buffer) {
    const isSet = (flag) => this.flags & ClientConstants$7[flag];
    const packet = new Packet$d(0, buffer, 0, buffer.length);
    packet.offset = 4;
    const encoding = CharsetToEncoding$8[this.charsetNumber];
    packet.writeInt8(CommandCode$4.CHANGE_USER);
    packet.writeNullTerminatedString(this.user, encoding);
    if (isSet('SECURE_CONNECTION')) {
      packet.writeInt8(this.authToken.length);
      packet.writeBuffer(this.authToken);
    } else {
      packet.writeBuffer(this.authToken);
      packet.writeInt8(0);
    }
    packet.writeNullTerminatedString(this.database, encoding);
    packet.writeInt16(this.charsetNumber);
    if (isSet('PLUGIN_AUTH')) {
      // TODO: read this from parameters
      packet.writeNullTerminatedString('mysql_native_password', 'latin1');
    }
    if (isSet('CONNECT_ATTRS')) {
      const connectAttributes = this.connectAttributes;
      const attrNames = Object.keys(connectAttributes);
      let keysLength = 0;
      for (let k = 0; k < attrNames.length; ++k) {
        keysLength += Packet$d.lengthCodedStringLength(attrNames[k], encoding);
        keysLength += Packet$d.lengthCodedStringLength(
          connectAttributes[attrNames[k]],
          encoding
        );
      }
      packet.writeLengthCodedNumber(keysLength);
      for (let k = 0; k < attrNames.length; ++k) {
        packet.writeLengthCodedString(attrNames[k], encoding);
        packet.writeLengthCodedString(
          connectAttributes[attrNames[k]],
          encoding
        );
      }
    }
    return packet;
  }

  toPacket() {
    if (typeof this.user !== 'string') {
      throw new Error('"user" connection config property must be a string');
    }
    if (typeof this.database !== 'string') {
      throw new Error('"database" connection config property must be a string');
    }
    // dry run: calculate resulting packet length
    const p = this.serializeToBuffer(Packet$d.MockBuffer());
    return this.serializeToBuffer(Buffer.allocUnsafe(p.offset));
  }
};

var change_user$1 = ChangeUser$2;

const Packet$c = packet;
const CommandCodes$3 = commands$1;

let CloseStatement$2 = class CloseStatement {
  constructor(id) {
    this.id = id;
  }

  // note: no response sent back
  toPacket() {
    const packet = new Packet$c(0, Buffer.allocUnsafe(9), 0, 9);
    packet.offset = 4;
    packet.writeInt8(CommandCodes$3.STMT_CLOSE);
    packet.writeInt32(this.id);
    return packet;
  }
};

var close_statement$1 = CloseStatement$2;

var field_flags = {};

var hasRequiredField_flags;

function requireField_flags () {
	if (hasRequiredField_flags) return field_flags;
	hasRequiredField_flags = 1;

	// Manually extracted from mysql-5.5.23/include/mysql_com.h
	field_flags.NOT_NULL = 1; /* Field can't be NULL */
	field_flags.PRI_KEY = 2; /* Field is part of a primary key */
	field_flags.UNIQUE_KEY = 4; /* Field is part of a unique key */
	field_flags.MULTIPLE_KEY = 8; /* Field is part of a key */
	field_flags.BLOB = 16; /* Field is a blob */
	field_flags.UNSIGNED = 32; /* Field is unsigned */
	field_flags.ZEROFILL = 64; /* Field is zerofill */
	field_flags.BINARY = 128; /* Field is binary   */

	/* The following are only sent to new clients */
	field_flags.ENUM = 256; /* field is an enum */
	field_flags.AUTO_INCREMENT = 512; /* field is a autoincrement field */
	field_flags.TIMESTAMP = 1024; /* Field is a timestamp */
	field_flags.SET = 2048; /* field is a set */
	field_flags.NO_DEFAULT_VALUE = 4096; /* Field doesn't have default value */
	field_flags.ON_UPDATE_NOW = 8192; /* Field is set to NOW on UPDATE */
	field_flags.NUM = 32768; /* Field is num (for clients) */
	return field_flags;
}

const Packet$b = packet;
const StringParser$2 = string;
const CharsetToEncoding$7 = /*@__PURE__*/ requireCharset_encodings();

const fields = ['catalog', 'schema', 'table', 'orgTable', 'name', 'orgName'];

// creating JS string is relatively expensive (compared to
// reading few bytes from buffer) because all string properties
// except for name are unlikely to be used we postpone
// string conversion until property access
//
// TODO: watch for integration benchmarks (one with real network buffer)
// there could be bad side effect as keeping reference to a buffer makes it
// sit in the memory longer (usually until final .query() callback)
// Latest v8 perform much better in regard to bufferer -> string conversion,
// at some point of time this optimisation might become unnecessary
// see https://github.com/sidorares/node-mysql2/pull/137
//
class ColumnDefinition {
  constructor(packet, clientEncoding) {
    this._buf = packet.buffer;
    this._clientEncoding = clientEncoding;
    this._catalogLength = packet.readLengthCodedNumber();
    this._catalogStart = packet.offset;
    packet.offset += this._catalogLength;
    this._schemaLength = packet.readLengthCodedNumber();
    this._schemaStart = packet.offset;
    packet.offset += this._schemaLength;
    this._tableLength = packet.readLengthCodedNumber();
    this._tableStart = packet.offset;
    packet.offset += this._tableLength;
    this._orgTableLength = packet.readLengthCodedNumber();
    this._orgTableStart = packet.offset;
    packet.offset += this._orgTableLength;
    // name is always used, don't make it lazy
    const _nameLength = packet.readLengthCodedNumber();
    const _nameStart = packet.offset;
    packet.offset += _nameLength;
    this._orgNameLength = packet.readLengthCodedNumber();
    this._orgNameStart = packet.offset;
    packet.offset += this._orgNameLength;
    packet.skip(1); //  length of the following fields (always 0x0c)
    this.characterSet = packet.readInt16();
    this.encoding = CharsetToEncoding$7[this.characterSet];
    this.name = StringParser$2.decode(
      this._buf,
      this.encoding === 'binary' ? this._clientEncoding : this.encoding,
      _nameStart,
      _nameStart + _nameLength
    );
    this.columnLength = packet.readInt32();
    this.columnType = packet.readInt8();
    this.type = this.columnType;
    this.flags = packet.readInt16();
    this.decimals = packet.readInt8();
  }

  inspect() {
    return {
      catalog: this.catalog,
      schema: this.schema,
      name: this.name,
      orgName: this.orgName,
      table: this.table,
      orgTable: this.orgTable,
      characterSet: this.characterSet,
      encoding: this.encoding,
      columnLength: this.columnLength,
      type: this.columnType,
      flags: this.flags,
      decimals: this.decimals,
    };
  }

  [Symbol.for('nodejs.util.inspect.custom')](depth, inspectOptions, inspect) {
    const Types = /*@__PURE__*/ requireTypes();
    const typeNames = [];
    for (const t in Types) {
      typeNames[Types[t]] = t;
    }
    const fiedFlags = /*@__PURE__*/ requireField_flags();
    const flagNames = [];
    // TODO: respect inspectOptions.showHidden
    //const inspectFlags = inspectOptions.showHidden ? this.flags : this.flags & ~fiedFlags.PRI_KEY;
    const inspectFlags = this.flags;
    for (const f in fiedFlags) {
      if (inspectFlags & fiedFlags[f]) {
        if (f === 'PRI_KEY') {
          flagNames.push('PRIMARY KEY');
        } else if (f === 'NOT_NULL') {
          flagNames.push('NOT NULL');
        } else if (f === 'BINARY') ; else if (f === 'MULTIPLE_KEY') ; else if (f === 'NO_DEFAULT_VALUE') ; else if (f === 'BLOB') ; else if (f === 'UNSIGNED') ; else if (f === 'TIMESTAMP') ; else if (f === 'ON_UPDATE_NOW') {
          flagNames.push('ON UPDATE CURRENT_TIMESTAMP');
        } else {
          flagNames.push(f);
        }
      }
    }

    if (depth > 1) {
      return inspect({
        ...this.inspect(),
        typeName: typeNames[this.columnType],
        flags: flagNames,
      });
    }

    const isUnsigned = this.flags & fiedFlags.UNSIGNED;

    let typeName = typeNames[this.columnType];
    if (typeName === 'BLOB') {
      // TODO: check for non-utf8mb4 encoding
      if (this.columnLength === 4294967295) {
        typeName = 'LONGTEXT';
      } else if (this.columnLength === 67108860) {
        typeName = 'MEDIUMTEXT';
      } else if (this.columnLength === 262140) {
        typeName = 'TEXT';
      } else if (this.columnLength === 1020) {
        // 255*4
        typeName = 'TINYTEXT';
      } else {
        typeName = `BLOB(${this.columnLength})`;
      }
    } else if (typeName === 'VAR_STRING') {
      // TODO: check for non-utf8mb4 encoding
      typeName = `VARCHAR(${Math.ceil(this.columnLength / 4)})`;
    } else if (typeName === 'TINY') {
      if (
        (this.columnLength === 3 && isUnsigned) ||
        (this.columnLength === 4 && !isUnsigned)
      ) {
        typeName = 'TINYINT';
      } else {
        typeName = `TINYINT(${this.columnLength})`;
      }
    } else if (typeName === 'LONGLONG') {
      if (this.columnLength === 20) {
        typeName = 'BIGINT';
      } else {
        typeName = `BIGINT(${this.columnLength})`;
      }
    } else if (typeName === 'SHORT') {
      if (isUnsigned && this.columnLength === 5) {
        typeName = 'SMALLINT';
      } else if (!isUnsigned && this.columnLength === 6) {
        typeName = 'SMALLINT';
      } else {
        typeName = `SMALLINT(${this.columnLength})`;
      }
    } else if (typeName === 'LONG') {
      if (isUnsigned && this.columnLength === 10) {
        typeName = 'INT';
      } else if (!isUnsigned && this.columnLength === 11) {
        typeName = 'INT';
      } else {
        typeName = `INT(${this.columnLength})`;
      }
    } else if (typeName === 'INT24') {
      if (isUnsigned && this.columnLength === 8) {
        typeName = 'MEDIUMINT';
      } else if (!isUnsigned && this.columnLength === 9) {
        typeName = 'MEDIUMINT';
      } else {
        typeName = `MEDIUMINT(${this.columnLength})`;
      }
    } else if (typeName === 'DOUBLE') {
      // DOUBLE without modifiers is reported as DOUBLE(22, 31)
      if (this.columnLength === 22 && this.decimals === 31) {
        typeName = 'DOUBLE';
      } else {
        typeName = `DOUBLE(${this.columnLength},${this.decimals})`;
      }
    } else if (typeName === 'FLOAT') {
      // FLOAT without modifiers is reported as FLOAT(12, 31)
      if (this.columnLength === 12 && this.decimals === 31) {
        typeName = 'FLOAT';
      } else {
        typeName = `FLOAT(${this.columnLength},${this.decimals})`;
      }
    } else if (typeName === 'NEWDECIMAL') {
      if (this.columnLength === 11 && this.decimals === 0) {
        typeName = 'DECIMAL';
      } else if (this.decimals === 0) {
        // not sure why, but DECIMAL(13) is reported as DECIMAL(14, 0)
        // and DECIMAL(13, 9) is reported as NEWDECIMAL(15, 9)
        if (isUnsigned) {
          typeName = `DECIMAL(${this.columnLength})`;
        } else {
          typeName = `DECIMAL(${this.columnLength - 1})`;
        }
      } else {
        typeName = `DECIMAL(${this.columnLength - 2},${this.decimals})`;
      }
    } else {
      typeName = `${typeNames[this.columnType]}(${this.columnLength})`;
    }

    if (isUnsigned) {
      typeName += ' UNSIGNED';
    }

    // TODO respect colors option
    return `\`${this.name}\` ${[typeName, ...flagNames].join(' ')}`;
  }

  static toPacket(column, sequenceId) {
    let length = 17; // = 4 padding + 1 + 12 for the rest
    fields.forEach((field) => {
      length += Packet$b.lengthCodedStringLength(
        column[field],
        CharsetToEncoding$7[column.characterSet]
      );
    });
    const buffer = Buffer.allocUnsafe(length);

    const packet = new Packet$b(sequenceId, buffer, 0, length);
    function writeField(name) {
      packet.writeLengthCodedString(
        column[name],
        CharsetToEncoding$7[column.characterSet]
      );
    }
    packet.offset = 4;
    fields.forEach(writeField);
    packet.writeInt8(0x0c);
    packet.writeInt16(column.characterSet);
    packet.writeInt32(column.columnLength);
    packet.writeInt8(column.columnType);
    packet.writeInt16(column.flags);
    packet.writeInt8(column.decimals);
    packet.writeInt16(0); // filler
    return packet;
  }

  // node-mysql compatibility: alias "db" to "schema"
  get db() {
    return this.schema;
  }
}

const addString = function (name) {
  Object.defineProperty(ColumnDefinition.prototype, name, {
    get: function () {
      const start = this[`_${name}Start`];
      const end = start + this[`_${name}Length`];
      const val = StringParser$2.decode(
        this._buf,
        this.encoding === 'binary' ? this._clientEncoding : this.encoding,
        start,
        end
      );

      Object.defineProperty(this, name, {
        value: val,
        writable: false,
        configurable: false,
        enumerable: false,
      });

      return val;
    },
  });
};

addString('catalog');
addString('schema');
addString('table');
addString('orgTable');
addString('orgName');

var column_definition = ColumnDefinition;

var cursor = {
  NO_CURSOR: 0};

const CursorType = cursor;
const CommandCodes$2 = commands$1;
const Types$4 = /*@__PURE__*/ requireTypes();
const Packet$a = packet;
const CharsetToEncoding$6 = /*@__PURE__*/ requireCharset_encodings();

function isJSON(value) {
  return (
    Array.isArray(value) ||
    value.constructor === Object ||
    (typeof value.toJSON === 'function' && !Buffer.isBuffer(value))
  );
}

/**
 * Converts a value to an object describing type, String/Buffer representation and length
 * @param {*} value
 */
function toParameter(value, encoding, timezone) {
  let type = Types$4.VAR_STRING;
  let length;
  let writer = function (value) {
    // eslint-disable-next-line no-invalid-this
    return Packet$a.prototype.writeLengthCodedString.call(this, value, encoding);
  };
  if (value !== null) {
    switch (typeof value) {
      case 'undefined':
        throw new TypeError('Bind parameters must not contain undefined');

      case 'number':
        type = Types$4.DOUBLE;
        length = 8;
        writer = Packet$a.prototype.writeDouble;
        break;

      case 'boolean':
        value = value | 0;
        type = Types$4.TINY;
        length = 1;
        writer = Packet$a.prototype.writeInt8;
        break;

      case 'object':
        if (Object.prototype.toString.call(value) === '[object Date]') {
          type = Types$4.DATETIME;
          length = 12;
          writer = function (value) {
            // eslint-disable-next-line no-invalid-this
            return Packet$a.prototype.writeDate.call(this, value, timezone);
          };
        } else if (isJSON(value)) {
          value = JSON.stringify(value);
          type = Types$4.JSON;
        } else if (Buffer.isBuffer(value)) {
          length = Packet$a.lengthCodedNumberLength(value.length) + value.length;
          writer = Packet$a.prototype.writeLengthCodedBuffer;
        }
        break;

      default:
        value = value.toString();
    }
  } else {
    value = '';
    type = Types$4.NULL;
  }
  if (!length) {
    length = Packet$a.lengthCodedStringLength(value, encoding);
  }
  return { value, type, length, writer };
}

let Execute$3 = class Execute {
  constructor(id, parameters, charsetNumber, timezone) {
    this.id = id;
    this.parameters = parameters;
    this.encoding = CharsetToEncoding$6[charsetNumber];
    this.timezone = timezone;
  }

  static fromPacket(packet, encoding) {
    const stmtId = packet.readInt32();
    const flags = packet.readInt8();
    const iterationCount = packet.readInt32();

    let i = packet.offset;
    while (i < packet.end - 1) {
      if (
        (packet.buffer[i + 1] === Types$4.VAR_STRING ||
          packet.buffer[i + 1] === Types$4.NULL ||
          packet.buffer[i + 1] === Types$4.DOUBLE ||
          packet.buffer[i + 1] === Types$4.TINY ||
          packet.buffer[i + 1] === Types$4.DATETIME ||
          packet.buffer[i + 1] === Types$4.JSON) &&
        packet.buffer[i] === 1 &&
        packet.buffer[i + 2] === 0
      ) {
        break;
      } else {
        packet.readInt8();
      }
      i++;
    }

    const types = [];

    for (let i = packet.offset + 1; i < packet.end - 1; i++) {
      if (
        (packet.buffer[i] === Types$4.VAR_STRING ||
          packet.buffer[i] === Types$4.NULL ||
          packet.buffer[i] === Types$4.DOUBLE ||
          packet.buffer[i] === Types$4.TINY ||
          packet.buffer[i] === Types$4.DATETIME ||
          packet.buffer[i] === Types$4.JSON) &&
        packet.buffer[i + 1] === 0
      ) {
        types.push(packet.buffer[i]);
        packet.skip(2);
      }
    }

    packet.skip(1);

    const values = [];
    for (let i = 0; i < types.length; i++) {
      if (types[i] === Types$4.VAR_STRING) {
        values.push(packet.readLengthCodedString(encoding));
      } else if (types[i] === Types$4.DOUBLE) {
        values.push(packet.readDouble());
      } else if (types[i] === Types$4.TINY) {
        values.push(packet.readInt8());
      } else if (types[i] === Types$4.DATETIME) {
        values.push(packet.readDateTime());
      } else if (types[i] === Types$4.JSON) {
        values.push(JSON.parse(packet.readLengthCodedString(encoding)));
      }
      if (types[i] === Types$4.NULL) {
        values.push(null);
      }
    }

    return { stmtId, flags, iterationCount, values };
  }

  toPacket() {
    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)
    // and copy + reallocate if not enough
    // 0 + 4 - length, seqId
    // 4 + 1 - COM_EXECUTE
    // 5 + 4 - stmtId
    // 9 + 1 - flags
    // 10 + 4 - iteration-count (always 1)
    let length = 14;
    let parameters;
    if (this.parameters && this.parameters.length > 0) {
      length += Math.floor((this.parameters.length + 7) / 8);
      length += 1; // new-params-bound-flag
      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set
      parameters = this.parameters.map((value) =>
        toParameter(value, this.encoding, this.timezone)
      );
      length += parameters.reduce(
        (accumulator, parameter) => accumulator + parameter.length,
        0
      );
    }
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$a(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCodes$2.STMT_EXECUTE);
    packet.writeInt32(this.id);
    packet.writeInt8(CursorType.NO_CURSOR); // flags
    packet.writeInt32(1); // iteration-count, always 1
    if (parameters) {
      let bitmap = 0;
      let bitValue = 1;
      parameters.forEach((parameter) => {
        if (parameter.type === Types$4.NULL) {
          bitmap += bitValue;
        }
        bitValue *= 2;
        if (bitValue === 256) {
          packet.writeInt8(bitmap);
          bitmap = 0;
          bitValue = 1;
        }
      });
      if (bitValue !== 1) {
        packet.writeInt8(bitmap);
      }
      // TODO: explain meaning of the flag
      // afaik, if set n*2 bytes with type of parameter are sent before parameters
      // if not, previous execution types are used (TODO prooflink)
      packet.writeInt8(1); // new-params-bound-flag
      // Write parameter types
      parameters.forEach((parameter) => {
        packet.writeInt8(parameter.type); // field type
        packet.writeInt8(0); // parameter flag
      });
      // Write parameter values
      parameters.forEach((parameter) => {
        if (parameter.type !== Types$4.NULL) {
          parameter.writer.call(packet, parameter.value);
        }
      });
    }
    return packet;
  }
};

var execute$2 = Execute$3;

const Packet$9 = packet;
const ClientConstants$6 = client;

// https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake

class Handshake {
  constructor(args) {
    this.protocolVersion = args.protocolVersion;
    this.serverVersion = args.serverVersion;
    this.capabilityFlags = args.capabilityFlags;
    this.connectionId = args.connectionId;
    this.authPluginData1 = args.authPluginData1;
    this.authPluginData2 = args.authPluginData2;
    this.characterSet = args.characterSet;
    this.statusFlags = args.statusFlags;
    this.authPluginName = args.authPluginName;
  }

  setScrambleData(cb) {
    require$$3$3.randomBytes(20, (err, data) => {
      if (err) {
        cb(err);
        return;
      }
      this.authPluginData1 = data.slice(0, 8);
      this.authPluginData2 = data.slice(8, 20);
      cb();
    });
  }

  toPacket(sequenceId) {
    const length = 68 + Buffer.byteLength(this.serverVersion, 'utf8');
    const buffer = Buffer.alloc(length + 4, 0); // zero fill, 10 bytes filler later needs to contain zeros
    const packet = new Packet$9(sequenceId, buffer, 0, length + 4);
    packet.offset = 4;
    packet.writeInt8(this.protocolVersion);
    packet.writeString(this.serverVersion, 'cesu8');
    packet.writeInt8(0);
    packet.writeInt32(this.connectionId);
    packet.writeBuffer(this.authPluginData1);
    packet.writeInt8(0);
    const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
    capabilityFlagsBuffer.writeUInt32LE(this.capabilityFlags, 0);
    packet.writeBuffer(capabilityFlagsBuffer.slice(0, 2));
    packet.writeInt8(this.characterSet);
    packet.writeInt16(this.statusFlags);
    packet.writeBuffer(capabilityFlagsBuffer.slice(2, 4));
    packet.writeInt8(21); // authPluginDataLength
    packet.skip(10);
    packet.writeBuffer(this.authPluginData2);
    packet.writeInt8(0);
    packet.writeString('mysql_native_password', 'latin1');
    packet.writeInt8(0);
    return packet;
  }

  static fromPacket(packet) {
    const args = {};
    args.protocolVersion = packet.readInt8();
    args.serverVersion = packet.readNullTerminatedString('cesu8');
    args.connectionId = packet.readInt32();
    args.authPluginData1 = packet.readBuffer(8);
    packet.skip(1);
    const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
    capabilityFlagsBuffer[0] = packet.readInt8();
    capabilityFlagsBuffer[1] = packet.readInt8();
    if (packet.haveMoreData()) {
      args.characterSet = packet.readInt8();
      args.statusFlags = packet.readInt16();
      // upper 2 bytes
      capabilityFlagsBuffer[2] = packet.readInt8();
      capabilityFlagsBuffer[3] = packet.readInt8();
      args.capabilityFlags = capabilityFlagsBuffer.readUInt32LE(0);
      if (args.capabilityFlags & ClientConstants$6.PLUGIN_AUTH) {
        args.authPluginDataLength = packet.readInt8();
      } else {
        args.authPluginDataLength = 0;
        packet.skip(1);
      }
      packet.skip(10);
    } else {
      args.capabilityFlags = capabilityFlagsBuffer.readUInt16LE(0);
    }

    const isSecureConnection =
      args.capabilityFlags & ClientConstants$6.SECURE_CONNECTION;
    if (isSecureConnection) {
      const authPluginDataLength = args.authPluginDataLength;
      if (authPluginDataLength === 0) {
        // for Secure Password Authentication
        args.authPluginDataLength = 20;
        args.authPluginData2 = packet.readBuffer(12);
        packet.skip(1);
      } else {
        // length > 0
        // for Custom Auth Plugin (PLUGIN_AUTH)
        const len = Math.max(13, authPluginDataLength - 8);
        args.authPluginData2 = packet.readBuffer(len);
      }
    }

    if (args.capabilityFlags & ClientConstants$6.PLUGIN_AUTH) {
      args.authPluginName = packet.readNullTerminatedString('ascii');
    }

    return new Handshake(args);
  }
}

var handshake = Handshake;

const ClientConstants$5 = client;
const CharsetToEncoding$5 = /*@__PURE__*/ requireCharset_encodings();
const Packet$8 = packet;

const auth41$1 = auth_41;

class HandshakeResponse {
  constructor(handshake) {
    this.user = handshake.user || '';
    this.database = handshake.database || '';
    this.password = handshake.password || '';
    this.passwordSha1 = handshake.passwordSha1;
    this.authPluginData1 = handshake.authPluginData1;
    this.authPluginData2 = handshake.authPluginData2;
    this.compress = handshake.compress;
    this.clientFlags = handshake.flags;
    // TODO: pre-4.1 auth support
    let authToken;
    if (this.passwordSha1) {
      authToken = auth41$1.calculateTokenFromPasswordSha(
        this.passwordSha1,
        this.authPluginData1,
        this.authPluginData2
      );
    } else {
      authToken = auth41$1.calculateToken(
        this.password,
        this.authPluginData1,
        this.authPluginData2
      );
    }
    this.authToken = authToken;
    this.charsetNumber = handshake.charsetNumber;
    this.encoding = CharsetToEncoding$5[handshake.charsetNumber];
    this.connectAttributes = handshake.connectAttributes;
  }

  serializeResponse(buffer) {
    const isSet = (flag) => this.clientFlags & ClientConstants$5[flag];
    const packet = new Packet$8(0, buffer, 0, buffer.length);
    packet.offset = 4;
    packet.writeInt32(this.clientFlags);
    packet.writeInt32(0); // max packet size. todo: move to config
    packet.writeInt8(this.charsetNumber);
    packet.skip(23);
    const encoding = this.encoding;
    packet.writeNullTerminatedString(this.user, encoding);
    let k;
    if (isSet('PLUGIN_AUTH_LENENC_CLIENT_DATA')) {
      packet.writeLengthCodedNumber(this.authToken.length);
      packet.writeBuffer(this.authToken);
    } else if (isSet('SECURE_CONNECTION')) {
      packet.writeInt8(this.authToken.length);
      packet.writeBuffer(this.authToken);
    } else {
      packet.writeBuffer(this.authToken);
      packet.writeInt8(0);
    }
    if (isSet('CONNECT_WITH_DB')) {
      packet.writeNullTerminatedString(this.database, encoding);
    }
    if (isSet('PLUGIN_AUTH')) {
      // TODO: pass from config
      packet.writeNullTerminatedString('mysql_native_password', 'latin1');
    }
    if (isSet('CONNECT_ATTRS')) {
      const connectAttributes = this.connectAttributes || {};
      const attrNames = Object.keys(connectAttributes);
      let keysLength = 0;
      for (k = 0; k < attrNames.length; ++k) {
        keysLength += Packet$8.lengthCodedStringLength(attrNames[k], encoding);
        keysLength += Packet$8.lengthCodedStringLength(
          connectAttributes[attrNames[k]],
          encoding
        );
      }
      packet.writeLengthCodedNumber(keysLength);
      for (k = 0; k < attrNames.length; ++k) {
        packet.writeLengthCodedString(attrNames[k], encoding);
        packet.writeLengthCodedString(
          connectAttributes[attrNames[k]],
          encoding
        );
      }
    }
    return packet;
  }

  toPacket() {
    if (typeof this.user !== 'string') {
      throw new Error('"user" connection config property must be a string');
    }
    if (typeof this.database !== 'string') {
      throw new Error('"database" connection config property must be a string');
    }
    // dry run: calculate resulting packet length
    const p = this.serializeResponse(Packet$8.MockBuffer());
    return this.serializeResponse(Buffer.alloc(p.offset));
  }
  static fromPacket(packet) {
    const args = {};
    args.clientFlags = packet.readInt32();
    function isSet(flag) {
      return args.clientFlags & ClientConstants$5[flag];
    }
    args.maxPacketSize = packet.readInt32();
    args.charsetNumber = packet.readInt8();
    const encoding = CharsetToEncoding$5[args.charsetNumber];
    args.encoding = encoding;
    packet.skip(23);
    args.user = packet.readNullTerminatedString(encoding);
    let authTokenLength;
    if (isSet('PLUGIN_AUTH_LENENC_CLIENT_DATA')) {
      authTokenLength = packet.readLengthCodedNumber(encoding);
      args.authToken = packet.readBuffer(authTokenLength);
    } else if (isSet('SECURE_CONNECTION')) {
      authTokenLength = packet.readInt8();
      args.authToken = packet.readBuffer(authTokenLength);
    } else {
      args.authToken = packet.readNullTerminatedString(encoding);
    }
    if (isSet('CONNECT_WITH_DB')) {
      args.database = packet.readNullTerminatedString(encoding);
    }
    if (isSet('PLUGIN_AUTH')) {
      args.authPluginName = packet.readNullTerminatedString(encoding);
    }
    if (isSet('CONNECT_ATTRS')) {
      const keysLength = packet.readLengthCodedNumber(encoding);
      const keysEnd = packet.offset + keysLength;
      const attrs = {};
      while (packet.offset < keysEnd) {
        attrs[packet.readLengthCodedString(encoding)] =
          packet.readLengthCodedString(encoding);
      }
      args.connectAttributes = attrs;
    }
    return args;
  }
}

var handshake_response = HandshakeResponse;

const Packet$7 = packet;
const CommandCodes$1 = commands$1;
const StringParser$1 = string;
const CharsetToEncoding$4 = /*@__PURE__*/ requireCharset_encodings();

class PrepareStatement {
  constructor(sql, charsetNumber) {
    this.query = sql;
    this.charsetNumber = charsetNumber;
    this.encoding = CharsetToEncoding$4[charsetNumber];
  }

  toPacket() {
    const buf = StringParser$1.encode(this.query, this.encoding);
    const length = 5 + buf.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$7(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCodes$1.STMT_PREPARE);
    packet.writeBuffer(buf);
    return packet;
  }
}

var prepare_statement = PrepareStatement;

class PreparedStatementHeader {
  constructor(packet) {
    packet.skip(1); // should be 0
    this.id = packet.readInt32();
    this.fieldCount = packet.readInt16();
    this.parameterCount = packet.readInt16();
    packet.skip(1); // should be 0
    this.warningCount = packet.readInt16();
  }
}

// TODO: toPacket

var prepared_statement_header = PreparedStatementHeader;

const Packet$6 = packet;
const CommandCode$3 = commands$1;
const StringParser = string;
const CharsetToEncoding$3 = /*@__PURE__*/ requireCharset_encodings();

let Query$3 = class Query {
  constructor(sql, charsetNumber) {
    this.query = sql;
    this.charsetNumber = charsetNumber;
    this.encoding = CharsetToEncoding$3[charsetNumber];
  }

  toPacket() {
    const buf = StringParser.encode(this.query, this.encoding);
    const length = 5 + buf.length;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$6(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCode$3.QUERY);
    packet.writeBuffer(buf);
    return packet;
  }
};

var query$2 = Query$3;

// http://dev.mysql.com/doc/internals/en/com-register-slave.html
// note that documentation is incorrect, for example command code is actually 0x15 but documented as 0x14

const Packet$5 = packet;
const CommandCodes = commands$1;

let RegisterSlave$2 = class RegisterSlave {
  constructor(opts) {
    this.serverId = opts.serverId || 0;
    this.slaveHostname = opts.slaveHostname || '';
    this.slaveUser = opts.slaveUser || '';
    this.slavePassword = opts.slavePassword || '';
    this.slavePort = opts.slavePort || 0;
    this.replicationRank = opts.replicationRank || 0;
    this.masterId = opts.masterId || 0;
  }

  toPacket() {
    const length =
      15 + // TODO: should be ascii?
      Buffer.byteLength(this.slaveHostname, 'utf8') +
      Buffer.byteLength(this.slaveUser, 'utf8') +
      Buffer.byteLength(this.slavePassword, 'utf8') +
      3 +
      4;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$5(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeInt8(CommandCodes.REGISTER_SLAVE);
    packet.writeInt32(this.serverId);
    packet.writeInt8(Buffer.byteLength(this.slaveHostname, 'utf8'));
    packet.writeString(this.slaveHostname);
    packet.writeInt8(Buffer.byteLength(this.slaveUser, 'utf8'));
    packet.writeString(this.slaveUser);
    packet.writeInt8(Buffer.byteLength(this.slavePassword, 'utf8'));
    packet.writeString(this.slavePassword);
    packet.writeInt16(this.slavePort);
    packet.writeInt32(this.replicationRank);
    packet.writeInt32(this.masterId);
    return packet;
  }
};

var register_slave$1 = RegisterSlave$2;

var server_status = {};

// Manually extracted from mysql-5.5.23/include/mysql_com.h

/**
  Is raised when a multi-statement transaction
  has been started, either explicitly, by means
  of BEGIN or COMMIT AND CHAIN, or
  implicitly, by the first transactional
  statement, when autocommit=off.
*/
server_status.SERVER_STATUS_IN_TRANS = 1;
server_status.SERVER_STATUS_AUTOCOMMIT = 2; /* Server in auto_commit mode */
server_status.SERVER_MORE_RESULTS_EXISTS = 8; /* Multi query - next query exists */
server_status.SERVER_QUERY_NO_GOOD_INDEX_USED = 16;
server_status.SERVER_QUERY_NO_INDEX_USED = 32;
/**
  The server was able to fulfill the clients request and opened a
  read-only non-scrollable cursor for a query. This flag comes
  in reply to COM_STMT_EXECUTE and COM_STMT_FETCH commands.
*/
server_status.SERVER_STATUS_CURSOR_EXISTS = 64;
/**
  This flag is sent when a read-only cursor is exhausted, in reply to
  COM_STMT_FETCH command.
*/
server_status.SERVER_STATUS_LAST_ROW_SENT = 128;
server_status.SERVER_STATUS_DB_DROPPED = 256; /* A database was dropped */
server_status.SERVER_STATUS_NO_BACKSLASH_ESCAPES = 512;
/**
  Sent to the client if after a prepared statement reprepare
  we discovered that the new statement returns a different
  number of result set columns.
*/
server_status.SERVER_STATUS_METADATA_CHANGED = 1024;
server_status.SERVER_QUERY_WAS_SLOW = 2048;

/**
  To mark ResultSet containing output parameter values.
*/
server_status.SERVER_PS_OUT_PARAMS = 4096;

server_status.SERVER_STATUS_IN_TRANS_READONLY = 0x2000; // in a read-only transaction
server_status.SERVER_SESSION_STATE_CHANGED = 0x4000;

// inverse of charset_encodings
// given encoding, get matching mysql charset number

var encoding_charset = {
  big5: 1,
  latin2: 2,
  dec8: 3,
  cp850: 4,
  latin1: 5,
  hp8: 6,
  koi8r: 7,
  swe7: 10,
  ascii: 11,
  eucjp: 12,
  sjis: 13,
  cp1251: 14,
  hebrew: 16,
  tis620: 18,
  euckr: 19,
  latin7: 20,
  koi8u: 22,
  gb2312: 24,
  greek: 25,
  cp1250: 26,
  gbk: 28,
  cp1257: 29,
  latin5: 30,
  armscii8: 32,
  cesu8: 33,
  ucs2: 35,
  cp866: 36,
  keybcs2: 37,
  macintosh: 38,
  macroman: 39,
  cp852: 40,
  utf8: 45,
  utf8mb4: 45,
  utf16: 54,
  utf16le: 56,
  cp1256: 57,
  utf32: 60,
  binary: 63,
  geostd8: 92,
  cp932: 95,
  eucjpms: 97,
  gb18030: 248,
  utf8mb3: 192,
};

var session_track = {};

(function (exports$1) {

	exports$1.SYSTEM_VARIABLES = 0;
	exports$1.SCHEMA = 1;
	exports$1.STATE_CHANGE = 2;
	exports$1.STATE_GTIDS = 3;
	exports$1.TRANSACTION_CHARACTERISTICS = 4;
	exports$1.TRANSACTION_STATE = 5;

	exports$1.FIRST_KEY = exports$1.SYSTEM_VARIABLES;
	exports$1.LAST_KEY = exports$1.TRANSACTION_STATE; 
} (session_track));

// TODO: rename to OK packet
// https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html

const Packet$4 = packet;
const ClientConstants$4 = client;
const ServerSatusFlags = server_status;

const EncodingToCharset = encoding_charset;
const sessionInfoTypes = session_track;

class ResultSetHeader {
  constructor(packet, connection) {
    const bigNumberStrings = connection.config.bigNumberStrings;
    const encoding = connection.serverEncoding;
    const flags = connection._handshakePacket.capabilityFlags;
    const isSet = function (flag) {
      return flags & ClientConstants$4[flag];
    };
    if (packet.buffer[packet.offset] !== 0) {
      this.fieldCount = packet.readLengthCodedNumber();
      if (this.fieldCount === null) {
        this.infileName = packet.readString(undefined, encoding);
      }
      return;
    }
    this.fieldCount = packet.readInt8(); // skip OK byte
    this.affectedRows = packet.readLengthCodedNumber(bigNumberStrings);
    this.insertId = packet.readLengthCodedNumberSigned(bigNumberStrings);
    this.info = '';
    if (isSet('PROTOCOL_41')) {
      this.serverStatus = packet.readInt16();
      this.warningStatus = packet.readInt16();
    } else if (isSet('TRANSACTIONS')) {
      this.serverStatus = packet.readInt16();
    }
    let stateChanges = null;
    if (isSet('SESSION_TRACK') && packet.offset < packet.end) {
      this.info = packet.readLengthCodedString(encoding);

      if (this.serverStatus && ServerSatusFlags.SERVER_SESSION_STATE_CHANGED) {
        // session change info record - see
        // https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html#cs-sect-packet-ok-sessioninfo
        let len =
          packet.offset < packet.end ? packet.readLengthCodedNumber() : 0;
        const end = packet.offset + len;
        let type, key, stateEnd;
        if (len > 0) {
          stateChanges = {
            systemVariables: {},
            schema: null,
            gtids: [],
            trackStateChange: null,
          };
        }
        while (packet.offset < end) {
          type = packet.readInt8();
          len = packet.readLengthCodedNumber();
          stateEnd = packet.offset + len;
          if (type === sessionInfoTypes.SYSTEM_VARIABLES) {
            key = packet.readLengthCodedString(encoding);
            const val = packet.readLengthCodedString(encoding);
            stateChanges.systemVariables[key] = val;
            if (key === 'character_set_client') {
              const charsetNumber = EncodingToCharset[val];
              // TODO - better api for driver users to handle unknown encodings?
              // maybe custom coverter in the config?
              // For now just ignore character_set_client command if there is
              // no known mapping from reported encoding to a charset code
              if (typeof charsetNumber !== 'undefined') {
                connection.config.charsetNumber = charsetNumber;
              }
            }
          } else if (type === sessionInfoTypes.SCHEMA) {
            key = packet.readLengthCodedString(encoding);
            stateChanges.schema = key;
          } else if (type === sessionInfoTypes.STATE_CHANGE) {
            stateChanges.trackStateChange =
              packet.readLengthCodedString(encoding);
          } else if (type === sessionInfoTypes.STATE_GTIDS) {
            // TODO: find if the first length coded string means anything. Usually comes as empty
            // eslint-disable-next-line no-unused-vars
            packet.readLengthCodedString(encoding);
            const gtid = packet.readLengthCodedString(encoding);
            stateChanges.gtids = gtid.split(',');
          } else ;
          packet.offset = stateEnd;
        }
      }
    } else {
      this.info = packet.readString(undefined, encoding);
    }
    if (stateChanges) {
      this.stateChanges = stateChanges;
    }
    const m = this.info.match(/\schanged:\s*(\d+)/i);
    if (m !== null) {
      this.changedRows = parseInt(m[1], 10);
    } else {
      this.changedRows = 0;
    }
  }

  // TODO: should be consistent instance member, but it's just easier here to have just function
  static toPacket(fieldCount, insertId) {
    let length = 4 + Packet$4.lengthCodedNumberLength(fieldCount);
    if (typeof insertId !== 'undefined') {
      length += Packet$4.lengthCodedNumberLength(insertId);
    }
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$4(0, buffer, 0, length);
    packet.offset = 4;
    packet.writeLengthCodedNumber(fieldCount);
    if (typeof insertId !== 'undefined') {
      packet.writeLengthCodedNumber(insertId);
    }
    return packet;
  }
}

var resultset_header = ResultSetHeader;

const ClientConstants$3 = client;
const Packet$3 = packet;

class SSLRequest {
  constructor(flags, charset) {
    this.clientFlags = flags | ClientConstants$3.SSL;
    this.charset = charset;
  }

  toPacket() {
    const length = 36;
    const buffer = Buffer.allocUnsafe(length);
    const packet = new Packet$3(0, buffer, 0, length);
    buffer.fill(0);
    packet.offset = 4;
    packet.writeInt32(this.clientFlags);
    packet.writeInt32(0); // max packet size. todo: move to config
    packet.writeInt8(this.charset);
    return packet;
  }
}

var ssl_request = SSLRequest;

const Packet$2 = packet;

class TextRow {
  constructor(columns) {
    this.columns = columns || [];
  }

  static fromPacket(packet) {
    // packet.reset(); // set offset to starting point?
    const columns = [];
    while (packet.haveMoreData()) {
      columns.push(packet.readLengthCodedString());
    }
    return new TextRow(columns);
  }

  static toPacket(columns, encoding) {
    const sequenceId = 0; // TODO remove, this is calculated now in connecton
    let length = 0;
    columns.forEach((val) => {
      if (val === null || typeof val === 'undefined') {
        ++length;
        return;
      }
      length += Packet$2.lengthCodedStringLength(val.toString(10), encoding);
    });
    const buffer = Buffer.allocUnsafe(length + 4);
    const packet = new Packet$2(sequenceId, buffer, 0, length + 4);
    packet.offset = 4;
    columns.forEach((val) => {
      if (val === null) {
        packet.writeNull();
        return;
      }
      if (typeof val === 'undefined') {
        packet.writeInt8(0);
        return;
      }
      packet.writeLengthCodedString(val.toString(10), encoding);
    });
    return packet;
  }
}

var text_row = TextRow;

(function (module, exports$1) {

	const process = require$$0$1;

	const AuthNextFactor = auth_next_factor;
	const AuthSwitchRequest = auth_switch_request;
	const AuthSwitchRequestMoreData = auth_switch_request_more_data;
	const AuthSwitchResponse = auth_switch_response;
	const BinaryRow = binary_row;
	const BinlogDump = binlog_dump$1;
	const ChangeUser = change_user$1;
	const CloseStatement = close_statement$1;
	const ColumnDefinition = column_definition;
	const Execute = execute$2;
	const Handshake = handshake;
	const HandshakeResponse = handshake_response;
	const PrepareStatement = prepare_statement;
	const PreparedStatementHeader = prepared_statement_header;
	const Query = query$2;
	const RegisterSlave = register_slave$1;
	const ResultSetHeader = resultset_header;
	const SSLRequest = ssl_request;
	const TextRow = text_row;

	const ctorMap = {
	  AuthNextFactor,
	  AuthSwitchRequest,
	  AuthSwitchRequestMoreData,
	  AuthSwitchResponse,
	  BinaryRow,
	  BinlogDump,
	  ChangeUser,
	  CloseStatement,
	  ColumnDefinition,
	  Execute,
	  Handshake,
	  HandshakeResponse,
	  PrepareStatement,
	  PreparedStatementHeader,
	  Query,
	  RegisterSlave,
	  ResultSetHeader,
	  SSLRequest,
	  TextRow,
	};
	Object.entries(ctorMap).forEach(([name, ctor]) => {
	  module.exports[name] = ctor;
	  // monkey-patch it to include name if debug is on
	  if (process.env.NODE_DEBUG) {
	    if (ctor.prototype.toPacket) {
	      const old = ctor.prototype.toPacket;
	      ctor.prototype.toPacket = function () {
	        const p = old.call(this);
	        p._name = name;
	        return p;
	      };
	    }
	  }
	});

	// simple packets:
	const Packet = packet;
	exports$1.Packet = Packet;

	class OK {
	  static toPacket(args, encoding) {
	    args = args || {};
	    const affectedRows = args.affectedRows || 0;
	    const insertId = args.insertId || 0;
	    const serverStatus = args.serverStatus || 0;
	    const warningCount = args.warningCount || 0;
	    const message = args.message || '';

	    let length = 9 + Packet.lengthCodedNumberLength(affectedRows);
	    length += Packet.lengthCodedNumberLength(insertId);

	    const buffer = Buffer.allocUnsafe(length);
	    const packet = new Packet(0, buffer, 0, length);
	    packet.offset = 4;
	    packet.writeInt8(0);
	    packet.writeLengthCodedNumber(affectedRows);
	    packet.writeLengthCodedNumber(insertId);
	    packet.writeInt16(serverStatus);
	    packet.writeInt16(warningCount);
	    packet.writeString(message, encoding);
	    packet._name = 'OK';
	    return packet;
	  }
	}

	exports$1.OK = OK;

	// warnings, statusFlags
	class EOF {
	  static toPacket(warnings, statusFlags) {
	    if (typeof warnings === 'undefined') {
	      warnings = 0;
	    }
	    if (typeof statusFlags === 'undefined') {
	      statusFlags = 0;
	    }
	    const packet = new Packet(0, Buffer.allocUnsafe(9), 0, 9);
	    packet.offset = 4;
	    packet.writeInt8(0xfe);
	    packet.writeInt16(warnings);
	    packet.writeInt16(statusFlags);
	    packet._name = 'EOF';
	    return packet;
	  }
	}

	exports$1.EOF = EOF;

	class Error {
	  static toPacket(args, encoding) {
	    const length = 13 + Buffer.byteLength(args.message, 'utf8');
	    const packet = new Packet(0, Buffer.allocUnsafe(length), 0, length);
	    packet.offset = 4;
	    packet.writeInt8(0xff);
	    packet.writeInt16(args.code);
	    // TODO: sql state parameter
	    packet.writeString('#_____', encoding);
	    packet.writeString(args.message, encoding);
	    packet._name = 'Error';
	    return packet;
	  }

	  static fromPacket(packet) {
	    packet.readInt8(); // marker
	    const code = packet.readInt16();
	    packet.readString(1, 'ascii'); // sql state marker
	    // The SQL state of the ERR_Packet which is always 5 bytes long.
	    // https://dev.mysql.com/doc/dev/mysql-server/8.0.11/page_protocol_basic_dt_strings.html#sect_protocol_basic_dt_string_fix
	    packet.readString(5, 'ascii'); // sql state (ignore for now)
	    const message = packet.readNullTerminatedString('utf8');
	    const error = new Error();
	    error.message = message;
	    error.code = code;
	    return error;
	  }
	}

	exports$1.Error = Error; 
} (packets, packets.exports));

var packetsExports = packets.exports;

const EventEmitter$5 = require$$0$6.EventEmitter;
const Timers$2 = require$$2$3;

let Command$b = class Command extends EventEmitter$5 {
  constructor() {
    super();
    this.next = null;
  }

  // slow. debug only
  stateName() {
    const state = this.next;
    for (const i in this) {
      if (this[i] === state && i !== 'next') {
        return i;
      }
    }
    return 'unknown name';
  }

  execute(packet, connection) {
    if (!this.next) {
      this.next = this.start;
      connection._resetSequenceId();
    }
    if (packet && packet.isError()) {
      const err = packet.asError(connection.clientEncoding);
      err.sql = this.sql || this.query;
      if (this.queryTimeout) {
        Timers$2.clearTimeout(this.queryTimeout);
        this.queryTimeout = null;
      }
      if (this.onResult) {
        this.onResult(err);
        this.emit('end');
      } else {
        this.emit('error', err);
        this.emit('end');
      }
      return true;
    }
    // TODO: don't return anything from execute, it's ugly and error-prone. Listen for 'end' event in connection
    this.next = this.next(packet, connection);
    if (this.next) {
      return false;
    }
    this.emit('end');
    return true;
  }
};

var command = Command$b;

var sha256_password;
var hasRequiredSha256_password;

function requireSha256_password () {
	if (hasRequiredSha256_password) return sha256_password;
	hasRequiredSha256_password = 1;

	const PLUGIN_NAME = 'sha256_password';
	const crypto = require$$3$3;
	const { xorRotating } = auth_41;
	const Tls = require$$4$1;

	const REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);

	const STATE_INITIAL = 0;
	const STATE_WAIT_SERVER_KEY = 1;
	const STATE_FINAL = -1;

	function encrypt(password, scramble, key) {
	  const stage1 = xorRotating(Buffer.from(`${password}\0`, 'utf8'), scramble);
	  return crypto.publicEncrypt(key, stage1);
	}

	sha256_password =
	  (pluginOptions = {}) =>
	  ({ connection }) => {
	    let state = 0;
	    let scramble = null;

	    const password = connection.config.password;

	    const authWithKey = (serverKey) => {
	      const _password = encrypt(password, scramble, serverKey);
	      state = STATE_FINAL;
	      return _password;
	    };

	    return (data) => {
	      switch (state) {
	        case STATE_INITIAL:
	          if (
	            connection.stream instanceof Tls.TLSSocket &&
	            connection.stream.encrypted === true
	          ) {
	            // We don't need to encrypt passwords over TLS connection
	            return Buffer.from(`${password}\0`, 'utf8');
	          }

	          scramble = data.slice(0, 20);
	          // if client provides key we can save one extra roundrip on first connection
	          if (pluginOptions.serverPublicKey) {
	            return authWithKey(pluginOptions.serverPublicKey);
	          }

	          state = STATE_WAIT_SERVER_KEY;
	          return REQUEST_SERVER_KEY_PACKET;

	        case STATE_WAIT_SERVER_KEY:
	          if (pluginOptions.onServerPublicKey) {
	            pluginOptions.onServerPublicKey(data);
	          }
	          return authWithKey(data);
	        case STATE_FINAL:
	          throw new Error(
	            `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`
	          );
	      }

	      throw new Error(
	        `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`
	      );
	    };
	  };
	return sha256_password;
}

var caching_sha2_password;
var hasRequiredCaching_sha2_password;

function requireCaching_sha2_password () {
	if (hasRequiredCaching_sha2_password) return caching_sha2_password;
	hasRequiredCaching_sha2_password = 1;

	// https://mysqlserverteam.com/mysql-8-0-4-new-default-authentication-plugin-caching_sha2_password/

	const PLUGIN_NAME = 'caching_sha2_password';
	const crypto = require$$3$3;
	const { xor, xorRotating } = auth_41;

	const REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);
	const FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);
	const PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);

	const STATE_INITIAL = 0;
	const STATE_TOKEN_SENT = 1;
	const STATE_WAIT_SERVER_KEY = 2;
	const STATE_FINAL = -1;

	function sha256(msg) {
	  const hash = crypto.createHash('sha256');
	  hash.update(msg);
	  return hash.digest();
	}

	function calculateToken(password, scramble) {
	  if (!password) {
	    return Buffer.alloc(0);
	  }
	  const stage1 = sha256(Buffer.from(password));
	  const stage2 = sha256(stage1);
	  const stage3 = sha256(Buffer.concat([stage2, scramble]));
	  return xor(stage1, stage3);
	}

	function encrypt(password, scramble, key) {
	  const stage1 = xorRotating(Buffer.from(`${password}\0`, 'utf8'), scramble);
	  return crypto.publicEncrypt(
	    {
	      key,
	      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
	    },
	    stage1
	  );
	}

	caching_sha2_password =
	  (pluginOptions = {}) =>
	  ({ connection }) => {
	    let state = 0;
	    let scramble = null;

	    const password = connection.config.password;

	    const authWithKey = (serverKey) => {
	      const _password = encrypt(password, scramble, serverKey);
	      state = STATE_FINAL;
	      return _password;
	    };

	    return (data) => {
	      switch (state) {
	        case STATE_INITIAL:
	          scramble = data.slice(0, 20);
	          state = STATE_TOKEN_SENT;
	          return calculateToken(password, scramble);

	        case STATE_TOKEN_SENT:
	          if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {
	            state = STATE_FINAL;
	            return null;
	          }

	          if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {
	            const isSecureConnection =
	              typeof pluginOptions.overrideIsSecure === 'undefined'
	                ? connection.config.ssl || connection.config.socketPath
	                : pluginOptions.overrideIsSecure;
	            if (isSecureConnection) {
	              state = STATE_FINAL;
	              return Buffer.from(`${password}\0`, 'utf8');
	            }

	            // if client provides key we can save one extra roundrip on first connection
	            if (pluginOptions.serverPublicKey) {
	              return authWithKey(pluginOptions.serverPublicKey);
	            }

	            state = STATE_WAIT_SERVER_KEY;
	            return REQUEST_SERVER_KEY_PACKET;
	          }
	          throw new Error(
	            `Invalid AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_TOKEN_SENT state.`
	          );
	        case STATE_WAIT_SERVER_KEY:
	          if (pluginOptions.onServerPublicKey) {
	            pluginOptions.onServerPublicKey(data);
	          }
	          return authWithKey(data);
	        case STATE_FINAL:
	          throw new Error(
	            `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`
	          );
	      }

	      throw new Error(
	        `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`
	      );
	    };
	  };
	return caching_sha2_password;
}

var mysql_native_password;
var hasRequiredMysql_native_password;

function requireMysql_native_password () {
	if (hasRequiredMysql_native_password) return mysql_native_password;
	hasRequiredMysql_native_password = 1;

	//const PLUGIN_NAME = 'mysql_native_password';
	const auth41 = auth_41;

	mysql_native_password =
	  (pluginOptions) =>
	  ({ connection, command }) => {
	    const password =
	      command.password || pluginOptions.password || connection.config.password;
	    const passwordSha1 =
	      command.passwordSha1 ||
	      pluginOptions.passwordSha1 ||
	      connection.config.passwordSha1;
	    return (data) => {
	      const authPluginData1 = data.slice(0, 8);
	      const authPluginData2 = data.slice(8, 20);
	      let authToken;
	      if (passwordSha1) {
	        authToken = auth41.calculateTokenFromPasswordSha(
	          passwordSha1,
	          authPluginData1,
	          authPluginData2
	        );
	      } else {
	        authToken = auth41.calculateToken(
	          password,
	          authPluginData1,
	          authPluginData2
	        );
	      }
	      return authToken;
	    };
	  };
	return mysql_native_password;
}

var mysql_clear_password;
var hasRequiredMysql_clear_password;

function requireMysql_clear_password () {
	if (hasRequiredMysql_clear_password) return mysql_clear_password;
	hasRequiredMysql_clear_password = 1;

	function bufferFromStr(str) {
	  return Buffer.from(`${str}\0`);
	}

	const create_mysql_clear_password_plugin = (pluginOptions) =>
	  function mysql_clear_password_plugin({ connection, command }) {
	    const password =
	      command.password || pluginOptions.password || connection.config.password;

	    return function (/* pluginData */) {
	      return bufferFromStr(password);
	    };
	  };

	mysql_clear_password = create_mysql_clear_password_plugin;
	return mysql_clear_password;
}

var auth_switch;
var hasRequiredAuth_switch;

function requireAuth_switch () {
	if (hasRequiredAuth_switch) return auth_switch;
	hasRequiredAuth_switch = 1;

	const Packets = packetsExports;
	const sha256_password = /*@__PURE__*/ requireSha256_password();
	const caching_sha2_password = /*@__PURE__*/ requireCaching_sha2_password();
	const mysql_native_password = /*@__PURE__*/ requireMysql_native_password();
	const mysql_clear_password = /*@__PURE__*/ requireMysql_clear_password();

	const standardAuthPlugins = {
	  sha256_password: sha256_password({}),
	  caching_sha2_password: caching_sha2_password({}),
	  mysql_native_password: mysql_native_password({}),
	  mysql_clear_password: mysql_clear_password({}),
	};

	function warnLegacyAuthSwitch() {
	  console.warn(
	    'WARNING! authSwitchHandler api is deprecated, please use new authPlugins api'
	  );
	}

	function authSwitchPluginError(error, command) {
	  // Authentication errors are fatal
	  error.code = 'AUTH_SWITCH_PLUGIN_ERROR';
	  error.fatal = true;

	  command.emit('error', error);
	}

	function authSwitchRequest(packet, connection, command) {
	  const { pluginName, pluginData } =
	    Packets.AuthSwitchRequest.fromPacket(packet);
	  let authPlugin =
	    connection.config.authPlugins && connection.config.authPlugins[pluginName];

	  // legacy plugin api don't allow to override mysql_native_password
	  // if pluginName is mysql_native_password it's using standard auth4.1 auth
	  if (
	    connection.config.authSwitchHandler &&
	    pluginName !== 'mysql_native_password'
	  ) {
	    const legacySwitchHandler = connection.config.authSwitchHandler;
	    warnLegacyAuthSwitch();
	    legacySwitchHandler({ pluginName, pluginData }, (err, data) => {
	      if (err) {
	        return authSwitchPluginError(err, command);
	      }
	      connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
	    });
	    return;
	  }
	  if (!authPlugin) {
	    authPlugin = standardAuthPlugins[pluginName];
	  }
	  if (!authPlugin) {
	    throw new Error(
	      `Server requests authentication using unknown plugin ${pluginName}. See ${'TODO: add plugins doco here'} on how to configure or author authentication plugins.`
	    );
	  }
	  connection._authPlugin = authPlugin({ connection, command });
	  Promise.resolve(connection._authPlugin(pluginData))
	    .then((data) => {
	      if (data) {
	        connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
	      }
	    })
	    .catch((err) => {
	      authSwitchPluginError(err, command);
	    });
	}

	function authSwitchRequestMoreData(packet, connection, command) {
	  const { data } = Packets.AuthSwitchRequestMoreData.fromPacket(packet);

	  if (connection.config.authSwitchHandler) {
	    const legacySwitchHandler = connection.config.authSwitchHandler;
	    warnLegacyAuthSwitch();
	    legacySwitchHandler({ pluginData: data }, (err, data) => {
	      if (err) {
	        return authSwitchPluginError(err, command);
	      }
	      connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
	    });
	    return;
	  }

	  if (!connection._authPlugin) {
	    throw new Error(
	      'AuthPluginMoreData received but no auth plugin instance found'
	    );
	  }
	  Promise.resolve(connection._authPlugin(data))
	    .then((data) => {
	      if (data) {
	        connection.writePacket(new Packets.AuthSwitchResponse(data).toPacket());
	      }
	    })
	    .catch((err) => {
	      authSwitchPluginError(err, command);
	    });
	}

	auth_switch = {
	  authSwitchRequest,
	  authSwitchRequestMoreData,
	};
	return auth_switch;
}

var seqQueue$1 = {exports: {}};

var hasRequiredSeqQueue$1;

function requireSeqQueue$1 () {
	if (hasRequiredSeqQueue$1) return seqQueue$1.exports;
	hasRequiredSeqQueue$1 = 1;
	(function (module) {
		var EventEmitter = require$$0$6.EventEmitter;
		var util = require$$0$2;

		var DEFAULT_TIMEOUT = 3000;
		var INIT_ID = 0;
		var EVENT_CLOSED = 'closed';
		var EVENT_DRAINED = 'drained';

		/**
		 * Instance a new queue
		 *
		 * @param {Number} timeout a global timeout for new queue
		 * @class
		 * @constructor
		 */
		var SeqQueue = function(timeout) {
			EventEmitter.call(this);
			
			if(timeout && timeout > 0) {
				this.timeout = timeout;
			} else {
				this.timeout = DEFAULT_TIMEOUT;
			}
			
			this.status = SeqQueueManager.STATUS_IDLE;
			this.curId = INIT_ID;
			this.queue = [];
		};
		util.inherits(SeqQueue, EventEmitter);

		/**
		 * Add a task into queue.
		 * 
		 * @param fn new request
		 * @param ontimeout callback when task timeout
		 * @param timeout timeout for current request. take the global timeout if this is invalid
		 * @returns true or false
		 */
		SeqQueue.prototype.push = function(fn, ontimeout, timeout) {
			if(this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {
				//ignore invalid status
				return false;
			}
			
			if(typeof fn !== 'function') {
				throw new Error('fn should be a function.');
			}
			this.queue.push({fn: fn, ontimeout: ontimeout, timeout: timeout});

			if(this.status === SeqQueueManager.STATUS_IDLE) {
				this.status = SeqQueueManager.STATUS_BUSY;
				var self = this;
				process.nextTick(function() {
					self._next(self.curId);
				});
			}
			return true;
		};

		/**
		 * Close queue
		 * 
		 * @param {Boolean} force if true will close the queue immediately else will execute the rest task in queue
		 */
		SeqQueue.prototype.close = function(force) {
			if(this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {
				//ignore invalid status
				return;
			}
			
			if(force) {
				this.status = SeqQueueManager.STATUS_DRAINED;
				if(this.timerId) {
					clearTimeout(this.timerId);
					this.timerId = undefined;
				}
				this.emit(EVENT_DRAINED);
			} else {
				this.status = SeqQueueManager.STATUS_CLOSED;
				this.emit(EVENT_CLOSED);
			}
		};

		/**
		 * Invoke next task
		 * 
		 * @param {String|Number} tid last executed task id
		 * @api private
		 */
		SeqQueue.prototype._next = function(tid) {
			if(tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {
				//ignore invalid next call
				return;
			}
			
			if(this.timerId) {
				clearTimeout(this.timerId);
				this.timerId = undefined;
			}
			
			var task = this.queue.shift();
			if(!task) {
				if(this.status === SeqQueueManager.STATUS_BUSY) {
					this.status = SeqQueueManager.STATUS_IDLE;
					this.curId++;	//modify curId to invalidate timeout task
				} else {
					this.status = SeqQueueManager.STATUS_DRAINED;
					this.emit(EVENT_DRAINED);
				}
				return;
			}
			
			var self = this;
			task.id = ++this.curId;

			var timeout = task.timeout > 0 ? task.timeout : this.timeout;
			timeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;
			this.timerId = setTimeout(function() {
				process.nextTick(function() {
					self._next(task.id);
				});
				self.emit('timeout', task);
				if(task.ontimeout) {
					task.ontimeout();
				}
			}, timeout);

			try {
				task.fn({
					done: function() {
						var res = task.id === self.curId;
						process.nextTick(function() {
							self._next(task.id);
						});
						return res;
					}
				});
			} catch(err) {
				self.emit('error', err, task);
				process.nextTick(function() {
					self._next(task.id);
				});
			}
		};

		/**
		 * Queue manager.
		 * 
		 * @module
		 */
		var SeqQueueManager = module.exports;

		/**
		 * Queue status: idle, welcome new tasks
		 *
		 * @const
		 * @type {Number}
		 * @memberOf SeqQueueManager
		 */
		SeqQueueManager.STATUS_IDLE = 0;

		/**
		 * Queue status: busy, queue is working for some tasks now
		 *
		 * @const
		 * @type {Number}
		 * @memberOf SeqQueueManager
		 */
		SeqQueueManager.STATUS_BUSY = 1;

		/**
		 * Queue status: closed, queue has closed and would not receive task any more 
		 * 					and is processing the remaining tasks now.
		 *
		 * @const
		 * @type {Number}
		 * @memberOf SeqQueueManager
		 */
		SeqQueueManager.STATUS_CLOSED = 2; 

		/**
		 * Queue status: drained, queue is ready to be destroy
		 *
		 * @const
		 * @type {Number}
		 * @memberOf SeqQueueManager
		 */
		SeqQueueManager.STATUS_DRAINED = 3;

		/**
		 * Create Sequence queue
		 * 
		 * @param  {Number} timeout a global timeout for the new queue instance
		 * @return {Object}         new queue instance
		 * @memberOf SeqQueueManager
		 */
		SeqQueueManager.createQueue = function(timeout) {
			return new SeqQueue(timeout);
		}; 
	} (seqQueue$1));
	return seqQueue$1.exports;
}

var seqQueue;
var hasRequiredSeqQueue;

function requireSeqQueue () {
	if (hasRequiredSeqQueue) return seqQueue;
	hasRequiredSeqQueue = 1;
	seqQueue = /*@__PURE__*/ requireSeqQueue$1();
	return seqQueue;
}

var compressed_protocol;
var hasRequiredCompressed_protocol;

function requireCompressed_protocol () {
	if (hasRequiredCompressed_protocol) return compressed_protocol;
	hasRequiredCompressed_protocol = 1;

	// connection mixins
	// implementation of http://dev.mysql.com/doc/internals/en/compression.html

	const zlib = require$$0$5;
	const PacketParser = packet_parser;

	function handleCompressedPacket(packet) {
	  // eslint-disable-next-line consistent-this, no-invalid-this
	  const connection = this;
	  const deflatedLength = packet.readInt24();
	  const body = packet.readBuffer();

	  if (deflatedLength !== 0) {
	    connection.inflateQueue.push((task) => {
	      zlib.inflate(body, (err, data) => {
	        if (err) {
	          connection._handleNetworkError(err);
	          return;
	        }
	        connection._bumpCompressedSequenceId(packet.numPackets);
	        connection._inflatedPacketsParser.execute(data);
	        task.done();
	      });
	    });
	  } else {
	    connection.inflateQueue.push((task) => {
	      connection._bumpCompressedSequenceId(packet.numPackets);
	      connection._inflatedPacketsParser.execute(body);
	      task.done();
	    });
	  }
	}

	function writeCompressed(buffer) {
	  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html
	  // note: sending a MySQL Packet of the size 2^245 to 2^241 via compression
	  // leads to at least one extra compressed packet.
	  // (this is because "length of the packet before compression" need to fit
	  // into 3 byte unsigned int. "length of the packet before compression" includes
	  // 4 byte packet header, hence 2^245)
	  const MAX_COMPRESSED_LENGTH = 16777210;
	  let start;
	  if (buffer.length > MAX_COMPRESSED_LENGTH) {
	    for (start = 0; start < buffer.length; start += MAX_COMPRESSED_LENGTH) {
	      writeCompressed.call(
	        // eslint-disable-next-line no-invalid-this
	        this,
	        buffer.slice(start, start + MAX_COMPRESSED_LENGTH)
	      );
	    }
	    return;
	  }

	  // eslint-disable-next-line no-invalid-this, consistent-this
	  const connection = this;

	  let packetLen = buffer.length;
	  const compressHeader = Buffer.allocUnsafe(7);

	  // seqqueue is used here because zlib async execution is routed via thread pool
	  // internally and when we have multiple compressed packets arriving we need
	  // to assemble uncompressed result sequentially
	  (function (seqId) {
	    connection.deflateQueue.push((task) => {
	      zlib.deflate(buffer, (err, compressed) => {
	        if (err) {
	          connection._handleFatalError(err);
	          return;
	        }
	        let compressedLength = compressed.length;

	        if (compressedLength < packetLen) {
	          compressHeader.writeUInt8(compressedLength & 0xff, 0);
	          compressHeader.writeUInt16LE(compressedLength >> 8, 1);
	          compressHeader.writeUInt8(seqId, 3);
	          compressHeader.writeUInt8(packetLen & 0xff, 4);
	          compressHeader.writeUInt16LE(packetLen >> 8, 5);
	          connection.writeUncompressed(compressHeader);
	          connection.writeUncompressed(compressed);
	        } else {
	          // http://dev.mysql.com/doc/internals/en/uncompressed-payload.html
	          // To send an uncompressed payload:
	          //   - set length of payload before compression to 0
	          //   - the compressed payload contains the uncompressed payload instead.
	          compressedLength = packetLen;
	          packetLen = 0;
	          compressHeader.writeUInt8(compressedLength & 0xff, 0);
	          compressHeader.writeUInt16LE(compressedLength >> 8, 1);
	          compressHeader.writeUInt8(seqId, 3);
	          compressHeader.writeUInt8(packetLen & 0xff, 4);
	          compressHeader.writeUInt16LE(packetLen >> 8, 5);
	          connection.writeUncompressed(compressHeader);
	          connection.writeUncompressed(buffer);
	        }
	        task.done();
	      });
	    });
	  })(connection.compressedSequenceId);
	  connection._bumpCompressedSequenceId(1);
	}

	function enableCompression(connection) {
	  connection._lastWrittenPacketId = 0;
	  connection._lastReceivedPacketId = 0;

	  connection._handleCompressedPacket = handleCompressedPacket;
	  connection._inflatedPacketsParser = new PacketParser((p) => {
	    connection.handlePacket(p);
	  }, 4);
	  connection._inflatedPacketsParser._lastPacket = 0;
	  connection.packetParser = new PacketParser((packet) => {
	    connection._handleCompressedPacket(packet);
	  }, 7);

	  connection.writeUncompressed = connection.write;
	  connection.write = writeCompressed;

	  const seqqueue = /*@__PURE__*/ requireSeqQueue();
	  connection.inflateQueue = seqqueue.createQueue();
	  connection.deflateQueue = seqqueue.createQueue();
	}

	compressed_protocol = {
	  enableCompression: enableCompression,
	};
	return compressed_protocol;
}

const Command$a = command;
const Packets$9 = packetsExports;
const ClientConstants$2 = client;
const CharsetToEncoding$2 = /*@__PURE__*/ requireCharset_encodings();
const auth41 = auth_41;

function flagNames(flags) {
  const res = [];
  for (const c in ClientConstants$2) {
    if (flags & ClientConstants$2[c]) {
      res.push(c.replace(/_/g, ' ').toLowerCase());
    }
  }
  return res;
}

let ClientHandshake$2 = class ClientHandshake extends Command$a {
  constructor(clientFlags) {
    super();
    this.handshake = null;
    this.clientFlags = clientFlags;
    this.authenticationFactor = 0;
  }

  start() {
    return ClientHandshake.prototype.handshakeInit;
  }

  sendSSLRequest(connection) {
    const sslRequest = new Packets$9.SSLRequest(
      this.clientFlags,
      connection.config.charsetNumber
    );
    connection.writePacket(sslRequest.toPacket());
  }

  sendCredentials(connection) {
    if (connection.config.debug) {
      // eslint-disable-next-line
      console.log(
        'Sending handshake packet: flags:%d=(%s)',
        this.clientFlags,
        flagNames(this.clientFlags).join(', ')
      );
    }
    this.user = connection.config.user;
    this.password = connection.config.password;
    // "password1" is an alias to the original "password" value
    // to make it easier to integrate multi-factor authentication
    this.password1 = connection.config.password;
    // "password2" and "password3" are the 2nd and 3rd factor authentication
    // passwords, which can be undefined depending on the authentication
    // plugin being used
    this.password2 = connection.config.password2;
    this.password3 = connection.config.password3;
    this.passwordSha1 = connection.config.passwordSha1;
    this.database = connection.config.database;
    this.authPluginName = this.handshake.authPluginName;
    const handshakeResponse = new Packets$9.HandshakeResponse({
      flags: this.clientFlags,
      user: this.user,
      database: this.database,
      password: this.password,
      passwordSha1: this.passwordSha1,
      charsetNumber: connection.config.charsetNumber,
      authPluginData1: this.handshake.authPluginData1,
      authPluginData2: this.handshake.authPluginData2,
      compress: connection.config.compress,
      connectAttributes: connection.config.connectAttributes,
    });
    connection.writePacket(handshakeResponse.toPacket());
  }

  calculateNativePasswordAuthToken(authPluginData) {
    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received
    const authPluginData1 = authPluginData.slice(0, 8);
    const authPluginData2 = authPluginData.slice(8, 20);
    let authToken;
    if (this.passwordSha1) {
      authToken = auth41.calculateTokenFromPasswordSha(
        this.passwordSha1,
        authPluginData1,
        authPluginData2
      );
    } else {
      authToken = auth41.calculateToken(
        this.password,
        authPluginData1,
        authPluginData2
      );
    }
    return authToken;
  }

  handshakeInit(helloPacket, connection) {
    this.on('error', (e) => {
      connection._fatalError = e;
      connection._protocolError = e;
    });
    this.handshake = Packets$9.Handshake.fromPacket(helloPacket);
    if (connection.config.debug) {
      // eslint-disable-next-line
      console.log(
        'Server hello packet: capability flags:%d=(%s)',
        this.handshake.capabilityFlags,
        flagNames(this.handshake.capabilityFlags).join(', ')
      );
    }
    connection.serverCapabilityFlags = this.handshake.capabilityFlags;
    connection.serverEncoding = CharsetToEncoding$2[this.handshake.characterSet];
    connection.connectionId = this.handshake.connectionId;
    const serverSSLSupport =
      this.handshake.capabilityFlags & ClientConstants$2.SSL;
    // multi factor authentication is enabled with the
    // "MULTI_FACTOR_AUTHENTICATION" capability and should only be used if it
    // is supported by the server
    const multiFactorAuthentication =
      this.handshake.capabilityFlags &
      ClientConstants$2.MULTI_FACTOR_AUTHENTICATION;
    this.clientFlags = this.clientFlags | multiFactorAuthentication;
    // use compression only if requested by client and supported by server
    connection.config.compress =
      connection.config.compress &&
      this.handshake.capabilityFlags & ClientConstants$2.COMPRESS;
    this.clientFlags = this.clientFlags | connection.config.compress;
    if (connection.config.ssl) {
      // client requires SSL but server does not support it
      if (!serverSSLSupport) {
        const err = new Error('Server does not support secure connection');
        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';
        err.fatal = true;
        this.emit('error', err);
        return false;
      }
      // send ssl upgrade request and immediately upgrade connection to secure
      this.clientFlags |= ClientConstants$2.SSL;
      this.sendSSLRequest(connection);
      connection.startTLS((err) => {
        // after connection is secure
        if (err) {
          // SSL negotiation error are fatal
          err.code = 'HANDSHAKE_SSL_ERROR';
          err.fatal = true;
          this.emit('error', err);
          return;
        }
        // rest of communication is encrypted
        this.sendCredentials(connection);
      });
    } else {
      this.sendCredentials(connection);
    }
    if (multiFactorAuthentication) {
      // if the server supports multi-factor authentication, we enable it in
      // the client
      this.authenticationFactor = 1;
    }
    return ClientHandshake.prototype.handshakeResult;
  }

  handshakeResult(packet, connection) {
    const marker = packet.peekByte();
    // packet can be OK_Packet, ERR_Packet, AuthSwitchRequest, AuthNextFactor
    // or AuthMoreData
    if (marker === 0xfe || marker === 1 || marker === 0x02) {
      const authSwitch = /*@__PURE__*/ requireAuth_switch();
      try {
        if (marker === 1) {
          authSwitch.authSwitchRequestMoreData(packet, connection, this);
        } else {
          // if authenticationFactor === 0, it means the server does not support
          // the multi-factor authentication capability
          if (this.authenticationFactor !== 0) {
            // if we are past the first authentication factor, we should use the
            // corresponding password (if there is one)
            connection.config.password =
              this[`password${this.authenticationFactor}`];
            // update the current authentication factor
            this.authenticationFactor += 1;
          }
          // if marker === 0x02, it means it is an AuthNextFactor packet,
          // which is similar in structure to an AuthSwitchRequest packet,
          // so, we can use it directly
          authSwitch.authSwitchRequest(packet, connection, this);
        }
        return ClientHandshake.prototype.handshakeResult;
      } catch (err) {
        // Authentication errors are fatal
        err.code = 'AUTH_SWITCH_PLUGIN_ERROR';
        err.fatal = true;

        if (this.onResult) {
          this.onResult(err);
        } else {
          this.emit('error', err);
        }
        return null;
      }
    }
    if (marker !== 0) {
      const err = new Error('Unexpected packet during handshake phase');
      // Unknown handshake errors are fatal
      err.code = 'HANDSHAKE_UNKNOWN_ERROR';
      err.fatal = true;

      if (this.onResult) {
        this.onResult(err);
      } else {
        this.emit('error', err);
      }
      return null;
    }
    // this should be called from ClientHandshake command only
    // and skipped when called from ChangeUser command
    if (!connection.authorized) {
      connection.authorized = true;
      if (connection.config.compress) {
        const enableCompression =
          /*@__PURE__*/ requireCompressed_protocol().enableCompression;
        enableCompression(connection);
      }
    }
    if (this.onResult) {
      this.onResult(null);
    }
    return null;
  }
};
var client_handshake = ClientHandshake$2;

const CommandCode$2 = commands$1;
const Errors = errors;

const Command$9 = command;
const Packets$8 = packetsExports;

let ServerHandshake$1 = class ServerHandshake extends Command$9 {
  constructor(args) {
    super();
    this.args = args;
    /*
    this.protocolVersion = args.protocolVersion || 10;
    this.serverVersion   = args.serverVersion;
    this.connectionId    = args.connectionId,
    this.statusFlags     = args.statusFlags,
    this.characterSet    = args.characterSet,
    this.capabilityFlags = args.capabilityFlags || 512;
    */
  }

  start(packet, connection) {
    const serverHelloPacket = new Packets$8.Handshake(this.args);
    this.serverHello = serverHelloPacket;
    serverHelloPacket.setScrambleData((err) => {
      if (err) {
        connection.emit('error', new Error('Error generating random bytes'));
        return;
      }
      connection.writePacket(serverHelloPacket.toPacket(0));
    });
    return ServerHandshake.prototype.readClientReply;
  }

  readClientReply(packet, connection) {
    // check auth here
    const clientHelloReply = Packets$8.HandshakeResponse.fromPacket(packet);
    // TODO check we don't have something similar already
    connection.clientHelloReply = clientHelloReply;
    if (this.args.authCallback) {
      this.args.authCallback(
        {
          user: clientHelloReply.user,
          database: clientHelloReply.database,
          address: connection.stream.remoteAddress,
          authPluginData1: this.serverHello.authPluginData1,
          authPluginData2: this.serverHello.authPluginData2,
          authToken: clientHelloReply.authToken,
        },
        (err, mysqlError) => {
          // if (err)
          if (!mysqlError) {
            connection.writeOk();
          } else {
            // TODO create constants / errorToCode
            // 1045 = ER_ACCESS_DENIED_ERROR
            connection.writeError({
              message: mysqlError.message || '',
              code: mysqlError.code || 1045,
            });
            connection.close();
          }
        }
      );
    } else {
      connection.writeOk();
    }
    return ServerHandshake.prototype.dispatchCommands;
  }

  _isStatement(query, name) {
    const firstWord = query.split(' ')[0].toUpperCase();
    return firstWord === name;
  }

  dispatchCommands(packet, connection) {
    // command from client to server
    let knownCommand = true;
    const encoding = connection.clientHelloReply.encoding;
    const commandCode = packet.readInt8();
    switch (commandCode) {
      case CommandCode$2.STMT_PREPARE:
        if (connection.listeners('stmt_prepare').length) {
          const query = packet.readString(undefined, encoding);
          connection.emit('stmt_prepare', query);
        } else {
          connection.writeError({
            code: Errors.HA_ERR_INTERNAL_ERROR,
            message: 'No query handler for prepared statements.',
          });
        }
        break;
      case CommandCode$2.STMT_EXECUTE:
        if (connection.listeners('stmt_execute').length) {
          const { stmtId, flags, iterationCount, values } =
            Packets$8.Execute.fromPacket(packet, encoding);
          connection.emit(
            'stmt_execute',
            stmtId,
            flags,
            iterationCount,
            values
          );
        } else {
          connection.writeError({
            code: Errors.HA_ERR_INTERNAL_ERROR,
            message: 'No query handler for execute statements.',
          });
        }
        break;
      case CommandCode$2.QUIT:
        if (connection.listeners('quit').length) {
          connection.emit('quit');
        } else {
          connection.stream.end();
        }
        break;
      case CommandCode$2.INIT_DB:
        if (connection.listeners('init_db').length) {
          const schemaName = packet.readString(undefined, encoding);
          connection.emit('init_db', schemaName);
        } else {
          connection.writeOk();
        }
        break;
      case CommandCode$2.QUERY:
        if (connection.listeners('query').length) {
          const query = packet.readString(undefined, encoding);
          if (
            this._isStatement(query, 'PREPARE') ||
            this._isStatement(query, 'SET')
          ) {
            connection.emit('stmt_prepare', query);
          } else if (this._isStatement(query, 'EXECUTE')) {
            connection.emit('stmt_execute', null, null, null, null, query);
          } else connection.emit('query', query);
        } else {
          connection.writeError({
            code: Errors.HA_ERR_INTERNAL_ERROR,
            message: 'No query handler',
          });
        }
        break;
      case CommandCode$2.FIELD_LIST:
        if (connection.listeners('field_list').length) {
          const table = packet.readNullTerminatedString(encoding);
          const fields = packet.readString(undefined, encoding);
          connection.emit('field_list', table, fields);
        } else {
          connection.writeError({
            code: Errors.ER_WARN_DEPRECATED_SYNTAX,
            message:
              'As of MySQL 5.7.11, COM_FIELD_LIST is deprecated and will be removed in a future version of MySQL.',
          });
        }
        break;
      case CommandCode$2.PING:
        if (connection.listeners('ping').length) {
          connection.emit('ping');
        } else {
          connection.writeOk();
        }
        break;
      default:
        knownCommand = false;
    }
    if (connection.listeners('packet').length) {
      connection.emit('packet', packet.clone(), knownCommand, commandCode);
    } else if (!knownCommand) {
      // eslint-disable-next-line no-console
      console.log('Unknown command:', commandCode);
    }
    return ServerHandshake.prototype.dispatchCommands;
  }
};

var server_handshake = ServerHandshake$1;

var charsets = {};

var hasRequiredCharsets;

function requireCharsets () {
	if (hasRequiredCharsets) return charsets;
	hasRequiredCharsets = 1;
	(function (exports$1) {

		exports$1.BIG5_CHINESE_CI = 1;
		exports$1.LATIN2_CZECH_CS = 2;
		exports$1.DEC8_SWEDISH_CI = 3;
		exports$1.CP850_GENERAL_CI = 4;
		exports$1.LATIN1_GERMAN1_CI = 5;
		exports$1.HP8_ENGLISH_CI = 6;
		exports$1.KOI8R_GENERAL_CI = 7;
		exports$1.LATIN1_SWEDISH_CI = 8;
		exports$1.LATIN2_GENERAL_CI = 9;
		exports$1.SWE7_SWEDISH_CI = 10;
		exports$1.ASCII_GENERAL_CI = 11;
		exports$1.UJIS_JAPANESE_CI = 12;
		exports$1.SJIS_JAPANESE_CI = 13;
		exports$1.CP1251_BULGARIAN_CI = 14;
		exports$1.LATIN1_DANISH_CI = 15;
		exports$1.HEBREW_GENERAL_CI = 16;
		exports$1.TIS620_THAI_CI = 18;
		exports$1.EUCKR_KOREAN_CI = 19;
		exports$1.LATIN7_ESTONIAN_CS = 20;
		exports$1.LATIN2_HUNGARIAN_CI = 21;
		exports$1.KOI8U_GENERAL_CI = 22;
		exports$1.CP1251_UKRAINIAN_CI = 23;
		exports$1.GB2312_CHINESE_CI = 24;
		exports$1.GREEK_GENERAL_CI = 25;
		exports$1.CP1250_GENERAL_CI = 26;
		exports$1.LATIN2_CROATIAN_CI = 27;
		exports$1.GBK_CHINESE_CI = 28;
		exports$1.CP1257_LITHUANIAN_CI = 29;
		exports$1.LATIN5_TURKISH_CI = 30;
		exports$1.LATIN1_GERMAN2_CI = 31;
		exports$1.ARMSCII8_GENERAL_CI = 32;
		exports$1.UTF8_GENERAL_CI = 33;
		exports$1.CP1250_CZECH_CS = 34;
		exports$1.UCS2_GENERAL_CI = 35;
		exports$1.CP866_GENERAL_CI = 36;
		exports$1.KEYBCS2_GENERAL_CI = 37;
		exports$1.MACCE_GENERAL_CI = 38;
		exports$1.MACROMAN_GENERAL_CI = 39;
		exports$1.CP852_GENERAL_CI = 40;
		exports$1.LATIN7_GENERAL_CI = 41;
		exports$1.LATIN7_GENERAL_CS = 42;
		exports$1.MACCE_BIN = 43;
		exports$1.CP1250_CROATIAN_CI = 44;
		exports$1.UTF8MB4_GENERAL_CI = 45;
		exports$1.UTF8MB4_BIN = 46;
		exports$1.LATIN1_BIN = 47;
		exports$1.LATIN1_GENERAL_CI = 48;
		exports$1.LATIN1_GENERAL_CS = 49;
		exports$1.CP1251_BIN = 50;
		exports$1.CP1251_GENERAL_CI = 51;
		exports$1.CP1251_GENERAL_CS = 52;
		exports$1.MACROMAN_BIN = 53;
		exports$1.UTF16_GENERAL_CI = 54;
		exports$1.UTF16_BIN = 55;
		exports$1.UTF16LE_GENERAL_CI = 56;
		exports$1.CP1256_GENERAL_CI = 57;
		exports$1.CP1257_BIN = 58;
		exports$1.CP1257_GENERAL_CI = 59;
		exports$1.UTF32_GENERAL_CI = 60;
		exports$1.UTF32_BIN = 61;
		exports$1.UTF16LE_BIN = 62;
		exports$1.BINARY = 63;
		exports$1.ARMSCII8_BIN = 64;
		exports$1.ASCII_BIN = 65;
		exports$1.CP1250_BIN = 66;
		exports$1.CP1256_BIN = 67;
		exports$1.CP866_BIN = 68;
		exports$1.DEC8_BIN = 69;
		exports$1.GREEK_BIN = 70;
		exports$1.HEBREW_BIN = 71;
		exports$1.HP8_BIN = 72;
		exports$1.KEYBCS2_BIN = 73;
		exports$1.KOI8R_BIN = 74;
		exports$1.KOI8U_BIN = 75;
		exports$1.UTF8_TOLOWER_CI = 76;
		exports$1.LATIN2_BIN = 77;
		exports$1.LATIN5_BIN = 78;
		exports$1.LATIN7_BIN = 79;
		exports$1.CP850_BIN = 80;
		exports$1.CP852_BIN = 81;
		exports$1.SWE7_BIN = 82;
		exports$1.UTF8_BIN = 83;
		exports$1.BIG5_BIN = 84;
		exports$1.EUCKR_BIN = 85;
		exports$1.GB2312_BIN = 86;
		exports$1.GBK_BIN = 87;
		exports$1.SJIS_BIN = 88;
		exports$1.TIS620_BIN = 89;
		exports$1.UCS2_BIN = 90;
		exports$1.UJIS_BIN = 91;
		exports$1.GEOSTD8_GENERAL_CI = 92;
		exports$1.GEOSTD8_BIN = 93;
		exports$1.LATIN1_SPANISH_CI = 94;
		exports$1.CP932_JAPANESE_CI = 95;
		exports$1.CP932_BIN = 96;
		exports$1.EUCJPMS_JAPANESE_CI = 97;
		exports$1.EUCJPMS_BIN = 98;
		exports$1.CP1250_POLISH_CI = 99;
		exports$1.UTF16_UNICODE_CI = 101;
		exports$1.UTF16_ICELANDIC_CI = 102;
		exports$1.UTF16_LATVIAN_CI = 103;
		exports$1.UTF16_ROMANIAN_CI = 104;
		exports$1.UTF16_SLOVENIAN_CI = 105;
		exports$1.UTF16_POLISH_CI = 106;
		exports$1.UTF16_ESTONIAN_CI = 107;
		exports$1.UTF16_SPANISH_CI = 108;
		exports$1.UTF16_SWEDISH_CI = 109;
		exports$1.UTF16_TURKISH_CI = 110;
		exports$1.UTF16_CZECH_CI = 111;
		exports$1.UTF16_DANISH_CI = 112;
		exports$1.UTF16_LITHUANIAN_CI = 113;
		exports$1.UTF16_SLOVAK_CI = 114;
		exports$1.UTF16_SPANISH2_CI = 115;
		exports$1.UTF16_ROMAN_CI = 116;
		exports$1.UTF16_PERSIAN_CI = 117;
		exports$1.UTF16_ESPERANTO_CI = 118;
		exports$1.UTF16_HUNGARIAN_CI = 119;
		exports$1.UTF16_SINHALA_CI = 120;
		exports$1.UTF16_GERMAN2_CI = 121;
		exports$1.UTF16_CROATIAN_CI = 122;
		exports$1.UTF16_UNICODE_520_CI = 123;
		exports$1.UTF16_VIETNAMESE_CI = 124;
		exports$1.UCS2_UNICODE_CI = 128;
		exports$1.UCS2_ICELANDIC_CI = 129;
		exports$1.UCS2_LATVIAN_CI = 130;
		exports$1.UCS2_ROMANIAN_CI = 131;
		exports$1.UCS2_SLOVENIAN_CI = 132;
		exports$1.UCS2_POLISH_CI = 133;
		exports$1.UCS2_ESTONIAN_CI = 134;
		exports$1.UCS2_SPANISH_CI = 135;
		exports$1.UCS2_SWEDISH_CI = 136;
		exports$1.UCS2_TURKISH_CI = 137;
		exports$1.UCS2_CZECH_CI = 138;
		exports$1.UCS2_DANISH_CI = 139;
		exports$1.UCS2_LITHUANIAN_CI = 140;
		exports$1.UCS2_SLOVAK_CI = 141;
		exports$1.UCS2_SPANISH2_CI = 142;
		exports$1.UCS2_ROMAN_CI = 143;
		exports$1.UCS2_PERSIAN_CI = 144;
		exports$1.UCS2_ESPERANTO_CI = 145;
		exports$1.UCS2_HUNGARIAN_CI = 146;
		exports$1.UCS2_SINHALA_CI = 147;
		exports$1.UCS2_GERMAN2_CI = 148;
		exports$1.UCS2_CROATIAN_CI = 149;
		exports$1.UCS2_UNICODE_520_CI = 150;
		exports$1.UCS2_VIETNAMESE_CI = 151;
		exports$1.UCS2_GENERAL_MYSQL500_CI = 159;
		exports$1.UTF32_UNICODE_CI = 160;
		exports$1.UTF32_ICELANDIC_CI = 161;
		exports$1.UTF32_LATVIAN_CI = 162;
		exports$1.UTF32_ROMANIAN_CI = 163;
		exports$1.UTF32_SLOVENIAN_CI = 164;
		exports$1.UTF32_POLISH_CI = 165;
		exports$1.UTF32_ESTONIAN_CI = 166;
		exports$1.UTF32_SPANISH_CI = 167;
		exports$1.UTF32_SWEDISH_CI = 168;
		exports$1.UTF32_TURKISH_CI = 169;
		exports$1.UTF32_CZECH_CI = 170;
		exports$1.UTF32_DANISH_CI = 171;
		exports$1.UTF32_LITHUANIAN_CI = 172;
		exports$1.UTF32_SLOVAK_CI = 173;
		exports$1.UTF32_SPANISH2_CI = 174;
		exports$1.UTF32_ROMAN_CI = 175;
		exports$1.UTF32_PERSIAN_CI = 176;
		exports$1.UTF32_ESPERANTO_CI = 177;
		exports$1.UTF32_HUNGARIAN_CI = 178;
		exports$1.UTF32_SINHALA_CI = 179;
		exports$1.UTF32_GERMAN2_CI = 180;
		exports$1.UTF32_CROATIAN_CI = 181;
		exports$1.UTF32_UNICODE_520_CI = 182;
		exports$1.UTF32_VIETNAMESE_CI = 183;
		exports$1.UTF8_UNICODE_CI = 192;
		exports$1.UTF8_ICELANDIC_CI = 193;
		exports$1.UTF8_LATVIAN_CI = 194;
		exports$1.UTF8_ROMANIAN_CI = 195;
		exports$1.UTF8_SLOVENIAN_CI = 196;
		exports$1.UTF8_POLISH_CI = 197;
		exports$1.UTF8_ESTONIAN_CI = 198;
		exports$1.UTF8_SPANISH_CI = 199;
		exports$1.UTF8_SWEDISH_CI = 200;
		exports$1.UTF8_TURKISH_CI = 201;
		exports$1.UTF8_CZECH_CI = 202;
		exports$1.UTF8_DANISH_CI = 203;
		exports$1.UTF8_LITHUANIAN_CI = 204;
		exports$1.UTF8_SLOVAK_CI = 205;
		exports$1.UTF8_SPANISH2_CI = 206;
		exports$1.UTF8_ROMAN_CI = 207;
		exports$1.UTF8_PERSIAN_CI = 208;
		exports$1.UTF8_ESPERANTO_CI = 209;
		exports$1.UTF8_HUNGARIAN_CI = 210;
		exports$1.UTF8_SINHALA_CI = 211;
		exports$1.UTF8_GERMAN2_CI = 212;
		exports$1.UTF8_CROATIAN_CI = 213;
		exports$1.UTF8_UNICODE_520_CI = 214;
		exports$1.UTF8_VIETNAMESE_CI = 215;
		exports$1.UTF8_GENERAL_MYSQL500_CI = 223;
		exports$1.UTF8MB4_UNICODE_CI = 224;
		exports$1.UTF8MB4_ICELANDIC_CI = 225;
		exports$1.UTF8MB4_LATVIAN_CI = 226;
		exports$1.UTF8MB4_ROMANIAN_CI = 227;
		exports$1.UTF8MB4_SLOVENIAN_CI = 228;
		exports$1.UTF8MB4_POLISH_CI = 229;
		exports$1.UTF8MB4_ESTONIAN_CI = 230;
		exports$1.UTF8MB4_SPANISH_CI = 231;
		exports$1.UTF8MB4_SWEDISH_CI = 232;
		exports$1.UTF8MB4_TURKISH_CI = 233;
		exports$1.UTF8MB4_CZECH_CI = 234;
		exports$1.UTF8MB4_DANISH_CI = 235;
		exports$1.UTF8MB4_LITHUANIAN_CI = 236;
		exports$1.UTF8MB4_SLOVAK_CI = 237;
		exports$1.UTF8MB4_SPANISH2_CI = 238;
		exports$1.UTF8MB4_ROMAN_CI = 239;
		exports$1.UTF8MB4_PERSIAN_CI = 240;
		exports$1.UTF8MB4_ESPERANTO_CI = 241;
		exports$1.UTF8MB4_HUNGARIAN_CI = 242;
		exports$1.UTF8MB4_SINHALA_CI = 243;
		exports$1.UTF8MB4_GERMAN2_CI = 244;
		exports$1.UTF8MB4_CROATIAN_CI = 245;
		exports$1.UTF8MB4_UNICODE_520_CI = 246;
		exports$1.UTF8MB4_VIETNAMESE_CI = 247;
		exports$1.GB18030_CHINESE_CI = 248;
		exports$1.GB18030_BIN = 249;
		exports$1.GB18030_UNICODE_520_CI = 250;
		exports$1.UTF8_GENERAL50_CI = 253; // deprecated
		exports$1.UTF8MB4_0900_AI_CI = 255;
		exports$1.UTF8MB4_DE_PB_0900_AI_CI = 256;
		exports$1.UTF8MB4_IS_0900_AI_CI = 257;
		exports$1.UTF8MB4_LV_0900_AI_CI = 258;
		exports$1.UTF8MB4_RO_0900_AI_CI = 259;
		exports$1.UTF8MB4_SL_0900_AI_CI = 260;
		exports$1.UTF8MB4_PL_0900_AI_CI = 261;
		exports$1.UTF8MB4_ET_0900_AI_CI = 262;
		exports$1.UTF8MB4_ES_0900_AI_CI = 263;
		exports$1.UTF8MB4_SV_0900_AI_CI = 264;
		exports$1.UTF8MB4_TR_0900_AI_CI = 265;
		exports$1.UTF8MB4_CS_0900_AI_CI = 266;
		exports$1.UTF8MB4_DA_0900_AI_CI = 267;
		exports$1.UTF8MB4_LT_0900_AI_CI = 268;
		exports$1.UTF8MB4_SK_0900_AI_CI = 269;
		exports$1.UTF8MB4_ES_TRAD_0900_AI_CI = 270;
		exports$1.UTF8MB4_LA_0900_AI_CI = 271;
		exports$1.UTF8MB4_EO_0900_AI_CI = 273;
		exports$1.UTF8MB4_HU_0900_AI_CI = 274;
		exports$1.UTF8MB4_HR_0900_AI_CI = 275;
		exports$1.UTF8MB4_VI_0900_AI_CI = 277;
		exports$1.UTF8MB4_0900_AS_CS = 278;
		exports$1.UTF8MB4_DE_PB_0900_AS_CS = 279;
		exports$1.UTF8MB4_IS_0900_AS_CS = 280;
		exports$1.UTF8MB4_LV_0900_AS_CS = 281;
		exports$1.UTF8MB4_RO_0900_AS_CS = 282;
		exports$1.UTF8MB4_SL_0900_AS_CS = 283;
		exports$1.UTF8MB4_PL_0900_AS_CS = 284;
		exports$1.UTF8MB4_ET_0900_AS_CS = 285;
		exports$1.UTF8MB4_ES_0900_AS_CS = 286;
		exports$1.UTF8MB4_SV_0900_AS_CS = 287;
		exports$1.UTF8MB4_TR_0900_AS_CS = 288;
		exports$1.UTF8MB4_CS_0900_AS_CS = 289;
		exports$1.UTF8MB4_DA_0900_AS_CS = 290;
		exports$1.UTF8MB4_LT_0900_AS_CS = 291;
		exports$1.UTF8MB4_SK_0900_AS_CS = 292;
		exports$1.UTF8MB4_ES_TRAD_0900_AS_CS = 293;
		exports$1.UTF8MB4_LA_0900_AS_CS = 294;
		exports$1.UTF8MB4_EO_0900_AS_CS = 296;
		exports$1.UTF8MB4_HU_0900_AS_CS = 297;
		exports$1.UTF8MB4_HR_0900_AS_CS = 298;
		exports$1.UTF8MB4_VI_0900_AS_CS = 300;
		exports$1.UTF8MB4_JA_0900_AS_CS = 303;
		exports$1.UTF8MB4_JA_0900_AS_CS_KS = 304;
		exports$1.UTF8MB4_0900_AS_CI = 305;
		exports$1.UTF8MB4_RU_0900_AI_CI = 306;
		exports$1.UTF8MB4_RU_0900_AS_CS = 307;
		exports$1.UTF8MB4_ZH_0900_AS_CS = 308;
		exports$1.UTF8MB4_0900_BIN = 309;

		// short aliases
		exports$1.BIG5 = exports$1.BIG5_CHINESE_CI;
		exports$1.DEC8 = exports$1.DEC8_SWEDISH_CI;
		exports$1.CP850 = exports$1.CP850_GENERAL_CI;
		exports$1.HP8 = exports$1.HP8_ENGLISH_CI;
		exports$1.KOI8R = exports$1.KOI8R_GENERAL_CI;
		exports$1.LATIN1 = exports$1.LATIN1_SWEDISH_CI;
		exports$1.LATIN2 = exports$1.LATIN2_GENERAL_CI;
		exports$1.SWE7 = exports$1.SWE7_SWEDISH_CI;
		exports$1.ASCII = exports$1.ASCII_GENERAL_CI;
		exports$1.UJIS = exports$1.UJIS_JAPANESE_CI;
		exports$1.SJIS = exports$1.SJIS_JAPANESE_CI;
		exports$1.HEBREW = exports$1.HEBREW_GENERAL_CI;
		exports$1.TIS620 = exports$1.TIS620_THAI_CI;
		exports$1.EUCKR = exports$1.EUCKR_KOREAN_CI;
		exports$1.KOI8U = exports$1.KOI8U_GENERAL_CI;
		exports$1.GB2312 = exports$1.GB2312_CHINESE_CI;
		exports$1.GREEK = exports$1.GREEK_GENERAL_CI;
		exports$1.CP1250 = exports$1.CP1250_GENERAL_CI;
		exports$1.GBK = exports$1.GBK_CHINESE_CI;
		exports$1.LATIN5 = exports$1.LATIN5_TURKISH_CI;
		exports$1.ARMSCII8 = exports$1.ARMSCII8_GENERAL_CI;
		exports$1.UTF8 = exports$1.UTF8_GENERAL_CI;
		exports$1.UCS2 = exports$1.UCS2_GENERAL_CI;
		exports$1.CP866 = exports$1.CP866_GENERAL_CI;
		exports$1.KEYBCS2 = exports$1.KEYBCS2_GENERAL_CI;
		exports$1.MACCE = exports$1.MACCE_GENERAL_CI;
		exports$1.MACROMAN = exports$1.MACROMAN_GENERAL_CI;
		exports$1.CP852 = exports$1.CP852_GENERAL_CI;
		exports$1.LATIN7 = exports$1.LATIN7_GENERAL_CI;
		exports$1.UTF8MB4 = exports$1.UTF8MB4_GENERAL_CI;
		exports$1.CP1251 = exports$1.CP1251_GENERAL_CI;
		exports$1.UTF16 = exports$1.UTF16_GENERAL_CI;
		exports$1.UTF16LE = exports$1.UTF16LE_GENERAL_CI;
		exports$1.CP1256 = exports$1.CP1256_GENERAL_CI;
		exports$1.CP1257 = exports$1.CP1257_GENERAL_CI;
		exports$1.UTF32 = exports$1.UTF32_GENERAL_CI;
		exports$1.CP932 = exports$1.CP932_JAPANESE_CI;
		exports$1.EUCJPMS = exports$1.EUCJPMS_JAPANESE_CI;
		exports$1.GB18030 = exports$1.GB18030_CHINESE_CI;
		exports$1.GEOSTD8 = exports$1.GEOSTD8_GENERAL_CI; 
	} (charsets));
	return charsets;
}

var helpers$4 = {};

/*

  this seems to be not only shorter, but faster than
  string.replace(/\\/g, '\\\\').
            replace(/\u0008/g, '\\b').
            replace(/\t/g, '\\t').
            replace(/\n/g, '\\n').
            replace(/\f/g, '\\f').
            replace(/\r/g, '\\r').
            replace(/'/g, '\\\'').
            replace(/"/g, '\\"');
  or string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
  see http://jsperf.com/string-escape-regexp-vs-json-stringify
  */
function srcEscape(str) {
  return JSON.stringify({
    [str]: 1,
  }).slice(1, -3);
}

helpers$4.srcEscape = srcEscape;

let highlightFn;
let cardinalRecommended = false;
try {
  // the purpose of this is to prevent projects using Webpack from displaying a warning during runtime if cardinal is not a dependency
  const REQUIRE_TERMINATOR = '';
  highlightFn = commonjsRequire(`cardinal${REQUIRE_TERMINATOR}`).highlight;
} catch (err) {
  highlightFn = (text) => {
    if (!cardinalRecommended) {
      // eslint-disable-next-line no-console
      console.log('For nicer debug output consider install cardinal@^2.0.0');
      cardinalRecommended = true;
    }
    return text;
  };
}

/**
 * Prints debug message with code frame, will try to use `cardinal` if available.
 */
function printDebugWithCode(msg, code) {
  // eslint-disable-next-line no-console
  console.log(`\n\n${msg}:\n`);
  // eslint-disable-next-line no-console
  console.log(`${highlightFn(code)}\n`);
}

helpers$4.printDebugWithCode = printDebugWithCode;

/**
 * checks whether the `type` is in the `list`
 */
function typeMatch(type, list, Types) {
  if (Array.isArray(list)) {
    return list.some((t) => type === Types[t]);
  }

  return !!list;
}

helpers$4.typeMatch = typeMatch;

const privateObjectProps = new Set([
  '__defineGetter__',
  '__defineSetter__',
  '__lookupGetter__',
  '__lookupSetter__',
  '__proto__',
]);

helpers$4.privateObjectProps = privateObjectProps;

const fieldEscape = (field, isEval = true) => {
  if (privateObjectProps.has(field)) {
    throw new Error(
      `The field name (${field}) can't be the same as an object's private property.`
    );
  }

  return isEval ? srcEscape(field) : field;
};
helpers$4.fieldEscape = fieldEscape;

function isProperty$1(str) {
  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
}
var isProperty_1 = isProperty$1;

var util = require$$0$2;
var isProperty = isProperty_1;

var INDENT_START = /[\{\[]/;
var INDENT_END = /[\}\]]/;

// from https://mathiasbynens.be/notes/reserved-keywords
var RESERVED = [
  'do',
  'if',
  'in',
  'for',
  'let',
  'new',
  'try',
  'var',
  'case',
  'else',
  'enum',
  'eval',
  'null',
  'this',
  'true',
  'void',
  'with',
  'await',
  'break',
  'catch',
  'class',
  'const',
  'false',
  'super',
  'throw',
  'while',
  'yield',
  'delete',
  'export',
  'import',
  'public',
  'return',
  'static',
  'switch',
  'typeof',
  'default',
  'extends',
  'finally',
  'package',
  'private',
  'continue',
  'debugger',
  'function',
  'arguments',
  'interface',
  'protected',
  'implements',
  'instanceof',
  'NaN',
  'undefined'
];

var RESERVED_MAP = {};

for (var i = 0; i < RESERVED.length; i++) {
  RESERVED_MAP[RESERVED[i]] = true;
}

var isVariable = function (name) {
  return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name)
};

var formats = {
  s: function(s) {
    return '' + s
  },
  d: function(d) {
    return '' + Number(d)
  },
  o: function(o) {
    return JSON.stringify(o)
  }
};

var genfun = function() {
  var lines = [];
  var indent = 0;
  var vars = {};

  var push = function(str) {
    var spaces = '';
    while (spaces.length < indent*2) spaces += '  ';
    lines.push(spaces+str);
  };

  var pushLine = function(line) {
    if (INDENT_END.test(line.trim()[0]) && INDENT_START.test(line[line.length-1])) {
      indent--;
      push(line);
      indent++;
      return
    }
    if (INDENT_START.test(line[line.length-1])) {
      push(line);
      indent++;
      return
    }
    if (INDENT_END.test(line.trim()[0])) {
      indent--;
      push(line);
      return
    }

    push(line);
  };

  var line = function(fmt) {
    if (!fmt) return line

    if (arguments.length === 1 && fmt.indexOf('\n') > -1) {
      var lines = fmt.trim().split('\n');
      for (var i = 0; i < lines.length; i++) {
        pushLine(lines[i].trim());
      }
    } else {
      pushLine(util.format.apply(util, arguments));
    }

    return line
  };

  line.scope = {};
  line.formats = formats;

  line.sym = function(name) {
    if (!name || !isVariable(name)) name = 'tmp';
    if (!vars[name]) vars[name] = 0;
    return name + (vars[name]++ || '')
  };

  line.property = function(obj, name) {
    if (arguments.length === 1) {
      name = obj;
      obj = '';
    }

    name = name + '';

    if (isProperty(name)) return (obj ? obj + '.' + name : name)
    return obj ? obj + '[' + JSON.stringify(name) + ']' : JSON.stringify(name)
  };

  line.toString = function() {
    return lines.join('\n')
  };

  line.toFunction = function(scope) {
    if (!scope) scope = {};

    var src = 'return ('+line.toString()+')';

    Object.keys(line.scope).forEach(function (key) {
      if (!scope[key]) scope[key] = line.scope[key];
    });

    var keys = Object.keys(scope).map(function(key) {
      return key
    });

    var vals = keys.map(function(key) {
      return scope[key]
    });

    return Function.apply(null, keys.concat(src)).apply(null, vals)
  };

  if (arguments.length) line.apply(null, arguments);

  return line
};

genfun.formats = formats;
var generateFunction = genfun;

const Types$3 = /*@__PURE__*/ requireTypes();
const Charsets$4 = /*@__PURE__*/ requireCharsets();
const helpers$3 = helpers$4;
const genFunc$1 = generateFunction;
const parserCache$1 = parser_cache;

const typeNames$3 = [];
for (const t in Types$3) {
  typeNames$3[Types$3[t]] = t;
}

function readCodeFor$1(type, charset, encodingExpr, config, options) {
  const supportBigNumbers = Boolean(
    options.supportBigNumbers || config.supportBigNumbers
  );
  const bigNumberStrings = Boolean(
    options.bigNumberStrings || config.bigNumberStrings
  );
  const timezone = options.timezone || config.timezone;
  const dateStrings = options.dateStrings || config.dateStrings;

  switch (type) {
    case Types$3.TINY:
    case Types$3.SHORT:
    case Types$3.LONG:
    case Types$3.INT24:
    case Types$3.YEAR:
      return 'packet.parseLengthCodedIntNoBigCheck()';
    case Types$3.LONGLONG:
      if (supportBigNumbers && bigNumberStrings) {
        return 'packet.parseLengthCodedIntString()';
      }
      return `packet.parseLengthCodedInt(${supportBigNumbers})`;
    case Types$3.FLOAT:
    case Types$3.DOUBLE:
      return 'packet.parseLengthCodedFloat()';
    case Types$3.NULL:
      return 'packet.readLengthCodedNumber()';
    case Types$3.DECIMAL:
    case Types$3.NEWDECIMAL:
      if (config.decimalNumbers) {
        return 'packet.parseLengthCodedFloat()';
      }
      return 'packet.readLengthCodedString("ascii")';
    case Types$3.DATE:
      if (helpers$3.typeMatch(type, dateStrings, Types$3)) {
        return 'packet.readLengthCodedString("ascii")';
      }
      return `packet.parseDate(${helpers$3.srcEscape(timezone)})`;
    case Types$3.DATETIME:
    case Types$3.TIMESTAMP:
      if (helpers$3.typeMatch(type, dateStrings, Types$3)) {
        return 'packet.readLengthCodedString("ascii")';
      }
      return `packet.parseDateTime(${helpers$3.srcEscape(timezone)})`;
    case Types$3.TIME:
      return 'packet.readLengthCodedString("ascii")';
    case Types$3.GEOMETRY:
      return 'packet.parseGeometryValue()';
    case Types$3.VECTOR:
      return 'packet.parseVector()';
    case Types$3.JSON:
      // Since for JSON columns mysql always returns charset 63 (BINARY),
      // we have to handle it according to JSON specs and use "utf8",
      // see https://github.com/sidorares/node-mysql2/issues/409
      return config.jsonStrings
        ? 'packet.readLengthCodedString("utf8")'
        : 'JSON.parse(packet.readLengthCodedString("utf8"))';
    default:
      if (charset === Charsets$4.BINARY) {
        return 'packet.readLengthCodedBuffer()';
      }
      return `packet.readLengthCodedString(${encodingExpr})`;
  }
}

function compile$1(fields, options, config) {
  // use global typeCast if current query doesn't specify one
  if (
    typeof config.typeCast === 'function' &&
    typeof options.typeCast !== 'function'
  ) {
    options.typeCast = config.typeCast;
  }

  function wrap(field, _this) {
    return {
      type: typeNames$3[field.columnType],
      length: field.columnLength,
      db: field.schema,
      table: field.table,
      name: field.name,
      string: function (encoding = field.encoding) {
        if (field.columnType === Types$3.JSON && encoding === field.encoding) {
          // Since for JSON columns mysql always returns charset 63 (BINARY),
          // we have to handle it according to JSON specs and use "utf8",
          // see https://github.com/sidorares/node-mysql2/issues/1661
          console.warn(
            `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
          );
        }

        return _this.packet.readLengthCodedString(encoding);
      },
      buffer: function () {
        return _this.packet.readLengthCodedBuffer();
      },
      geometry: function () {
        return _this.packet.parseGeometryValue();
      },
    };
  }

  const parserFn = genFunc$1();

  parserFn('(function () {')('return class TextRow {');

  // constructor method
  parserFn('constructor(fields) {');
  // node-mysql typeCast compatibility wrapper
  // see https://github.com/mysqljs/mysql/blob/96fdd0566b654436624e2375c7b6604b1f50f825/lib/protocol/packets/Field.js
  if (typeof options.typeCast === 'function') {
    parserFn('const _this = this;');
    parserFn('for(let i=0; i<fields.length; ++i) {');
    parserFn('this[`wrap${i}`] = wrap(fields[i], _this);');
    parserFn('}');
  }
  parserFn('}');

  // next method
  parserFn('next(packet, fields, options) {');
  parserFn('this.packet = packet;');
  if (options.rowsAsArray) {
    parserFn(`const result = new Array(${fields.length});`);
  } else {
    parserFn('const result = {};');
  }

  const resultTables = {};
  let resultTablesArray = [];

  if (options.nestTables === true) {
    for (let i = 0; i < fields.length; i++) {
      resultTables[fields[i].table] = 1;
    }
    resultTablesArray = Object.keys(resultTables);
    for (let i = 0; i < resultTablesArray.length; i++) {
      parserFn(`result[${helpers$3.fieldEscape(resultTablesArray[i])}] = {};`);
    }
  }

  let lvalue = '';
  let fieldName = '';
  let tableName = '';
  for (let i = 0; i < fields.length; i++) {
    fieldName = helpers$3.fieldEscape(fields[i].name);
    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);

    if (typeof options.nestTables === 'string') {
      lvalue = `result[${helpers$3.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;
    } else if (options.nestTables === true) {
      tableName = helpers$3.fieldEscape(fields[i].table);

      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
      lvalue = `result[${tableName}][${fieldName}]`;
    } else if (options.rowsAsArray) {
      lvalue = `result[${i.toString(10)}]`;
    } else {
      lvalue = `result[${fieldName}]`;
    }
    if (options.typeCast === false) {
      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
    } else {
      const encodingExpr = `fields[${i}].encoding`;
      const readCode = readCodeFor$1(
        fields[i].columnType,
        fields[i].characterSet,
        encodingExpr,
        config,
        options
      );
      if (typeof options.typeCast === 'function') {
        parserFn(
          `${lvalue} = options.typeCast(this.wrap${i}, function() { return ${readCode} });`
        );
      } else {
        parserFn(`${lvalue} = ${readCode};`);
      }
    }
  }

  parserFn('return result;');
  parserFn('}');
  parserFn('};')('})()');

  if (config.debug) {
    helpers$3.printDebugWithCode(
      'Compiled text protocol row parser',
      parserFn.toString()
    );
  }
  if (typeof options.typeCast === 'function') {
    return parserFn.toFunction({ wrap });
  }
  return parserFn.toFunction();
}

function getTextParser$2(fields, options, config) {
  return parserCache$1.getParser('text', fields, options, config, compile$1);
}

var text_parser = getTextParser$2;

const Types$2 = /*@__PURE__*/ requireTypes();
const Charsets$3 = /*@__PURE__*/ requireCharsets();
const helpers$2 = helpers$4;

const typeNames$2 = [];
for (const t in Types$2) {
  typeNames$2[Types$2[t]] = t;
}

function readField({ packet, type, charset, encoding, config, options }) {
  const supportBigNumbers = Boolean(
    options.supportBigNumbers || config.supportBigNumbers
  );
  const bigNumberStrings = Boolean(
    options.bigNumberStrings || config.bigNumberStrings
  );
  const timezone = options.timezone || config.timezone;
  const dateStrings = options.dateStrings || config.dateStrings;

  switch (type) {
    case Types$2.TINY:
    case Types$2.SHORT:
    case Types$2.LONG:
    case Types$2.INT24:
    case Types$2.YEAR:
      return packet.parseLengthCodedIntNoBigCheck();
    case Types$2.LONGLONG:
      if (supportBigNumbers && bigNumberStrings) {
        return packet.parseLengthCodedIntString();
      }
      return packet.parseLengthCodedInt(supportBigNumbers);
    case Types$2.FLOAT:
    case Types$2.DOUBLE:
      return packet.parseLengthCodedFloat();
    case Types$2.NULL:
    case Types$2.DECIMAL:
    case Types$2.NEWDECIMAL:
      if (config.decimalNumbers) {
        return packet.parseLengthCodedFloat();
      }
      return packet.readLengthCodedString('ascii');
    case Types$2.DATE:
      if (helpers$2.typeMatch(type, dateStrings, Types$2)) {
        return packet.readLengthCodedString('ascii');
      }
      return packet.parseDate(timezone);
    case Types$2.DATETIME:
    case Types$2.TIMESTAMP:
      if (helpers$2.typeMatch(type, dateStrings, Types$2)) {
        return packet.readLengthCodedString('ascii');
      }
      return packet.parseDateTime(timezone);
    case Types$2.TIME:
      return packet.readLengthCodedString('ascii');
    case Types$2.GEOMETRY:
      return packet.parseGeometryValue();
    case Types$2.VECTOR:
      return packet.parseVector();
    case Types$2.JSON:
      // Since for JSON columns mysql always returns charset 63 (BINARY),
      // we have to handle it according to JSON specs and use "utf8",
      // see https://github.com/sidorares/node-mysql2/issues/409
      return config.jsonStrings
        ? packet.readLengthCodedString('utf8')
        : JSON.parse(packet.readLengthCodedString('utf8'));
    default:
      if (charset === Charsets$3.BINARY) {
        return packet.readLengthCodedBuffer();
      }
      return packet.readLengthCodedString(encoding);
  }
}

function createTypecastField(field, packet) {
  return {
    type: typeNames$2[field.columnType],
    length: field.columnLength,
    db: field.schema,
    table: field.table,
    name: field.name,
    string: function (encoding = field.encoding) {
      if (field.columnType === Types$2.JSON && encoding === field.encoding) {
        // Since for JSON columns mysql always returns charset 63 (BINARY),
        // we have to handle it according to JSON specs and use "utf8",
        // see https://github.com/sidorares/node-mysql2/issues/1661
        console.warn(
          `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
        );
      }
      return packet.readLengthCodedString(encoding);
    },
    buffer: function () {
      return packet.readLengthCodedBuffer();
    },
    geometry: function () {
      return packet.parseGeometryValue();
    },
  };
}

function getTextParser$1(_fields, _options, config) {
  return {
    next(packet, fields, options) {
      const result = options.rowsAsArray ? [] : {};
      for (let i = 0; i < fields.length; i++) {
        const field = fields[i];
        const typeCast = options.typeCast ? options.typeCast : config.typeCast;
        const next = () =>
          readField({
            packet,
            type: field.columnType,
            encoding: field.encoding,
            charset: field.characterSet,
            config,
            options,
          });

        let value;

        if (options.typeCast === false) {
          value = packet.readLengthCodedBuffer();
        } else if (typeof typeCast === 'function') {
          value = typeCast(createTypecastField(field, packet), next);
        } else {
          value = next();
        }

        if (options.rowsAsArray) {
          result.push(value);
        } else if (typeof options.nestTables === 'string') {
          result[
            `${helpers$2.fieldEscape(field.table, false)}${options.nestTables}${helpers$2.fieldEscape(field.name, false)}`
          ] = value;
        } else if (options.nestTables) {
          const tableName = helpers$2.fieldEscape(field.table, false);
          if (!result[tableName]) {
            result[tableName] = {};
          }
          result[tableName][helpers$2.fieldEscape(field.name, false)] = value;
        } else {
          result[helpers$2.fieldEscape(field.name, false)] = value;
        }
      }

      return result;
    },
  };
}

var static_text_parser = getTextParser$1;

const process$3 = require$$0$1;
const Timers$1 = require$$2$3;

const Readable$1 = require$$2$2.Readable;

const Command$8 = command;
const Packets$7 = packetsExports;
const getTextParser = text_parser;
const staticParser = static_text_parser;
const ServerStatus = server_status;

const EmptyPacket = new Packets$7.Packet(0, Buffer.allocUnsafe(4), 0, 4);

// http://dev.mysql.com/doc/internals/en/com-query.html
let Query$2 = class Query extends Command$8 {
  constructor(options, callback) {
    super();
    this.sql = options.sql;
    this.values = options.values;
    this._queryOptions = options;
    this.namedPlaceholders = options.namedPlaceholders || false;
    this.onResult = callback;
    this.timeout = options.timeout;
    this.queryTimeout = null;
    this._fieldCount = 0;
    this._rowParser = null;
    this._fields = [];
    this._rows = [];
    this._receivedFieldsCount = 0;
    this._resultIndex = 0;
    this._localStream = null;
    this._unpipeStream = function () {};
    this._streamFactory = options.infileStreamFactory;
    this._connection = null;
  }

  then() {
    const err =
      "You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://sidorares.github.io/node-mysql2/docs#using-promise-wrapper, or the mysql2 documentation at https://sidorares.github.io/node-mysql2/docs/documentation/promise-wrapper";
    // eslint-disable-next-line
    console.log(err);
    throw new Error(err);
  }

  /* eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }] */
  start(_packet, connection) {
    if (connection.config.debug) {
      // eslint-disable-next-line
      console.log('        Sending query command: %s', this.sql);
    }
    this._connection = connection;
    this.options = Object.assign({}, connection.config, this._queryOptions);
    this._setTimeout();

    const cmdPacket = new Packets$7.Query(
      this.sql,
      connection.config.charsetNumber
    );
    connection.writePacket(cmdPacket.toPacket(1));
    return Query.prototype.resultsetHeader;
  }

  done() {
    this._unpipeStream();
    // if all ready timeout, return null directly
    if (this.timeout && !this.queryTimeout) {
      return null;
    }
    // else clear timer
    if (this.queryTimeout) {
      Timers$1.clearTimeout(this.queryTimeout);
      this.queryTimeout = null;
    }
    if (this.onResult) {
      let rows, fields;
      if (this._resultIndex === 0) {
        rows = this._rows[0];
        fields = this._fields[0];
      } else {
        rows = this._rows;
        fields = this._fields;
      }
      if (fields) {
        process$3.nextTick(() => {
          this.onResult(null, rows, fields);
        });
      } else {
        process$3.nextTick(() => {
          this.onResult(null, rows);
        });
      }
    }
    return null;
  }

  doneInsert(rs) {
    if (this._localStreamError) {
      if (this.onResult) {
        this.onResult(this._localStreamError, rs);
      } else {
        this.emit('error', this._localStreamError);
      }
      return null;
    }
    this._rows.push(rs);
    this._fields.push(void 0);
    this.emit('fields', void 0);
    this.emit('result', rs);
    if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
      this._resultIndex++;
      return this.resultsetHeader;
    }
    return this.done();
  }

  resultsetHeader(packet, connection) {
    const rs = new Packets$7.ResultSetHeader(packet, connection);
    this._fieldCount = rs.fieldCount;
    if (connection.config.debug) {
      // eslint-disable-next-line
      console.log(
        `        Resultset header received, expecting ${rs.fieldCount} column definition packets`
      );
    }
    if (this._fieldCount === 0) {
      return this.doneInsert(rs);
    }
    if (this._fieldCount === null) {
      return this._streamLocalInfile(connection, rs.infileName);
    }
    this._receivedFieldsCount = 0;
    this._rows.push([]);
    this._fields.push([]);
    return this.readField;
  }

  _streamLocalInfile(connection, path) {
    if (this._streamFactory) {
      this._localStream = this._streamFactory(path);
    } else {
      this._localStreamError = new Error(
        `As a result of LOCAL INFILE command server wants to read ${path} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`
      );
      connection.writePacket(EmptyPacket);
      return this.infileOk;
    }

    const onConnectionError = () => {
      this._unpipeStream();
    };
    const onDrain = () => {
      this._localStream.resume();
    };
    const onPause = () => {
      this._localStream.pause();
    };
    const onData = function (data) {
      const dataWithHeader = Buffer.allocUnsafe(data.length + 4);
      data.copy(dataWithHeader, 4);
      connection.writePacket(
        new Packets$7.Packet(0, dataWithHeader, 0, dataWithHeader.length)
      );
    };
    const onEnd = () => {
      connection.removeListener('error', onConnectionError);
      connection.writePacket(EmptyPacket);
    };
    const onError = (err) => {
      this._localStreamError = err;
      connection.removeListener('error', onConnectionError);
      connection.writePacket(EmptyPacket);
    };
    this._unpipeStream = () => {
      connection.stream.removeListener('pause', onPause);
      connection.stream.removeListener('drain', onDrain);
      this._localStream.removeListener('data', onData);
      this._localStream.removeListener('end', onEnd);
      this._localStream.removeListener('error', onError);
    };
    connection.stream.on('pause', onPause);
    connection.stream.on('drain', onDrain);
    this._localStream.on('data', onData);
    this._localStream.on('end', onEnd);
    this._localStream.on('error', onError);
    connection.once('error', onConnectionError);
    return this.infileOk;
  }

  readField(packet, connection) {
    this._receivedFieldsCount++;
    // Often there is much more data in the column definition than in the row itself
    // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)
    // you can 'cache' result of parsing. Field packets still received, but ignored in that case
    // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)
    if (this._fields[this._resultIndex].length !== this._fieldCount) {
      const field = new Packets$7.ColumnDefinition(
        packet,
        connection.clientEncoding
      );
      this._fields[this._resultIndex].push(field);
      if (connection.config.debug) {
        /* eslint-disable no-console */
        console.log('        Column definition:');
        console.log(`          name: ${field.name}`);
        console.log(`          type: ${field.columnType}`);
        console.log(`         flags: ${field.flags}`);
        /* eslint-enable no-console */
      }
    }
    // last field received
    if (this._receivedFieldsCount === this._fieldCount) {
      const fields = this._fields[this._resultIndex];
      this.emit('fields', fields);
      if (this.options.disableEval) {
        this._rowParser = staticParser(fields, this.options, connection.config);
      } else {
        this._rowParser = new (getTextParser(
          fields,
          this.options,
          connection.config
        ))(fields);
      }
      return Query.prototype.fieldsEOF;
    }
    return Query.prototype.readField;
  }

  fieldsEOF(packet, connection) {
    // check EOF
    if (!packet.isEOF()) {
      return connection.protocolError('Expected EOF packet');
    }
    return this.row;
  }

  /* eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }] */
  row(packet, _connection) {
    if (packet.isEOF()) {
      const status = packet.eofStatusFlags();
      const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;
      if (moreResults) {
        this._resultIndex++;
        return Query.prototype.resultsetHeader;
      }
      return this.done();
    }
    let row;
    try {
      row = this._rowParser.next(
        packet,
        this._fields[this._resultIndex],
        this.options
      );
    } catch (err) {
      this._localStreamError = err;
      return this.doneInsert(null);
    }
    if (this.onResult) {
      this._rows[this._resultIndex].push(row);
    } else {
      this.emit('result', row, this._resultIndex);
    }
    return Query.prototype.row;
  }

  infileOk(packet, connection) {
    const rs = new Packets$7.ResultSetHeader(packet, connection);
    return this.doneInsert(rs);
  }

  stream(options) {
    options = options || Object.create(null);
    options.objectMode = true;

    const stream = new Readable$1({
      ...options,
      emitClose: true,
      autoDestroy: true,
      read: () => {
        this._connection && this._connection.resume();
      },
    });

    // Prevent a breaking change for users that rely on `end` event
    stream.once('close', () => {
      if (!stream.readableEnded) {
        stream.emit('end');
      }
    });

    const onResult = (row, index) => {
      if (stream.destroyed) return;

      if (!stream.push(row)) {
        this._connection && this._connection.pause();
      }

      stream.emit('result', row, index); // replicate old emitter
    };

    const onFields = (fields) => {
      if (stream.destroyed) return;

      stream.emit('fields', fields); // replicate old emitter
    };

    const onEnd = () => {
      if (stream.destroyed) return;

      stream.push(null); // pushing null, indicating EOF
    };

    const onError = (err) => {
      stream.destroy(err);
    };

    stream._destroy = (err, cb) => {
      this._connection && this._connection.resume();

      this.removeListener('result', onResult);
      this.removeListener('fields', onFields);
      this.removeListener('end', onEnd);
      this.removeListener('error', onError);

      cb(err); // Pass on any errors
    };

    this.on('result', onResult);
    this.on('fields', onFields);
    this.on('end', onEnd);
    this.on('error', onError);

    return stream;
  }

  _setTimeout() {
    if (this.timeout) {
      const timeoutHandler = this._handleTimeoutError.bind(this);
      this.queryTimeout = Timers$1.setTimeout(timeoutHandler, this.timeout);
    }
  }

  _handleTimeoutError() {
    if (this.queryTimeout) {
      Timers$1.clearTimeout(this.queryTimeout);
      this.queryTimeout = null;
    }

    const err = new Error('Query inactivity timeout');
    err.errorno = 'PROTOCOL_SEQUENCE_TIMEOUT';
    err.code = 'PROTOCOL_SEQUENCE_TIMEOUT';
    err.syscall = 'query';

    if (this.onResult) {
      this.onResult(err);
    } else {
      this.emit('error', err);
    }
  }
};

Query$2.prototype.catch = Query$2.prototype.then;

var query$1 = Query$2;

const Command$7 = command;
const Packets$6 = packetsExports;

let CloseStatement$1 = class CloseStatement extends Command$7 {
  constructor(id) {
    super();
    this.id = id;
  }

  start(packet, connection) {
    connection.writePacket(new Packets$6.CloseStatement(this.id).toPacket(1));
    return null;
  }
};

var close_statement = CloseStatement$1;

const FieldFlags$1 = /*@__PURE__*/ requireField_flags();
const Charsets$2 = /*@__PURE__*/ requireCharsets();
const Types$1 = /*@__PURE__*/ requireTypes();
const helpers$1 = helpers$4;
const genFunc = generateFunction;
const parserCache = parser_cache;
const typeNames$1 = [];
for (const t in Types$1) {
  typeNames$1[Types$1[t]] = t;
}

function readCodeFor(field, config, options, fieldNum) {
  const supportBigNumbers = Boolean(
    options.supportBigNumbers || config.supportBigNumbers
  );
  const bigNumberStrings = Boolean(
    options.bigNumberStrings || config.bigNumberStrings
  );
  const timezone = options.timezone || config.timezone;
  const dateStrings = options.dateStrings || config.dateStrings;
  const unsigned = field.flags & FieldFlags$1.UNSIGNED;
  switch (field.columnType) {
    case Types$1.TINY:
      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';
    case Types$1.SHORT:
      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';
    case Types$1.LONG:
    case Types$1.INT24: // in binary protocol int24 is encoded in 4 bytes int32
      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';
    case Types$1.YEAR:
      return 'packet.readInt16()';
    case Types$1.FLOAT:
      return 'packet.readFloat();';
    case Types$1.DOUBLE:
      return 'packet.readDouble();';
    case Types$1.NULL:
      return 'null;';
    case Types$1.DATE:
    case Types$1.DATETIME:
    case Types$1.TIMESTAMP:
    case Types$1.NEWDATE:
      if (helpers$1.typeMatch(field.columnType, dateStrings, Types$1)) {
        return `packet.readDateTimeString(${parseInt(field.decimals, 10)}, ${null}, ${field.columnType});`;
      }
      return `packet.readDateTime(${helpers$1.srcEscape(timezone)});`;
    case Types$1.TIME:
      return 'packet.readTimeString()';
    case Types$1.DECIMAL:
    case Types$1.NEWDECIMAL:
      if (config.decimalNumbers) {
        return 'packet.parseLengthCodedFloat();';
      }
      return 'packet.readLengthCodedString("ascii");';
    case Types$1.GEOMETRY:
      return 'packet.parseGeometryValue();';
    case Types$1.VECTOR:
      return 'packet.parseVector()';
    case Types$1.JSON:
      // Since for JSON columns mysql always returns charset 63 (BINARY),
      // we have to handle it according to JSON specs and use "utf8",
      // see https://github.com/sidorares/node-mysql2/issues/409
      return config.jsonStrings
        ? 'packet.readLengthCodedString("utf8")'
        : 'JSON.parse(packet.readLengthCodedString("utf8"));';
    case Types$1.LONGLONG:
      if (!supportBigNumbers) {
        return unsigned
          ? 'packet.readInt64JSNumber();'
          : 'packet.readSInt64JSNumber();';
      }
      if (bigNumberStrings) {
        return unsigned
          ? 'packet.readInt64String();'
          : 'packet.readSInt64String();';
      }
      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';

    default:
      if (field.characterSet === Charsets$2.BINARY) {
        return 'packet.readLengthCodedBuffer();';
      }
      return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;
  }
}

function compile(fields, options, config) {
  const parserFn = genFunc();
  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);

  function wrap(field, packet) {
    return {
      type: typeNames$1[field.columnType],
      length: field.columnLength,
      db: field.schema,
      table: field.table,
      name: field.name,
      string: function (encoding = field.encoding) {
        if (field.columnType === Types$1.JSON && encoding === field.encoding) {
          // Since for JSON columns mysql always returns charset 63 (BINARY),
          // we have to handle it according to JSON specs and use "utf8",
          // see https://github.com/sidorares/node-mysql2/issues/1661
          console.warn(
            `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
          );
        }

        if (
          [Types$1.DATETIME, Types$1.NEWDATE, Types$1.TIMESTAMP, Types$1.DATE].includes(
            field.columnType
          )
        ) {
          return packet.readDateTimeString(
            parseInt(field.decimals, 10),
            ' ',
            field.columnType
          );
        }

        if (field.columnType === Types$1.TINY) {
          const unsigned = field.flags & FieldFlags$1.UNSIGNED;

          return String(unsigned ? packet.readInt8() : packet.readSInt8());
        }

        if (field.columnType === Types$1.TIME) {
          return packet.readTimeString();
        }

        return packet.readLengthCodedString(encoding);
      },
      buffer: function () {
        return packet.readLengthCodedBuffer();
      },
      geometry: function () {
        return packet.parseGeometryValue();
      },
    };
  }

  parserFn('(function(){');
  parserFn('return class BinaryRow {');
  parserFn('constructor() {');
  parserFn('}');

  parserFn('next(packet, fields, options) {');
  if (options.rowsAsArray) {
    parserFn(`const result = new Array(${fields.length});`);
  } else {
    parserFn('const result = {};');
  }

  // Global typeCast
  if (
    typeof config.typeCast === 'function' &&
    typeof options.typeCast !== 'function'
  ) {
    options.typeCast = config.typeCast;
  }

  parserFn('packet.readInt8();'); // status byte
  for (let i = 0; i < nullBitmapLength; ++i) {
    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);
  }

  let lvalue = '';
  let currentFieldNullBit = 4;
  let nullByteIndex = 0;
  let fieldName = '';
  let tableName = '';

  for (let i = 0; i < fields.length; i++) {
    fieldName = helpers$1.fieldEscape(fields[i].name);
    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);

    if (typeof options.nestTables === 'string') {
      lvalue = `result[${helpers$1.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;
    } else if (options.nestTables === true) {
      tableName = helpers$1.fieldEscape(fields[i].table);

      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
      lvalue = `result[${tableName}][${fieldName}]`;
    } else if (options.rowsAsArray) {
      lvalue = `result[${i.toString(10)}]`;
    } else {
      lvalue = `result[${fieldName}]`;
    }

    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);
    parserFn(`${lvalue} = null;`);
    parserFn('else {');

    if (options.typeCast === false) {
      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
    } else {
      const fieldWrapperVar = `fieldWrapper${i}`;
      parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);
      const readCode = readCodeFor(fields[i], config, options, i);

      if (typeof options.typeCast === 'function') {
        parserFn(
          `${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`
        );
      } else {
        parserFn(`${lvalue} = ${readCode};`);
      }
    }
    parserFn('}');

    currentFieldNullBit *= 2;
    if (currentFieldNullBit === 0x100) {
      currentFieldNullBit = 1;
      nullByteIndex++;
    }
  }

  parserFn('return result;');
  parserFn('}');
  parserFn('};')('})()');

  if (config.debug) {
    helpers$1.printDebugWithCode(
      'Compiled binary protocol row parser',
      parserFn.toString()
    );
  }
  return parserFn.toFunction({ wrap });
}

function getBinaryParser$2(fields, options, config) {
  return parserCache.getParser('binary', fields, options, config, compile);
}

var binary_parser = getBinaryParser$2;

const FieldFlags = /*@__PURE__*/ requireField_flags();
const Charsets$1 = /*@__PURE__*/ requireCharsets();
const Types = /*@__PURE__*/ requireTypes();
const helpers = helpers$4;

const typeNames = [];
for (const t in Types) {
  typeNames[Types[t]] = t;
}

function getBinaryParser$1(fields, _options, config) {
  function readCode(field, config, options, fieldNum, packet) {
    const supportBigNumbers = Boolean(
      options.supportBigNumbers || config.supportBigNumbers
    );
    const bigNumberStrings = Boolean(
      options.bigNumberStrings || config.bigNumberStrings
    );
    const timezone = options.timezone || config.timezone;
    const dateStrings = options.dateStrings || config.dateStrings;
    const unsigned = field.flags & FieldFlags.UNSIGNED;

    switch (field.columnType) {
      case Types.TINY:
        return unsigned ? packet.readInt8() : packet.readSInt8();
      case Types.SHORT:
        return unsigned ? packet.readInt16() : packet.readSInt16();
      case Types.LONG:
      case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32
        return unsigned ? packet.readInt32() : packet.readSInt32();
      case Types.YEAR:
        return packet.readInt16();
      case Types.FLOAT:
        return packet.readFloat();
      case Types.DOUBLE:
        return packet.readDouble();
      case Types.NULL:
        return null;
      case Types.DATE:
      case Types.DATETIME:
      case Types.TIMESTAMP:
      case Types.NEWDATE:
        return helpers.typeMatch(field.columnType, dateStrings, Types)
          ? packet.readDateTimeString(
              parseInt(field.decimals, 10),
              null,
              field.columnType
            )
          : packet.readDateTime(timezone);
      case Types.TIME:
        return packet.readTimeString();
      case Types.DECIMAL:
      case Types.NEWDECIMAL:
        return config.decimalNumbers
          ? packet.parseLengthCodedFloat()
          : packet.readLengthCodedString('ascii');
      case Types.GEOMETRY:
        return packet.parseGeometryValue();
      case Types.VECTOR:
        return packet.parseVector();
      case Types.JSON:
        // Since for JSON columns mysql always returns charset 63 (BINARY),
        // we have to handle it according to JSON specs and use "utf8",
        // see https://github.com/sidorares/node-mysql2/issues/409
        return config.jsonStrings
          ? packet.readLengthCodedString('utf8')
          : JSON.parse(packet.readLengthCodedString('utf8'));
      case Types.LONGLONG:
        if (!supportBigNumbers)
          return unsigned
            ? packet.readInt64JSNumber()
            : packet.readSInt64JSNumber();
        return bigNumberStrings
          ? unsigned
            ? packet.readInt64String()
            : packet.readSInt64String()
          : unsigned
            ? packet.readInt64()
            : packet.readSInt64();
      default:
        return field.characterSet === Charsets$1.BINARY
          ? packet.readLengthCodedBuffer()
          : packet.readLengthCodedString(fields[fieldNum].encoding);
    }
  }

  return class BinaryRow {
    constructor() {}

    next(packet, fields, options) {
      packet.readInt8(); // status byte

      const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);
      const nullBitmaskBytes = new Array(nullBitmapLength);

      for (let i = 0; i < nullBitmapLength; i++) {
        nullBitmaskBytes[i] = packet.readInt8();
      }

      const result = options.rowsAsArray ? new Array(fields.length) : {};
      let currentFieldNullBit = 4;
      let nullByteIndex = 0;

      for (let i = 0; i < fields.length; i++) {
        const field = fields[i];
        const typeCast =
          options.typeCast !== undefined ? options.typeCast : config.typeCast;

        let value;
        if (nullBitmaskBytes[nullByteIndex] & currentFieldNullBit) {
          value = null;
        } else if (options.typeCast === false) {
          value = packet.readLengthCodedBuffer();
        } else {
          const next = () => readCode(field, config, options, i, packet);
          value =
            typeof typeCast === 'function'
              ? typeCast(
                  {
                    type: typeNames[field.columnType],
                    length: field.columnLength,
                    db: field.schema,
                    table: field.table,
                    name: field.name,
                    string: function (encoding = field.encoding) {
                      if (
                        field.columnType === Types.JSON &&
                        encoding === field.encoding
                      ) {
                        // Since for JSON columns mysql always returns charset 63 (BINARY),
                        // we have to handle it according to JSON specs and use "utf8",
                        // see https://github.com/sidorares/node-mysql2/issues/1661
                        console.warn(
                          `typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``
                        );
                      }

                      if (
                        [
                          Types.DATETIME,
                          Types.NEWDATE,
                          Types.TIMESTAMP,
                          Types.DATE,
                        ].includes(field.columnType)
                      ) {
                        return packet.readDateTimeString(
                          parseInt(field.decimals, 10),
                          ' ',
                          field.columnType
                        );
                      }

                      if (field.columnType === Types.TINY) {
                        const unsigned = field.flags & FieldFlags.UNSIGNED;

                        return String(
                          unsigned ? packet.readInt8() : packet.readSInt8()
                        );
                      }

                      if (field.columnType === Types.TIME) {
                        return packet.readTimeString();
                      }

                      return packet.readLengthCodedString(encoding);
                    },
                    buffer: function () {
                      return packet.readLengthCodedBuffer();
                    },
                    geometry: function () {
                      return packet.parseGeometryValue();
                    },
                  },
                  next
                )
              : next();
        }

        if (options.rowsAsArray) {
          result[i] = value;
        } else if (typeof options.nestTables === 'string') {
          const key = helpers.fieldEscape(
            field.table + options.nestTables + field.name,
            false
          );
          result[key] = value;
        } else if (options.nestTables === true) {
          const tableName = helpers.fieldEscape(field.table, false);
          if (!result[tableName]) {
            result[tableName] = {};
          }
          const fieldName = helpers.fieldEscape(field.name, false);
          result[tableName][fieldName] = value;
        } else {
          const key = helpers.fieldEscape(field.name, false);
          result[key] = value;
        }

        currentFieldNullBit *= 2;
        if (currentFieldNullBit === 0x100) {
          currentFieldNullBit = 1;
          nullByteIndex++;
        }
      }

      return result;
    }
  };
}

var static_binary_parser = getBinaryParser$1;

const Command$6 = command;
const Query$1 = query$1;
const Packets$5 = packetsExports;

const getBinaryParser = binary_parser;
const getStaticBinaryParser = static_binary_parser;

let Execute$2 = class Execute extends Command$6 {
  constructor(options, callback) {
    super();
    this.statement = options.statement;
    this.sql = options.sql;
    this.values = options.values;
    this.onResult = callback;
    this.parameters = options.values;
    this.insertId = 0;
    this.timeout = options.timeout;
    this.queryTimeout = null;
    this._rows = [];
    this._fields = [];
    this._result = [];
    this._fieldCount = 0;
    this._rowParser = null;
    this._executeOptions = options;
    this._resultIndex = 0;
    this._localStream = null;
    this._unpipeStream = function () {};
    this._streamFactory = options.infileStreamFactory;
    this._connection = null;
  }

  buildParserFromFields(fields, connection) {
    if (this.options.disableEval) {
      return getStaticBinaryParser(fields, this.options, connection.config);
    }

    return getBinaryParser(fields, this.options, connection.config);
  }

  start(packet, connection) {
    this._connection = connection;
    this.options = Object.assign({}, connection.config, this._executeOptions);
    this._setTimeout();
    const executePacket = new Packets$5.Execute(
      this.statement.id,
      this.parameters,
      connection.config.charsetNumber,
      connection.config.timezone
    );
    //For reasons why this try-catch is here, please see
    // https://github.com/sidorares/node-mysql2/pull/689
    //For additional discussion, see
    // 1. https://github.com/sidorares/node-mysql2/issues/493
    // 2. https://github.com/sidorares/node-mysql2/issues/187
    // 3. https://github.com/sidorares/node-mysql2/issues/480
    try {
      connection.writePacket(executePacket.toPacket(1));
    } catch (error) {
      this.onResult(error);
    }
    return Execute.prototype.resultsetHeader;
  }

  readField(packet, connection) {
    let fields;
    // disabling for now, but would be great to find reliable way to parse fields only once
    // fields reported by prepare can be empty at all or just incorrect - see #169
    //
    // perfomance optimisation: if we already have this field parsed in statement header, use one from header
    // const field = this.statement.columns.length == this._fieldCount ?
    //  this.statement.columns[this._receivedFieldsCount] : new Packets.ColumnDefinition(packet);
    const field = new Packets$5.ColumnDefinition(
      packet,
      connection.clientEncoding
    );
    this._receivedFieldsCount++;
    this._fields[this._resultIndex].push(field);
    if (this._receivedFieldsCount === this._fieldCount) {
      fields = this._fields[this._resultIndex];
      this.emit('fields', fields, this._resultIndex);
      return Execute.prototype.fieldsEOF;
    }
    return Execute.prototype.readField;
  }

  fieldsEOF(packet, connection) {
    // check EOF
    if (!packet.isEOF()) {
      return connection.protocolError('Expected EOF packet');
    }
    this._rowParser = new (this.buildParserFromFields(
      this._fields[this._resultIndex],
      connection
    ))();
    return Execute.prototype.row;
  }
};

Execute$2.prototype.done = Query$1.prototype.done;
Execute$2.prototype.doneInsert = Query$1.prototype.doneInsert;
Execute$2.prototype.resultsetHeader = Query$1.prototype.resultsetHeader;
Execute$2.prototype._findOrCreateReadStream =
  Query$1.prototype._findOrCreateReadStream;
Execute$2.prototype._streamLocalInfile = Query$1.prototype._streamLocalInfile;
Execute$2.prototype._setTimeout = Query$1.prototype._setTimeout;
Execute$2.prototype._handleTimeoutError = Query$1.prototype._handleTimeoutError;
Execute$2.prototype.row = Query$1.prototype.row;
Execute$2.prototype.stream = Query$1.prototype.stream;

var execute$1 = Execute$2;

const Packets$4 = packetsExports;
const Command$5 = command;
const CloseStatement = close_statement;
const Execute$1 = execute$1;

class PreparedStatementInfo {
  constructor(query, id, columns, parameters, connection) {
    this.query = query;
    this.id = id;
    this.columns = columns;
    this.parameters = parameters;
    this.rowParser = null;
    this._connection = connection;
  }

  close() {
    return this._connection.addCommand(new CloseStatement(this.id));
  }

  execute(parameters, callback) {
    if (typeof parameters === 'function') {
      callback = parameters;
      parameters = [];
    }
    return this._connection.addCommand(
      new Execute$1({ statement: this, values: parameters }, callback)
    );
  }
}

let Prepare$1 = class Prepare extends Command$5 {
  constructor(options, callback) {
    super();
    this.query = options.sql;
    this.onResult = callback;
    this.id = 0;
    this.fieldCount = 0;
    this.parameterCount = 0;
    this.fields = [];
    this.parameterDefinitions = [];
    this.options = options;
  }

  start(packet, connection) {
    const Connection = connection.constructor;
    this.key = Connection.statementKey(this.options);
    const statement = connection._statements.get(this.key);
    if (statement) {
      if (this.onResult) {
        this.onResult(null, statement);
      }
      return null;
    }
    const cmdPacket = new Packets$4.PrepareStatement(
      this.query,
      connection.config.charsetNumber,
      this.options.values
    );
    connection.writePacket(cmdPacket.toPacket(1));
    return Prepare.prototype.prepareHeader;
  }

  prepareHeader(packet, connection) {
    const header = new Packets$4.PreparedStatementHeader(packet);
    this.id = header.id;
    this.fieldCount = header.fieldCount;
    this.parameterCount = header.parameterCount;
    if (this.parameterCount > 0) {
      return Prepare.prototype.readParameter;
    }
    if (this.fieldCount > 0) {
      return Prepare.prototype.readField;
    }
    return this.prepareDone(connection);
  }

  readParameter(packet, connection) {
    // there might be scenarios when mysql server reports more parameters than
    // are actually present in the array of parameter definitions.
    // if EOF packet is received we switch to "read fields" state if there are
    // any fields reported by the server, otherwise we finish the command.
    if (packet.isEOF()) {
      if (this.fieldCount > 0) {
        return Prepare.prototype.readField;
      }
      return this.prepareDone(connection);
    }
    const def = new Packets$4.ColumnDefinition(packet, connection.clientEncoding);
    this.parameterDefinitions.push(def);
    if (this.parameterDefinitions.length === this.parameterCount) {
      return Prepare.prototype.parametersEOF;
    }
    return this.readParameter;
  }

  readField(packet, connection) {
    if (packet.isEOF()) {
      return this.prepareDone(connection);
    }
    const def = new Packets$4.ColumnDefinition(packet, connection.clientEncoding);
    this.fields.push(def);
    if (this.fields.length === this.fieldCount) {
      return Prepare.prototype.fieldsEOF;
    }
    return Prepare.prototype.readField;
  }

  parametersEOF(packet, connection) {
    if (!packet.isEOF()) {
      return connection.protocolError('Expected EOF packet after parameters');
    }
    if (this.fieldCount > 0) {
      return Prepare.prototype.readField;
    }
    return this.prepareDone(connection);
  }

  fieldsEOF(packet, connection) {
    if (!packet.isEOF()) {
      return connection.protocolError('Expected EOF packet after fields');
    }
    return this.prepareDone(connection);
  }

  prepareDone(connection) {
    const statement = new PreparedStatementInfo(
      this.query,
      this.id,
      this.fields,
      this.parameterDefinitions,
      connection
    );
    connection._statements.set(this.key, statement);
    if (this.onResult) {
      this.onResult(null, statement);
    }
    return null;
  }
};

var prepare = Prepare$1;

const Command$4 = command;
const CommandCode$1 = commands$1;
const Packet$1 = packet;

// TODO: time statistics?
// usefull for queue size and network latency monitoring
// store created,sent,reply timestamps
let Ping$1 = class Ping extends Command$4 {
  constructor(callback) {
    super();
    this.onResult = callback;
  }

  start(packet, connection) {
    const ping = new Packet$1(
      0,
      Buffer.from([1, 0, 0, 0, CommandCode$1.PING]),
      0,
      5
    );
    connection.writePacket(ping);
    return Ping.prototype.pingResponse;
  }

  pingResponse() {
    // TODO: check it's OK packet. error check already done in caller
    if (this.onResult) {
      process.nextTick(this.onResult.bind(this));
    }
    return null;
  }
};

var ping = Ping$1;

const Command$3 = command;
const Packets$3 = packetsExports;

let RegisterSlave$1 = class RegisterSlave extends Command$3 {
  constructor(opts, callback) {
    super();
    this.onResult = callback;
    this.opts = opts;
  }

  start(packet, connection) {
    const newPacket = new Packets$3.RegisterSlave(this.opts);
    connection.writePacket(newPacket.toPacket(1));
    return RegisterSlave.prototype.registerResponse;
  }

  registerResponse() {
    if (this.onResult) {
      process.nextTick(this.onResult.bind(this));
    }
    return null;
  }
};

var register_slave = RegisterSlave$1;

var binlog_query_statusvars;
var hasRequiredBinlog_query_statusvars;

function requireBinlog_query_statusvars () {
	if (hasRequiredBinlog_query_statusvars) return binlog_query_statusvars;
	hasRequiredBinlog_query_statusvars = 1;

	// http://dev.mysql.com/doc/internals/en/query-event.html

	const keys = {
	  FLAGS2: 0,
	  SQL_MODE: 1,
	  CATALOG: 2,
	  CHARSET: 4,
	  TIME_ZONE: 5,
	  CATALOG_NZ: 6,
	  LC_TIME_NAMES: 7,
	  CHARSET_DATABASE: 8,
	  TABLE_MAP_FOR_UPDATE: 9,
	  MASTER_DATA_WRITTEN: 10,
	  INVOKERS: 11,
	  UPDATED_DB_NAMES: 12,
	  MICROSECONDS: 3,
	};

	binlog_query_statusvars = function parseStatusVars(buffer) {
	  const result = {};
	  let offset = 0;
	  let key, length, prevOffset;
	  while (offset < buffer.length) {
	    key = buffer[offset++];
	    switch (key) {
	      case keys.FLAGS2:
	        result.flags = buffer.readUInt32LE(offset);
	        offset += 4;
	        break;
	      case keys.SQL_MODE:
	        // value is 8 bytes, but all dcumented flags are in first 4 bytes
	        result.sqlMode = buffer.readUInt32LE(offset);
	        offset += 8;
	        break;
	      case keys.CATALOG:
	        length = buffer[offset++];
	        result.catalog = buffer.toString('utf8', offset, offset + length);
	        offset += length + 1; // null byte after string
	        break;
	      case keys.CHARSET:
	        result.clientCharset = buffer.readUInt16LE(offset);
	        result.connectionCollation = buffer.readUInt16LE(offset + 2);
	        result.serverCharset = buffer.readUInt16LE(offset + 4);
	        offset += 6;
	        break;
	      case keys.TIME_ZONE:
	        length = buffer[offset++];
	        result.timeZone = buffer.toString('utf8', offset, offset + length);
	        offset += length; // no null byte
	        break;
	      case keys.CATALOG_NZ:
	        length = buffer[offset++];
	        result.catalogNz = buffer.toString('utf8', offset, offset + length);
	        offset += length; // no null byte
	        break;
	      case keys.LC_TIME_NAMES:
	        result.lcTimeNames = buffer.readUInt16LE(offset);
	        offset += 2;
	        break;
	      case keys.CHARSET_DATABASE:
	        result.schemaCharset = buffer.readUInt16LE(offset);
	        offset += 2;
	        break;
	      case keys.TABLE_MAP_FOR_UPDATE:
	        result.mapForUpdate1 = buffer.readUInt32LE(offset);
	        result.mapForUpdate2 = buffer.readUInt32LE(offset + 4);
	        offset += 8;
	        break;
	      case keys.MASTER_DATA_WRITTEN:
	        result.masterDataWritten = buffer.readUInt32LE(offset);
	        offset += 4;
	        break;
	      case keys.INVOKERS:
	        length = buffer[offset++];
	        result.invokerUsername = buffer.toString(
	          'utf8',
	          offset,
	          offset + length
	        );
	        offset += length;
	        length = buffer[offset++];
	        result.invokerHostname = buffer.toString(
	          'utf8',
	          offset,
	          offset + length
	        );
	        offset += length;
	        break;
	      case keys.UPDATED_DB_NAMES:
	        length = buffer[offset++];
	        // length - number of null-terminated strings
	        result.updatedDBs = []; // we'll store them as array here
	        for (; length; --length) {
	          prevOffset = offset;
	          // fast forward to null terminating byte
	          while (buffer[offset++] && offset < buffer.length) {
	            // empty body, everything inside while condition
	          }
	          result.updatedDBs.push(
	            buffer.toString('utf8', prevOffset, offset - 1)
	          );
	        }
	        break;
	      case keys.MICROSECONDS:
	        result.microseconds =
	          // REVIEW: INVALID UNKNOWN VARIABLE!
	          buffer.readInt16LE(offset) + (buffer[offset + 2] << 16);
	        offset += 3;
	    }
	  }
	  return result;
	};
	return binlog_query_statusvars;
}

const Command$2 = command;
const Packets$2 = packetsExports;

const eventParsers = [];

class BinlogEventHeader {
  constructor(packet) {
    this.timestamp = packet.readInt32();
    this.eventType = packet.readInt8();
    this.serverId = packet.readInt32();
    this.eventSize = packet.readInt32();
    this.logPos = packet.readInt32();
    this.flags = packet.readInt16();
  }
}

let BinlogDump$1 = class BinlogDump extends Command$2 {
  constructor(opts) {
    super();
    // this.onResult = callback;
    this.opts = opts;
  }

  start(packet, connection) {
    const newPacket = new Packets$2.BinlogDump(this.opts);
    connection.writePacket(newPacket.toPacket(1));
    return BinlogDump.prototype.binlogData;
  }

  binlogData(packet) {
    // ok - continue consuming events
    // error - error
    // eof - end of binlog
    if (packet.isEOF()) {
      this.emit('eof');
      return null;
    }
    // binlog event header
    packet.readInt8();
    const header = new BinlogEventHeader(packet);
    const EventParser = eventParsers[header.eventType];
    let event;
    if (EventParser) {
      event = new EventParser(packet);
    } else {
      event = {
        name: 'UNKNOWN',
      };
    }
    event.header = header;
    this.emit('event', event);
    return BinlogDump.prototype.binlogData;
  }
};

class RotateEvent {
  constructor(packet) {
    this.pposition = packet.readInt32();
    // TODO: read uint64 here
    packet.readInt32(); // positionDword2
    this.nextBinlog = packet.readString();
    this.name = 'RotateEvent';
  }
}

class FormatDescriptionEvent {
  constructor(packet) {
    this.binlogVersion = packet.readInt16();
    this.serverVersion = packet.readString(50).replace(/\u0000.*/, ''); // eslint-disable-line no-control-regex
    this.createTimestamp = packet.readInt32();
    this.eventHeaderLength = packet.readInt8(); // should be 19
    this.eventsLength = packet.readBuffer();
    this.name = 'FormatDescriptionEvent';
  }
}

class QueryEvent {
  constructor(packet) {
    const parseStatusVars = /*@__PURE__*/ requireBinlog_query_statusvars();
    this.slaveProxyId = packet.readInt32();
    this.executionTime = packet.readInt32();
    const schemaLength = packet.readInt8();
    this.errorCode = packet.readInt16();
    const statusVarsLength = packet.readInt16();
    const statusVars = packet.readBuffer(statusVarsLength);
    this.schema = packet.readString(schemaLength);
    packet.readInt8(); // should be zero
    this.statusVars = parseStatusVars(statusVars);
    this.query = packet.readString();
    this.name = 'QueryEvent';
  }
}

class XidEvent {
  constructor(packet) {
    this.binlogVersion = packet.readInt16();
    this.xid = packet.readInt64();
    this.name = 'XidEvent';
  }
}

eventParsers[2] = QueryEvent;
eventParsers[4] = RotateEvent;
eventParsers[15] = FormatDescriptionEvent;
eventParsers[16] = XidEvent;

var binlog_dump = BinlogDump$1;

const Command$1 = command;
const Packets$1 = packetsExports;
const ClientConstants$1 = client;
const ClientHandshake$1 = client_handshake;
const CharsetToEncoding$1 = /*@__PURE__*/ requireCharset_encodings();

let ChangeUser$1 = class ChangeUser extends Command$1 {
  constructor(options, callback) {
    super();
    this.onResult = callback;
    this.user = options.user;
    this.password = options.password;
    // "password1" is an alias of "password"
    this.password1 = options.password;
    this.password2 = options.password2;
    this.password3 = options.password3;
    this.database = options.database;
    this.passwordSha1 = options.passwordSha1;
    this.charsetNumber = options.charsetNumber;
    this.currentConfig = options.currentConfig;
    this.authenticationFactor = 0;
  }
  start(packet, connection) {
    const newPacket = new Packets$1.ChangeUser({
      flags: connection.config.clientFlags,
      user: this.user,
      database: this.database,
      charsetNumber: this.charsetNumber,
      password: this.password,
      passwordSha1: this.passwordSha1,
      authPluginData1: connection._handshakePacket.authPluginData1,
      authPluginData2: connection._handshakePacket.authPluginData2,
    });
    this.currentConfig.user = this.user;
    this.currentConfig.password = this.password;
    this.currentConfig.database = this.database;
    this.currentConfig.charsetNumber = this.charsetNumber;
    connection.clientEncoding = CharsetToEncoding$1[this.charsetNumber];
    // clear prepared statements cache as all statements become invalid after changeUser
    connection._statements.clear();
    connection.writePacket(newPacket.toPacket());
    // check if the server supports multi-factor authentication
    const multiFactorAuthentication =
      connection.serverCapabilityFlags &
      ClientConstants$1.MULTI_FACTOR_AUTHENTICATION;
    if (multiFactorAuthentication) {
      // if the server supports multi-factor authentication, we enable it in
      // the client
      this.authenticationFactor = 1;
    }
    return ChangeUser.prototype.handshakeResult;
  }
};

ChangeUser$1.prototype.handshakeResult =
  ClientHandshake$1.prototype.handshakeResult;
ChangeUser$1.prototype.calculateNativePasswordAuthToken =
  ClientHandshake$1.prototype.calculateNativePasswordAuthToken;

var change_user = ChangeUser$1;

const Command = command;
const CommandCode = commands$1;
const Packet = packet;

let Quit$1 = class Quit extends Command {
  constructor(callback) {
    super();
    this.onResult = callback;
  }

  start(packet, connection) {
    connection._closing = true;
    const quit = new Packet(
      0,
      Buffer.from([1, 0, 0, 0, CommandCode.QUIT]),
      0,
      5
    );
    if (this.onResult) {
      this.onResult();
    }
    connection.writePacket(quit);
    return null;
  }
};

var quit = Quit$1;

const ClientHandshake = client_handshake;
const ServerHandshake = server_handshake;
const Query = query$1;
const Prepare = prepare;
const Execute = execute$1;
const Ping = ping;
const RegisterSlave = register_slave;
const BinlogDump = binlog_dump;
const ChangeUser = change_user;
const Quit = quit;

var commands = {
  ClientHandshake,
  ServerHandshake,
  Query,
  Prepare,
  Execute,
  Ping,
  RegisterSlave,
  BinlogDump,
  ChangeUser,
  Quit,
};

var version$1 = "3.16.0";
const require$$3 = {
	version: version$1};

var ssl_profiles = {};

var lib$1 = {exports: {}};

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.defaults = void 0;
	/**
	 * CA Certificates for **Amazon RDS** (2024)
	 *
	 * - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html
	 * - https://docs.amazonaws.cn/en_us/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html
	 * - https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.tls
	 */
	defaults.defaults = [
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEEjCCAvqgAwIBAgIJAM2ZN/+nPi27MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\n' +
	        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
	        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
	        'em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0Ew\n' +
	        'HhcNMTkxMDI4MTgwNTU4WhcNMjQxMDI2MTgwNTU4WjCBlTELMAkGA1UEBhMCVVMx\n' +
	        'EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\n' +
	        'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n' +
	        'JjAkBgNVBAMMHUFtYXpvbiBSRFMgYWYtc291dGgtMSBSb290IENBMIIBIjANBgkq\n' +
	        'hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwR2351uPMZaJk2gMGT+1sk8HE9MQh2rc\n' +
	        '/sCnbxGn2p1c7Oi9aBbd/GiFijeJb2BXvHU+TOq3d3Jjqepq8tapXVt4ojbTJNyC\n' +
	        'J5E7r7KjTktKdLxtBE1MK25aY+IRJjtdU6vG3KiPKUT1naO3xs3yt0F76WVuFivd\n' +
	        '9OHv2a+KHvPkRUWIxpmAHuMY9SIIMmEZtVE7YZGx5ah0iO4JzItHcbVR0y0PBH55\n' +
	        'arpFBddpIVHCacp1FUPxSEWkOpI7q0AaU4xfX0fe1BV5HZYRKpBOIp1TtZWvJD+X\n' +
	        'jGUtL1BEsT5vN5g9MkqdtYrC+3SNpAk4VtpvJrdjraI/hhvfeXNnAwIDAQABo2Mw\n' +
	        'YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUEEi/\n' +
	        'WWMcBJsoGXg+EZwkQ0MscZQwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0Ms\n' +
	        'cZQwDQYJKoZIhvcNAQELBQADggEBAGDZ5js5Pc/gC58LJrwMPXFhJDBS8QuDm23C\n' +
	        'FFUdlqucskwOS3907ErK1ZkmVJCIqFLArHqskFXMAkRZ2PNR7RjWLqBs+0znG5yH\n' +
	        'hRKb4DXzhUFQ18UBRcvT6V6zN97HTRsEEaNhM/7k8YLe7P8vfNZ28VIoJIGGgv9D\n' +
	        'wQBBvkxQ71oOmAG0AwaGD0ORGUfbYry9Dz4a4IcUsZyRWRMADixgrFv6VuETp26s\n' +
	        '/+z+iqNaGWlELBKh3iQCT6Y/1UnkPLO42bxrCSyOvshdkYN58Q2gMTE1SVTqyo8G\n' +
	        'Lw8lLAz9bnvUSgHzB3jRrSx6ggF/WRMRYlR++y6LXP4SAsSAaC0=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEEjCCAvqgAwIBAgIJAJYM4LxvTZA6MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\n' +
	        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
	        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
	        'em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0Ew\n' +
	        'HhcNMTkxMDMwMjAyMDM2WhcNMjQxMDI4MjAyMDM2WjCBlTELMAkGA1UEBhMCVVMx\n' +
	        'EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\n' +
	        'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n' +
	        'JjAkBgNVBAMMHUFtYXpvbiBSRFMgZXUtc291dGgtMSBSb290IENBMIIBIjANBgkq\n' +
	        'hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqM921jXCXeqpRNCS9CBPOe5N7gMaEt+D\n' +
	        's5uR3riZbqzRlHGiF1jZihkXfHAIQewDwy+Yz+Oec1aEZCQMhUHxZJPusuX0cJfj\n' +
	        'b+UluFqHIijL2TfXJ3D0PVLLoNTQJZ8+GAPECyojAaNuoHbdVqxhOcznMsXIXVFq\n' +
	        'yVLKDGvyKkJjai/iSPDrQMXufg3kWt0ISjNLvsG5IFXgP4gttsM8i0yvRd4QcHoo\n' +
	        'DjvH7V3cS+CQqW5SnDrGnHToB0RLskE1ET+oNOfeN9PWOxQprMOX/zmJhnJQlTqD\n' +
	        'QP7jcf7SddxrKFjuziFiouskJJyNDsMjt1Lf60+oHZhed2ogTeifGwIDAQABo2Mw\n' +
	        'YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUFBAF\n' +
	        'cgJe/BBuZiGeZ8STfpkgRYQwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkg\n' +
	        'RYQwDQYJKoZIhvcNAQELBQADggEBAKAYUtlvDuX2UpZW9i1QgsjFuy/ErbW0dLHU\n' +
	        'e/IcFtju2z6RLZ+uF+5A8Kme7IKG1hgt8s+w9TRVQS/7ukQzoK3TaN6XKXRosjtc\n' +
	        'o9Rm4gYWM8bmglzY1TPNaiI4HC7546hSwJhubjN0bXCuj/0sHD6w2DkiGuwKNAef\n' +
	        'yTu5vZhPkeNyXLykxkzz7bNp2/PtMBnzIp+WpS7uUDmWyScGPohKMq5PqvL59z+L\n' +
	        'ZI3CYeMZrJ5VpXUg3fNNIz/83N3G0sk7wr0ohs/kHTP7xPOYB0zD7Ku4HA0Q9Swf\n' +
	        'WX0qr6UQgTPMjfYDLffI7aEId0gxKw1eGYc6Cq5JAZ3ipi/cBFc=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEEjCCAvqgAwIBAgIJANew34ehz5l8MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\n' +
	        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
	        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
	        'em9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0Ew\n' +
	        'HhcNMTkwNTEwMjE0ODI3WhcNMjQwNTA4MjE0ODI3WjCBlTELMAkGA1UEBhMCVVMx\n' +
	        'EDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\n' +
	        'GUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\n' +
	        'JjAkBgNVBAMMHUFtYXpvbiBSRFMgbWUtc291dGgtMSBSb290IENBMIIBIjANBgkq\n' +
	        'hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp7BYV88MukcY+rq0r79+C8UzkT30fEfT\n' +
	        'aPXbx1d6M7uheGN4FMaoYmL+JE1NZPaMRIPTHhFtLSdPccInvenRDIatcXX+jgOk\n' +
	        'UA6lnHQ98pwN0pfDUyz/Vph4jBR9LcVkBbe0zdoKKp+HGbMPRU0N2yNrog9gM5O8\n' +
	        'gkU/3O2csJ/OFQNnj4c2NQloGMUpEmedwJMOyQQfcUyt9CvZDfIPNnheUS29jGSw\n' +
	        'ERpJe/AENu8Pxyc72jaXQuD+FEi2Ck6lBkSlWYQFhTottAeGvVFNCzKszCntrtqd\n' +
	        'rdYUwurYsLTXDHv9nW2hfDUQa0mhXf9gNDOBIVAZugR9NqNRNyYLHQIDAQABo2Mw\n' +
	        'YTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU54cf\n' +
	        'DjgwBx4ycBH8+/r8WXdaiqYwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXda\n' +
	        'iqYwDQYJKoZIhvcNAQELBQADggEBAIIMTSPx/dR7jlcxggr+O6OyY49Rlap2laKA\n' +
	        'eC/XI4ySP3vQkIFlP822U9Kh8a9s46eR0uiwV4AGLabcu0iKYfXjPkIprVCqeXV7\n' +
	        'ny9oDtrbflyj7NcGdZLvuzSwgl9SYTJp7PVCZtZutsPYlbJrBPHwFABvAkMvRtDB\n' +
	        'hitIg4AESDGPoCl94sYHpfDfjpUDMSrAMDUyO6DyBdZH5ryRMAs3lGtsmkkNUrso\n' +
	        'aTW6R05681Z0mvkRdb+cdXtKOSuDZPoe2wJJIaz3IlNQNSrB5TImMYgmt6iAsFhv\n' +
	        '3vfTSTKrZDNTJn4ybG6pq1zWExoXsktZPylJly6R3RBwV6nwqBM=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBjCCAu6gAwIBAgIJAMc0ZzaSUK51MA0GCSqGSIb3DQEBCwUAMIGPMQswCQYD\n' +
	        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
	        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
	        'em9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkw\n' +
	        'ODIyMTcwODUwWhcNMjQwODIyMTcwODUwWjCBjzELMAkGA1UEBhMCVVMxEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoMGUFtYXpv\n' +
	        'biBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxIDAeBgNV\n' +
	        'BAMMF0FtYXpvbiBSRFMgUm9vdCAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n' +
	        'AQ8AMIIBCgKCAQEArXnF/E6/Qh+ku3hQTSKPMhQQlCpoWvnIthzX6MK3p5a0eXKZ\n' +
	        'oWIjYcNNG6UwJjp4fUXl6glp53Jobn+tWNX88dNH2n8DVbppSwScVE2LpuL+94vY\n' +
	        '0EYE/XxN7svKea8YvlrqkUBKyxLxTjh+U/KrGOaHxz9v0l6ZNlDbuaZw3qIWdD/I\n' +
	        '6aNbGeRUVtpM6P+bWIoxVl/caQylQS6CEYUk+CpVyJSkopwJlzXT07tMoDL5WgX9\n' +
	        'O08KVgDNz9qP/IGtAcRduRcNioH3E9v981QO1zt/Gpb2f8NqAjUUCUZzOnij6mx9\n' +
	        'McZ+9cWX88CRzR0vQODWuZscgI08NvM69Fn2SQIDAQABo2MwYTAOBgNVHQ8BAf8E\n' +
	        'BAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUc19g2LzLA5j0Kxc0LjZa\n' +
	        'pmD/vB8wHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJKoZIhvcN\n' +
	        'AQELBQADggEBAHAG7WTmyjzPRIM85rVj+fWHsLIvqpw6DObIjMWokpliCeMINZFV\n' +
	        'ynfgBKsf1ExwbvJNzYFXW6dihnguDG9VMPpi2up/ctQTN8tm9nDKOy08uNZoofMc\n' +
	        'NUZxKCEkVKZv+IL4oHoeayt8egtv3ujJM6V14AstMQ6SwvwvA93EP/Ug2e4WAXHu\n' +
	        'cbI1NAbUgVDqp+DRdfvZkgYKryjTWd/0+1fS8X1bBZVWzl7eirNVnHbSH2ZDpNuY\n' +
	        '0SBd8dj5F6ld3t58ydZbrTHze7JJOd8ijySAp4/kiu9UfZWuTPABzDa/DSdz9Dk/\n' +
	        'zPW4CXXvhLmE02TA9/HeCw3KEHIwicNuEfw=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEEDCCAvigAwIBAgIJAKFMXyltvuRdMA0GCSqGSIb3DQEBCwUAMIGUMQswCQYD\n' +
	        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
	        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
	        'em9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTAe\n' +
	        'Fw0xOTA4MTkxNzM4MjZaFw0yNDA4MTkxNzM4MjZaMIGUMQswCQYDVQQGEwJVUzEQ\n' +
	        'MA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UECgwZ\n' +
	        'QW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEl\n' +
	        'MCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTCCASIwDQYJKoZI\n' +
	        'hvcNAQEBBQADggEPADCCAQoCggEBAMkZdnIH9ndatGAcFo+DppGJ1HUt4x+zeO+0\n' +
	        'ZZ29m0sfGetVulmTlv2d5b66e+QXZFWpcPQMouSxxYTW08TbrQiZngKr40JNXftA\n' +
	        'atvzBqIImD4II0ZX5UEVj2h98qe/ypW5xaDN7fEa5e8FkYB1TEemPaWIbNXqchcL\n' +
	        'tV7IJPr3Cd7Z5gZJlmujIVDPpMuSiNaal9/6nT9oqN+JSM1fx5SzrU5ssg1Vp1vv\n' +
	        '5Xab64uOg7wCJRB9R2GC9XD04odX6VcxUAGrZo6LR64ZSifupo3l+R5sVOc5i8NH\n' +
	        'skdboTzU9H7+oSdqoAyhIU717PcqeDum23DYlPE2nGBWckE+eT8CAwEAAaNjMGEw\n' +
	        'DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFK2hDBWl\n' +
	        'sbHzt/EHd0QYOooqcFPhMB8GA1UdIwQYMBaAFK2hDBWlsbHzt/EHd0QYOooqcFPh\n' +
	        'MA0GCSqGSIb3DQEBCwUAA4IBAQAO/718k8EnOqJDx6wweUscGTGL/QdKXUzTVRAx\n' +
	        'JUsjNUv49mH2HQVEW7oxszfH6cPCaupNAddMhQc4C/af6GHX8HnqfPDk27/yBQI+\n' +
	        'yBBvIanGgxv9c9wBbmcIaCEWJcsLp3HzXSYHmjiqkViXwCpYfkoV3Ns2m8bp+KCO\n' +
	        'y9XmcCKRaXkt237qmoxoh2sGmBHk2UlQtOsMC0aUQ4d7teAJG0q6pbyZEiPyKZY1\n' +
	        'XR/UVxMJL0Q4iVpcRS1kaNCMfqS2smbLJeNdsan8pkw1dvPhcaVTb7CvjhJtjztF\n' +
	        'YfDzAI5794qMlWxwilKMmUvDlPPOTen8NNHkLwWvyFCH7Doh\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEFjCCAv6gAwIBAgIJAMzYZJ+R9NBVMA0GCSqGSIb3DQEBCwUAMIGXMQswCQYD\n' +
	        'VQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\n' +
	        'MCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\n' +
	        'em9uIFJEUzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBD\n' +
	        'QTAeFw0xOTA4MjEyMjI5NDlaFw0yNDA4MjEyMjI5NDlaMIGXMQswCQYDVQQGEwJV\n' +
	        'UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\n' +
	        'CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\n' +
	        'UzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBDQTCCASIw\n' +
	        'DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM7kkS6vjgKKQTPynC2NjdN5aPPV\n' +
	        'O71G0JJS/2ARVBVJd93JLiGovVJilfWYfwZCs4gTRSSjrUD4D4HyqCd6A+eEEtJq\n' +
	        'M0DEC7i0dC+9WNTsPszuB206Jy2IUmxZMIKJAA1NHSbIMjB+b6/JhbSUi7nKdbR/\n' +
	        'brj83bF+RoSA+ogrgX7mQbxhmFcoZN9OGaJgYKsKWUt5Wqv627KkGodUK8mDepgD\n' +
	        'S3ZfoRQRx3iceETpcmHJvaIge6+vyDX3d9Z22jmvQ4AKv3py2CmU2UwuhOltFDwB\n' +
	        '0ddtb39vgwrJxaGfiMRHpEP1DfNLWHAnA69/pgZPwIggidS+iBPUhgucMp8CAwEA\n' +
	        'AaNjMGEwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\n' +
	        'FGnTGpQuQ2H/DZlXMQijZEhjs7TdMB8GA1UdIwQYMBaAFGnTGpQuQ2H/DZlXMQij\n' +
	        'ZEhjs7TdMA0GCSqGSIb3DQEBCwUAA4IBAQC3xz1vQvcXAfpcZlngiRWeqU8zQAMQ\n' +
	        'LZPCFNv7PVk4pmqX+ZiIRo4f9Zy7TrOVcboCnqmP/b/mNq0gVF4O+88jwXJZD+f8\n' +
	        '/RnABMZcnGU+vK0YmxsAtYU6TIb1uhRFmbF8K80HHbj9vSjBGIQdPCbvmR2zY6VJ\n' +
	        'BYM+w9U9hp6H4DVMLKXPc1bFlKA5OBTgUtgkDibWJKFOEPW3UOYwp9uq6pFoN0AO\n' +
	        'xMTldqWFsOF3bJIlvOY0c/1EFZXu3Ns6/oCP//Ap9vumldYMUZWmbK+gK33FPOXV\n' +
	        '8BQ6jNC29icv7lLDpRPwjibJBXX+peDR5UK4FdYcswWEB1Tix5X8dYu6\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSYwJAYDVQQDDB1BbWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw\n' +
	        'MjgxODA2NTNaFw0yNDEwMjgxODA2NTNaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\n' +
	        'CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\n' +
	        'IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\n' +
	        'AwwYQW1hem9uIFJEUyBhZi1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n' +
	        'AQ8AMIIBCgKCAQEAvtV1OqmFa8zCVQSKOvPUJERLVFtd4rZmDpImc5rIoeBk7w/P\n' +
	        '9lcKUJjO8R/w1a2lJXx3oQ81tiY0Piw6TpT62YWVRMWrOw8+Vxq1dNaDSFp9I8d0\n' +
	        'UHillSSbOk6FOrPDp+R6AwbGFqUDebbN5LFFoDKbhNmH1BVS0a6YNKpGigLRqhka\n' +
	        'cClPslWtPqtjbaP3Jbxl26zWzLo7OtZl98dR225pq8aApNBwmtgA7Gh60HK/cX0t\n' +
	        '32W94n8D+GKSg6R4MKredVFqRTi9hCCNUu0sxYPoELuM+mHiqB5NPjtm92EzCWs+\n' +
	        '+vgWhMc6GxG+82QSWx1Vj8sgLqtE/vLrWddf5QIDAQABo2YwZDAOBgNVHQ8BAf8E\n' +
	        'BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUuLB4gYVJrSKJj/Gz\n' +
	        'pqc6yeA+RcAwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0MscZQwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBABauYOZxUhe9/RhzGJ8MsWCz8eKcyDVd4FCnY6Qh+9wcmYNT\n' +
	        'LtnD88LACtJKb/b81qYzcB0Em6+zVJ3Z9jznfr6buItE6es9wAoja22Xgv44BTHL\n' +
	        'rimbgMwpTt3uEMXDffaS0Ww6YWb3pSE0XYI2ISMWz+xRERRf+QqktSaL39zuiaW5\n' +
	        'tfZMre+YhohRa/F0ZQl3RCd6yFcLx4UoSPqQsUl97WhYzwAxZZfwvLJXOc4ATt3u\n' +
	        'VlCUylNDkaZztDJc/yN5XQoK9W5nOt2cLu513MGYKbuarQr8f+gYU8S+qOyuSRSP\n' +
	        'NRITzwCRVnsJE+2JmcRInn/NcanB7uOGqTvJ9+c=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSYwJAYDVQQDDB1BbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw\n' +
	        'MzAyMDIxMzBaFw0yNDEwMzAyMDIxMzBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\n' +
	        'CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\n' +
	        'IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\n' +
	        'AwwYQW1hem9uIFJEUyBldS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n' +
	        'AQ8AMIIBCgKCAQEAtEyjYcajx6xImJn8Vz1zjdmL4ANPgQXwF7+tF7xccmNAZETb\n' +
	        'bzb3I9i5fZlmrRaVznX+9biXVaGxYzIUIR3huQ3Q283KsDYnVuGa3mk690vhvJbB\n' +
	        'QIPgKa5mVwJppnuJm78KqaSpi0vxyCPe3h8h6LLFawVyWrYNZ4okli1/U582eef8\n' +
	        'RzJp/Ear3KgHOLIiCdPDF0rjOdCG1MOlDLixVnPn9IYOciqO+VivXBg+jtfc5J+L\n' +
	        'AaPm0/Yx4uELt1tkbWkm4BvTU/gBOODnYziITZM0l6Fgwvbwgq5duAtKW+h031lC\n' +
	        '37rEvrclqcp4wrsUYcLAWX79ZyKIlRxcAdvEhQIDAQABo2YwZDAOBgNVHQ8BAf8E\n' +
	        'BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU7zPyc0azQxnBCe7D\n' +
	        'b9KAadH1QSEwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkgRYQwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBAFGaNiYxg7yC/xauXPlaqLCtwbm2dKyK9nIFbF/7be8mk7Q3\n' +
	        'MOA0of1vGHPLVQLr6bJJpD9MAbUcm4cPAwWaxwcNpxOjYOFDaq10PCK4eRAxZWwF\n' +
	        'NJRIRmGsl8NEsMNTMCy8X+Kyw5EzH4vWFl5Uf2bGKOeFg0zt43jWQVOX6C+aL3Cd\n' +
	        'pRS5MhmYpxMG8irrNOxf4NVFE2zpJOCm3bn0STLhkDcV/ww4zMzObTJhiIb5wSWn\n' +
	        'EXKKWhUXuRt7A2y1KJtXpTbSRHQxE++69Go1tWhXtRiULCJtf7wF2Ksm0RR/AdXT\n' +
	        '1uR1vKyH5KBJPX3ppYkQDukoHTFR0CpB+G84NLo=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSYwJAYDVQQDDB1BbWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTA1\n' +
	        'MTAyMTU4NDNaFw0yNTA2MDExMjAwMDBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\n' +
	        'CAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\n' +
	        'IFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\n' +
	        'AwwYQW1hem9uIFJEUyBtZS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\n' +
	        'AQ8AMIIBCgKCAQEAudOYPZH+ihJAo6hNYMB5izPVBe3TYhnZm8+X3IoaaYiKtsp1\n' +
	        'JJhkTT0CEejYIQ58Fh4QrMUyWvU8qsdK3diNyQRoYLbctsBPgxBR1u07eUJDv38/\n' +
	        'C1JlqgHmMnMi4y68Iy7ymv50QgAMuaBqgEBRI1R6Lfbyrb2YvH5txjJyTVMwuCfd\n' +
	        'YPAtZVouRz0JxmnfsHyxjE+So56uOKTDuw++Ho4HhZ7Qveej7XB8b+PIPuroknd3\n' +
	        'FQB5RVbXRvt5ZcVD4F2fbEdBniF7FAF4dEiofVCQGQ2nynT7dZdEIPfPdH3n7ZmE\n' +
	        'lAOmwHQ6G83OsiHRBLnbp+QZRgOsjkHJxT20bQIDAQABo2YwZDAOBgNVHQ8BAf8E\n' +
	        'BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUOEVDM7VomRH4HVdA\n' +
	        'QvIMNq2tXOcwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXdaiqYwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBAHhvMssj+Th8IpNePU6RH0BiL6o9c437R3Q4IEJeFdYL+nZz\n' +
	        'PW/rELDPvLRUNMfKM+KzduLZ+l29HahxefejYPXtvXBlq/E/9czFDD4fWXg+zVou\n' +
	        'uDXhyrV4kNmP4S0eqsAP/jQHPOZAMFA4yVwO9hlqmePhyDnszCh9c1PfJSBh49+b\n' +
	        '4w7i/L3VBOMt8j3EKYvqz0gVfpeqhJwL4Hey8UbVfJRFJMJzfNHpePqtDRAY7yjV\n' +
	        'PYquRaV2ab/E+/7VFkWMM4tazYz/qsYA2jSH+4xDHvYk8LnsbcrF9iuidQmEc5sb\n' +
	        'FgcWaSKG4DJjcI5k7AJLWcXyTDt21Ci43LE+I9Q=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECDCCAvCgAwIBAgICVIYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDQxNzEz\n' +
	        'MDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\n' +
	        'em9uIFJEUyBhcC1zb3V0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n' +
	        'DwAwggEKAoIBAQDUYOz1hGL42yUCrcsMSOoU8AeD/3KgZ4q7gP+vAz1WnY9K/kim\n' +
	        'eWN/2Qqzlo3+mxSFQFyD4MyV3+CnCPnBl9Sh1G/F6kThNiJ7dEWSWBQGAB6HMDbC\n' +
	        'BaAsmUc1UIz8sLTL3fO+S9wYhA63Wun0Fbm/Rn2yk/4WnJAaMZcEtYf6e0KNa0LM\n' +
	        'p/kN/70/8cD3iz3dDR8zOZFpHoCtf0ek80QqTich0A9n3JLxR6g6tpwoYviVg89e\n' +
	        'qCjQ4axxOkWWeusLeTJCcY6CkVyFvDAKvcUl1ytM5AiaUkXblE7zDFXRM4qMMRdt\n' +
	        'lPm8d3pFxh0fRYk8bIKnpmtOpz3RIctDrZZxAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n' +
	        'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT99wKJftD3jb4sHoHG\n' +
	        'i3uGlH6W6TAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n' +
	        '9w0BAQsFAAOCAQEAZ17hhr3dII3hUfuHQ1hPWGrpJOX/G9dLzkprEIcCidkmRYl+\n' +
	        'hu1Pe3caRMh/17+qsoEErmnVq5jNY9X1GZL04IZH8YbHc7iRHw3HcWAdhN8633+K\n' +
	        'jYEB2LbJ3vluCGnCejq9djDb6alOugdLMJzxOkHDhMZ6/gYbECOot+ph1tQuZXzD\n' +
	        'tZ7prRsrcuPBChHlPjmGy8M9z8u+kF196iNSUGC4lM8vLkHM7ycc1/ZOwRq9aaTe\n' +
	        'iOghbQQyAEe03MWCyDGtSmDfr0qEk+CHN+6hPiaL8qKt4s+V9P7DeK4iW08ny8Ox\n' +
	        'AVS7u0OK/5+jKMAMrKwpYrBydOjTUTHScocyNw==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBzCCAu+gAwIBAgICQ2QwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDUxODQ2\n' +
	        'MjlaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
	        'em9uIFJEUyBzYS1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
	        'ADCCAQoCggEBAMMvR+ReRnOzqJzoaPipNTt1Z2VA968jlN1+SYKUrYM3No+Vpz0H\n' +
	        'M6Tn0oYB66ByVsXiGc28ulsqX1HbHsxqDPwvQTKvO7SrmDokoAkjJgLocOLUAeld\n' +
	        '5AwvUjxGRP6yY90NV7X786MpnYb2Il9DIIaV9HjCmPt+rjy2CZjS0UjPjCKNfB8J\n' +
	        'bFjgW6GGscjeyGb/zFwcom5p4j0rLydbNaOr9wOyQrtt3ZQWLYGY9Zees/b8pmcc\n' +
	        'Jt+7jstZ2UMV32OO/kIsJ4rMUn2r/uxccPwAc1IDeRSSxOrnFKhW3Cu69iB3bHp7\n' +
	        'JbawY12g7zshE4I14sHjv3QoXASoXjx4xgMCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
	        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFI1Fc/Ql2jx+oJPgBVYq\n' +
	        'ccgP0pQ8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
	        'DQEBCwUAA4IBAQB4VVVabVp70myuYuZ3vltQIWqSUMhkaTzehMgGcHjMf9iLoZ/I\n' +
	        '93KiFUSGnek5cRePyS9wcpp0fcBT3FvkjpUdCjVtdttJgZFhBxgTd8y26ImdDDMR\n' +
	        '4+BUuhI5msvjL08f+Vkkpu1GQcGmyFVPFOy/UY8iefu+QyUuiBUnUuEDd49Hw0Fn\n' +
	        '/kIPII6Vj82a2mWV/Q8e+rgN8dIRksRjKI03DEoP8lhPlsOkhdwU6Uz9Vu6NOB2Q\n' +
	        'Ls1kbcxAc7cFSyRVJEhh12Sz9d0q/CQSTFsVJKOjSNQBQfVnLz1GwO/IieUEAr4C\n' +
	        'jkTntH0r1LX5b/GwN4R887LvjAEdTbg1his7\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECDCCAvCgAwIBAgIDAIkHMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\n' +
	        'UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\n' +
	        'CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\n' +
	        'UzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTA2MTc0\n' +
	        'MDIxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\n' +
	        'c2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\n' +
	        'U2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\n' +
	        'YXpvbiBSRFMgdXMtd2VzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n' +
	        'DwAwggEKAoIBAQDD2yzbbAl77OofTghDMEf624OvU0eS9O+lsdO0QlbfUfWa1Kd6\n' +
	        '0WkgjkLZGfSRxEHMCnrv4UPBSK/Qwn6FTjkDLgemhqBtAnplN4VsoDL+BkRX4Wwq\n' +
	        '/dSQJE2b+0hm9w9UMVGFDEq1TMotGGTD2B71eh9HEKzKhGzqiNeGsiX4VV+LJzdH\n' +
	        'uM23eGisNqmd4iJV0zcAZ+Gbh2zK6fqTOCvXtm7Idccv8vZZnyk1FiWl3NR4WAgK\n' +
	        'AkvWTIoFU3Mt7dIXKKClVmvssG8WHCkd3Xcb4FHy/G756UZcq67gMMTX/9fOFM/v\n' +
	        'l5C0+CHl33Yig1vIDZd+fXV1KZD84dEJfEvHAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n' +
	        'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBR+ap20kO/6A7pPxo3+\n' +
	        'T3CfqZpQWjAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n' +
	        '9w0BAQsFAAOCAQEAHCJky2tPjPttlDM/RIqExupBkNrnSYnOK4kr9xJ3sl8UF2DA\n' +
	        'PAnYsjXp3rfcjN/k/FVOhxwzi3cXJF/2Tjj39Bm/OEfYTOJDNYtBwB0VVH4ffa/6\n' +
	        'tZl87jaIkrxJcreeeHqYMnIxeN0b/kliyA+a5L2Yb0VPjt9INq34QDc1v74FNZ17\n' +
	        '4z8nr1nzg4xsOWu0Dbjo966lm4nOYIGBRGOKEkHZRZ4mEiMgr3YLkv8gSmeitx57\n' +
	        'Z6dVemNtUic/LVo5Iqw4n3TBS0iF2C1Q1xT/s3h+0SXZlfOWttzSluDvoMv5PvCd\n' +
	        'pFjNn+aXLAALoihL1MJSsxydtsLjOBro5eK0Vw==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEDDCCAvSgAwIBAgICOFAwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAxNzQ2\n' +
	        'MjFaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
	        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
	        'AAOCAQ8AMIIBCgKCAQEAzU72e6XbaJbi4HjJoRNjKxzUEuChKQIt7k3CWzNnmjc5\n' +
	        '8I1MjCpa2W1iw1BYVysXSNSsLOtUsfvBZxi/1uyMn5ZCaf9aeoA9UsSkFSZBjOCN\n' +
	        'DpKPCmfV1zcEOvJz26+1m8WDg+8Oa60QV0ou2AU1tYcw98fOQjcAES0JXXB80P2s\n' +
	        '3UfkNcnDz+l4k7j4SllhFPhH6BQ4lD2NiFAP4HwoG6FeJUn45EPjzrydxjq6v5Fc\n' +
	        'cQ8rGuHADVXotDbEhaYhNjIrsPL+puhjWfhJjheEw8c4whRZNp6gJ/b6WEes/ZhZ\n' +
	        'h32DwsDsZw0BfRDUMgUn8TdecNexHUw8vQWeC181hwIDAQABo2YwZDAOBgNVHQ8B\n' +
	        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwW9bWgkWkr0U\n' +
	        'lrOsq2kvIdrECDgwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
	        'KoZIhvcNAQELBQADggEBAEugF0Gj7HVhX0ehPZoGRYRt3PBuI2YjfrrJRTZ9X5wc\n' +
	        '9T8oHmw07mHmNy1qqWvooNJg09bDGfB0k5goC2emDiIiGfc/kvMLI7u+eQOoMKj6\n' +
	        'mkfCncyRN3ty08Po45vTLBFZGUvtQmjM6yKewc4sXiASSBmQUpsMbiHRCL72M5qV\n' +
	        'obcJOjGcIdDTmV1BHdWT+XcjynsGjUqOvQWWhhLPrn4jWe6Xuxll75qlrpn3IrIx\n' +
	        'CRBv/5r7qbcQJPOgwQsyK4kv9Ly8g7YT1/vYBlR3cRsYQjccw5ceWUj2DrMVWhJ4\n' +
	        'prf+E3Aa4vYmLLOUUvKnDQ1k3RGNu56V0tonsQbfsaM=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECjCCAvKgAwIBAgICEzUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAyMDUy\n' +
	        'MjVaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\n' +
	        'em9uIFJEUyBjYS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\n' +
	        'ggEPADCCAQoCggEBAOxHqdcPSA2uBjsCP4DLSlqSoPuQ/X1kkJLusVRKiQE2zayB\n' +
	        'viuCBt4VB9Qsh2rW3iYGM+usDjltGnI1iUWA5KHcvHszSMkWAOYWLiMNKTlg6LCp\n' +
	        'XnE89tvj5dIH6U8WlDvXLdjB/h30gW9JEX7S8supsBSci2GxEzb5mRdKaDuuF/0O\n' +
	        'qvz4YE04pua3iZ9QwmMFuTAOYzD1M72aOpj+7Ac+YLMM61qOtU+AU6MndnQkKoQi\n' +
	        'qmUN2A9IFaqHFzRlSdXwKCKUA4otzmz+/N3vFwjb5F4DSsbsrMfjeHMo6o/nb6Nh\n' +
	        'YDb0VJxxPee6TxSuN7CQJ2FxMlFUezcoXqwqXD0CAwEAAaNmMGQwDgYDVR0PAQH/\n' +
	        'BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFDGGpon9WfIpsggE\n' +
	        'CxHq8hZ7E2ESMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\n' +
	        'SIb3DQEBCwUAA4IBAQAvpeQYEGZvoTVLgV9rd2+StPYykMsmFjWQcyn3dBTZRXC2\n' +
	        'lKq7QhQczMAOhEaaN29ZprjQzsA2X/UauKzLR2Uyqc2qOeO9/YOl0H3qauo8C/W9\n' +
	        'r8xqPbOCDLEXlOQ19fidXyyEPHEq5WFp8j+fTh+s8WOx2M7IuC0ANEetIZURYhSp\n' +
	        'xl9XOPRCJxOhj7JdelhpweX0BJDNHeUFi0ClnFOws8oKQ7sQEv66d5ddxqqZ3NVv\n' +
	        'RbCvCtEutQMOUMIuaygDlMn1anSM8N7Wndx8G6+Uy67AnhjGx7jw/0YPPxopEj6x\n' +
	        'JXP8j0sJbcT9K/9/fPVLNT25RvQ/93T2+IQL4Ca2\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBzCCAu+gAwIBAgICYpgwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExNzMx\n' +
	        'NDhaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
	        'em9uIFJEUyBldS13ZXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
	        'ADCCAQoCggEBAMk3YdSZ64iAYp6MyyKtYJtNzv7zFSnnNf6vv0FB4VnfITTMmOyZ\n' +
	        'LXqKAT2ahZ00hXi34ewqJElgU6eUZT/QlzdIu359TEZyLVPwURflL6SWgdG01Q5X\n' +
	        'O++7fSGcBRyIeuQWs9FJNIIqK8daF6qw0Rl5TXfu7P9dBc3zkgDXZm2DHmxGDD69\n' +
	        '7liQUiXzoE1q2Z9cA8+jirDioJxN9av8hQt12pskLQumhlArsMIhjhHRgF03HOh5\n' +
	        'tvi+RCfihVOxELyIRTRpTNiIwAqfZxxTWFTgfn+gijTmd0/1DseAe82aYic8JbuS\n' +
	        'EMbrDduAWsqrnJ4GPzxHKLXX0JasCUcWyMECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
	        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPLtsq1NrwJXO13C9eHt\n' +
	        'sLY11AGwMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
	        'DQEBCwUAA4IBAQAnWBKj5xV1A1mYd0kIgDdkjCwQkiKF5bjIbGkT3YEFFbXoJlSP\n' +
	        '0lZZ/hDaOHI8wbLT44SzOvPEEmWF9EE7SJzkvSdQrUAWR9FwDLaU427ALI3ngNHy\n' +
	        'lGJ2hse1fvSRNbmg8Sc9GBv8oqNIBPVuw+AJzHTacZ1OkyLZrz1c1QvwvwN2a+Jd\n' +
	        'vH0V0YIhv66llKcYDMUQJAQi4+8nbRxXWv6Gq3pvrFoorzsnkr42V3JpbhnYiK+9\n' +
	        'nRKd4uWl62KRZjGkfMbmsqZpj2fdSWMY1UGyN1k+kDmCSWYdrTRDP0xjtIocwg+A\n' +
	        'J116n4hV/5mbA0BaPiS2krtv17YAeHABZcvz\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECjCCAvKgAwIBAgICV2YwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExOTM2\n' +
	        'MjBaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\n' +
	        'em9uIFJEUyBldS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\n' +
	        'ggEPADCCAQoCggEBAMEx54X2pHVv86APA0RWqxxRNmdkhAyp2R1cFWumKQRofoFv\n' +
	        'n+SPXdkpIINpMuEIGJANozdiEz7SPsrAf8WHyD93j/ZxrdQftRcIGH41xasetKGl\n' +
	        'I67uans8d+pgJgBKGb/Z+B5m+UsIuEVekpvgpwKtmmaLFC/NCGuSsJoFsRqoa6Gh\n' +
	        'm34W6yJoY87UatddCqLY4IIXaBFsgK9Q/wYzYLbnWM6ZZvhJ52VMtdhcdzeTHNW0\n' +
	        '5LGuXJOF7Ahb4JkEhoo6TS2c0NxB4l4MBfBPgti+O7WjR3FfZHpt18A6Zkq6A2u6\n' +
	        'D/oTSL6c9/3sAaFTFgMyL3wHb2YlW0BPiljZIqECAwEAAaNmMGQwDgYDVR0PAQH/\n' +
	        'BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFOcAToAc6skWffJa\n' +
	        'TnreaswAfrbcMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\n' +
	        'SIb3DQEBCwUAA4IBAQA1d0Whc1QtspK496mFWfFEQNegLh0a9GWYlJm+Htcj5Nxt\n' +
	        'DAIGXb+8xrtOZFHmYP7VLCT5Zd2C+XytqseK/+s07iAr0/EPF+O2qcyQWMN5KhgE\n' +
	        'cXw2SwuP9FPV3i+YAm11PBVeenrmzuk9NrdHQ7TxU4v7VGhcsd2C++0EisrmquWH\n' +
	        'mgIfmVDGxphwoES52cY6t3fbnXmTkvENvR+h3rj+fUiSz0aSo+XZUGHPgvuEKM/W\n' +
	        'CBD9Smc9CBoBgvy7BgHRgRUmwtABZHFUIEjHI5rIr7ZvYn+6A0O6sogRfvVYtWFc\n' +
	        'qpyrW1YX8mD0VlJ8fGKM3G+aCOsiiPKDV/Uafrm+\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECDCCAvCgAwIBAgICGAcwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIxODE5\n' +
	        'NDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\n' +
	        'em9uIFJEUyBldS1ub3J0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n' +
	        'DwAwggEKAoIBAQCiIYnhe4UNBbdBb/nQxl5giM0XoVHWNrYV5nB0YukA98+TPn9v\n' +
	        'Aoj1RGYmtryjhrf01Kuv8SWO+Eom95L3zquoTFcE2gmxCfk7bp6qJJ3eHOJB+QUO\n' +
	        'XsNRh76fwDzEF1yTeZWH49oeL2xO13EAx4PbZuZpZBttBM5zAxgZkqu4uWQczFEs\n' +
	        'JXfla7z2fvWmGcTagX10O5C18XaFroV0ubvSyIi75ue9ykg/nlFAeB7O0Wxae88e\n' +
	        'uhiBEFAuLYdqWnsg3459NfV8Yi1GnaitTym6VI3tHKIFiUvkSiy0DAlAGV2iiyJE\n' +
	        'q+DsVEO4/hSINJEtII4TMtysOsYPpINqeEzRAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n' +
	        'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRR0UpnbQyjnHChgmOc\n' +
	        'hnlc0PogzTAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n' +
	        '9w0BAQsFAAOCAQEAKJD4xVzSf4zSGTBJrmamo86jl1NHQxXUApAZuBZEc8tqC6TI\n' +
	        'T5CeoSr9CMuVC8grYyBjXblC4OsM5NMvmsrXl/u5C9dEwtBFjo8mm53rOOIm1fxl\n' +
	        'I1oYB/9mtO9ANWjkykuLzWeBlqDT/i7ckaKwalhLODsRDO73vRhYNjsIUGloNsKe\n' +
	        'pxw3dzHwAZx4upSdEVG4RGCZ1D0LJ4Gw40OfD69hfkDfRVVxKGrbEzqxXRvovmDc\n' +
	        'tKLdYZO/6REoca36v4BlgIs1CbUXJGLSXUwtg7YXGLSVBJ/U0+22iGJmBSNcoyUN\n' +
	        'cjPFD9JQEhDDIYYKSGzIYpvslvGc4T5ISXFiuQ==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBzCCAu+gAwIBAgICZIEwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIyMTMy\n' +
	        'MzJaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
	        'em9uIFJEUyBldS13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
	        'ADCCAQoCggEBALGiwqjiF7xIjT0Sx7zB3764K2T2a1DHnAxEOr+/EIftWKxWzT3u\n' +
	        'PFwS2eEZcnKqSdRQ+vRzonLBeNLO4z8aLjQnNbkizZMBuXGm4BqRm1Kgq3nlLDQn\n' +
	        '7YqdijOq54SpShvR/8zsO4sgMDMmHIYAJJOJqBdaus2smRt0NobIKc0liy7759KB\n' +
	        '6kmQ47Gg+kfIwxrQA5zlvPLeQImxSoPi9LdbRoKvu7Iot7SOa+jGhVBh3VdqndJX\n' +
	        '7tm/saj4NE375csmMETFLAOXjat7zViMRwVorX4V6AzEg1vkzxXpA9N7qywWIT5Y\n' +
	        'fYaq5M8i6vvLg0CzrH9fHORtnkdjdu1y+0MCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
	        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFOhOx1yt3Z7mvGB9jBv\n' +
	        '2ymdZwiOMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
	        'DQEBCwUAA4IBAQBehqY36UGDvPVU9+vtaYGr38dBbp+LzkjZzHwKT1XJSSUc2wqM\n' +
	        'hnCIQKilonrTIvP1vmkQi8qHPvDRtBZKqvz/AErW/ZwQdZzqYNFd+BmOXaeZWV0Q\n' +
	        'oHtDzXmcwtP8aUQpxN0e1xkWb1E80qoy+0uuRqb/50b/R4Q5qqSfJhkn6z8nwB10\n' +
	        '7RjLtJPrK8igxdpr3tGUzfAOyiPrIDncY7UJaL84GFp7WWAkH0WG3H8Y8DRcRXOU\n' +
	        'mqDxDLUP3rNuow3jnGxiUY+gGX5OqaZg4f4P6QzOSmeQYs6nLpH0PiN00+oS1BbD\n' +
	        'bpWdZEttILPI+vAYkU4QuBKKDjJL6HbSd+cn\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECDCCAvCgAwIBAgIDAIVCMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\n' +
	        'UzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\n' +
	        'CgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\n' +
	        'UzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTEzMTcw\n' +
	        'NjQxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\n' +
	        'c2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\n' +
	        'U2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\n' +
	        'YXpvbiBSRFMgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n' +
	        'DwAwggEKAoIBAQDE+T2xYjUbxOp+pv+gRA3FO24+1zCWgXTDF1DHrh1lsPg5k7ht\n' +
	        '2KPYzNc+Vg4E+jgPiW0BQnA6jStX5EqVh8BU60zELlxMNvpg4KumniMCZ3krtMUC\n' +
	        'au1NF9rM7HBh+O+DYMBLK5eSIVt6lZosOb7bCi3V6wMLA8YqWSWqabkxwN4w0vXI\n' +
	        '8lu5uXXFRemHnlNf+yA/4YtN4uaAyd0ami9+klwdkZfkrDOaiy59haOeBGL8EB/c\n' +
	        'dbJJlguHH5CpCscs3RKtOOjEonXnKXldxarFdkMzi+aIIjQ8GyUOSAXHtQHb3gZ4\n' +
	        'nS6Ey0CMlwkB8vUObZU9fnjKJcL5QCQqOfwvAgMBAAGjZjBkMA4GA1UdDwEB/wQE\n' +
	        'AwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQUPuRHohPxx4VjykmH\n' +
	        '6usGrLL1ETAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n' +
	        '9w0BAQsFAAOCAQEAUdR9Vb3y33Yj6X6KGtuthZ08SwjImVQPtknzpajNE5jOJAh8\n' +
	        'quvQnU9nlnMO85fVDU1Dz3lLHGJ/YG1pt1Cqq2QQ200JcWCvBRgdvH6MjHoDQpqZ\n' +
	        'HvQ3vLgOGqCLNQKFuet9BdpsHzsctKvCVaeBqbGpeCtt3Hh/26tgx0rorPLw90A2\n' +
	        'V8QSkZJjlcKkLa58N5CMM8Xz8KLWg3MZeT4DmlUXVCukqK2RGuP2L+aME8dOxqNv\n' +
	        'OnOz1zrL5mR2iJoDpk8+VE/eBDmJX40IJk6jBjWoxAO/RXq+vBozuF5YHN1ujE92\n' +
	        'tO8HItgTp37XT8bJBAiAnt5mxw+NLSqtxk2QdQ==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEDDCCAvSgAwIBAgICY4kwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTMyMDEx\n' +
	        'NDJaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
	        'em9uIFJEUyBhcC1zb3V0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
	        'AAOCAQ8AMIIBCgKCAQEAr5u9OuLL/OF/fBNUX2kINJLzFl4DnmrhnLuSeSnBPgbb\n' +
	        'qddjf5EFFJBfv7IYiIWEFPDbDG5hoBwgMup5bZDbas+ZTJTotnnxVJTQ6wlhTmns\n' +
	        'eHECcg2pqGIKGrxZfbQhlj08/4nNAPvyYCTS0bEcmQ1emuDPyvJBYDDLDU6AbCB5\n' +
	        '6Z7YKFQPTiCBblvvNzchjLWF9IpkqiTsPHiEt21sAdABxj9ityStV3ja/W9BfgxH\n' +
	        'wzABSTAQT6FbDwmQMo7dcFOPRX+hewQSic2Rn1XYjmNYzgEHisdUsH7eeXREAcTw\n' +
	        '61TRvaLH8AiOWBnTEJXPAe6wYfrcSd1pD0MXpoB62wIDAQABo2YwZDAOBgNVHQ8B\n' +
	        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUytwMiomQOgX5\n' +
	        'Ichd+2lDWRUhkikwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
	        'KoZIhvcNAQELBQADggEBACf6lRDpfCD7BFRqiWM45hqIzffIaysmVfr+Jr+fBTjP\n' +
	        'uYe/ba1omSrNGG23bOcT9LJ8hkQJ9d+FxUwYyICQNWOy6ejicm4z0C3VhphbTPqj\n' +
	        'yjpt9nG56IAcV8BcRJh4o/2IfLNzC/dVuYJV8wj7XzwlvjysenwdrJCoLadkTr1h\n' +
	        'eIdG6Le07sB9IxrGJL9e04afk37h7c8ESGSE4E+oS4JQEi3ATq8ne1B9DQ9SasXi\n' +
	        'IRmhNAaISDzOPdyLXi9N9V9Lwe/DHcja7hgLGYx3UqfjhLhOKwp8HtoZORixAmOI\n' +
	        'HfILgNmwyugAbuZoCazSKKBhQ0wgO0WZ66ZKTMG8Oho=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBzCCAu+gAwIBAgICUYkwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxODIx\n' +
	        'MTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
	        'em9uIFJEUyB1cy13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
	        'ADCCAQoCggEBANCEZBZyu6yJQFZBJmSUZfSZd3Ui2gitczMKC4FLr0QzkbxY+cLa\n' +
	        'uVONIOrPt4Rwi+3h/UdnUg917xao3S53XDf1TDMFEYp4U8EFPXqCn/GXBIWlU86P\n' +
	        'PvBN+gzw3nS+aco7WXb+woTouvFVkk8FGU7J532llW8o/9ydQyDIMtdIkKTuMfho\n' +
	        'OiNHSaNc+QXQ32TgvM9A/6q7ksUoNXGCP8hDOkSZ/YOLiI5TcdLh/aWj00ziL5bj\n' +
	        'pvytiMZkilnc9dLY9QhRNr0vGqL0xjmWdoEXz9/OwjmCihHqJq+20MJPsvFm7D6a\n' +
	        '2NKybR9U+ddrjb8/iyLOjURUZnj5O+2+OPcCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
	        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEBxMBdv81xuzqcK5TVu\n' +
	        'pHj+Aor8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
	        'DQEBCwUAA4IBAQBZkfiVqGoJjBI37aTlLOSjLcjI75L5wBrwO39q+B4cwcmpj58P\n' +
	        '3sivv+jhYfAGEbQnGRzjuFoyPzWnZ1DesRExX+wrmHsLLQbF2kVjLZhEJMHF9eB7\n' +
	        'GZlTPdTzHErcnuXkwA/OqyXMpj9aghcQFuhCNguEfnROY9sAoK2PTfnTz9NJHL+Q\n' +
	        'UpDLEJEUfc0GZMVWYhahc0x38ZnSY2SKacIPECQrTI0KpqZv/P+ijCEcMD9xmYEb\n' +
	        'jL4en+XKS1uJpw5fIU5Sj0MxhdGstH6S84iAE5J3GM3XHklGSFwwqPYvuTXvANH6\n' +
	        'uboynxRgSae59jIlAK6Jrr6GWMwQRbgcaAlW\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEDDCCAvSgAwIBAgICEkYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxOTUz\n' +
	        'NDdaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
	        'em9uIFJEUyBhcC1zb3V0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
	        'AAOCAQ8AMIIBCgKCAQEAufodI2Flker8q7PXZG0P0vmFSlhQDw907A6eJuF/WeMo\n' +
	        'GHnll3b4S6nC3oRS3nGeRMHbyU2KKXDwXNb3Mheu+ox+n5eb/BJ17eoj9HbQR1cd\n' +
	        'gEkIciiAltf8gpMMQH4anP7TD+HNFlZnP7ii3geEJB2GGXSxgSWvUzH4etL67Zmn\n' +
	        'TpGDWQMB0T8lK2ziLCMF4XAC/8xDELN/buHCNuhDpxpPebhct0T+f6Arzsiswt2j\n' +
	        '7OeNeLLZwIZvVwAKF7zUFjC6m7/VmTQC8nidVY559D6l0UhhU0Co/txgq3HVsMOH\n' +
	        'PbxmQUwJEKAzQXoIi+4uZzHFZrvov/nDTNJUhC6DqwIDAQABo2YwZDAOBgNVHQ8B\n' +
	        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwaZpaCme+EiV\n' +
	        'M5gcjeHZSTgOn4owHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
	        'KoZIhvcNAQELBQADggEBAAR6a2meCZuXO2TF9bGqKGtZmaah4pH2ETcEVUjkvXVz\n' +
	        'sl+ZKbYjrun+VkcMGGKLUjS812e7eDF726ptoku9/PZZIxlJB0isC/0OyixI8N4M\n' +
	        'NsEyvp52XN9QundTjkl362bomPnHAApeU0mRbMDRR2JdT70u6yAzGLGsUwMkoNnw\n' +
	        '1VR4XKhXHYGWo7KMvFrZ1KcjWhubxLHxZWXRulPVtGmyWg/MvE6KF+2XMLhojhUL\n' +
	        '+9jB3Fpn53s6KMx5tVq1x8PukHmowcZuAF8k+W4gk8Y68wIwynrdZrKRyRv6CVtR\n' +
	        'FZ8DeJgoNZT3y/GT254VqMxxfuy2Ccb/RInd16tEvVk=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEDDCCAvSgAwIBAgICOYIwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTcyMDA1\n' +
	        'MjlaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
	        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMyAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
	        'AAOCAQ8AMIIBCgKCAQEA4dMak8W+XW8y/2F6nRiytFiA4XLwePadqWebGtlIgyCS\n' +
	        'kbug8Jv5w7nlMkuxOxoUeD4WhI6A9EkAn3r0REM/2f0aYnd2KPxeqS2MrtdxxHw1\n' +
	        'xoOxk2x0piNSlOz6yog1idsKR5Wurf94fvM9FdTrMYPPrDabbGqiBMsZZmoHLvA3\n' +
	        'Z+57HEV2tU0Ei3vWeGIqnNjIekS+E06KhASxrkNU5vi611UsnYZlSi0VtJsH4UGV\n' +
	        'LhnHl53aZL0YFO5mn/fzuNG/51qgk/6EFMMhaWInXX49Dia9FnnuWXwVwi6uX1Wn\n' +
	        '7kjoHi5VtmC8ZlGEHroxX2DxEr6bhJTEpcLMnoQMqwIDAQABo2YwZDAOBgNVHQ8B\n' +
	        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUsUI5Cb3SWB8+\n' +
	        'gv1YLN/ABPMdxSAwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
	        'KoZIhvcNAQELBQADggEBAJAF3E9PM1uzVL8YNdzb6fwJrxxqI2shvaMVmC1mXS+w\n' +
	        'G0zh4v2hBZOf91l1EO0rwFD7+fxoI6hzQfMxIczh875T6vUXePKVOCOKI5wCrDad\n' +
	        'zQbVqbFbdhsBjF4aUilOdtw2qjjs9JwPuB0VXN4/jY7m21oKEOcnpe36+7OiSPjN\n' +
	        'xngYewCXKrSRqoj3mw+0w/+exYj3Wsush7uFssX18av78G+ehKPIVDXptOCP/N7W\n' +
	        '8iKVNeQ2QGTnu2fzWsGUSvMGyM7yqT+h1ILaT//yQS8er511aHMLc142bD4D9VSy\n' +
	        'DgactwPDTShK/PXqhvNey9v/sKXm4XatZvwcc8KYlW4=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEDDCCAvSgAwIBAgICcEUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNjU2\n' +
	        'MjBaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\n' +
	        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\n' +
	        'AAOCAQ8AMIIBCgKCAQEAndtkldmHtk4TVQAyqhAvtEHSMb6pLhyKrIFved1WO3S7\n' +
	        '+I+bWwv9b2W/ljJxLq9kdT43bhvzonNtI4a1LAohS6bqyirmk8sFfsWT3akb+4Sx\n' +
	        '1sjc8Ovc9eqIWJCrUiSvv7+cS7ZTA9AgM1PxvHcsqrcUXiK3Jd/Dax9jdZE1e15s\n' +
	        'BEhb2OEPE+tClFZ+soj8h8Pl2Clo5OAppEzYI4LmFKtp1X/BOf62k4jviXuCSst3\n' +
	        'UnRJzE/CXtjmN6oZySVWSe0rQYuyqRl6//9nK40cfGKyxVnimB8XrrcxUN743Vud\n' +
	        'QQVU0Esm8OVTX013mXWQXJHP2c0aKkog8LOga0vobQIDAQABo2YwZDAOBgNVHQ8B\n' +
	        'Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQULmoOS1mFSjj+\n' +
	        'snUPx4DgS3SkLFYwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\n' +
	        'KoZIhvcNAQELBQADggEBAAkVL2P1M2/G9GM3DANVAqYOwmX0Xk58YBHQu6iiQg4j\n' +
	        'b4Ky/qsZIsgT7YBsZA4AOcPKQFgGTWhe9pvhmXqoN3RYltN8Vn7TbUm/ZVDoMsrM\n' +
	        'gwv0+TKxW1/u7s8cXYfHPiTzVSJuOogHx99kBW6b2f99GbP7O1Sv3sLq4j6lVvBX\n' +
	        'Fiacf5LAWC925nvlTzLlBgIc3O9xDtFeAGtZcEtxZJ4fnGXiqEnN4539+nqzIyYq\n' +
	        'nvlgCzyvcfRAxwltrJHuuRu6Maw5AGcd2Y0saMhqOVq9KYKFKuD/927BTrbd2JVf\n' +
	        '2sGWyuPZPCk3gq+5pCjbD0c6DkhcMGI6WwxvM5V/zSM=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBzCCAu+gAwIBAgICJDQwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNzAz\n' +
	        'MTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
	        'em9uIFJEUyBldS13ZXN0LTMgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
	        'ADCCAQoCggEBAL9bL7KE0n02DLVtlZ2PL+g/BuHpMYFq2JnE2RgompGurDIZdjmh\n' +
	        '1pxfL3nT+QIVMubuAOy8InRfkRxfpxyjKYdfLJTPJG+jDVL+wDcPpACFVqoV7Prg\n' +
	        'pVYEV0lc5aoYw4bSeYFhdzgim6F8iyjoPnObjll9mo4XsHzSoqJLCd0QC+VG9Fw2\n' +
	        'q+GDRZrLRmVM2oNGDRbGpGIFg77aRxRapFZa8SnUgs2AqzuzKiprVH5i0S0M6dWr\n' +
	        'i+kk5epmTtkiDHceX+dP/0R1NcnkCPoQ9TglyXyPdUdTPPRfKCq12dftqll+u4mV\n' +
	        'ARdN6WFjovxax8EAP2OAUTi1afY+1JFMj+sCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
	        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFLfhrbrO5exkCVgxW0x3\n' +
	        'Y2mAi8lNMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
	        'DQEBCwUAA4IBAQAigQ5VBNGyw+OZFXwxeJEAUYaXVoP/qrhTOJ6mCE2DXUVEoJeV\n' +
	        'SxScy/TlFA9tJXqmit8JH8VQ/xDL4ubBfeMFAIAo4WzNWDVoeVMqphVEcDWBHsI1\n' +
	        'AETWzfsapRS9yQekOMmxg63d/nV8xewIl8aNVTHdHYXMqhhik47VrmaVEok1UQb3\n' +
	        'O971RadLXIEbVd9tjY5bMEHm89JsZDnDEw1hQXBb67Elu64OOxoKaHBgUH8AZn/2\n' +
	        'zFsL1ynNUjOhCSAA15pgd1vjwc0YsBbAEBPcHBWYBEyME6NLNarjOzBl4FMtATSF\n' +
	        'wWCKRGkvqN8oxYhwR2jf2rR5Mu4DWkK5Q8Ep\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBzCCAu+gAwIBAgICJVUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTkxODE2\n' +
	        'NTNaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\n' +
	        'aGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\n' +
	        'ZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\n' +
	        'em9uIFJEUyB1cy1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n' +
	        'ADCCAQoCggEBAM3i/k2u6cqbMdcISGRvh+m+L0yaSIoOXjtpNEoIftAipTUYoMhL\n' +
	        'InXGlQBVA4shkekxp1N7HXe1Y/iMaPEyb3n+16pf3vdjKl7kaSkIhjdUz3oVUEYt\n' +
	        'i8Z/XeJJ9H2aEGuiZh3kHixQcZczn8cg3dA9aeeyLSEnTkl/npzLf//669Ammyhs\n' +
	        'XcAo58yvT0D4E0D/EEHf2N7HRX7j/TlyWvw/39SW0usiCrHPKDLxByLojxLdHzso\n' +
	        'QIp/S04m+eWn6rmD+uUiRteN1hI5ncQiA3wo4G37mHnUEKo6TtTUh+sd/ku6a8HK\n' +
	        'glMBcgqudDI90s1OpuIAWmuWpY//8xEG2YECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\n' +
	        'AgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPqhoWZcrVY9mU7tuemR\n' +
	        'RBnQIj1jMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\n' +
	        'DQEBCwUAA4IBAQB6zOLZ+YINEs72heHIWlPZ8c6WY8MDU+Be5w1M+BK2kpcVhCUK\n' +
	        'PJO4nMXpgamEX8DIiaO7emsunwJzMSvavSPRnxXXTKIc0i/g1EbiDjnYX9d85DkC\n' +
	        'E1LaAUCmCZBVi9fIe0H2r9whIh4uLWZA41oMnJx/MOmo3XyMfQoWcqaSFlMqfZM4\n' +
	        '0rNoB/tdHLNuV4eIdaw2mlHxdWDtF4oH+HFm+2cVBUVC1jXKrFv/euRVtsTT+A6i\n' +
	        'h2XBHKxQ1Y4HgAn0jACP2QSPEmuoQEIa57bEKEcZsBR8SDY6ZdTd2HLRIApcCOSF\n' +
	        'MRM8CKLeF658I0XgF8D5EsYoKPsA+74Z+jDH\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEETCCAvmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZQxCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSUwIwYDVQQDDBxBbWF6b24gUkRTIEJldGEgUm9vdCAyMDE5IENBMB4XDTE5MDgy\n' +
	        'MDE3MTAwN1oXDTI0MDgxOTE3MzgyNlowgZkxCzAJBgNVBAYTAlVTMRMwEQYDVQQI\n' +
	        'DApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6b24g\n' +
	        'V2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSowKAYDVQQD\n' +
	        'DCFBbWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3\n' +
	        'DQEBAQUAA4IBDwAwggEKAoIBAQDTNCOlotQcLP8TP82U2+nk0bExVuuMVOgFeVMx\n' +
	        'vbUHZQeIj9ikjk+jm6eTDnnkhoZcmJiJgRy+5Jt69QcRbb3y3SAU7VoHgtraVbxF\n' +
	        'QDh7JEHI9tqEEVOA5OvRrDRcyeEYBoTDgh76ROco2lR+/9uCvGtHVrMCtG7BP7ZB\n' +
	        'sSVNAr1IIRZZqKLv2skKT/7mzZR2ivcw9UeBBTUf8xsfiYVBvMGoEsXEycjYdf6w\n' +
	        'WV+7XS7teNOc9UgsFNN+9AhIBc1jvee5E//72/4F8pAttAg/+mmPUyIKtekNJ4gj\n' +
	        'OAR2VAzGx1ybzWPwIgOudZFHXFduxvq4f1hIRPH0KbQ/gkRrAgMBAAGjZjBkMA4G\n' +
	        'A1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTkvpCD\n' +
	        '6C43rar9TtJoXr7q8dkrrjAfBgNVHSMEGDAWgBStoQwVpbGx87fxB3dEGDqKKnBT\n' +
	        '4TANBgkqhkiG9w0BAQsFAAOCAQEAJd9fOSkwB3uVdsS+puj6gCER8jqmhd3g/J5V\n' +
	        'Zjk9cKS8H0e8pq/tMxeJ8kpurPAzUk5RkCspGt2l0BSwmf3ahr8aJRviMX6AuW3/\n' +
	        'g8aKplTvq/WMNGKLXONa3Sq8591J+ce8gtOX/1rDKmFI4wQ/gUzOSYiT991m7QKS\n' +
	        'Fr6HMgFuz7RNJbb3Fy5cnurh8eYWA7mMv7laiLwTNsaro5qsqErD5uXuot6o9beT\n' +
	        'a+GiKinEur35tNxAr47ax4IRubuIzyfCrezjfKc5raVV2NURJDyKP0m0CCaffAxE\n' +
	        'qn2dNfYc3v1D8ypg3XjHlOzRo32RB04o8ALHMD9LSwsYDLpMag==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEFzCCAv+gAwIBAgICFSUwDQYJKoZIhvcNAQELBQAwgZcxCzAJBgNVBAYTAlVT\n' +
	        'MRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\n' +
	        'DBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\n' +
	        'MSgwJgYDVQQDDB9BbWF6b24gUkRTIFByZXZpZXcgUm9vdCAyMDE5IENBMB4XDTE5\n' +
	        'MDgyMTIyMzk0N1oXDTI0MDgyMTIyMjk0OVowgZwxCzAJBgNVBAYTAlVTMRMwEQYD\n' +
	        'VQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6\n' +
	        'b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMS0wKwYD\n' +
	        'VQQDDCRBbWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0G\n' +
	        'CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQD0dB/U7qRnSf05wOi7m10Pa2uPMTJv\n' +
	        'r6U/3Y17a5prq5Zr4++CnSUYarG51YuIf355dKs+7Lpzs782PIwCmLpzAHKWzix6\n' +
	        'pOaTQ+WZ0+vUMTxyqgqWbsBgSCyP7pVBiyqnmLC/L4az9XnscrbAX4pNaoJxsuQe\n' +
	        'mzBo6yofjQaAzCX69DuqxFkVTRQnVy7LCFkVaZtjNAftnAHJjVgQw7lIhdGZp9q9\n' +
	        'IafRt2gteihYfpn+EAQ/t/E4MnhrYs4CPLfS7BaYXBycEKC5Muj1l4GijNNQ0Efo\n' +
	        'xG8LSZz7SNgUvfVwiNTaqfLP3AtEAWiqxyMyh3VO+1HpCjT7uNBFtmF3AgMBAAGj\n' +
	        'ZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\n' +
	        'BBQtinkdrj+0B2+qdXngV2tgHnPIujAfBgNVHSMEGDAWgBRp0xqULkNh/w2ZVzEI\n' +
	        'o2RIY7O03TANBgkqhkiG9w0BAQsFAAOCAQEAtJdqbCxDeMc8VN1/RzCabw9BIL/z\n' +
	        '73Auh8eFTww/sup26yn8NWUkfbckeDYr1BrXa+rPyLfHpg06kwR8rBKyrs5mHwJx\n' +
	        'bvOzXD/5WTdgreB+2Fb7mXNvWhenYuji1MF+q1R2DXV3I05zWHteKX6Dajmx+Uuq\n' +
	        'Yq78oaCBSV48hMxWlp8fm40ANCL1+gzQ122xweMFN09FmNYFhwuW+Ao+Vv90ZfQG\n' +
	        'PYwTvN4n/gegw2TYcifGZC2PNX74q3DH03DXe5fvNgRW5plgz/7f+9mS+YHd5qa9\n' +
	        'tYTPUvoRbi169ou6jicsMKUKPORHWhiTpSCWR1FMMIbsAcsyrvtIsuaGCQ==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/jCCAuagAwIBAgIQdOCSuA9psBpQd8EI368/0DANBgkqhkiG9w0BAQsFADCB\n' +
	        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
	        'bWF6b24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTE5MTgwNjI2WhgPMjA2MTA1MTkxOTA2MjZaMIGXMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
	        'biBSRFMgc2EtZWFzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN6ftL6w8v3dB2yW\n' +
	        'LjCxSP1D7ZsOTeLZOSCz1Zv0Gkd0XLhil5MdHOHBvwH/DrXqFU2oGzCRuAy+aZis\n' +
	        'DardJU6ChyIQIciXCO37f0K23edhtpXuruTLLwUwzeEPdcnLPCX+sWEn9Y5FPnVm\n' +
	        'pCd6J8edH2IfSGoa9LdErkpuESXdidLym/w0tWG/O2By4TabkNSmpdrCL00cqI+c\n' +
	        'prA8Bx1jX8/9sY0gpAovtuFaRN+Ivg3PAnWuhqiSYyQ5nC2qDparOWuDiOhpY56E\n' +
	        'EgmTvjwqMMjNtExfYx6Rv2Ndu50TriiNKEZBzEtkekwXInTupmYTvc7U83P/959V\n' +
	        'UiQ+WSMCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU4uYHdH0+\n' +
	        'bUeh81Eq2l5/RJbW+vswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\n' +
	        'AQBhxcExJ+w74bvDknrPZDRgTeMLYgbVJjx2ExH7/Ac5FZZWcpUpFwWMIJJxtewI\n' +
	        'AnhryzM3tQYYd4CG9O+Iu0+h/VVfW7e4O3joWVkxNMb820kQSEwvZfA78aItGwOY\n' +
	        'WSaFNVRyloVicZRNJSyb1UL9EiJ9ldhxm4LTT0ax+4ontI7zTx6n6h8Sr6r/UOvX\n' +
	        'd9T5aUUENWeo6M9jGupHNn3BobtL7BZm2oS8wX8IVYj4tl0q5T89zDi2x0MxbsIV\n' +
	        '5ZjwqBQ5JWKv7ASGPb+z286RjPA9R2knF4lJVZrYuNV90rHvI/ECyt/JrDqeljGL\n' +
	        'BLl1W/UsvZo6ldLIpoMbbrb5\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBDCCAuygAwIBAgIQUfVbqapkLYpUqcLajpTJWzANBgkqhkiG9w0BAQsFADCB\n' +
	        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
	        'bWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUwIBcNMjIwNTA2MjMyMDA5WhgPMjA2MjA1MDcwMDIwMDlaMIGa\n' +
	        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
	        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
	        'YXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJIeovu3\n' +
	        'ewI9FVitXMQzvkh34aQ6WyI4NO3YepfJaePiv3cnyFGYHN2S1cR3UQcLWgypP5va\n' +
	        'j6bfroqwGbCbZZcb+6cyOB4ceKO9Ws1UkcaGHnNDcy5gXR7aCW2OGTUfinUuhd2d\n' +
	        '5bOGgV7JsPbpw0bwJ156+MwfOK40OLCWVbzy8B1kITs4RUPNa/ZJnvIbiMu9rdj4\n' +
	        '8y7GSFJLnKCjlOFUkNI5LcaYvI1+ybuNgphT3nuu5ZirvTswGakGUT/Q0J3dxP0J\n' +
	        'pDfg5Sj/2G4gXiaM0LppVOoU5yEwVewhQ250l0eQAqSrwPqAkdTg9ng360zqCFPE\n' +
	        'JPPcgI1tdGUgneECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU\n' +
	        '/2AJVxWdZxc8eJgdpbwpW7b0f7IwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB\n' +
	        'CwUAA4IBAQBYm63jTu2qYKJ94gKnqc+oUgqmb1mTXmgmp/lXDbxonjszJDOXFbri\n' +
	        '3CCO7xB2sg9bd5YWY8sGKHaWmENj3FZpCmoefbUx++8D7Mny95Cz8R32rNcwsPTl\n' +
	        'ebpd9A/Oaw5ug6M0x/cNr0qzF8Wk9Dx+nFEimp8RYQdKvLDfNFZHjPa1itnTiD8M\n' +
	        'TorAqj+VwnUGHOYBsT/0NY12tnwXdD+ATWfpEHdOXV+kTMqFFwDyhfgRVNpTc+os\n' +
	        'ygr8SwhnSCpJPB/EYl2S7r+tgAbJOkuwUvGT4pTqrzDQEhwE7swgepnHC87zhf6l\n' +
	        'qN6mVpSnQKQLm6Ob5TeCEFgcyElsF5bH\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjSgAwIBAgIRAOxu0I1QuMAhIeszB3fJIlkwCgYIKoZIzj0EAwMwgZYx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
	        'em9uIFJEUyB1cy13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTI0MjIwNjU5WhgPMjEyMTA1MjQyMzA2NTlaMIGWMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
	        'RFMgdXMtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
	        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEz4bylRcGqqDWdP7gQIIoTHdBK6FNtKH1\n' +
	        '4SkEIXRXkYDmRvL9Bci1MuGrwuvrka5TDj4b7e+csY0llEzHpKfq6nJPFljoYYP9\n' +
	        'uqHFkv77nOpJJ633KOr8IxmeHW5RXgrZo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
	        'A1UdDgQWBBQQikVz8wmjd9eDFRXzBIU8OseiGzAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
	        'KoZIzj0EAwMDaAAwZQIwf06Mcrpw1O0EBLBBrp84m37NYtOkE/0Z0O+C7D41wnXi\n' +
	        'EQdn6PXUVgdD23Gj82SrAjEAklhKs+liO1PtN15yeZR1Io98nFve+lLptaLakZcH\n' +
	        '+hfFuUtCqMbaI8CdvJlKnPqT\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGCTCCA/GgAwIBAgIRALyWMTyCebLZOGcZZQmkmfcwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyODAzWhgPMjEyMTA1MjQyMTI4MDNa\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
	        'wGFiyDyCrGqgdn4fXG12cxKAAfVvhMea1mw5h9CVRoavkPqhzQpAitSOuMB9DeiP\n' +
	        'wQyqcsiGl/cTEau4L+AUBG8b9v26RlY48exUYBXj8CieYntOT9iNw5WtdYJa3kF/\n' +
	        'JxgI+HDMzE9cmHDs5DOO3S0uwZVyra/xE1ymfSlpOeUIOTpHRJv97CBUEpaZMUW5\n' +
	        'Sr6GruuOwFVpO5FX3A/jQlcS+UN4GjSRgDUJuqg6RRQldEZGCVCCmodbByvI2fGm\n' +
	        'reGpsPJD54KkmAX08nOR8e5hkGoHxq0m2DLD4SrOFmt65vG47qnuwplWJjtk9B3Z\n' +
	        '9wDoopwZLBOtlkPIkUllWm1P8EuHC1IKOA+wSP6XdT7cy8S77wgyHzR0ynxv7q/l\n' +
	        'vlZtH30wnNqFI0y9FeogD0TGMCHcnGqfBSicJXPy9T4fU6f0r1HwqKwPp2GArwe7\n' +
	        'dnqLTj2D7M9MyVtFjEs6gfGWXmu1y5uDrf+CszurE8Cycoma+OfjjuVQgWOCy7Nd\n' +
	        'jJswPxAroTzVfpgoxXza4ShUY10woZu0/J+HmNmqK7lh4NS75q1tz75in8uTZDkV\n' +
	        'be7GK+SEusTrRgcf3tlgPjSTWG3veNzFDF2Vn1GLJXmuZfhdlVQDBNXW4MNREExS\n' +
	        'dG57kJjICpT+r8X+si+5j51gRzkSnMYs7VHulpxfcwECAwEAAaNCMEAwDwYDVR0T\n' +
	        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQU4JWOpDBmUBuWKvGPZelw87ezhL8wDgYDVR0P\n' +
	        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBRNLMql7itvXSEFQRAnyOjivHz\n' +
	        'l5IlWVQjAbOUr6ogZcwvK6YpxNAFW5zQr8F+fdkiypLz1kk5irx9TIpff0BWC9hQ\n' +
	        '/odMPO8Gxn8+COlSvc+dLsF2Dax3Hvz0zLeKMo+cYisJOzpdR/eKd0/AmFdkvQoM\n' +
	        'AOK9n0yYvVJU2IrSgeJBiiCarpKSeAktEVQ4rvyacQGr+QAPkkjRwm+5LHZKK43W\n' +
	        'nNnggRli9N/27qYtc5bgr3AaQEhEXMI4RxPRXCLsod0ehMGWyRRK728a+6PMMJAJ\n' +
	        'WHOU0x7LCEMPP/bvpLj3BdvSGqNor4ZtyXEbwREry1uzsgODeRRns5acPwTM6ff+\n' +
	        'CmxO2NZ0OktIUSYRmf6H/ZFlZrIhV8uWaIwEJDz71qvj7buhQ+RFDZ9CNL64C0X6\n' +
	        'mf0zJGEpddjANHaaVky+F4gYMtEy2K2Lcm4JGTdyIzUoIe+atzCnRp0QeIcuWtF+\n' +
	        's8AjDYCVFNypcMmqbRmNpITSnOoCHSRuVkY3gutVoYyMLbp8Jm9SJnCIlEWTA6Rm\n' +
	        'wADOMGZJVn5/XRTRuetVOB3KlQDjs9OO01XN5NzGSZO2KT9ngAUfh9Eqhf1iRWSP\n' +
	        'nZlRbQ2NRCuY/oJ5N59mLGxnNJSE7giEKEBRhTQ/XEPIUYAUPD5fca0arKRJwbol\n' +
	        'l9Se1Hsq0ZU5f+OZKQ==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGATCCA+mgAwIBAgIRAK7vlRrGVEePJpW1VHMXdlIwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
	        'QW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMTA1MTkxOTI4NDNaGA8yMTIxMDUxOTIwMjg0M1owgZgx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
	        'em9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
	        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMZiHOQC6x4o\n' +
	        'eC7vVOMCGiN5EuLqPYHdceFPm4h5k/ZejXTf7kryk6aoKZKsDIYihkaZwXVS7Y/y\n' +
	        '7Ig1F1ABi2jD+CYprj7WxXbhpysmN+CKG7YC3uE4jSvfvUnpzionkQbjJsRJcrPO\n' +
	        'cZJM4FVaVp3mlHHtvnM+K3T+ni4a38nAd8xrv1na4+B8ZzZwWZXarfg8lJoGskSn\n' +
	        'ou+3rbGQ0r+XlUP03zWujHoNlVK85qUIQvDfTB7n3O4s1XNGvkfv3GNBhYRWJYlB\n' +
	        '4p8T+PFN8wG+UOByp1gV7BD64RnpuZ8V3dRAlO6YVAmINyG5UGrPzkIbLtErUNHO\n' +
	        '4iSp4UqYvztDqJWWHR/rA84ef+I9RVwwZ8FQbjKq96OTnPrsr63A5mXTC9dXKtbw\n' +
	        'XNJPQY//FEdyM3K8sqM0IdCzxCA1MXZ8+QapWVjwyTjUwFvL69HYky9H8eAER59K\n' +
	        '5I7u/CWWeCy2R1SYUBINc3xxLr0CGGukcWPEZW2aPo5ibW5kepU1P/pzdMTaTfao\n' +
	        'F42jSFXbc7gplLcSqUgWwzBnn35HLTbiZOFBPKf6vRRu8aRX9atgHw/EjCebi2xP\n' +
	        'xIYr5Ub8u0QVHIqcnF1/hVzO/Xz0chj3E6VF/yTXnsakm+W1aM2QkZbFGpga+LMy\n' +
	        'mFCtdPrELjea2CfxgibaJX1Q4rdEpc8DAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
	        'Af8wHQYDVR0OBBYEFDSaycEyuspo/NOuzlzblui8KotFMA4GA1UdDwEB/wQEAwIB\n' +
	        'hjANBgkqhkiG9w0BAQwFAAOCAgEAbosemjeTRsL9o4v0KadBUNS3V7gdAH+X4vH2\n' +
	        'Ee1Jc91VOGLdd/s1L9UX6bhe37b9WjUD69ur657wDW0RzxMYgQdZ27SUl0tEgGGp\n' +
	        'cCmVs1ky3zEN+Hwnhkz+OTmIg1ufq0W2hJgJiluAx2r1ib1GB+YI3Mo3rXSaBYUk\n' +
	        'bgQuujYPctf0PA153RkeICE5GI3OaJ7u6j0caYEixBS3PDHt2MJWexITvXGwHWwc\n' +
	        'CcrC05RIrTUNOJaetQw8smVKYOfRImEzLLPZ5kf/H3Cbj8BNAFNsa10wgvlPuGOW\n' +
	        'XLXqzNXzrG4V3sjQU5YtisDMagwYaN3a6bBf1wFwFIHQoAPIgt8q5zaQ9WI+SBns\n' +
	        'Il6rd4zfvjq/BPmt0uI7rVg/cgbaEg/JDL2neuM9CJAzmKxYxLQuHSX2i3Fy4Y1B\n' +
	        'cnxnRQETCRZNPGd00ADyxPKVoYBC45/t+yVusArFt+2SVLEGiFBr23eG2CEZu+HS\n' +
	        'nDEgIfQ4V3YOTUNa86wvbAss1gbbnT/v1XCnNGClEWCWNCSRjwV2ZmQ/IVTmNHPo\n' +
	        '7axTTBBJbKJbKzFndCnuxnDXyytdYRgFU7Ly3sa27WS2KFyFEDebLFRHQEfoYqCu\n' +
	        'IupSqBSbXsR3U10OTjc9z6EPo1nuV6bdz+gEDthmxKa1NI+Qb1kvyliXQHL2lfhr\n' +
	        '5zT5+Bs=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/zCCA+egAwIBAgIRAOLV6zZcL4IV2xmEneN1GwswDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUxOTE5MDg1OFoYDzIxMjEwNTE5MjAwODU4WjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7koAKGXXlLixN\n' +
	        'fVjhuqvz0WxDeTQfhthPK60ekRpftkfE5QtnYGzeovaUAiS58MYVzqnnTACDwcJs\n' +
	        'IGTFE6Wd7sB6r8eI/3CwI1pyJfxepubiQNVAQG0zJETOVkoYKe/5KnteKtnEER3X\n' +
	        'tCBRdV/rfbxEDG9ZAsYfMl6zzhEWKF88G6xhs2+VZpDqwJNNALvQuzmTx8BNbl5W\n' +
	        'RUWGq9CQ9GK9GPF570YPCuURW7kl35skofudE9bhURNz51pNoNtk2Z3aEeRx3ouT\n' +
	        'ifFJlzh+xGJRHqBG7nt5NhX8xbg+vw4xHCeq1aAe6aVFJ3Uf9E2HzLB4SfIT9bRp\n' +
	        'P7c9c0ySGt+3n+KLSHFf/iQ3E4nft75JdPjeSt0dnyChi1sEKDi0tnWGiXaIg+J+\n' +
	        'r1ZtcHiyYpCB7l29QYMAdD0TjfDwwPayLmq//c20cPmnSzw271VwqjUT0jYdrNAm\n' +
	        'gV+JfW9t4ixtE3xF2jaUh/NzL3bAmN5v8+9k/aqPXlU1BgE3uPwMCjrfn7V0I7I1\n' +
	        'WLpHyd9jF3U/Ysci6H6i8YKgaPiOfySimQiDu1idmPld659qerutUSemQWmPD3bE\n' +
	        'dcjZolmzS9U0Ujq/jDF1YayN3G3xvry1qWkTci0qMRMu2dZu30Herugh9vsdTYkf\n' +
	        '00EqngPbqtIVLDrDjEQLqPcb8QvWFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
	        'MB0GA1UdDgQWBBQBqg8Za/L0YMHURGExHfvPyfLbOTAOBgNVHQ8BAf8EBAMCAYYw\n' +
	        'DQYJKoZIhvcNAQEMBQADggIBACAGPMa1QL7P/FIO7jEtMelJ0hQlQepKnGtbKz4r\n' +
	        'Xq1bUX1jnLvnAieR9KZmeQVuKi3g3CDU6b0mDgygS+FL1KDDcGRCSPh238Ou8KcG\n' +
	        'HIxtt3CMwMHMa9gmdcMlR5fJF9vhR0C56KM2zvyelUY51B/HJqHwGvWuexryXUKa\n' +
	        'wq1/iK2/d9mNeOcjDvEIj0RCMI8dFQCJv3PRCTC36XS36Tzr6F47TcTw1c3mgKcs\n' +
	        'xpcwt7ezrXMUunzHS4qWAA5OGdzhYlcv+P5GW7iAA7TDNrBF+3W4a/6s9v2nQAnX\n' +
	        'UvXd9ul0ob71377UhZbJ6SOMY56+I9cJOOfF5QvaL83Sz29Ij1EKYw/s8TYdVqAq\n' +
	        '+dCyQZBkMSnDFLVe3J1KH2SUSfm3O98jdPORQrUlORQVYCHPls19l2F6lCmU7ICK\n' +
	        'hRt8EVSpXm4sAIA7zcnR2nU00UH8YmMQLnx5ok9YGhuh3Ehk6QlTQLJux6LYLskd\n' +
	        '9YHOLGW/t6knVtV78DgPqDeEx/Wu/5A8R0q7HunpWxr8LCPBK6hksZnOoUhhb8IP\n' +
	        'vl46Ve5Tv/FlkyYr1RTVjETmg7lb16a8J0At14iLtpZWmwmuv4agss/1iBVMXfFk\n' +
	        '+ZGtx5vytWU5XJmsfKA51KLsMQnhrLxb3X3zC+JRCyJoyc8++F3YEcRi2pkRYE3q\n' +
	        'Hing\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgIRANxgyBbnxgTEOpDul2ZnC0UwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNjEwMTgxOTA3WhgPMjA2MTA2MTAxOTE5MDda\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
	        'xnwSDAChrMkfk5TA4Dk8hKzStDlSlONzmd3fTG0Wqr5+x3EmFT6Ksiu/WIwEl9J2\n' +
	        'K98UI7vYyuZfCxUKb1iMPeBdVGqk0zb92GpURd+Iz/+K1ps9ZLeGBkzR8mBmAi1S\n' +
	        'OfpwKiTBzIv6E8twhEn4IUpHsdcuX/2Y78uESpJyM8O5CpkG0JaV9FNEbDkJeBUQ\n' +
	        'Ao2qqNcH4R0Qcr5pyeqA9Zto1RswgL06BQMI9dTpfwSP5VvkvcNUaLl7Zv5WzLQE\n' +
	        'JzORWePvdPzzvWEkY/3FPjxBypuYwssKaERW0fkPDmPtykktP9W/oJolKUFI6pXp\n' +
	        'y+Y6p6/AVdnQD2zZjW5FhQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
	        'DgQWBBT+jEKs96LC+/X4BZkUYUkzPfXdqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBAIGQqgqcQ6XSGkmNebzR6DhadTbfDmbYeN5N0Vuzv+Tdmufb\n' +
	        'tMGjdjnYMg4B+IVnTKQb+Ox3pL9gbX6KglGK8HupobmIRtwKVth+gYYz3m0SL/Nk\n' +
	        'haWPYzOm0x3tJm8jSdufJcEob4/ATce9JwseLl76pSWdl5A4lLjnhPPKudUDfH+1\n' +
	        'BLNUi3lxpp6GkC8aWUPtupnhZuXddolTLOuA3GwTZySI44NfaFRm+o83N1jp+EwD\n' +
	        '6e94M4cTRzjUv6J3MZmSbdtQP/Tk1uz2K4bQZGP0PZC3bVpqiesdE/xr+wbu8uHr\n' +
	        'cM1JXH0AmXf1yIkTgyWzmvt0k1/vgcw5ixAqvvE=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEATCCAumgAwIBAgIRAMhw98EQU18mIji+unM2YH8wDQYJKoZIhvcNAQELBQAw\n' +
	        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQyMjJaGA8yMDYyMDYwNjIyNDIyMlowgZgx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
	        'em9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwH\n' +
	        'U2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIeeRoLfTm+7\n' +
	        'vqm7ZlFSx+1/CGYHyYrOOryM4/Z3dqYVHFMgWTR7V3ziO8RZ6yUanrRcWVX3PZbF\n' +
	        'AfX0KFE8OgLsXEZIX8odSrq86+/Th5eZOchB2fDBsUB7GuN2rvFBbM8lTI9ivVOU\n' +
	        'lbuTnYyb55nOXN7TpmH2bK+z5c1y9RVC5iQsNAl6IJNvSN8VCqXh31eK5MlKB4DT\n' +
	        '+Y3OivCrSGsjM+UR59uZmwuFB1h+icE+U0p9Ct3Mjq3MzSX5tQb6ElTNGlfmyGpW\n' +
	        'Kh7GQ5XU1KaKNZXoJ37H53woNSlq56bpVrKI4uv7ATpdpFubOnSLtpsKlpLdR3sy\n' +
	        'Ws245200pC8CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUp0ki\n' +
	        '6+eWvsnBjQhMxwMW5pwn7DgwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUA\n' +
	        'A4IBAQB2V8lv0aqbYQpj/bmVv/83QfE4vOxKCJAHv7DQ35cJsTyBdF+8pBczzi3t\n' +
	        '3VNL5IUgW6WkyuUOWnE0eqAFOUVj0yTS1jSAtfl3vOOzGJZmWBbqm9BKEdu1D8O6\n' +
	        'sB8bnomwiab2tNDHPmUslpdDqdabbkWwNWzLJ97oGFZ7KNODMEPXWKWNxg33iHfS\n' +
	        '/nlmnrTVI3XgaNK9qLZiUrxu9Yz5gxi/1K+sG9/Dajd32ZxjRwDipOLiZbiXQrsd\n' +
	        'qzIMY4GcWf3g1gHL5mCTfk7dG22h/rhPyGV0svaDnsb+hOt6sv1McMN6Y3Ou0mtM\n' +
	        '/UaAXojREmJmTSCNvs2aBny3/2sy\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjSgAwIBAgIRAMnRxsKLYscJV8Qv5pWbL7swCgYIKoZIzj0EAwMwgZYx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
	        'em9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTE5MTgxNjAxWhgPMjEyMTA1MTkxOTE2MDFaMIGWMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
	        'RFMgc2EtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
	        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjFOCZgTNVKxLKhUxffiDEvTLFhrmIqdO\n' +
	        'dKqVdgDoELEzIHWDdC+19aDPitbCYtBVHl65ITu/9pn6mMUl5hhUNtfZuc6A+Iw1\n' +
	        'sBe0v0qI3y9Q9HdQYrGgeHDh8M5P7E2ho0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
	        'A1UdDgQWBBS5L7/8M0TzoBZk39Ps7BkfTB4yJTAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
	        'KoZIzj0EAwMDaAAwZQIwI43O0NtWKTgnVv9z0LO5UMZYgSve7GvGTwqktZYCMObE\n' +
	        'rUI4QerXM9D6JwLy09mqAjEAypfkdLyVWtaElVDUyHFkihAS1I1oUxaaDrynLNQK\n' +
	        'Ou/Ay+ns+J+GyvyDUjBpVVW1\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/jCCA+agAwIBAgIQR71Z8lTO5Sj+as2jB7IWXzANBgkqhkiG9w0BAQwFADCB\n' +
	        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
	        'bWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTI0MjIwMzIwWhgPMjEyMTA1MjQyMzAzMjBaMIGXMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
	        'biBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAM977bHIs1WJijrS\n' +
	        'XQMfUOhmlJjr2v0K0UjPl52sE1TJ76H8umo1yR4T7Whkd9IwBHNGKXCJtJmMr9zp\n' +
	        'fB38eLTu+5ydUAXdFuZpRMKBWwPVe37AdJRKqn5beS8HQjd3JXAgGKUNNuE92iqF\n' +
	        'qi2fIqFMpnJXWo0FIW6s2Dl2zkORd7tH0DygcRi7lgVxCsw1BJQhFJon3y+IV8/F\n' +
	        'bnbUXSNSDUnDW2EhvWSD8L+t4eiXYsozhDAzhBvojpxhPH9OB7vqFYw5qxFx+G0t\n' +
	        'lSLX5iWi1jzzc3XyGnB6WInZDVbvnvJ4BGZ+dTRpOCvsoMIn9bz4EQTvu243c7aU\n' +
	        'HbS/kvnCASNt+zk7C6lbmaq0AGNztwNj85Opn2enFciWZVnnJ/4OeefUWQxD0EPp\n' +
	        'SjEd9Cn2IHzkBZrHCg+lWZJQBKbUVS0lLIMSsLQQ6WvR38jY7D2nxM1A93xWxwpt\n' +
	        'ZtQnYRCVXH6zt2OwDAFePInWwxUjR5t/wu3XxPgpSfrmTi3WYtr1wFypAJ811e/P\n' +
	        'yBtswWUQ6BNJQvy+KnOEeGfOwmtdDFYR+GOCfvCihzrKJrxOtHIieehR5Iw3cbXG\n' +
	        'sm4pDzfMUVvDDz6C2M6PRlJhhClbatHCjik9hxFYEsAlqtVVK9pxaz9i8hOqSFQq\n' +
	        'kJSQsgWw+oM/B2CyjcSqkSQEu8RLAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
	        'HQYDVR0OBBYEFPmrdxpRRgu3IcaB5BTqlprcKdTsMA4GA1UdDwEB/wQEAwIBhjAN\n' +
	        'BgkqhkiG9w0BAQwFAAOCAgEAVdlxWjPvVKky3kn8ZizeM4D+EsLw9dWLau2UD/ls\n' +
	        'zwDCFoT6euagVeCknrn+YEl7g20CRYT9iaonGoMUPuMR/cdtPL1W/Rf40PSrGf9q\n' +
	        'QuxavWiHLEXOQTCtCaVZMokkvjuuLNDXyZnstgECuiZECTwhexUF4oiuhyGk9o01\n' +
	        'QMaiz4HX4lgk0ozALUvEzaNd9gWEwD2qe+rq9cQMTVq3IArUkvTIftZUaVUMzr0O\n' +
	        'ed1+zAsNa9nJhURJ/6anJPJjbQgb5qA1asFcp9UaMT1ku36U3gnR1T/BdgG2jX3X\n' +
	        'Um0UcaGNVPrH1ukInWW743pxWQb7/2sumEEMVh+jWbB18SAyLI4WIh4lkurdifzS\n' +
	        'IuTFp8TEx+MouISFhz/vJDWZ84tqoLVjkEcP6oDypq9lFoEzHDJv3V1CYcIgOusT\n' +
	        'k1jm9P7BXdTG7TYzUaTb9USb6bkqkD9EwJAOSs7DI94aE6rsSws2yAHavjAMfuMZ\n' +
	        'sDAZvkqS2Qg2Z2+CI6wUZn7mzkJXbZoqRjDvChDXEB1mIhzVXhiNW/CR5WKVDvlj\n' +
	        '9v1sdGByh2pbxcLQtVaq/5coM4ANgphoNz3pOYUPWHS+JUrIivBZ+JobjXcxr3SN\n' +
	        '9iDzcu5/FVVNbq7+KN/nvPMngT+gduEN5m+EBjm8GukJymFG0m6BENRA0QSDqZ7k\n' +
	        'zDY=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgIRAK5EYG3iHserxMqgg+0EFjgwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyMzE2WhgPMjA2MTA1MjQyMTIzMTZa\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
	        's1L6TtB84LGraLHVC+rGPhLBW2P0oN/91Rq3AnYwqDOuTom7agANwEjvLq7dSRG/\n' +
	        'sIfZsSV/ABTgArZ5sCmLjHFZAo8Kd45yA9byx20RcYtAG8IZl+q1Cri+s0XefzyO\n' +
	        'U6mlfXZkVe6lzjlfXBkrlE/+5ifVbJK4dqOS1t9cWIpgKqv5fbE6Qbq4LVT+5/WM\n' +
	        'Vd2BOljuBMGMzdZubqFKFq4mzTuIYfnBm7SmHlZfTdfBYPP1ScNuhpjuzw4n3NCR\n' +
	        'EdU6dQv04Q6th4r7eiOCwbWI9LkmVbvBe3ylhH63lApC7MiiPYLlB13xBubVHVhV\n' +
	        'q1NHoNTi+zA3MN9HWicRxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
	        'DgQWBBSuxoqm0/wjNiZLvqv+JlQwsDvTPDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBAFfTK/j5kv90uIbM8VaFdVbr/6weKTwehafT0pAk1bfLVX+7\n' +
	        'uf8oHgYiyKTTl0DFQicXejghXTeyzwoEkWSR8c6XkhD5vYG3oESqmt/RGvvoxz11\n' +
	        'rHHy7yHYu7RIUc3VQG60c4qxXv/1mWySGwVwJrnuyNT9KZXPevu3jVaWOVHEILaK\n' +
	        'HvzQ2YEcWBPmde/zEseO2QeeGF8FL45Q1d66wqIP4nNUd2pCjeTS5SpB0MMx7yi9\n' +
	        'ki1OH1pv8tOuIdimtZ7wkdB8+JSZoaJ81b8sRrydRwJyvB88rftuI3YB4WwGuONT\n' +
	        'ZezUPsmaoK69B0RChB0ofDpAaviF9V3xOWvVZfo=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGDzCCA/egAwIBAgIRAI0sMNG2XhaBMRN3zD7ZyoEwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv\n' +
	        'QW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzEx\n' +
	        'EDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA1NzUwWhgPMjEyMTA1MTgyMTU3\n' +
	        'NTBaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n' +
	        'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV\n' +
	        'BAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2\n' +
	        'IEcxMRAwDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC\n' +
	        'CgKCAgEAh/otSiCu4Uw3hu7OJm0PKgLsLRqBmUS6jihcrkxfN2SHmp2zuRflkweU\n' +
	        'BhMkebzL+xnNvC8okzbgPWtUxSmDnIRhE8J7bvSKFlqs/tmEdiI/LMqe/YIKcdsI\n' +
	        '20UYmvyLIjtDaJIh598SHHlF9P8DB5jD8snJfhxWY+9AZRN+YVTltgQAAgayxkWp\n' +
	        'M1BbvxpOnz4CC00rE0eqkguXIUSuobb1vKqdKIenlYBNxm2AmtgvQfpsBIQ0SB+8\n' +
	        '8Zip8Ef5rtjSw5J3s2Rq0aYvZPfCVIsKYepIboVwXtD7E9J31UkB5onLBQlaHaA6\n' +
	        'XlH4srsMmrew5d2XejQGy/lGZ1nVWNsKO0x/Az2QzY5Kjd6AlXZ8kq6H68hscA5i\n' +
	        'OMbNlXzeEQsZH0YkId3+UsEns35AAjZv4qfFoLOu8vDotWhgVNT5DfdbIWZW3ZL8\n' +
	        'qbmra3JnCHuaTwXMnc25QeKgVq7/rG00YB69tCIDwcf1P+tFJWxvaGtV0g2NthtB\n' +
	        'a+Xo09eC0L53gfZZ3hZw1pa3SIF5dIZ6RFRUQ+lFOux3Q/I3u+rYstYw7Zxc4Zeo\n' +
	        'Y8JiedpQXEAnbw2ECHix/L6mVWgiWCiDzBnNLLdbmXjJRnafNSndSfFtHCnY1SiP\n' +
	        'aCrNpzwZIJejoV1zDlWAMO+gyS28EqzuIq3WJK/TFE7acHkdKIcCAwEAAaNCMEAw\n' +
	        'DwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUrmV1YASnuudfmqAZP4sKGTvScaEw\n' +
	        'DgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBGpEKeQoPvE85tN/25\n' +
	        'qHFkys9oHDl93DZ62EnOqAUKLd6v0JpCyEiop4nlrJe+4KrBYVBPyKOJDcIqE2Sp\n' +
	        '3cvgJXLhY4i46VM3Qxe8yuYF1ElqBpg3jJVj/sCQnYz9dwoAMWIJFaDWOvmU2E7M\n' +
	        'MRaKx+sPXFkIjiDA6Bv0m+VHef7aedSYIY7IDltEQHuXoqNacGrYo3I50R+fZs88\n' +
	        '/mB3e/V7967e99D6565yf9Lcjw4oQf2Hy7kl/6P9AuMz0LODnGITwh2TKk/Zo3RU\n' +
	        'Vgq25RDrT4xJK6nFHyjUF6+4cOBxVpimmFw/VP1zaXT8DN5r4HyJ9p4YuSK8ha5N\n' +
	        '2pJc/exvU8Nv2+vS/efcDZWyuEdZ7eh1IJWQZlOZKIAONfRDRTpeQHJ3zzv3QVYy\n' +
	        't78pYp/eWBHyVIfEE8p2lFKD4279WYe+Uvdb8c4Jm4TJwqkSJV8ifID7Ub80Lsir\n' +
	        'lPAU3OCVTBeVRFPXT2zpC4PB4W6KBSuj6OOcEu2y/HgWcoi7Cnjvp0vFTUhDFdus\n' +
	        'Wz3ucmJjfVsrkEO6avDKu4SwdbVHsk30TVAwPd6srIdi9U6MOeOQSOSE4EsrrS7l\n' +
	        'SVmu2QIDUVFpm8QAHYplkyWIyGkupyl3ashH9mokQhixIU/Pzir0byePxHLHrwLu\n' +
	        '1axqeKpI0F5SBUPsaVNYY2uNFg==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECDCCAvCgAwIBAgIQCREfzzVyDTMcNME+gWnTCTANBgkqhkiG9w0BAQsFADCB\n' +
	        'nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\n' +
	        'bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4G\n' +
	        'A1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQyMzNaGA8yMDYxMDUyNDIxNDIzM1ow\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDL\n' +
	        '1MT6br3L/4Pq87DPXtcjlXN3cnbNk2YqRAZHJayStTz8VtsFcGPJOpk14geRVeVk\n' +
	        'e9uKFHRbcyr/RM4owrJTj5X4qcEuATYZbo6ou/rW2kYzuWFZpFp7lqm0vasV4Z9F\n' +
	        'fChlhwkNks0UbM3G+psCSMNSoF19ERunj7w2c4E62LwujkeYLvKGNepjnaH10TJL\n' +
	        '2krpERd+ZQ4jIpObtRcMH++bTrvklc+ei8W9lqrVOJL+89v2piN3Ecdd389uphst\n' +
	        'qQdb1BBVXbhUrtuGHgVf7zKqN1SkCoktoWxVuOprVWhSvr7akaWeq0UmlvbEsujU\n' +
	        'vADqxGMcJFyCzxx3CkJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O\n' +
	        'BBYEFFk8UJmlhoxFT3PP12PvhvazHjT4MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG\n' +
	        '9w0BAQsFAAOCAQEAfFtr2lGoWVXmWAsIo2NYre7kzL8Xb9Tx7desKxCCz5HOOvIr\n' +
	        '8JMB1YK6A7IOvQsLJQ/f1UnKRh3X3mJZjKIywfrMSh0FiDf+rjcEzXxw2dGtUem4\n' +
	        'A+WMvIA3jwxnJ90OQj5rQ8bg3iPtE6eojzo9vWQGw/Vu48Dtw1DJo9210Lq/6hze\n' +
	        'hPhNkFh8fMXNT7Q1Wz/TJqJElyAQGNOXhyGpHKeb0jHMMhsy5UNoW5hLeMS5ffao\n' +
	        'TBFWEJ1gVfxIU9QRxSh+62m46JIg+dwDlWv8Aww14KgepspRbMqDuaM2cinoejv6\n' +
	        't3dyOyHHrsOyv3ffZUKtQhQbQr+sUcL89lARsg==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/zCCAuegAwIBAgIRAIJLTMpzGNxqHZ4t+c1MlCIwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyBhcC1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyNTIxMzAzM1oYDzIwNjEwNTI1MjIzMDMzWjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDtdHut0ZhJ9Nn2\n' +
	        'MpVafFcwHdoEzx06okmmhjJsNy4l9QYVeh0UUoek0SufRNMRF4d5ibzpgZol0Y92\n' +
	        '/qKWNe0jNxhEj6sXyHsHPeYtNBPuDMzThfbvsLK8z7pBP7vVyGPGuppqW/6m4ZBB\n' +
	        'lcc9fsf7xpZ689iSgoyjiT6J5wlVgmCx8hFYc/uvcRtfd8jAHvheug7QJ3zZmIye\n' +
	        'V4htOW+fRVWnBjf40Q+7uTv790UAqs0Zboj4Yil+hER0ibG62y1g71XcCyvcVpto\n' +
	        '2/XW7Y9NCgMNqQ7fGN3wR1gjtSYPd7DO32LTzYhutyvfbpAZjsAHnoObmoljcgXI\n' +
	        'QjfBcCFpAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJI3aWLg\n' +
	        'CS5xqU5WYVaeT5s8lpO0MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
	        'AQEAUwATpJOcGVOs3hZAgJwznWOoTzOVJKfrqBum7lvkVH1vBwxBl9CahaKj3ZOt\n' +
	        'YYp2qJzhDUWludL164DL4ZjS6eRedLRviyy5cRy0581l1MxPWTThs27z+lCC14RL\n' +
	        'PJZNVYYdl7Jy9Q5NsQ0RBINUKYlRY6OqGDySWyuMPgno2GPbE8aynMdKP+f6G/uE\n' +
	        'YHOf08gFDqTsbyfa70ztgVEJaRooVf5JJq4UQtpDvVswW2reT96qi6tXPKHN5qp3\n' +
	        '3wI0I1Mp4ePmiBKku2dwYzPfrJK/pQlvu0Gu5lKOQ65QdotwLAAoaFqrf9za1yYs\n' +
	        'INUkHLWIxDds+4OHNYcerGp5Dw==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGCTCCA/GgAwIBAgIRAIO6ldra1KZvNWJ0TA1ihXEwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjE0NTA1WhgPMjEyMTA1MjEyMjQ1MDVa\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
	        'sDN52Si9pFSyZ1ruh3xAN0nVqEs960o2IK5CPu/ZfshFmzAwnx/MM8EHt/jMeZtj\n' +
	        'SM58LADAsNDL01ELpFZATjgZQ6xNAyXRXE7RiTRUvNkK7O3o2qAGbLnJq/UqF7Sw\n' +
	        'LRnB8V6hYOv+2EjVnohtGCn9SUFGZtYDjWXsLd4ML4Zpxv0a5LK7oEC7AHzbUR7R\n' +
	        'jsjkrXqSv7GE7bvhSOhMkmgxgj1F3J0b0jdQdtyyj109aO0ATUmIvf+Bzadg5AI2\n' +
	        'A9UA+TUcGeebhpHu8AP1Hf56XIlzPpaQv3ZJ4vzoLaVNUC7XKzAl1dlvCl7Klg/C\n' +
	        '84qmbD/tjZ6GHtzpLKgg7kQEV7mRoXq8X4wDX2AFPPQl2fv+Kbe+JODqm5ZjGegm\n' +
	        'uskABBi8IFv1hYx9jEulZPxC6uD/09W2+niFm3pirnlWS83BwVDTUBzF+CooUIMT\n' +
	        'jhWkIIZGDDgMJTzouBHfoSJtS1KpUZi99m2WyVs21MNKHeWAbs+zmI6TO5iiMC+T\n' +
	        'uB8spaOiHFO1573Fmeer4sy3YA6qVoqVl6jjTQqOdy3frAMbCkwH22/crV8YA+08\n' +
	        'hLeHXrMK+6XUvU+EtHAM3VzcrLbuYJUI2XJbzTj5g0Eb8I8JWsHvWHR5K7Z7gceR\n' +
	        '78AzxQmoGEfV6KABNWKsgoCQnfb1BidDJIe3BsI0A6UCAwEAAaNCMEAwDwYDVR0T\n' +
	        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQUABp0MlB14MSHgAcuNSOhs3MOlUcwDgYDVR0P\n' +
	        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCv4CIOBSQi/QR9NxdRgVAG/pAh\n' +
	        'tFJhV7OWb/wqwsNKFDtg6tTxwaahdCfWpGWId15OUe7G9LoPiKiwM9C92n0ZeHRz\n' +
	        '4ewbrQVo7Eu1JI1wf0rnZJISL72hVYKmlvaWaacHhWxvsbKLrB7vt6Cknxa+S993\n' +
	        'Kf8i2Psw8j5886gaxhiUtzMTBwoDWak8ZaK7m3Y6C6hXQk08+3pnIornVSFJ9dlS\n' +
	        'PAqt5UPwWmrEfF+0uIDORlT+cvrAwgSp7nUF1q8iasledycZ/BxFgQqzNwnkBDwQ\n' +
	        'Z/aM52ArGsTzfMhkZRz9HIEhz1/0mJw8gZtDVQroD8778h8zsx2SrIz7eWQ6uWsD\n' +
	        'QEeSWXpcheiUtEfzkDImjr2DLbwbA23c9LoexUD10nwohhoiQQg77LmvBVxeu7WU\n' +
	        'E63JqaYUlOLOzEmNJp85zekIgR8UTkO7Gc+5BD7P4noYscI7pPOL5rP7YLg15ZFi\n' +
	        'ega+G53NTckRXz4metsd8XFWloDjZJJq4FfD60VuxgXzoMNT9wpFTNSH42PR2s9L\n' +
	        'I1vcl3w8yNccs9se2utM2nLsItZ3J0m/+QSRiw9hbrTYTcM9sXki0DtH2kyIOwYf\n' +
	        'lOrGJDiYOIrXSQK36H0gQ+8omlrUTvUj4msvkXuQjlfgx6sgp2duOAfnGxE7uHnc\n' +
	        'UhnJzzoe6M+LfGHkVQ==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICuDCCAj2gAwIBAgIQSAG6j2WHtWUUuLGJTPb1nTAKBggqhkjOPQQDAzCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyMDE2MzgyNloYDzIxMjEwNTIwMTczODI2WjCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE2eqwU4FOzW8RV1W381Bd\n' +
	        'olhDOrqoMqzWli21oDUt7y8OnXM/lmAuOS6sr8Nt61BLVbONdbr+jgCYw75KabrK\n' +
	        'ZGg3siqvMOgabIKkKuXO14wtrGyGDt7dnKXg5ERGYOZlo0IwQDAPBgNVHRMBAf8E\n' +
	        'BTADAQH/MB0GA1UdDgQWBBS1Acp2WYxOcblv5ikZ3ZIbRCCW+zAOBgNVHQ8BAf8E\n' +
	        'BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAJL84J08PBprxmsAKPTotBuVI3MyW1r8\n' +
	        'xQ0i8lgCQUf8GcmYjQ0jI4oZyv+TuYJAcwIxAP9Xpzq0Docxb+4N1qVhpiOfWt1O\n' +
	        'FnemFiy9m1l+wv6p3riQMPV7mBVpklmijkIv3Q==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgIRALZLcqCVIJ25maDPE3sbPCIwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjEzOTM5WhgPMjA2MTA1MjEyMjM5Mzla\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
	        'ypKc+6FfGx6Gl6fQ78WYS29QoKgQiur58oxR3zltWeg5fqh9Z85K5S3UbRSTqWWu\n' +
	        'Xcfnkz0/FS07qHX+nWAGU27JiQb4YYqhjZNOAq8q0+ptFHJ6V7lyOqXBq5xOzO8f\n' +
	        '+0DlbJSsy7GEtJp7d7QCM3M5KVY9dENVZUKeJwa8PC5StvwPx4jcLeZRJC2rAVDG\n' +
	        'SW7NAInbATvr9ssSh03JqjXb+HDyywiqoQ7EVLtmtXWimX+0b3/2vhqcH5jgcKC9\n' +
	        'IGFydrjPbv4kwMrKnm6XlPZ9L0/3FMzanXPGd64LQVy51SI4d5Xymn0Mw2kMX8s6\n' +
	        'Nf05OsWcDzJ1n6/Q1qHSxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
	        'DgQWBBRmaIc8eNwGP7i6P7AJrNQuK6OpFzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBAIBeHfGwz3S2zwIUIpqEEI5/sMySDeS+3nJR+woWAHeO0C8i\n' +
	        'BJdDh+kzzkP0JkWpr/4NWz84/IdYo1lqASd1Kopz9aT1+iROXaWr43CtbzjXb7/X\n' +
	        'Zv7eZZFC8/lS5SROq42pPWl4ekbR0w8XGQElmHYcWS41LBfKeHCUwv83ATF0XQ6I\n' +
	        '4t+9YSqZHzj4vvedrvcRInzmwWJaal9s7Z6GuwTGmnMsN3LkhZ+/GD6oW3pU/Pyh\n' +
	        'EtWqffjsLhfcdCs3gG8x9BbkcJPH5aPAVkPn4wc8wuXg6xxb9YGsQuY930GWTYRf\n' +
	        'schbgjsuqznW4HHakq4WNhs1UdTSTKkRdZz7FUQ=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEDzCCAvegAwIBAgIRAM2zAbhyckaqRim63b+Tib8wDQYJKoZIhvcNAQELBQAw\n' +
	        'gZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv\n' +
	        'QW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzEx\n' +
	        'EDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA0OTQ1WhgPMjA2MTA1MTgyMTQ5\n' +
	        'NDVaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\n' +
	        'cywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV\n' +
	        'BAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4\n' +
	        'IEcxMRAwDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n' +
	        'CgKCAQEA1ybjQMH1MkbvfKsWJaCTXeCSN1SG5UYid+Twe+TjuSqaXWonyp4WRR5z\n' +
	        'tlkqq+L2MWUeQQAX3S17ivo/t84mpZ3Rla0cx39SJtP3BiA2BwfUKRjhPwOjmk7j\n' +
	        '3zrcJjV5k1vSeLNOfFFSlwyDiVyLAE61lO6onBx+cRjelu0egMGq6WyFVidTdCmT\n' +
	        'Q9Zw3W6LTrnPvPmEyjHy2yCHzH3E50KSd/5k4MliV4QTujnxYexI2eR8F8YQC4m3\n' +
	        'DYjXt/MicbqA366SOoJA50JbgpuVv62+LSBu56FpzY12wubmDZsdn4lsfYKiWxUy\n' +
	        'uc83a2fRXsJZ1d3whxrl20VFtLFHFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
	        'MB0GA1UdDgQWBBRC0ytKmDYbfz0Bz0Psd4lRQV3aNTAOBgNVHQ8BAf8EBAMCAYYw\n' +
	        'DQYJKoZIhvcNAQELBQADggEBAGv8qZu4uaeoF6zsbumauz6ea6tdcWt+hGFuwGrb\n' +
	        'tRbI85ucAmVSX06x59DJClsb4MPhL1XmqO3RxVMIVVfRwRHWOsZQPnXm8OYQ2sny\n' +
	        'rYuFln1COOz1U/KflZjgJmxbn8x4lYiTPZRLarG0V/OsCmnLkQLPtEl/spMu8Un7\n' +
	        'r3K8SkbWN80gg17Q8EV5mnFwycUx9xsTAaFItuG0en9bGsMgMmy+ZsDmTRbL+lcX\n' +
	        'Fq8r4LT4QjrFz0shrzCwuuM4GmcYtBSxlacl+HxYEtAs5k10tmzRf6OYlY33tGf6\n' +
	        '1tkYvKryxDPF/EDgGp/LiBwx6ixYMBfISoYASt4V/ylAlHA=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICtTCCAjqgAwIBAgIRAK9BSZU6nIe6jqfODmuVctYwCgYIKoZIzj0EAwMwgZkx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\n' +
	        'em9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTIxMjIxMzA5WhgPMjEyMTA1MjEyMzEzMDlaMIGZMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\n' +
	        'biBSRFMgY2EtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEUkEERcgxneT5H+P+fERcbGmf\n' +
	        'bVx+M7rNWtgWUr6w+OBENebQA9ozTkeSg4c4M+qdYSObFqjxITdYxT1z/nHz1gyx\n' +
	        'OKAhLjWu+nkbRefqy3RwXaWT680uUaAP6ccnkZOMo0IwQDAPBgNVHRMBAf8EBTAD\n' +
	        'AQH/MB0GA1UdDgQWBBSN6fxlg0s5Wny08uRBYZcQ3TUoyzAOBgNVHQ8BAf8EBAMC\n' +
	        'AYYwCgYIKoZIzj0EAwMDaQAwZgIxAORaz+MBVoFBTmZ93j2G2vYTwA6T5hWzBWrx\n' +
	        'CrI54pKn5g6At56DBrkjrwZF5T1enAIxAJe/LZ9xpDkAdxDgGJFN8gZYLRWc0NRy\n' +
	        'Rb4hihy5vj9L+w9uKc9VfEBIFuhT7Z3ljg==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEADCCAuigAwIBAgIQB/57HSuaqUkLaasdjxUdPjANBgkqhkiG9w0BAQsFADCB\n' +
	        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
	        'bWF6b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUxOTE3NDAzNFoYDzIwNjEwNTE5MTg0MDM0WjCBmDEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtbkaoVsUS76o\n' +
	        'TgLFmcnaB8cswBk1M3Bf4IVRcwWT3a1HeJSnaJUqWHCJ+u3ip/zGVOYl0gN1MgBb\n' +
	        'MuQRIJiB95zGVcIa6HZtx00VezDTr3jgGWRHmRjNVCCHGmxOZWvJjsIE1xavT/1j\n' +
	        'QYV/ph4EZEIZ/qPq7e3rHohJaHDe23Z7QM9kbyqp2hANG2JtU/iUhCxqgqUHNozV\n' +
	        'Zd0l5K6KnltZQoBhhekKgyiHqdTrH8fWajYl5seD71bs0Axowb+Oh0rwmrws3Db2\n' +
	        'Dh+oc2PwREnjHeca9/1C6J2vhY+V0LGaJmnnIuOANrslx2+bgMlyhf9j0Bv8AwSi\n' +
	        'dSWsobOhNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQb7vJT\n' +
	        'VciLN72yJGhaRKLn6Krn2TAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
	        'ggEBAAxEj8N9GslReAQnNOBpGl8SLgCMTejQ6AW/bapQvzxrZrfVOZOYwp/5oV0f\n' +
	        '9S1jcGysDM+DrmfUJNzWxq2Y586R94WtpH4UpJDGqZp+FuOVJL313te4609kopzO\n' +
	        'lDdmd+8z61+0Au93wB1rMiEfnIMkOEyt7D2eTFJfJRKNmnPrd8RjimRDlFgcLWJA\n' +
	        '3E8wca67Lz/G0eAeLhRHIXv429y8RRXDtKNNz0wA2RwURWIxyPjn1fHjA9SPDkeW\n' +
	        'E1Bq7gZj+tBnrqz+ra3yjZ2blss6Ds3/uRY6NYqseFTZWmQWT7FolZEnT9vMUitW\n' +
	        'I0VynUbShVpGf6946e0vgaaKw20=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/jCCAuagAwIBAgIQGyUVTaVjYJvWhroVEiHPpDANBgkqhkiG9w0BAQsFADCB\n' +
	        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
	        'bWF6b24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTE5MTkwNDA2WhgPMjA2MTA1MTkyMDA0MDZaMIGXMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
	        'biBSRFMgdXMtd2VzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANhyXpJ0t4nigRDZ\n' +
	        'EwNtFOem1rM1k8k5XmziHKDvDk831p7QsX9ZOxl/BT59Pu/P+6W6SvasIyKls1sW\n' +
	        'FJIjFF+6xRQcpoE5L5evMgN/JXahpKGeQJPOX9UEXVW5B8yi+/dyUitFT7YK5LZA\n' +
	        'MqWBN/LtHVPa8UmE88RCDLiKkqiv229tmwZtWT7nlMTTCqiAHMFcryZHx0pf9VPh\n' +
	        'x/iPV8p2gBJnuPwcz7z1kRKNmJ8/cWaY+9w4q7AYlAMaq/rzEqDaN2XXevdpsYAK\n' +
	        'TMMj2kji4x1oZO50+VPNfBl5ZgJc92qz1ocF95SAwMfOUsP8AIRZkf0CILJYlgzk\n' +
	        '/6u6qZECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm5jfcS9o\n' +
	        '+LwL517HpB6hG+PmpBswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\n' +
	        'AQAcQ6lsqxi63MtpGk9XK8mCxGRLCad51+MF6gcNz6i6PAqhPOoKCoFqdj4cEQTF\n' +
	        'F8dCfa3pvfJhxV6RIh+t5FCk/y6bWT8Ls/fYKVo6FhHj57bcemWsw/Z0XnROdVfK\n' +
	        'Yqbc7zvjCPmwPHEqYBhjU34NcY4UF9yPmlLOL8uO1JKXa3CAR0htIoW4Pbmo6sA4\n' +
	        '6P0co/clW+3zzsQ92yUCjYmRNeSbdXbPfz3K/RtFfZ8jMtriRGuO7KNxp8MqrUho\n' +
	        'HK8O0mlSUxGXBZMNicfo7qY8FD21GIPH9w5fp5oiAl7lqFzt3E3sCLD3IiVJmxbf\n' +
	        'fUwpGd1XZBBSdIxysRLM6j48\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrTCCAjOgAwIBAgIQU+PAILXGkpoTcpF200VD/jAKBggqhkjOPQQDAzCBljEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\n' +
	        'b24gUkRTIGFwLWVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTAgFw0yMTA1MjUyMTQ1MTFaGA8yMTIxMDUyNTIyNDUxMVowgZYxCzAJBgNV\n' +
	        'BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\n' +
	        'VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\n' +
	        'UyBhcC1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\n' +
	        'djAQBgcqhkjOPQIBBgUrgQQAIgNiAAT3tFKE8Kw1sGQAvNLlLhd8OcGhlc7MiW/s\n' +
	        'NXm3pOiCT4vZpawKvHBzD76Kcv+ZZzHRxQEmG1/muDzZGlKR32h8AAj+NNO2Wy3d\n' +
	        'CKTtYMiVF6Z2zjtuSkZQdjuQbe4eQ7qjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\n' +
	        'VR0OBBYEFAiSQOp16Vv0Ohpvqcbd2j5RmhYNMA4GA1UdDwEB/wQEAwIBhjAKBggq\n' +
	        'hkjOPQQDAwNoADBlAjBVsi+5Ape0kOhMt/WFkANkslD4qXA5uqhrfAtH29Xzz2NV\n' +
	        'tR7akiA771OaIGB/6xsCMQCZt2egCtbX7J0WkuZ2KivTh66jecJr5DHvAP4X2xtS\n' +
	        'F/5pS+AUhcKTEGjI9jDH3ew=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICuDCCAj2gAwIBAgIQT5mGlavQzFHsB7hV6Mmy6TAKBggqhkjOPQQDAzCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyNDIwNTAxNVoYDzIxMjEwNTI0MjE1MDE1WjCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEcm4BBBjYK7clwm0HJRWS\n' +
	        'flt3iYwoJbIXiXn9c1y3E+Vb7bmuyKhS4eO8mwO4GefUcXObRfoHY2TZLhMJLVBQ\n' +
	        '7MN2xDc0RtZNj07BbGD3VAIFRTDX0mH9UNYd0JQM3t/Oo0IwQDAPBgNVHRMBAf8E\n' +
	        'BTADAQH/MB0GA1UdDgQWBBRrd5ITedfAwrGo4FA9UaDaGFK3rjAOBgNVHQ8BAf8E\n' +
	        'BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAPBNqmVv1IIA3EZyQ6XuVf4gj79/DMO8\n' +
	        'bkicNS1EcBpUqbSuU4Zwt2BYc8c/t7KVOQIxAOHoWkoKZPiKyCxfMtJpCZySUG+n\n' +
	        'sXgB/LOyWE5BJcXUfm+T1ckeNoWeUUMOLmnJjg==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgIRAJcDeinvdNrDQBeJ8+t38WQwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY0OTE2WhgPMjA2MjA1MjUxNzQ5MTZa\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
	        'k8DBNkr9tMoIM0NHoFiO7cQfSX0cOMhEuk/CHt0fFx95IBytx7GHCnNzpM27O5z6\n' +
	        'x6iRhfNnx+B6CrGyCzOjxvPizneY+h+9zfvNz9jj7L1I2uYMuiNyOKR6FkHR46CT\n' +
	        '1CiArfVLLPaTqgD/rQjS0GL2sLHS/0dmYipzynnZcs613XT0rAWdYDYgxDq7r/Yi\n' +
	        'Xge5AkWQFkMUq3nOYDLCyGGfQqWKkwv6lZUHLCDKf+Y0Uvsrj8YGCI1O8mF0qPCQ\n' +
	        'lmlfaDvbuBu1AV+aabmkvyFj3b8KRIlNLEtQ4N8KGYR2Jdb82S4YUGIOAt4wuuFt\n' +
	        '1B7AUDLk3V/u+HTWiwfoLQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
	        'DgQWBBSNpcjz6ArWBtAA+Gz6kyyZxrrgdDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBAGJEd7UgOzHYIcQRSF7nSYyjLROyalaIV9AX4WXW/Cqlul1c\n' +
	        'MblP5etDZm7A/thliZIWAuyqv2bNicmS3xKvNy6/QYi1YgxZyy/qwJ3NdFl067W0\n' +
	        't8nGo29B+EVK94IPjzFHWShuoktIgp+dmpijB7wkTIk8SmIoe9yuY4+hzgqk+bo4\n' +
	        'ms2SOXSN1DoQ75Xv+YmztbnZM8MuWhL1T7hA4AMorzTQLJ9Pof8SpSdMHeDsHp0R\n' +
	        '01jogNFkwy25nw7cL62nufSuH2fPYGWXyNDg+y42wKsKWYXLRgUQuDVEJ2OmTFMB\n' +
	        'T0Vf7VuNijfIA9hkN2d3K53m/9z5WjGPSdOjGhg=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/jCCAuagAwIBAgIQRiwspKyrO0xoxDgSkqLZczANBgkqhkiG9w0BAQsFADCB\n' +
	        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
	        'bWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTI0MjE1OTAwWhgPMjA2MTA1MjQyMjU5MDBaMIGXMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
	        'biBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL53Jk3GsKiu+4bx\n' +
	        'jDfsevWbwPCNJ3H08Zp7GWhvI3Tgi39opfHYv2ku2BKFjK8N2L6RvNPSR8yplv5j\n' +
	        'Y0tK0U+XVNl8o0ibhqRDhbTuh6KL8CFINWYzAajuxFS+CF0U6c1Q3tXLBdALxA7l\n' +
	        'FlXJ71QrP06W31kRe7kvgrvO7qWU3/OzUf9qYw4LSiR1/VkvvRCTqcVNw09clw/M\n' +
	        'Jbw6FSgweN65M9j7zPbjGAXSHkXyxH1Erin2fa+B9PE4ZDgX9cp2C1DHewYJQL/g\n' +
	        'SepwwcudVNRN1ibKH7kpMrgPnaNIVNx5sXVsTjk6q2ZqYw3SVHegltJpLy/cZReP\n' +
	        'mlivF2kCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUmTcQd6o1\n' +
	        'CuS65MjBrMwQ9JJjmBwwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\n' +
	        'AQAKSDSIzl956wVddPThf2VAzI8syw9ngSwsEHZvxVGHBvu5gg618rDyguVCYX9L\n' +
	        '4Kw/xJrk6S3qxOS2ZDyBcOpsrBskgahDFIunzoRP3a18ARQVq55LVgfwSDQiunch\n' +
	        'Bd05cnFGLoiLkR5rrkgYaP2ftn3gRBRaf0y0S3JXZ2XB3sMZxGxavYq9mfiEcwB0\n' +
	        'LMTMQ1NYzahIeG6Jm3LqRqR8HkzP/Ztq4dT2AtSLvFebbNMiWqeqT7OcYp94HTYT\n' +
	        'zqrtaVdUg9bwyAUCDgy0GV9RHDIdNAOInU/4LEETovrtuBU7Z1q4tcHXvN6Hd1H8\n' +
	        'gMb0mCG5I393qW5hFsA/diFb\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgIRAPQAvihfjBg/JDbj6U64K98wDQYJKoZIhvcNAQELBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYyODQxWhgPMjA2MTA1MjAxNzI4NDFa\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
	        'vJ9lgyksCxkBlY40qOzI1TCj/Q0FVGuPL/Z1Mw2YN0l+41BDv0FHApjTUkIKOeIP\n' +
	        'nwDwpXTa3NjYbk3cOZ/fpH2rYJ++Fte6PNDGPgKppVCUh6x3jiVZ1L7wOgnTdK1Q\n' +
	        'Trw8440IDS5eLykRHvz8OmwvYDl0iIrt832V0QyOlHTGt6ZJ/aTQKl12Fy3QBLv7\n' +
	        'stClPzvHTrgWqVU6uidSYoDtzHbU7Vda7YH0wD9IUoMBf7Tu0rqcE4uH47s2XYkc\n' +
	        'SdLEoOg/Ngs7Y9B1y1GCyj3Ux7hnyvCoRTw014QyNB7dTatFMDvYlrRDGG14KeiU\n' +
	        'UL7Vo/+EejWI31eXNLw84wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
	        'DgQWBBQkgTWFsNg6wA3HbbihDQ4vpt1E2zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBAGz1Asiw7hn5WYUj8RpOCzpE0h/oBZcnxP8wulzZ5Xd0YxWO\n' +
	        '0jYUcUk3tTQy1QvoY+Q5aCjg6vFv+oFBAxkib/SmZzp4xLisZIGlzpJQuAgRkwWA\n' +
	        '6BVMgRS+AaOMQ6wKPgz1x4v6T0cIELZEPq3piGxvvqkcLZKdCaeC3wCS6sxuafzZ\n' +
	        '4qA3zMwWuLOzRftgX2hQto7d/2YkRXga7jSvQl3id/EI+xrYoH6zIWgjdU1AUaNq\n' +
	        'NGT7DIo47vVMfnd9HFZNhREsd4GJE83I+JhTqIxiKPNxrKgESzyADmNPt0gXDnHo\n' +
	        'tbV1pMZz5HpJtjnP/qVZhEK5oB0tqlKPv9yx074=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICuTCCAj6gAwIBAgIRAKp1Rn3aL/g/6oiHVIXtCq8wCgYIKoZIzj0EAwMwgZsx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\n' +
	        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMTA1MjQyMDMyMTdaGA8yMTIxMDUyNDIxMzIxN1owgZsx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\n' +
	        'em9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABGTYWPILeBJXfcL3Dz4z\n' +
	        'EWMUq78xB1HpjBwHoTURYfcMd5r96BTVG6yaUBWnAVCMeeD6yTG9a1eVGNhG14Hk\n' +
	        'ZAEjgLiNB7RRbEG5JZ/XV7W/vODh09WCst2y9SLKsdgeAaNCMEAwDwYDVR0TAQH/\n' +
	        'BAUwAwEB/zAdBgNVHQ4EFgQUoE0qZHmDCDB+Bnm8GUa/evpfPwgwDgYDVR0PAQH/\n' +
	        'BAQDAgGGMAoGCCqGSM49BAMDA2kAMGYCMQCnil5MMwhY3qoXv0xvcKZGxGPaBV15\n' +
	        '0CCssCKn0oVtdJQfJQ3Jrf3RSaEyijXIJsoCMQC35iJi4cWoNX3N/qfgnHohW52O\n' +
	        'B5dg0DYMqy5cNZ40+UcAanRMyqNQ6P7fy3umGco=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICtzCCAj2gAwIBAgIQPXnDTPegvJrI98qz8WxrMjAKBggqhkjOPQQDAzCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUxODIxNDAxMloYDzIxMjEwNTE4MjI0MDEyWjCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEI0sR7gwutK5AB46hM761\n' +
	        'gcLTGBIYlURSEoM1jcBwy56CL+3CJKZwLLyJ7qoOKfWbu5GsVLUTWS8MV6Nw33cx\n' +
	        '2KQD2svb694wi+Px2f4n9+XHkEFQw8BbiodDD7RZA70fo0IwQDAPBgNVHRMBAf8E\n' +
	        'BTADAQH/MB0GA1UdDgQWBBTQSioOvnVLEMXwNSDg+zgln/vAkjAOBgNVHQ8BAf8E\n' +
	        'BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAMwu1hqm5Bc98uE/E0B5iMYbBQ4kpMxO\n' +
	        'tP8FTfz5UR37HUn26nXE0puj6S/Ffj4oJgIwXI7s2c26tFQeqzq6u3lrNJHp5jC9\n' +
	        'Uxlo/hEJOLoDj5jnpxo8dMAtCNoQPaHdfL0P\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjWgAwIBAgIQGKVv+5VuzEZEBzJ+bVfx2zAKBggqhkjOPQQDAzCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTE5MTc1MDU5WhgPMjEyMTA1MTkxODUwNTlaMIGXMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
	        'RFMgYXAtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
	        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABMqdLJ0tZF/DGFZTKZDrGRJZID8ivC2I\n' +
	        'JRCYTWweZKCKSCAzoiuGGHzJhr5RlLHQf/QgmFcgXsdmO2n3CggzhA4tOD9Ip7Lk\n' +
	        'P05eHd2UPInyPCHRgmGjGb0Z+RdQ6zkitKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
	        'BgNVHQ4EFgQUC1yhRgVqU5bR8cGzOUCIxRpl4EYwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
	        'CCqGSM49BAMDA2cAMGQCMG0c/zLGECRPzGKJvYCkpFTCUvdP4J74YP0v/dPvKojL\n' +
	        't/BrR1Tg4xlfhaib7hPc7wIwFvgqHes20CubQnZmswbTKLUrgSUW4/lcKFpouFd2\n' +
	        't2/ewfi/0VhkeUW+IiHhOMdU\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGCTCCA/GgAwIBAgIRAOXxJuyXVkbfhZCkS/dOpfEwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1OTEwWhgPMjEyMTA1MjUyMjU5MTBa\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
	        'xiP4RDYm4tIS12hGgn1csfO8onQDmK5SZDswUpl0HIKXOUVVWkHNlINkVxbdqpqH\n' +
	        'FhbyZmNN6F/EWopotMDKe1B+NLrjNQf4zefv2vyKvPHJXhxoKmfyuTd5Wk8k1F7I\n' +
	        'lNwLQzznB+ElhrLIDJl9Ro8t31YBBNFRGAGEnxyACFGcdkjlsa52UwfYrwreEg2l\n' +
	        'gW5AzqHgjFfj9QRLydeU/n4bHm0F1adMsV7P3rVwilcUlqsENDwXnWyPEyv3sw6F\n' +
	        'wNemLEs1129mB77fwvySb+lLNGsnzr8w4wdioZ74co+T9z2ca+eUiP+EQccVw1Is\n' +
	        'D4Fh57IjPa6Wuc4mwiUYKkKY63+38aCfEWb0Qoi+zW+mE9nek6MOQ914cN12u5LX\n' +
	        'dBoYopphRO5YmubSN4xcBy405nIdSdbrAVWwxXnVVyjqjknmNeqQsPZaxAhdoKhV\n' +
	        'AqxNr8AUAdOAO6Sz3MslmcLlDXFihrEEOeUbpg/m1mSUUHGbu966ajTG1FuEHHwS\n' +
	        '7WB52yxoJo/tHvt9nAWnh3uH5BHmS8zn6s6CGweWKbX5yICnZ1QFR1e4pogxX39v\n' +
	        'XD6YcNOO+Vn+HY4nXmjgSYVC7l+eeP8eduMg1xJujzjrbmrXU+d+cBObgdTOAlpa\n' +
	        'JFHaGwYw1osAwPCo9cZ2f04yitBfj9aPFia8ASKldakCAwEAAaNCMEAwDwYDVR0T\n' +
	        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQUqKS+ltlior0SyZKYAkJ/efv55towDgYDVR0P\n' +
	        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQAdElvp8bW4B+Cv+1WSN87dg6TN\n' +
	        'wGyIjJ14/QYURgyrZiYpUmZpj+/pJmprSWXu4KNyqHftmaidu7cdjL5nCAvAfnY5\n' +
	        '/6eDDbX4j8Gt9fb/6H9y0O0dn3mUPSEKG0crR+JRFAtPhn/2FNvst2P82yguWLv0\n' +
	        'pHjHVUVcq+HqDMtUIJsTPYjSh9Iy77Q6TOZKln9dyDOWJpCSkiUWQtMAKbCSlvzd\n' +
	        'zTs/ahqpT+zLfGR1SR+T3snZHgQnbnemmz/XtlKl52NxccARwfcEEKaCRQyGq/pR\n' +
	        '0PVZasyJS9JY4JfQs4YOdeOt4UMZ8BmW1+BQWGSkkb0QIRl8CszoKofucAlqdPcO\n' +
	        'IT/ZaMVhI580LFGWiQIizWFskX6lqbCyHqJB3LDl8gJISB5vNTHOHpvpMOMs5PYt\n' +
	        'cRl5Mrksx5MKMqG7y5R734nMlZxQIHjL5FOoOxTBp9KeWIL/Ib89T2QDaLw1SQ+w\n' +
	        'ihqWBJ4ZdrIMWYpP3WqM+MXWk7WAem+xsFJdR+MDgOOuobVQTy5dGBlPks/6gpjm\n' +
	        'rO9TjfQ36ppJ3b7LdKUPeRfnYmlR5RU4oyYJ//uLbClI443RZAgxaCXX/nyc12lr\n' +
	        'eVLUMNF2abLX4/VF63m2/Z9ACgMRfqGshPssn1NN33OonrotQoj4S3N9ZrjvzKt8\n' +
	        'iHcaqd60QKpfiH2A3A==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICuDCCAj2gAwIBAgIQPaVGRuu86nh/ylZVCLB0MzAKBggqhkjOPQQDAzCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyNTIyMDMxNloYDzIxMjEwNTI1MjMwMzE2WjCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEexNURoB9KE93MEtEAlJG\n' +
	        'obz4LS/pD2hc8Gczix1WhVvpJ8bN5zCDXaKdnDMCebetyRQsmQ2LYlfmCwpZwSDu\n' +
	        '0zowB11Pt3I5Avu2EEcuKTlKIDMBeZ1WWuOd3Tf7MEAMo0IwQDAPBgNVHRMBAf8E\n' +
	        'BTADAQH/MB0GA1UdDgQWBBSaYbZPBvFLikSAjpa8mRJvyArMxzAOBgNVHQ8BAf8E\n' +
	        'BAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAOEJkuh3Zjb7Ih/zuNRd1RBqmIYcnyw0\n' +
	        'nwUZczKXry+9XebYj3VQxSRNadrarPWVqgIxAMg1dyGoDAYjY/L/9YElyMnvHltO\n' +
	        'PwpJShmqHvCLc/mXMgjjYb/akK7yGthvW6j/uQ==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGCDCCA/CgAwIBAgIQChu3v5W1Doil3v6pgRIcVzANBgkqhkiG9w0BAQwFADCB\n' +
	        'nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\n' +
	        'bWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\n' +
	        'A1UEBwwHU2VhdHRsZTAgFw0yMTA1MTgyMTM0MTVaGA8yMTIxMDUxODIyMzQxNVow\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC1\n' +
	        'FUGQ5tf3OwpDR6hGBxhUcrkwKZhaXP+1St1lSOQvjG8wXT3RkKzRGMvb7Ee0kzqI\n' +
	        'mzKKe4ASIhtV3UUWdlNmP0EA3XKnif6N79MismTeGkDj75Yzp5A6tSvqByCgxIjK\n' +
	        'JqpJrch3Dszoyn8+XhwDxMZtkUa5nQVdJgPzJ6ltsQ8E4SWLyLtTu0S63jJDkqYY\n' +
	        'S7cQblk7y7fel+Vn+LS5dGTdRRhMvSzEnb6mkVBaVzRyVX90FNUED06e8q+gU8Ob\n' +
	        'htvQlf9/kRzHwRAdls2YBhH40ZeyhpUC7vdtPwlmIyvW5CZ/QiG0yglixnL6xahL\n' +
	        'pbmTuTSA/Oqz4UGQZv2WzHe1lD2gRHhtFX2poQZeNQX8wO9IcUhrH5XurW/G9Xwl\n' +
	        'Sat9CMPERQn4KC3HSkat4ir2xaEUrjfg6c4XsGyh2Pk/LZ0gLKum0dyWYpWP4JmM\n' +
	        'RQNjrInXPbMhzQObozCyFT7jYegS/3cppdyy+K1K7434wzQGLU1gYXDKFnXwkX8R\n' +
	        'bRKgx2pHNbH5lUddjnNt75+e8m83ygSq/ZNBUz2Ur6W2s0pl6aBjwaDES4VfWYlI\n' +
	        'jokcmrGvJNDfQWygb1k00eF2bzNeNCHwgWsuo3HSxVgc/WGsbcGrTlDKfz+g3ich\n' +
	        'bXUeUidPhRiv5UQIVCLIHpHuin3bj9lQO/0t6p+tAQIDAQABo0IwQDAPBgNVHRMB\n' +
	        'Af8EBTADAQH/MB0GA1UdDgQWBBSFmMBgm5IsRv3hLrvDPIhcPweXYTAOBgNVHQ8B\n' +
	        'Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAAa2EuozymOsQDJlEi7TqnyA2OhT\n' +
	        'GXPfYqCyMJVkfrqNgcnsNpCAiNEiZbb+8sIPXnT8Ay8hrwJYEObJ5b7MHXpLuyft\n' +
	        'z0Pu1oFLKnQxKjNxrIsCvaB4CRRdYjm1q7EqGhMGv76se9stOxkOqO9it31w/LoU\n' +
	        'ENDk7GLsSqsV1OzYLhaH8t+MaNP6rZTSNuPrHwbV3CtBFl2TAZ7iKgKOhdFz1Hh9\n' +
	        'Pez0lG+oKi4mHZ7ajov6PD0W7njn5KqzCAkJR6OYmlNVPjir+c/vUtEs0j+owsMl\n' +
	        'g7KE5g4ZpTRShyh5BjCFRK2tv0tkqafzNtxrKC5XNpEkqqVTCnLcKG+OplIEadtr\n' +
	        'C7UWf4HyhCiR+xIyxFyR05p3uY/QQU/5uza7GlK0J+U1sBUytx7BZ+Fo8KQfPPqV\n' +
	        'CqDCaYUksoJcnJE/KeoksyqNQys7sDGJhkd0NeUGDrFLKHSLhIwAMbEWnqGxvhli\n' +
	        'E7sP2E5rI/I9Y9zTbLIiI8pfeZlFF8DBdoP/Hzg8pqsiE/yiXSFTKByDwKzGwNqz\n' +
	        'F0VoFdIZcIbLdDbzlQitgGpJtvEL7HseB0WH7B2PMMD8KPJlYvPveO3/6OLzCsav\n' +
	        '+CAkvk47NQViKMsUTKOA0JDCW+u981YRozxa3K081snhSiSe83zIPBz1ikldXxO9\n' +
	        '6YYLNPRrj3mi9T/f\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjSgAwIBAgIRAMkvdFnVDb0mWWFiXqnKH68wCgYIKoZIzj0EAwMwgZYx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
	        'em9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTE5MTkxMzI0WhgPMjEyMTA1MTkyMDEzMjRaMIGWMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
	        'RFMgdXMtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
	        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEy86DB+9th/0A5VcWqMSWDxIUblWTt/R0\n' +
	        'ao6Z2l3vf2YDF2wt1A2NIOGpfQ5+WAOJO/IQmnV9LhYo+kacB8sOnXdQa6biZZkR\n' +
	        'IyouUfikVQAKWEJnh1Cuo5YMM4E2sUt5o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
	        'A1UdDgQWBBQ8u3OnecANmG8OoT7KLWDuFzZwBTAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
	        'KoZIzj0EAwMDaAAwZQIwQ817qkb7mWJFnieRAN+m9W3E0FLVKaV3zC5aYJUk2fcZ\n' +
	        'TaUx3oLp3jPLGvY5+wgeAjEA6wAicAki4ZiDfxvAIuYiIe1OS/7H5RA++R8BH6qG\n' +
	        'iRzUBM/FItFpnkus7u/eTkvo\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrzCCAjWgAwIBAgIQS/+Ryfgb/IOVEa1pWoe8oTAKBggqhkjOPQQDAzCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjIwNjA2MjE1NDQyWhgPMjEyMjA2MDYyMjU0NDJaMIGXMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
	        'RFMgYXAtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
	        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDsX6fhdUWBQpYTdseBD/P3s96Dtw2Iw\n' +
	        'OrXKNToCnmX5nMkUGdRn9qKNiz1pw3EPzaPxShbYwQ7LYP09ENK/JN4QQjxMihxC\n' +
	        'jLFxS85nhBQQQGRCWikDAe38mD8fSvREQKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
	        'BgNVHQ4EFgQUIh1xZiseQYFjPYKJmGbruAgRH+AwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
	        'CCqGSM49BAMDA2gAMGUCMFudS4zLy+UUGrtgNLtRMcu/DZ9BUzV4NdHxo0bkG44O\n' +
	        'thnjl4+wTKI6VbyAbj2rkgIxAOHps8NMITU5DpyiMnKTxV8ubb/WGHrLl0BjB8Lw\n' +
	        'ETVJk5DNuZvsIIcm7ykk6iL4Tw==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGBDCCA+ygAwIBAgIQDcEmNIAVrDpUw5cH5ynutDANBgkqhkiG9w0BAQwFADCB\n' +
	        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
	        'bWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUwIBcNMjIwNTA3MDA0MDIzWhgPMjEyMjA1MDcwMTQwMjNaMIGa\n' +
	        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
	        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
	        'YXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKvADk8t\n' +
	        'Fl9bFlU5sajLPPDSOUpPAkKs6iPlz+27o1GJC88THcOvf3x0nVAcu9WYe9Qaas+4\n' +
	        'j4a0vv51agqyODRD/SNi2HnqW7DbtLPAm6KBHe4twl28ItB/JD5g7u1oPAHFoXMS\n' +
	        'cH1CZEAs5RtlZGzJhcBXLFsHNv/7+SCLyZ7+2XFh9OrtgU4wMzkHoRNndhfwV5bu\n' +
	        '17bPTwuH+VxH37zXf1mQ/KjhuJos0C9dL0FpjYBAuyZTAWhZKs8dpSe4DI544z4w\n' +
	        'gkwUB4bC2nA1TBzsywEAHyNuZ/xRjNpWvx0ToWAA2iFJqC3VO3iKcnBplMvaUuMt\n' +
	        'jwzVSNBnKcoabXCZL2XDLt4YTZR8FSwz05IvsmwcPB7uNTBXq3T9sjejW8QQK3vT\n' +
	        'tzyfLq4jKmQE7PoS6cqYm+hEPm2hDaC/WP9bp3FdEJxZlPH26fq1b7BWYWhQ9pBA\n' +
	        'Nv9zTnzdR1xohTyOJBUFQ81ybEzabqXqVXUIANqIOaNcTB09/sLJ7+zuMhp3mwBu\n' +
	        'LtjfJv8PLuT1r63bU3seROhKA98b5KfzjvbvPSg3vws78JQyoYGbqNyDfyjVjg3U\n' +
	        'v//AdVuPie6PNtdrW3upZY4Qti5IjP9e3kimaJ+KAtTgMRG56W0WxD3SP7+YGGbG\n' +
	        'KhntDOkKsN39hLpn9UOafTIqFu7kIaueEy/NAgMBAAGjQjBAMA8GA1UdEwEB/wQF\n' +
	        'MAMBAf8wHQYDVR0OBBYEFHAems86dTwdZbLe8AaPy3kfIUVoMA4GA1UdDwEB/wQE\n' +
	        'AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOBHpp0ICx81kmeoBcZTrMdJs2gnhcd85\n' +
	        'FoSCjXx9H5XE5rmN/lQcxxOgj8hr3uPuLdLHu+i6THAyzjrl2NA1FWiqpfeECGmy\n' +
	        '0jm7iZsYORgGQYp/VKnDrwnKNSqlZvOuRr0kfUexwFlr34Y4VmupvEOK/RdGsd3S\n' +
	        '+3hiemcHse9ST/sJLHx962AWMkN86UHPscJEe4+eT3f2Wyzg6La8ARwdWZSNS+WH\n' +
	        'ZfybrncMmuiXuUdHv9XspPsqhKgtHhcYeXOGUtrwQPLe3+VJZ0LVxhlTWr9951GZ\n' +
	        'GfmWwTV/9VsyKVaCFIXeQ6L+gjcKyEzYF8wpMtQlSc7FFqwgC4bKxvMBSaRy88Nr\n' +
	        'lV2+tJD/fr8zGUeBK44Emon0HKDBWGX+/Hq1ZIv0Da0S+j6LbA4fusWxtGfuGha+\n' +
	        'luhHgVInCpALIOamiBEdGhILkoTtx7JrYppt3/Raqg9gUNCOOYlCvGhqX7DXeEfL\n' +
	        'DGabooiY2FNWot6h04JE9nqGj5QqT8D6t/TL1nzxhRPzbcSDIHUd/b5R+a0bAA+7\n' +
	        'YTU6JqzEVCWKEIEynYmqikgLMGB/OzWsgyEL6822QW6hJAQ78XpbNeCzrICF4+GC\n' +
	        '7KShLnwuWoWpAb26268lvOEvCTFM47VC6jNQl97md+2SA9Ma81C9wflid2M83Wle\n' +
	        'cuLMVcQZceE=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEADCCAuigAwIBAgIQAhAteLRCvizAElaWORFU2zANBgkqhkiG9w0BAQsFADCB\n' +
	        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
	        'bWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyMDE3MDkxNloYDzIwNjEwNTIwMTgwOTE2WjCBmDEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
	        'b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA+qg7JAcOVKjh\n' +
	        'N83SACnBFZPyB63EusfDr/0V9ZdL8lKcmZX9sv/CqoBo3N0EvBqHQqUUX6JvFb7F\n' +
	        'XrMUZ740kr28gSRALfXTFgNODjXeDsCtEkKRTkac/UM8xXHn+hR7UFRPHS3e0GzI\n' +
	        'iLiwQWDkr0Op74W8aM0CfaVKvh2bp4BI1jJbdDnQ9OKXpOxNHGUf0ZGb7TkNPkgI\n' +
	        'b2CBAc8J5o3H9lfw4uiyvl6Fz5JoP+A+zPELAioYBXDrbE7wJeqQDJrETWqR9VEK\n' +
	        'BXURCkVnHeaJy123MpAX2ozf4pqk0V0LOEOZRS29I+USF5DcWr7QIXR/w2I8ws1Q\n' +
	        '7ys+qbE+kQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQFJ16n\n' +
	        '1EcCMOIhoZs/F9sR+Jy++zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
	        'ggEBAOc5nXbT3XTDEZsxX2iD15YrQvmL5m13B3ImZWpx/pqmObsgx3/dg75rF2nQ\n' +
	        'qS+Vl+f/HLh516pj2BPP/yWCq12TRYigGav8UH0qdT3CAClYy2o+zAzUJHm84oiB\n' +
	        'ud+6pFVGkbqpsY+QMpJUbZWu52KViBpJMYsUEy+9cnPSFRVuRAHjYynSiLk2ZEjb\n' +
	        'Wkdc4x0nOZR5tP0FgrX0Ve2KcjFwVQJVZLgOUqmFYQ/G0TIIGTNh9tcmR7yp+xJR\n' +
	        'A2tbPV2Z6m9Yxx4E8lLEPNuoeouJ/GR4CkMEmF8cLwM310t174o3lKKUXJ4Vs2HO\n' +
	        'Wj2uN6R9oI+jGLMSswTzCNV1vgc=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICuDCCAj6gAwIBAgIRAOocLeZWjYkG/EbHmscuy8gwCgYIKoZIzj0EAwMwgZsx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\n' +
	        'em9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMTA1MjEyMTUwMDFaGA8yMTIxMDUyMTIyNTAwMVowgZsx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\n' +
	        'em9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABCEr3jq1KtRncnZfK5cq\n' +
	        'btY0nW6ZG3FMbh7XwBIR6Ca0f8llGZ4vJEC1pXgiM/4Dh045B9ZIzNrR54rYOIfa\n' +
	        '2NcYZ7mk06DjIQML64hbAxbQzOAuNzLPx268MrlL2uW2XaNCMEAwDwYDVR0TAQH/\n' +
	        'BAUwAwEB/zAdBgNVHQ4EFgQUln75pChychwN4RfHl+tOinMrfVowDgYDVR0PAQH/\n' +
	        'BAQDAgGGMAoGCCqGSM49BAMDA2gAMGUCMGiyPINRU1mwZ4Crw01vpuPvxZxb2IOr\n' +
	        'yX3RNlOIu4We1H+5dQk5tIvH8KGYFbWEpAIxAO9NZ6/j9osMhLgZ0yj0WVjb+uZx\n' +
	        'YlZR9fyFisY/jNfX7QhSk+nrc3SFLRUNtpXrng==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBTCCAu2gAwIBAgIRAKiaRZatN8eiz9p0s0lu0rQwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\n' +
	        'QW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD\n' +
	        'VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDIzNVoYDzIwNjEwNTIxMjMwMjM1WjCB\n' +
	        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
	        'bWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCygVMf\n' +
	        'qB865IR9qYRBRFHn4eAqGJOCFx+UbraQZmjr/mnRqSkY+nhbM7Pn/DWOrRnxoh+w\n' +
	        'q5F9ZxdZ5D5T1v6kljVwxyfFgHItyyyIL0YS7e2h7cRRscCM+75kMedAP7icb4YN\n' +
	        'LfWBqfKHbHIOqvvQK8T6+Emu/QlG2B5LvuErrop9K0KinhITekpVIO4HCN61cuOe\n' +
	        'CADBKF/5uUJHwS9pWw3uUbpGUwsLBuhJzCY/OpJlDqC8Y9aToi2Ivl5u3/Q/sKjr\n' +
	        '6AZb9lx4q3J2z7tJDrm5MHYwV74elGSXoeoG8nODUqjgklIWAPrt6lQ3WJpO2kug\n' +
	        '8RhCdSbWkcXHfX95AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\n' +
	        'FOIxhqTPkKVqKBZvMWtKewKWDvDBMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B\n' +
	        'AQsFAAOCAQEAqoItII89lOl4TKvg0I1EinxafZLXIheLcdGCxpjRxlZ9QMQUN3yb\n' +
	        'y/8uFKBL0otbQgJEoGhxm4h0tp54g28M6TN1U0332dwkjYxUNwvzrMaV5Na55I2Z\n' +
	        '1hq4GB3NMXW+PvdtsgVOZbEN+zOyOZ5MvJHEQVkT3YRnf6avsdntltcRzHJ16pJc\n' +
	        'Y8rR7yWwPXh1lPaPkxddrCtwayyGxNbNmRybjR48uHRhwu7v2WuAMdChL8H8bp89\n' +
	        'TQLMrMHgSbZfee9hKhO4Zebelf1/cslRSrhkG0ESq6G5MUINj6lMg2g6F0F7Xz2v\n' +
	        'ncD/vuRN5P+vT8th/oZ0Q2Gc68Pun0cn/g==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/zCCAuegAwIBAgIRAJYlnmkGRj4ju/2jBQsnXJYwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyMTIzMDQ0NFoYDzIwNjEwNTIyMDAwNDQ0WjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC74V3eigv+pCj5\n' +
	        'nqDBqplY0Jp16pTeNB06IKbzb4MOTvNde6QjsZxrE1xUmprT8LxQqN9tI3aDYEYk\n' +
	        'b9v4F99WtQVgCv3Y34tYKX9NwWQgwS1vQwnIR8zOFBYqsAsHEkeJuSqAB12AYUSd\n' +
	        'Zv2RVFjiFmYJho2X30IrSLQfS/IE3KV7fCyMMm154+/K1Z2IJlcissydEAwgsUHw\n' +
	        'edrE6CxJVkkJ3EvIgG4ugK/suxd8eEMztaQYJwSdN8TdfT59LFuSPl7zmF3fIBdJ\n' +
	        '//WexcQmGabaJ7Xnx+6o2HTfkP8Zzzzaq8fvjAcvA7gyFH5EP26G2ZqMG+0y4pTx\n' +
	        'SPVTrQEXAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFIWWuNEF\n' +
	        'sUMOC82XlfJeqazzrkPDMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
	        'AQEAgClmxcJaQTGpEZmjElL8G2Zc8lGc+ylGjiNlSIw8X25/bcLRptbDA90nuP+q\n' +
	        'zXAMhEf0ccbdpwxG/P5a8JipmHgqQLHfpkvaXx+0CuP++3k+chAJ3Gk5XtY587jX\n' +
	        '+MJfrPgjFt7vmMaKmynndf+NaIJAYczjhJj6xjPWmGrjM3MlTa9XesmelMwP3jep\n' +
	        'bApIWAvCYVjGndbK9byyMq1nyj0TUzB8oJZQooaR3MMjHTmADuVBylWzkRMxbKPl\n' +
	        '4Nlsk4Ef1JvIWBCzsMt+X17nuKfEatRfp3c9tbpGlAE/DSP0W2/Lnayxr4RpE9ds\n' +
	        'ICF35uSis/7ZlsftODUe8wtpkQ==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/zCCA+egAwIBAgIRAPvvd+MCcp8E36lHziv0xhMwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyMTIzMTEwNloYDzIxMjEwNTIyMDAxMTA2WjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDbvwekKIKGcV/s\n' +
	        'lDU96a71ZdN2pTYkev1X2e2/ICb765fw/i1jP9MwCzs8/xHBEQBJSxdfO4hPeNx3\n' +
	        'ENi0zbM+TrMKliS1kFVe1trTTEaHYjF8BMK9yTY0VgSpWiGxGwg4tshezIA5lpu8\n' +
	        'sF6XMRxosCEVCxD/44CFqGZTzZaREIvvFPDTXKJ6yOYnuEkhH3OcoOajHN2GEMMQ\n' +
	        'ShuyRFDQvYkqOC/Q5icqFbKg7eGwfl4PmimdV7gOVsxSlw2s/0EeeIILXtHx22z3\n' +
	        '8QBhX25Lrq2rMuaGcD3IOMBeBo2d//YuEtd9J+LGXL9AeOXHAwpvInywJKAtXTMq\n' +
	        'Wsy3LjhuANFrzMlzjR2YdjkGVzeQVx3dKUzJ2//Qf7IXPSPaEGmcgbxuatxjnvfT\n' +
	        'H85oeKr3udKnXm0Kh7CLXeqJB5ITsvxI+Qq2iXtYCc+goHNR01QJwtGDSzuIMj3K\n' +
	        'f+YMrqBXZgYBwU2J/kCNTH31nfw96WTbOfNGwLwmVRDgguzFa+QzmQsJW4FTDMwc\n' +
	        '7cIjwdElQQVA+Gqa67uWmyDKAnoTkudmgAP+OTBkhnmc6NJuZDcy6f/iWUdl0X0u\n' +
	        '/tsfgXXR6ZovnHonM13ANiN7VmEVqFlEMa0VVmc09m+2FYjjlk8F9sC7Rc4wt214\n' +
	        '7u5YvCiCsFZwx44baP5viyRZgkJVpQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
	        'MB0GA1UdDgQWBBQgCZCsc34nVTRbWsniXBPjnUTQ2DAOBgNVHQ8BAf8EBAMCAYYw\n' +
	        'DQYJKoZIhvcNAQEMBQADggIBAAQas3x1G6OpsIvQeMS9BbiHG3+kU9P/ba6Rrg+E\n' +
	        'lUz8TmL04Bcd+I+R0IyMBww4NznT+K60cFdk+1iSmT8Q55bpqRekyhcdWda1Qu0r\n' +
	        'JiTi7zz+3w2v66akofOnGevDpo/ilXGvCUJiLOBnHIF0izUqzvfczaMZGJT6xzKq\n' +
	        'PcEVRyAN1IHHf5KnGzUlVFv9SGy47xJ9I1vTk24JU0LWkSLzMMoxiUudVmHSqJtN\n' +
	        'u0h+n/x3Q6XguZi1/C1KOntH56ewRh8n5AF7c+9LJJSRM9wunb0Dzl7BEy21Xe9q\n' +
	        '03xRYjf5wn8eDELB8FZPa1PrNKXIOLYM9egdctbKEcpSsse060+tkyBrl507+SJT\n' +
	        '04lvJ4tcKjZFqxn+bUkDQvXYj0D3WK+iJ7a8kZJPRvz8BDHfIqancY8Tgw+69SUn\n' +
	        'WqIb+HNZqFuRs16WFSzlMksqzXv6wcDSyI7aZOmCGGEcYW9NHk8EuOnOQ+1UMT9C\n' +
	        'Qb1GJcipjRzry3M4KN/t5vN3hIetB+/PhmgTO4gKhBETTEyPC3HC1QbdVfRndB6e\n' +
	        'U/NF2U/t8U2GvD26TTFLK4pScW7gyw4FQyXWs8g8FS8f+R2yWajhtS9++VDJQKom\n' +
	        'fAUISoCH+PlPRJpu/nHd1Zrddeiiis53rBaLbXu2J1Q3VqjWOmtj0HjxJJxWnYmz\n' +
	        'Pqj2\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGATCCA+mgAwIBAgIRAI/U4z6+GF8/znpHM8Dq8G0wDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQ4MThaGA8yMTIyMDYwNjIyNDgxOFowgZgx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
	        'em9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
	        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK5WqMvyq888\n' +
	        '3uuOtEj1FcP6iZhqO5kJurdJF59Otp2WCg+zv6I+QwaAspEWHQsKD405XfFsTGKV\n' +
	        'SKTCwoMxwBniuChSmyhlagQGKSnRY9+znOWq0v7hgmJRwp6FqclTbubmr+K6lzPy\n' +
	        'hs86mEp68O5TcOTYWUlPZDqfKwfNTbtCl5YDRr8Gxb5buHmkp6gUSgDkRsXiZ5VV\n' +
	        'b3GBmXRqbnwo5ZRNAzQeM6ylXCn4jKs310lQGUrFbrJqlyxUdfxzqdlaIRn2X+HY\n' +
	        'xRSYbHox3LVNPpJxYSBRvpQVFSy9xbX8d1v6OM8+xluB31cbLBtm08KqPFuqx+cO\n' +
	        'I2H5F0CYqYzhyOSKJsiOEJT6/uH4ewryskZzncx9ae62SC+bB5n3aJLmOSTkKLFY\n' +
	        'YS5IsmDT2m3iMgzsJNUKVoCx2zihAzgBanFFBsG+Xmoq0aKseZUI6vd2qpd5tUST\n' +
	        '/wS1sNk0Ph7teWB2ACgbFE6etnJ6stwjHFZOj/iTYhlnR2zDRU8akunFdGb6CB4/\n' +
	        'hMxGJxaqXSJeGtHm7FpadlUTf+2ESbYcVW+ui/F8sdBJseQdKZf3VdZZMgM0bcaX\n' +
	        'NE47cauDTy72WdU9YJX/YXKYMLDE0iFHTnGpfVGsuWGPYhlwZ3dFIO07mWnCRM6X\n' +
	        'u5JXRB1oy5n5HRluMsmpSN/R92MeBxKFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
	        'Af8wHQYDVR0OBBYEFNtH0F0xfijSLHEyIkRGD9gW6NazMA4GA1UdDwEB/wQEAwIB\n' +
	        'hjANBgkqhkiG9w0BAQwFAAOCAgEACo+5jFeY3ygxoDDzL3xpfe5M0U1WxdKk+az4\n' +
	        '/OfjZvkoma7WfChi3IIMtwtKLYC2/seKWA4KjlB3rlTsCVNPnK6D+gAnybcfTKk/\n' +
	        'IRSPk92zagwQkSUWtAk80HpVfWJzpkSU16ejiajhedzOBRtg6BwsbSqLCDXb8hXr\n' +
	        'eXWC1S9ZceGc+LcKRHewGWPu31JDhHE9bNcl9BFSAS0lYVZqxIRWxivZ+45j5uQv\n' +
	        'wPrC8ggqsdU3K8quV6dblUQzzA8gKbXJpCzXZihkPrYpQHTH0szvXvgebh+CNUAG\n' +
	        'rUxm8+yTS0NFI3U+RLbcLFVzSvjMOnEwCX0SPj5XZRYYXs5ajtQCoZhTUkkwpDV8\n' +
	        'RxXk8qGKiXwUxDO8GRvmvM82IOiXz5w2jy/h7b7soyIgdYiUydMq4Ja4ogB/xPZa\n' +
	        'gf4y0o+bremO15HFf1MkaU2UxPK5FFVUds05pKvpSIaQWbF5lw4LHHj4ZtVup7zF\n' +
	        'CLjPWs4Hs/oUkxLMqQDw0FBwlqa4uot8ItT8uq5BFpz196ZZ+4WXw5PVzfSxZibI\n' +
	        'C/nwcj0AS6qharXOs8yPnPFLPSZ7BbmWzFDgo3tpglRqo3LbSPsiZR+sLeivqydr\n' +
	        '0w4RK1btRda5Ws88uZMmW7+2aufposMKcbAdrApDEAVzHijbB/nolS5nsnFPHZoA\n' +
	        'KDPtFEk=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICtzCCAj2gAwIBAgIQVZ5Y/KqjR4XLou8MCD5pOjAKBggqhkjOPQQDAzCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIyMDUyNTE2NTgzM1oYDzIxMjIwNTI1MTc1ODMzWjCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEbo473OmpD5vkckdJajXg\n' +
	        'brhmNFyoSa0WCY1njuZC2zMFp3zP6rX4I1r3imrYnJd9pFH/aSiV/r6L5ACE5RPx\n' +
	        '4qdg5SQ7JJUaZc3DWsTOiOed7BCZSzM+KTYK/2QzDMApo0IwQDAPBgNVHRMBAf8E\n' +
	        'BTADAQH/MB0GA1UdDgQWBBTmogc06+1knsej1ltKUOdWFvwgsjAOBgNVHQ8BAf8E\n' +
	        'BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAIs7TlLMbGTWNXpGiKf9DxaM07d/iDHe\n' +
	        'F/Vv/wyWSTGdobxBL6iArQNVXz0Gr4dvPAIwd0rsoa6R0x5mtvhdRPtM37FYrbHJ\n' +
	        'pbV+OMusQqcSLseunLBoCHenvJW0QOCQ8EDY\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICvTCCAkOgAwIBAgIQCIY7E/bFvFN2lK9Kckb0dTAKBggqhkjOPQQDAzCBnjEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5BbWF6\n' +
	        'b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYD\n' +
	        'VQQHDAdTZWF0dGxlMCAXDTIxMDUxODIxMDUxMFoYDzIxMjEwNTE4MjIwNTEwWjCB\n' +
	        'njELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5B\n' +
	        'bWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEMI0hzf1JCEOI\n' +
	        'Eue4+DmcNnSs2i2UaJxHMrNGGfU7b42a7vwP53F7045ffHPBGP4jb9q02/bStZzd\n' +
	        'VHqfcgqkSRI7beBKjD2mfz82hF/wJSITTgCLs+NRpS6zKMFOFHUNo0IwQDAPBgNV\n' +
	        'HRMBAf8EBTADAQH/MB0GA1UdDgQWBBS8uF/6hk5mPLH4qaWv9NVZaMmyTjAOBgNV\n' +
	        'HQ8BAf8EBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAO7Pu9wzLyM0X7Q08uLIL+vL\n' +
	        'qaxe3UFuzFTWjM16MLJHbzLf1i9IDFKz+Q4hXCSiJwIwClMBsqT49BPUxVsJnjGr\n' +
	        'EbyEk6aOOVfY1p2yQL649zh3M4h8okLnwf+bYIb1YpeU\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEADCCAuigAwIBAgIQY+JhwFEQTe36qyRlUlF8ozANBgkqhkiG9w0BAQsFADCB\n' +
	        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
	        'bWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUxOTE5MjQxNloYDzIwNjEwNTE5MjAyNDE2WjCBmDEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
	        'b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnIye77j6ev40\n' +
	        '8wRPyN2OdKFSUfI9jB20Or2RLO+RDoL43+USXdrze0Wv4HMRLqaen9BcmCfaKMp0\n' +
	        'E4SFo47bXK/O17r6G8eyq1sqnHE+v288mWtYH9lAlSamNFRF6YwA7zncmE/iKL8J\n' +
	        '0vePHMHP/B6svw8LULZCk+nZk3tgxQn2+r0B4FOz+RmpkoVddfqqUPMbKUxhM2wf\n' +
	        'fO7F6bJaUXDNMBPhCn/3ayKCjYr49ErmnpYV2ZVs1i34S+LFq39J7kyv6zAgbHv9\n' +
	        '+/MtRMoRB1CjpqW0jIOZkHBdYcd1o9p1zFn591Do1wPkmMsWdjIYj+6e7UXcHvOB\n' +
	        '2+ScIRAcnwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQGtq2W\n' +
	        'YSyMMxpdQ3IZvcGE+nyZqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
	        'ggEBAEgoP3ixJsKSD5FN8dQ01RNHERl/IFbA7TRXfwC+L1yFocKnQh4Mp/msPRSV\n' +
	        '+OeHIvemPW/wtZDJzLTOFJ6eTolGekHK1GRTQ6ZqsWiU2fmiOP8ks4oSpI+tQ9Lw\n' +
	        'VrfZqTiEcS5wEIqyfUAZZfKDo7W1xp+dQWzfczSBuZJZwI5iaha7+ILM0r8Ckden\n' +
	        'TVTapc5pLSoO15v0ziRuQ2bT3V3nwu/U0MRK44z+VWOJdSiKxdnOYDs8hFNnKhfe\n' +
	        'klbTZF7kW7WbiNYB43OaAQBJ6BALZsIskEaqfeZT8FD71uN928TcEQyBDXdZpRN+\n' +
	        'iGQZDGhht0r0URGMDSs9waJtTfA=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/jCCA+agAwIBAgIQXY/dmS+72lZPranO2JM9jjANBgkqhkiG9w0BAQwFADCB\n' +
	        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
	        'bWF6b24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTI1MjEzNDUxWhgPMjEyMTA1MjUyMjM0NTFaMIGXMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
	        'biBSRFMgYXAtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMyW9kBJjD/hx8e8\n' +
	        'b5E1sF42bp8TXsz1htSYE3Tl3T1Aq379DfEhB+xa/ASDZxt7/vwa81BkNo4M6HYq\n' +
	        'okYIXeE7cu5SnSgjWXqcERhgPevtAwgmhdE3yREe8oz2DyOi2qKKZqah+1gpPaIQ\n' +
	        'fK0uAqoeQlyHosye3KZZKkDHBatjBsQ5kf8lhuf7wVulEZVRHY2bP2X7N98PfbpL\n' +
	        'QdH7mWXzDtJJ0LiwFwds47BrkgK1pkHx2p1mTo+HMkfX0P6Fq1atkVC2RHHtbB/X\n' +
	        'iYyH7paaHBzviFrhr679zNqwXIOKlbf74w3mS11P76rFn9rS1BAH2Qm6eY5S/Fxe\n' +
	        'HEKXm4kjPN63Zy0p3yE5EjPt54yPkvumOnT+RqDGJ2HCI9k8Ehcbve0ogfdRKNqQ\n' +
	        'VHWYTy8V33ndQRHZlx/CuU1yN61TH4WSoMly1+q1ihTX9sApmlQ14B2pJi/9DnKW\n' +
	        'cwECrPy1jAowC2UJ45RtC8UC05CbP9yrIy/7Noj8gQDiDOepm+6w1g6aNlWoiuQS\n' +
	        'kyI6nzz1983GcnOHya73ga7otXo0Qfg9jPghlYiMomrgshlSLDHZG0Ib/3hb8cnR\n' +
	        '1OcN9FpzNmVK2Ll1SmTMLrIhuCkyNYX9O/bOknbcf706XeESxGduSkHEjIw/k1+2\n' +
	        'Atteoq5dT6cwjnJ9hyhiueVlVkiDAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
	        'HQYDVR0OBBYEFLUI+DD7RJs+0nRnjcwIVWzzYSsFMA4GA1UdDwEB/wQEAwIBhjAN\n' +
	        'BgkqhkiG9w0BAQwFAAOCAgEAb1mcCHv4qMQetLGTBH9IxsB2YUUhr5dda0D2BcHr\n' +
	        'UtDbfd0VQs4tux6h/6iKwHPx0Ew8fuuYj99WknG0ffgJfNc5/fMspxR/pc1jpdyU\n' +
	        '5zMQ+B9wi0lOZPO9uH7/pr+d2odcNEy8zAwqdv/ihsTwLmGP54is9fVbsgzNW1cm\n' +
	        'HKAVL2t/Ope+3QnRiRilKCN1lzhav4HHdLlN401TcWRWKbEuxF/FgxSO2Hmx86pj\n' +
	        'e726lweCTMmnq/cTsPOVY0WMjs0or3eHDVlyLgVeV5ldyN+ptg3Oit60T05SRa58\n' +
	        'AJPTaVKIcGQ/gKkKZConpu7GDofT67P/ox0YNY57LRbhsx9r5UY4ROgz7WMQ1yoS\n' +
	        'Y+19xizm+mBm2PyjMUbfwZUyCxsdKMwVdOq5/UmTmdms+TR8+m1uBHPOTQ2vKR0s\n' +
	        'Pd/THSzPuu+d3dbzRyDSLQbHFFneG760CUlD/ZmzFlQjJ89/HmAmz8IyENq+Sjhx\n' +
	        'Jgzy+FjVZb8aRUoYLlnffpUpej1n87Ynlr1GrvC4GsRpNpOHlwuf6WD4W0qUTsC/\n' +
	        'C9JO+fBzUj/aWlJzNcLEW6pte1SB+EdkR2sZvWH+F88TxemeDrV0jKJw5R89CDf8\n' +
	        'ZQNfkxJYjhns+YeV0moYjqQdc7tq4i04uggEQEtVzEhRLU5PE83nlh/K2NZZm8Kj\n' +
	        'dIA=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/zCCAuegAwIBAgIRAPVSMfFitmM5PhmbaOFoGfUwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyNTIyMzQ1N1oYDzIwNjEwNTI1MjMzNDU3WjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDu9H7TBeGoDzMr\n' +
	        'dxN6H8COntJX4IR6dbyhnj5qMD4xl/IWvp50lt0VpmMd+z2PNZzx8RazeGC5IniV\n' +
	        '5nrLg0AKWRQ2A/lGGXbUrGXCSe09brMQCxWBSIYe1WZZ1iU1IJ/6Bp4D2YEHpXrW\n' +
	        'bPkOq5x3YPcsoitgm1Xh8ygz6vb7PsvJvPbvRMnkDg5IqEThapPjmKb8ZJWyEFEE\n' +
	        'QRrkCIRueB1EqQtJw0fvP4PKDlCJAKBEs/y049FoOqYpT3pRy0WKqPhWve+hScMd\n' +
	        '6obq8kxTFy1IHACjHc51nrGII5Bt76/MpTWhnJIJrCnq1/Uc3Qs8IVeb+sLaFC8K\n' +
	        'DI69Sw6bAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFE7PCopt\n' +
	        'lyOgtXX0Y1lObBUxuKaCMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
	        'AQEAFj+bX8gLmMNefr5jRJfHjrL3iuZCjf7YEZgn89pS4z8408mjj9z6Q5D1H7yS\n' +
	        'jNETVV8QaJip1qyhh5gRzRaArgGAYvi2/r0zPsy+Tgf7v1KGL5Lh8NT8iCEGGXwF\n' +
	        'g3Ir+Nl3e+9XUp0eyyzBIjHtjLBm6yy8rGk9p6OtFDQnKF5OxwbAgip42CD75r/q\n' +
	        'p421maEDDvvRFR4D+99JZxgAYDBGqRRceUoe16qDzbMvlz0A9paCZFclxeftAxv6\n' +
	        'QlR5rItMz/XdzpBJUpYhdzM0gCzAzdQuVO5tjJxmXhkSMcDP+8Q+Uv6FA9k2VpUV\n' +
	        'E/O5jgpqUJJ2Hc/5rs9VkAPXeA==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrzCCAjWgAwIBAgIQW0yuFCle3uj4vWiGU0SaGzAKBggqhkjOPQQDAzCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTE5MTkzNTE2WhgPMjEyMTA1MTkyMDM1MTZaMIGXMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
	        'RFMgYWYtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
	        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDPiKNZSaXs3Un/J/v+LTsFDANHpi7en\n' +
	        'oL2qh0u0DoqNzEBTbBjvO23bLN3k599zh6CY3HKW0r2k1yaIdbWqt4upMCRCcUFi\n' +
	        'I4iedAmubgzh56wJdoMZztjXZRwDthTkJKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
	        'BgNVHQ4EFgQUWbYkcrvVSnAWPR5PJhIzppcAnZIwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
	        'CCqGSM49BAMDA2gAMGUCMCESGqpat93CjrSEjE7z+Hbvz0psZTHwqaxuiH64GKUm\n' +
	        'mYynIiwpKHyBrzjKBmeDoQIxANGrjIo6/b8Jl6sdIZQI18V0pAyLfLiZjlHVOnhM\n' +
	        'MOTVgr82ZuPoEHTX78MxeMnYlw==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgIRAIbsx8XOl0sgTNiCN4O+18QwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1NDU4WhgPMjA2MTA1MjUyMjU0NTha\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
	        'tROxwXWCgn5R9gI/2Ivjzaxc0g95ysBjoJsnhPdJEHQb7w3y2kWrVWU3Y9fOitgb\n' +
	        'CEsnEC3PrhRnzNVW0fPsK6kbvOeCmjvY30rdbxbc8h+bjXfGmIOgAkmoULEr6Hc7\n' +
	        'G1Q/+tvv4lEwIs7bEaf+abSZxRJbZ0MBxhbHn7UHHDiMZYvzK+SV1MGCxx7JVhrm\n' +
	        'xWu3GC1zZCsGDhB9YqY9eR6PmjbqA5wy8vqbC57dZZa1QVtWIQn3JaRXn+faIzHx\n' +
	        'nLMN5CEWihsdmHBXhnRboXprE/OS4MFv1UrQF/XM/h5RBeCywpHePpC+Oe1T3LNC\n' +
	        'iP8KzRFrjC1MX/WXJnmOVQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
	        'DgQWBBS33XbXAUMs1znyZo4B0+B3D68WFTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBADuadd2EmlpueY2VlrIIPC30QkoA1EOSoCmZgN6124apkoY1\n' +
	        'HiV4r+QNPljN4WP8gmcARnNkS7ZeR4fvWi8xPh5AxQCpiaBMw4gcbTMCuKDV68Pw\n' +
	        'P2dZCTMspvR3CDfM35oXCufdtFnxyU6PAyINUqF/wyTHguO3owRFPz64+sk3r2pT\n' +
	        'WHmJjG9E7V+KOh0s6REgD17Gqn6C5ijLchSrPUHB0wOIkeLJZndHxN/76h7+zhMt\n' +
	        'fFeNxPWHY2MfpcaLjz4UREzZPSB2U9k+y3pW1omCIcl6MQU9itGx/LpQE+H3ZeX2\n' +
	        'M2bdYd5L+ow+bdbGtsVKOuN+R9Dm17YpswF+vyQ=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGATCCA+mgAwIBAgIRAKlQ+3JX9yHXyjP/Ja6kZhkwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMTA1MTkxNzQ1MjBaGA8yMTIxMDUxOTE4NDUyMFowgZgx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
	        'em9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
	        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKtahBrpUjQ6\n' +
	        'H2mni05BAKU6Z5USPZeSKmBBJN3YgD17rJ93ikJxSgzJ+CupGy5rvYQ0xznJyiV0\n' +
	        '91QeQN4P+G2MjGQR0RGeUuZcfcZitJro7iAg3UBvw8WIGkcDUg+MGVpRv/B7ry88\n' +
	        '7E4OxKb8CPNoa+a9j6ABjOaaxaI22Bb7j3OJ+JyMICs6CU2bgkJaj3VUV9FCNUOc\n' +
	        'h9PxD4jzT9yyGYm/sK9BAT1WOTPG8XQUkpcFqy/IerZDfiQkf1koiSd4s5VhBkUn\n' +
	        'aQHOdri/stldT7a+HJFVyz2AXDGPDj+UBMOuLq0K6GAT6ThpkXCb2RIf4mdTy7ox\n' +
	        'N5BaJ+ih+Ro3ZwPkok60egnt/RN98jgbm+WstgjJWuLqSNInnMUgkuqjyBWwePqX\n' +
	        'Kib+wdpyx/LOzhKPEFpeMIvHQ3A0sjlulIjnh+j+itezD+dp0UNxMERlW4Bn/IlS\n' +
	        'sYQVNfYutWkRPRLErXOZXtlxxkI98JWQtLjvGzQr+jywxTiw644FSLWdhKa6DtfU\n' +
	        '2JWBHqQPJicMElfZpmfaHZjtXuCZNdZQXWg7onZYohe281ZrdFPOqC4rUq7gYamL\n' +
	        'T+ZB+2P+YCPOLJ60bj/XSvcB7mesAdg8P0DNddPhHUFWx2dFqOs1HxIVB4FZVA9U\n' +
	        'Ppbv4a484yxjTgG7zFZNqXHKTqze6rBBAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
	        'Af8wHQYDVR0OBBYEFCEAqjighncv/UnWzBjqu1Ka2Yb4MA4GA1UdDwEB/wQEAwIB\n' +
	        'hjANBgkqhkiG9w0BAQwFAAOCAgEAYyvumblckIXlohzi3QiShkZhqFzZultbFIu9\n' +
	        'GhA5CDar1IFMhJ9vJpO9nUK/camKs1VQRs8ZsBbXa0GFUM2p8y2cgUfLwFULAiC/\n' +
	        'sWETyW5lcX/xc4Pyf6dONhqFJt/ovVBxNZtcmMEWv/1D6Tf0nLeEb0P2i/pnSRR4\n' +
	        'Oq99LVFjossXtyvtaq06OSiUUZ1zLPvV6AQINg8dWeBOWRcQYhYcEcC2wQ06KShZ\n' +
	        '0ahuu7ar5Gym3vuLK6nH+eQrkUievVomN/LpASrYhK32joQ5ypIJej3sICIgJUEP\n' +
	        'UoeswJ+Z16f3ECoL1OSnq4A0riiLj1ZGmVHNhM6m/gotKaHNMxsK9zsbqmuU6IT/\n' +
	        'P6cR0S+vdigQG8ZNFf5vEyVNXhl8KcaJn6lMD/gMB2rY0qpaeTg4gPfU5wcg8S4Y\n' +
	        'C9V//tw3hv0f2n+8kGNmqZrylOQDQWSSo8j8M2SRSXiwOHDoTASd1fyBEIqBAwzn\n' +
	        'LvXVg8wQd1WlmM3b0Vrsbzltyh6y4SuKSkmgufYYvC07NknQO5vqvZcNoYbLNea3\n' +
	        '76NkFaMHUekSbwVejZgG5HGwbaYBgNdJEdpbWlA3X4yGRVxknQSUyt4dZRnw/HrX\n' +
	        'k8x6/wvtw7wht0/DOqz1li7baSsMazqxx+jDdSr1h9xML416Q4loFCLgqQhil8Jq\n' +
	        'Em4Hy3A=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGBTCCA+2gAwIBAgIRAJfKe4Zh4aWNt3bv6ZjQwogwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\n' +
	        'QW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYD\n' +
	        'VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDg1M1oYDzIxMjEwNTIxMjMwODUzWjCB\n' +
	        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
	        'bWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCpgUH6\n' +
	        'Crzd8cOw9prAh2rkQqAOx2vtuI7xX4tmBG4I/um28eBjyVmgwQ1fpq0Zg2nCKS54\n' +
	        'Nn0pCmT7f3h6Bvopxn0J45AzXEtajFqXf92NQ3iPth95GVfAJSD7gk2LWMhpmID9\n' +
	        'JGQyoGuDPg+hYyr292X6d0madzEktVVGO4mKTF989qEg+tY8+oN0U2fRTrqa2tZp\n' +
	        'iYsmg350ynNopvntsJAfpCO/srwpsqHHLNFZ9jvhTU8uW90wgaKO9i31j/mHggCE\n' +
	        '+CAOaJCM3g+L8DPl/2QKsb6UkBgaaIwKyRgKSj1IlgrK+OdCBCOgM9jjId4Tqo2j\n' +
	        'ZIrrPBGl6fbn1+etZX+2/tf6tegz+yV0HHQRAcKCpaH8AXF44bny9andslBoNjGx\n' +
	        'H6R/3ib4FhPrnBMElzZ5i4+eM/cuPC2huZMBXb/jKgRC/QN1Wm3/nah5FWq+yn+N\n' +
	        'tiAF10Ga0BYzVhHDEwZzN7gn38bcY5yi/CjDUNpY0OzEe2+dpaBKPlXTaFfn9Nba\n' +
	        'CBmXPRF0lLGGtPeTAgjcju+NEcVa82Ht1pqxyu2sDtbu3J5bxp4RKtj+ShwN8nut\n' +
	        'Tkf5Ea9rSmHEY13fzgibZlQhXaiFSKA2ASUwgJP19Putm0XKlBCNSGCoECemewxL\n' +
	        '+7Y8FszS4Uu4eaIwvXVqUEE2yf+4ex0hqQ1acQIDAQABo0IwQDAPBgNVHRMBAf8E\n' +
	        'BTADAQH/MB0GA1UdDgQWBBSeUnXIRxNbYsZLtKomIz4Y1nOZEzAOBgNVHQ8BAf8E\n' +
	        'BAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAIpRvxVS0dzoosBh/qw65ghPUGSbP2D4\n' +
	        'dm6oYCv5g/zJr4fR7NzEbHOXX5aOQnHbQL4M/7veuOCLNPOW1uXwywMg6gY+dbKe\n' +
	        'YtPVA1as8G9sUyadeXyGh2uXGsziMFXyaESwiAXZyiYyKChS3+g26/7jwECFo5vC\n' +
	        'XGhWpIO7Hp35Yglp8AnwnEAo/PnuXgyt2nvyTSrxlEYa0jus6GZEZd77pa82U1JH\n' +
	        'qFhIgmKPWWdvELA3+ra1nKnvpWM/xX0pnMznMej5B3RT3Y+k61+kWghJE81Ix78T\n' +
	        '+tG4jSotgbaL53BhtQWBD1yzbbilqsGE1/DXPXzHVf9yD73fwh2tGWSaVInKYinr\n' +
	        'a4tcrB3KDN/PFq0/w5/21lpZjVFyu/eiPj6DmWDuHW73XnRwZpHo/2OFkei5R7cT\n' +
	        'rn/YdDD6c1dYtSw5YNnS6hdCQ3sOiB/xbPRN9VWJa6se79uZ9NLz6RMOr73DNnb2\n' +
	        'bhIR9Gf7XAA5lYKqQk+A+stoKbIT0F65RnkxrXi/6vSiXfCh/bV6B41cf7MY/6YW\n' +
	        'ehserSdjhQamv35rTFdM+foJwUKz1QN9n9KZhPxeRmwqPitAV79PloksOnX25ElN\n' +
	        'SlyxdndIoA1wia1HRd26EFm2pqfZ2vtD2EjU3wD42CXX4H8fKVDna30nNFSYF0yn\n' +
	        'jGKc3k6UNxpg\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/jCCA+agAwIBAgIQaRHaEqqacXN20e8zZJtmDDANBgkqhkiG9w0BAQwFADCB\n' +
	        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
	        'bWF6b24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTI1MjIzODM1WhgPMjEyMTA1MjUyMzM4MzVaMIGXMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
	        'biBSRFMgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAInfBCaHuvj6Rb5c\n' +
	        'L5Wmn1jv2PHtEGMHm+7Z8dYosdwouG8VG2A+BCYCZfij9lIGszrTXkY4O7vnXgru\n' +
	        'JUNdxh0Q3M83p4X+bg+gODUs3jf+Z3Oeq7nTOk/2UYvQLcxP4FEXILxDInbQFcIx\n' +
	        'yen1ESHggGrjEodgn6nbKQNRfIhjhW+TKYaewfsVWH7EF2pfj+cjbJ6njjgZ0/M9\n' +
	        'VZifJFBgat6XUTOf3jwHwkCBh7T6rDpgy19A61laImJCQhdTnHKvzTpxcxiLRh69\n' +
	        'ZObypR7W04OAUmFS88V7IotlPmCL8xf7kwxG+gQfvx31+A9IDMsiTqJ1Cc4fYEKg\n' +
	        'bL+Vo+2Ii4W2esCTGVYmHm73drznfeKwL+kmIC/Bq+DrZ+veTqKFYwSkpHRyJCEe\n' +
	        'U4Zym6POqQ/4LBSKwDUhWLJIlq99bjKX+hNTJykB+Lbcx0ScOP4IAZQoxmDxGWxN\n' +
	        'S+lQj+Cx2pwU3S/7+OxlRndZAX/FKgk7xSMkg88HykUZaZ/ozIiqJqSnGpgXCtED\n' +
	        'oQ4OJw5ozAr+/wudOawaMwUWQl5asD8fuy/hl5S1nv9XxIc842QJOtJFxhyeMIXt\n' +
	        'LVECVw/dPekhMjS3Zo3wwRgYbnKG7YXXT5WMxJEnHu8+cYpMiRClzq2BEP6/MtI2\n' +
	        'AZQQUFu2yFjRGL2OZA6IYjxnXYiRAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
	        'HQYDVR0OBBYEFADCcQCPX2HmkqQcmuHfiQ2jjqnrMA4GA1UdDwEB/wQEAwIBhjAN\n' +
	        'BgkqhkiG9w0BAQwFAAOCAgEASXkGQ2eUmudIKPeOIF7RBryCoPmMOsqP0+1qxF8l\n' +
	        'pGkwmrgNDGpmd9s0ArfIVBTc1jmpgB3oiRW9c6n2OmwBKL4UPuQ8O3KwSP0iD2sZ\n' +
	        'KMXoMEyphCEzW1I2GRvYDugL3Z9MWrnHkoaoH2l8YyTYvszTvdgxBPpM2x4pSkp+\n' +
	        '76d4/eRpJ5mVuQ93nC+YG0wXCxSq63hX4kyZgPxgCdAA+qgFfKIGyNqUIqWgeyTP\n' +
	        'n5OgKaboYk2141Rf2hGMD3/hsGm0rrJh7g3C0ZirPws3eeJfulvAOIy2IZzqHUSY\n' +
	        'jkFzraz6LEH3IlArT3jUPvWKqvh2lJWnnp56aqxBR7qHH5voD49UpJWY1K0BjGnS\n' +
	        'OHcurpp0Yt/BIs4VZeWdCZwI7JaSeDcPMaMDBvND3Ia5Fga0thgYQTG6dE+N5fgF\n' +
	        'z+hRaujXO2nb0LmddVyvE8prYlWRMuYFv+Co8hcMdJ0lEZlfVNu0jbm9/GmwAZ+l\n' +
	        '9umeYO9yz/uC7edC8XJBglMAKUmVK9wNtOckUWAcCfnPWYLbYa/PqtXBYcxrso5j\n' +
	        'iaS/A7iEW51uteHBGrViCy1afGG+hiUWwFlesli+Rq4dNstX3h6h2baWABaAxEVJ\n' +
	        'y1RnTQSz6mROT1VmZSgSVO37rgIyY0Hf0872ogcTS+FfvXgBxCxsNWEbiQ/XXva4\n' +
	        '0Ws=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICtDCCAjqgAwIBAgIRAMyaTlVLN0ndGp4ffwKAfoMwCgYIKoZIzj0EAwMwgZkx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\n' +
	        'em9uIFJEUyBtZS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjIwNTA3MDA0NDM3WhgPMjEyMjA1MDcwMTQ0MzdaMIGZMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\n' +
	        'biBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE19nCV1nsI6CohSor13+B25cr\n' +
	        'zg+IHdi9Y3L7ziQnHWI6yjBazvnKD+oC71aRRlR8b5YXsYGUQxWzPLHN7EGPcSGv\n' +
	        'bzA9SLG1KQYCJaQ0m9Eg/iGrwKWOgylbhVw0bCxoo0IwQDAPBgNVHRMBAf8EBTAD\n' +
	        'AQH/MB0GA1UdDgQWBBS4KsknsJXM9+QPEkBdZxUPaLr11zAOBgNVHQ8BAf8EBAMC\n' +
	        'AYYwCgYIKoZIzj0EAwMDaAAwZQIxAJaRgrYIEfXQMZQQDxMTYS0azpyWSseQooXo\n' +
	        'L3nYq4OHGBgYyQ9gVjvRYWU85PXbfgIwdi82DtANQFkCu+j+BU0JBY/uRKPEeYzo\n' +
	        'JG92igKIcXPqCoxIJ7lJbbzmuf73gQu5\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGATCCA+mgAwIBAgIRAJwCobx0Os8F7ihbJngxrR8wDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
	        'QW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMTA1MjAxNzE1MzNaGA8yMTIxMDUyMDE4MTUzM1owgZgx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
	        'em9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
	        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANukKwlm+ZaI\n' +
	        'Y5MkWGbEVLApEyLmlrHLEg8PfiiEa9ts7jssQcin3bzEPdTqGr5jo91ONoZ3ccWq\n' +
	        'xJgg1W3bLu5CAO2CqIOXTXHRyCO/u0Ch1FGgWB8xETPSi3UHt/Vn1ltdO6DYdbDU\n' +
	        'mYgwzYrvLBdRCwxsb9o+BuYQHVFzUYonqk/y9ujz3gotzFq7r55UwDTA1ita3vb4\n' +
	        'eDKjIb4b1M4Wr81M23WHonpje+9qkkrAkdQcHrkgvSCV046xsq/6NctzwCUUNsgF\n' +
	        '7Q1a8ut5qJEYpz5ta8vI1rqFqAMBqCbFjRYlmAoTTpFPOmzAVxV+YoqTrW5A16su\n' +
	        '/2SXlMYfJ/n/ad/QfBNPPAAQMpyOr2RCL/YiL/PFZPs7NxYjnZHNWxMLSPgFyI+/\n' +
	        't2klnn5jR76KJK2qimmaXedB90EtFsMRUU1e4NxH9gDuyrihKPJ3aVnZ35mSipvR\n' +
	        '/1KB8t8gtFXp/VQaz2sg8+uxPMKB81O37fL4zz6Mg5K8+aq3ejBiyHucpFGnsnVB\n' +
	        '3kQWeD36ONkybngmgWoyPceuSWm1hQ0Z7VRAQX+KlxxSaHmSaIk1XxZu9h9riQHx\n' +
	        'fMuev6KXjRn/CjCoUTn+7eFrt0dT5GryQEIZP+nA0oq0LKxogigHNZlwAT4flrqb\n' +
	        'JUfZJrqgoce5HjZSXl10APbtPjJi0fW9AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
	        'Af8wHQYDVR0OBBYEFEfV+LztI29OVDRm0tqClP3NrmEWMA4GA1UdDwEB/wQEAwIB\n' +
	        'hjANBgkqhkiG9w0BAQwFAAOCAgEAvSNe+0wuk53KhWlRlRf2x/97H2Q76X3anzF0\n' +
	        '5fOSVm022ldALzXMzqOfdnoKIhAu2oVKiHHKs7mMas+T6TL+Mkphx0CYEVxFE3PG\n' +
	        '061q3CqJU+wMm9W9xsB79oB2XG47r1fIEywZZ3GaRsatAbjcNOT8uBaATPQAfJFN\n' +
	        'zjFe4XyN+rA4cFrYNvfHTeu5ftrYmvks7JlRaJgEGWsz+qXux7uvaEEVPqEumd2H\n' +
	        'uYeaRNOZ2V23R009X5lbgBFx9tq5VDTnKhQiTQ2SeT0rc1W3Dz5ik6SbQQNP3nSR\n' +
	        '0Ywy7r/sZ3fcDyfFiqnrVY4Ympfvb4YW2PZ6OsQJbzH6xjdnTG2HtzEU30ngxdp1\n' +
	        'WUEF4zt6rjJCp7QBUqXgdlHvJqYu6949qtWjEPiFN9uSsRV2i1YDjJqN52dLjAPn\n' +
	        'AipJKo8x1PHTwUzuITqnB9BdP+5TlTl8biJfkEf/+08eWDTLlDHr2VrZLOLompTh\n' +
	        'bS5OrhDmqA2Q+O+EWrTIhMflwwlCpR9QYM/Xwvlbad9H0FUHbJsCVNaru3wGOgWo\n' +
	        'tt3dNSK9Lqnv/Ej9K9v6CRr36in4ylJKivhJ5B9E7ABHg7EpBJ1xi7O5eNDkNoJG\n' +
	        '+pFyphJq3AkBR2U4ni2tUaTAtSW2tks7IaiDV+UMtqZyGabT5ISQfWLLtLHSWn2F\n' +
	        'Tspdjbg=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIECTCCAvGgAwIBAgIRAJZFh4s9aZGzKaTMLrSb4acwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjEyODQxWhgPMjA2MTA1MTgyMjI4NDFa\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgQmV0YSB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n' +
	        '17i2yoU6diep+WrqxIn2CrDEO2NdJVwWTSckx4WMZlLpkQDoymSmkNHjq9ADIApD\n' +
	        'A31Cx+843apL7wub8QkFZD0Tk7/ThdHWJOzcAM3ov98QBPQfOC1W5zYIIRP2F+vQ\n' +
	        'TRETHQnLcW3rLv0NMk5oQvIKpJoC9ett6aeVrzu+4cU4DZVWYlJUoC/ljWzCluau\n' +
	        '8blfW0Vwin6OB7s0HCG5/wijQWJBU5SrP/KAIPeQi1GqG5efbqAXDr/ple0Ipwyo\n' +
	        'Xjjl73LenGUgqpANlC9EAT4i7FkJcllLPeK3NcOHjuUG0AccLv1lGsHAxZLgjk/x\n' +
	        'z9ZcnVV9UFWZiyJTKxeKPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n' +
	        'DgQWBBRWyMuZUo4gxCR3Luf9/bd2AqZ7CjAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\n' +
	        'hvcNAQELBQADggEBAIqN2DlIKlvDFPO0QUZQVFbsi/tLdYM98/vvzBpttlTGVMyD\n' +
	        'gJuQeHVz+MnhGIwoCGOlGU3OOUoIlLAut0+WG74qYczn43oA2gbMd7HoD7oL/IGg\n' +
	        'njorBwJVcuuLv2G//SqM3nxGcLRtkRnQ+lvqPxMz9+0fKFUn6QcIDuF0QSfthLs2\n' +
	        'WSiGEPKO9c9RSXdRQ4pXA7c3hXng8P4A2ZmdciPne5Nu4I4qLDGZYRrRLRkNTrOi\n' +
	        'TyS6r2HNGUfgF7eOSeKt3NWL+mNChcYj71/Vycf5edeczpUgfnWy9WbPrK1svKyl\n' +
	        'aAs2xg+X6O8qB+Mnj2dNBzm+lZIS3sIlm+nO9sg=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjSgAwIBAgIRAPAlEk8VJPmEzVRRaWvTh2AwCgYIKoZIzj0EAwMwgZYx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
	        'em9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTI1MjI0MTU1WhgPMjEyMTA1MjUyMzQxNTVaMIGWMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
	        'RFMgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
	        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEx5xjrup8II4HOJw15NTnS3H5yMrQGlbj\n' +
	        'EDA5MMGnE9DmHp5dACIxmPXPMe/99nO7wNdl7G71OYPCgEvWm0FhdvVUeTb3LVnV\n' +
	        'BnaXt32Ek7/oxGk1T+Df03C+W0vmuJ+wo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
	        'A1UdDgQWBBTGXmqBWN/1tkSea4pNw0oHrjk2UDAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
	        'KoZIzj0EAwMDaAAwZQIxAIqqZWCSrIkZ7zsv/FygtAusW6yvlL935YAWYPVXU30m\n' +
	        'jkMFLM+/RJ9GMvnO8jHfCgIwB+whlkcItzE9CRQ6CsMo/d5cEHDUu/QW6jSIh9BR\n' +
	        'OGh9pTYPVkUbBiKPA7lVVhre\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/zCCA+egAwIBAgIRAJGY9kZITwfSRaAS/bSBOw8wDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUxOTE4MTEyMFoYDzIxMjEwNTE5MTkxMTIwWjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDe2vlDp6Eo4WQi\n' +
	        'Wi32YJOgdXHhxTFrLjB9SRy22DYoMaWfginJIwJcSR8yse8ZDQuoNhERB9LRggAE\n' +
	        'eng23mhrfvtL1yQkMlZfBu4vG1nOb22XiPFzk7X2wqz/WigdYNBCqa1kK3jrLqPx\n' +
	        'YUy7jk2oZle4GLVRTNGuMfcid6S2hs3UCdXfkJuM2z2wc3WUlvHoVNk37v2/jzR/\n' +
	        'hSCHZv5YHAtzL/kLb/e64QkqxKll5QmKhyI6d7vt6Lr1C0zb+DmwxUoJhseAS0hI\n' +
	        'dRk5DklMb4Aqpj6KN0ss0HAYqYERGRIQM7KKA4+hxDMUkJmt8KqWKZkAlCZgflzl\n' +
	        'm8NZ31o2cvBzf6g+VFHx+6iVrSkohVQydkCxx7NJ743iPKsh8BytSM4qU7xx4OnD\n' +
	        'H2yNXcypu+D5bZnVZr4Pywq0w0WqbTM2bpYthG9IC4JeVUvZ2mDc01lqOlbMeyfT\n' +
	        'og5BRPLDXdZK8lapo7se2teh64cIfXtCmM2lDSwm1wnH2iSK+AWZVIM3iE45WSGc\n' +
	        'vZ+drHfVgjJJ5u1YrMCWNL5C2utFbyF9Obw9ZAwm61MSbPQL9JwznhNlCh7F2ANW\n' +
	        'ZHWQPNcOAJqzE4uVcJB1ZeVl28ORYY1668lx+s9yYeMXk3QQdj4xmdnvoBFggqRB\n' +
	        'ZR6Z0D7ZohADXe024RzEo1TukrQgKQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
	        'MB0GA1UdDgQWBBT7Vs4Y5uG/9aXnYGNMEs6ycPUT3jAOBgNVHQ8BAf8EBAMCAYYw\n' +
	        'DQYJKoZIhvcNAQEMBQADggIBACN4Htp2PvGcQA0/sAS+qUVWWJoAXSsu8Pgc6Gar\n' +
	        '7tKVlNJ/4W/a6pUV2Xo/Tz3msg4yiE8sMESp2k+USosD5n9Alai5s5qpWDQjrqrh\n' +
	        '76AGyF2nzve4kIN19GArYhm4Mz/EKEG1QHYvBDGgXi3kNvL/a2Zbybp+3LevG+q7\n' +
	        'xtx4Sz9yIyMzuT/6Y7ijtiMZ9XbuxGf5wab8UtwT3Xq1UradJy0KCkzRJAz/Wy/X\n' +
	        'HbTkEvKSaYKExH6sLo0jqdIjV/d2Io31gt4e0Ly1ER2wPyFa+pc/swu7HCzrN+iz\n' +
	        'A2ZM4+KX9nBvFyfkHLix4rALg+WTYJa/dIsObXkdZ3z8qPf5A9PXlULiaa1mcP4+\n' +
	        'rokw74IyLEYooQ8iSOjxumXhnkTS69MAdGzXYE5gnHokABtGD+BB5qLhtLt4fqAp\n' +
	        '8AyHpQWMyV42M9SJLzQ+iOz7kAgJOBOaVtJI3FV/iAg/eqWVm3yLuUTWDxSHrKuL\n' +
	        'N19+pSjF6TNvUSFXwEa2LJkfDqIOCE32iOuy85QY//3NsgrSQF6UkSPa95eJrSGI\n' +
	        '3hTRYYh3Up2GhBGl1KUy7/o0k3KRZTk4s38fylY8bZ3TakUOH5iIGoHyFVVcp361\n' +
	        'Pyy25SzFSmNalWoQd9wZVc/Cps2ldxhcttM+WLkFNzprd0VJa8qTz8vYtHP0ouDN\n' +
	        'nWS0\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGCTCCA/GgAwIBAgIRAOY7gfcBZgR2tqfBzMbFQCUwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY1NDU5WhgPMjEyMjA1MjUxNzU0NTla\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
	        'lfxER43FuLRdL08bddF0YhbCP+XXKj1A/TFMXmd2My8XDei8rPXFYyyjMig9+xZw\n' +
	        'uAsIxLwz8uiA26CKA8bCZKg5VG2kTeOJAfvBJaLv1CZefs3Z4Uf1Sjvm6MF2yqEj\n' +
	        'GoORfyfL9HiZFTDuF/hcjWoKYCfMuG6M/wO8IbdICrX3n+BiYQJu/pFO660Mg3h/\n' +
	        '8YBBWYDbHoCiH/vkqqJugQ5BM3OI5nsElW51P1icEEqti4AZ7JmtSv9t7fIFBVyR\n' +
	        'oaEyOgpp0sm193F/cDJQdssvjoOnaubsSYm1ep3awZAUyGN/X8MBrPY95d0hLhfH\n' +
	        'Ehc5Icyg+hsosBljlAyksmt4hFQ9iBnWIz/ZTfGMck+6p3HVL9RDgvluez+rWv59\n' +
	        '8q7omUGsiPApy5PDdwI/Wt/KtC34/2sjslIJfvgifdAtkRPkhff1WEwER00ADrN9\n' +
	        'eGGInaCpJfb1Rq8cV2n00jxg7DcEd65VR3dmIRb0bL+jWK62ni/WdEyomAOMfmGj\n' +
	        'aWf78S/4rasHllWJ+QwnaUYY3u6N8Cgio0/ep4i34FxMXqMV3V0/qXdfhyabi/LM\n' +
	        'wCxNo1Dwt+s6OtPJbwO92JL+829QAxydfmaMTeHBsgMPkG7RwAekeuatKGHNsc2Z\n' +
	        'x2Q4C2wVvOGAhcHwxfM8JfZs3nDSZJndtVVnFlUY0UECAwEAAaNCMEAwDwYDVR0T\n' +
	        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQUpnG7mWazy6k97/tb5iduRB3RXgQwDgYDVR0P\n' +
	        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCDLqq1Wwa9Tkuv7vxBnIeVvvFF\n' +
	        'ecTn+P+wJxl9Qa2ortzqTHZsBDyJO62d04AgBwiDXkJ9a+bthgG0H1J7Xee8xqv1\n' +
	        'xyX2yKj24ygHjspLotKP4eDMdDi5TYq+gdkbPmm9Q69B1+W6e049JVGXvWG8/7kU\n' +
	        'igxeuCYwtCCdUPRLf6D8y+1XMGgVv3/DSOHWvTg3MJ1wJ3n3+eve3rjGdRYWZeJu\n' +
	        'k21HLSZYzVrCtUsh2YAeLnUbSxVuT2Xr4JehYe9zW5HEQ8Je/OUfnCy9vzoN/ITw\n' +
	        'osAH+EBJQey7RxEDqMwCaRefH0yeHFcnOll0OXg/urnQmwbEYzQ1uutJaBPsjU0J\n' +
	        'Qf06sMxI7GiB5nPE+CnI2sM6A9AW9kvwexGXpNJiLxF8dvPQthpOKGcYu6BFvRmt\n' +
	        '6ctfXd9b7JJoVqMWuf5cCY6ihpk1e9JTlAqu4Eb/7JNyGiGCR40iSLvV28un9wiE\n' +
	        'plrdYxwcNYq851BEu3r3AyYWw/UW1AKJ5tM+/Gtok+AphMC9ywT66o/Kfu44mOWm\n' +
	        'L3nSLSWEcgfUVgrikpnyGbUnGtgCmHiMlUtNVexcE7OtCIZoVAlCGKNu7tyuJf10\n' +
	        'Qlk8oIIzfSIlcbHpOYoN79FkLoDNc2er4Gd+7w1oPQmdAB0jBJnA6t0OUBPKdDdE\n' +
	        'Ufff2jrbfbzECn1ELg==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGCDCCA/CgAwIBAgIQIuO1A8LOnmc7zZ/vMm3TrDANBgkqhkiG9w0BAQwFADCB\n' +
	        'nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\n' +
	        'bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\n' +
	        'A1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQ2MThaGA8yMTIxMDUyNDIxNDYxOFow\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDq\n' +
	        'qRHKbG8ZK6/GkGm2cenznEF06yHwI1gD5sdsHjTgekDZ2Dl9RwtDmUH2zFuIQwGj\n' +
	        'SeC7E2iKwrJRA5wYzL9/Vk8NOILEKQOP8OIKUHbc7q8rEtjs401KcU6pFBBEdO9G\n' +
	        'CTiRhogq+8mhC13AM/UriZJbKhwgM2UaDOzAneGMhQAGjH8z83NsNcPxpYVE7tqM\n' +
	        'sch5yLtIJLkJRusrmQQTeHUev16YNqyUa+LuFclFL0FzFCimkcxUhXlbfEKXbssS\n' +
	        'yPzjiv8wokGyo7+gA0SueceMO2UjfGfute3HlXZDcNvBbkSY+ver41jPydyRD6Qq\n' +
	        'oEkh0tyIbPoa3oU74kwipJtz6KBEA3u3iq61OUR0ENhR2NeP7CSKrC24SnQJZ/92\n' +
	        'qxusrbyV/0w+U4m62ug/o4hWNK1lUcc2AqiBOvCSJ7qpdteTFxcEIzDwYfERDx6a\n' +
	        'd9+3IPvzMb0ZCxBIIUFMxLTF7yAxI9s6KZBBXSZ6tDcCCYIgEysEPRWMRAcG+ye/\n' +
	        'fZVn9Vnzsj4/2wchC2eQrYpb1QvG4eMXA4M5tFHKi+/8cOPiUzJRgwS222J8YuDj\n' +
	        'yEBval874OzXk8H8Mj0JXJ/jH66WuxcBbh5K7Rp5oJn7yju9yqX6qubY8gVeMZ1i\n' +
	        'u4oXCopefDqa35JplQNUXbWwSebi0qJ4EK0V8F9Q+QIDAQABo0IwQDAPBgNVHRMB\n' +
	        'Af8EBTADAQH/MB0GA1UdDgQWBBT4ysqCxaPe7y+g1KUIAenqu8PAgzAOBgNVHQ8B\n' +
	        'Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBALU8WN35KAjPZEX65tobtCDQFkIO\n' +
	        'uJjv0alD7qLB0i9eY80C+kD87HKqdMDJv50a5fZdqOta8BrHutgFtDm+xo5F/1M3\n' +
	        'u5/Vva5lV4xy5DqPajcF4Mw52czYBmeiLRTnyPJsU93EQIC2Bp4Egvb6LI4cMOgm\n' +
	        '4pY2hL8DojOC5PXt4B1/7c1DNcJX3CMzHDm4SMwiv2MAxSuC/cbHXcWMk+qXdrVx\n' +
	        '+ayLUSh8acaAOy3KLs1MVExJ6j9iFIGsDVsO4vr4ZNsYQiyHjp+L8ops6YVBO5AT\n' +
	        'k/pI+axHIVsO5qiD4cFWvkGqmZ0gsVtgGUchZaacboyFsVmo6QPrl28l6LwxkIEv\n' +
	        'GGJYvIBW8sfqtGRspjfX5TlNy5IgW/VOwGBdHHsvg/xpRo31PR3HOFw7uPBi7cAr\n' +
	        'FiZRLJut7af98EB2UvovZnOh7uIEGPeecQWeOTQfJeWet2FqTzFYd0NUMgqPuJx1\n' +
	        'vLKferP+ajAZLJvVnW1J7Vccx/pm0rMiUJEf0LRb/6XFxx7T2RGjJTi0EzXODTYI\n' +
	        'gnLfBBjnolQqw+emf4pJ4pAtly0Gq1KoxTG2QN+wTd4lsCMjnelklFDjejwnl7Uy\n' +
	        'vtxzRBAu/hi/AqDkDFf94m6j+edIrjbi9/JDFtQ9EDlyeqPgw0qwi2fwtJyMD45V\n' +
	        'fejbXelUSJSzDIdY\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGCTCCA/GgAwIBAgIRAN7Y9G9i4I+ZaslPobE7VL4wDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYzMzIzWhgPMjEyMTA1MjAxNzMzMjNa\n' +
	        'MIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\n' +
	        'SW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\n' +
	        'LEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\n' +
	        'DgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n' +
	        '4BEPCiIfiK66Q/qa8k+eqf1Q3qsa6Xuu/fPkpuStXVBShhtXd3eqrM0iT4Xxs420\n' +
	        'Va0vSB3oZ7l86P9zYfa60n6PzRxdYFckYX330aI7L/oFIdaodB/C9szvROI0oLG+\n' +
	        '6RwmIF2zcprH0cTby8MiM7G3v9ykpq27g4WhDC1if2j8giOQL3oHpUaByekZNIHF\n' +
	        'dIllsI3RkXmR3xmmxoOxJM1B9MZi7e1CvuVtTGOnSGpNCQiqofehTGwxCN2wFSK8\n' +
	        'xysaWlw48G0VzZs7cbxoXMH9QbMpb4tpk0d+T8JfAPu6uWO9UwCLWWydf0CkmA/+\n' +
	        'D50/xd1t33X9P4FEaPSg5lYbHXzSLWn7oLbrN2UqMLaQrkoEBg/VGvzmfN0mbflw\n' +
	        '+T87bJ/VEOVNlG+gepyCTf89qIQVWOjuYMox4sK0PjzZGsYEuYiq1+OUT3vk/e5K\n' +
	        'ag1fCcq2Isy4/iwB2xcXrsQ6ljwdk1fc+EmOnjGKrhuOHJY3S+RFv4ToQBsVyYhC\n' +
	        'XGaC3EkqIX0xaCpDimxYhFjWhpDXAjG/zJ+hRLDAMCMhl/LPGRk/D1kzSbPmdjpl\n' +
	        'lEMK5695PeBvEBTQdBQdOiYgOU3vWU6tzwwHfiM2/wgvess/q0FDAHfJhppbgbb9\n' +
	        '3vgsIUcsvoC5o29JvMsUxsDRvsAfEmMSDGkJoA/X6GECAwEAAaNCMEAwDwYDVR0T\n' +
	        'AQH/BAUwAwEB/zAdBgNVHQ4EFgQUgEWm1mZCbGD6ytbwk2UU1aLaOUUwDgYDVR0P\n' +
	        'AQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBb4+ABTGBGwxK1U/q4g8JDqTQM\n' +
	        '1Wh8Oz8yAk4XtPJMAmCctxbd81cRnSnePWw/hxViLVtkZ/GsemvXfqAQyOn1coN7\n' +
	        'QeYSw+ZOlu0j2jEJVynmgsR7nIRqE7QkCyZAU+d2FTJUfmee+IiBiGyFGgxz9n7A\n' +
	        'JhBZ/eahBbiuoOik/APW2JWLh0xp0W0GznfJ8lAlaQTyDa8iDXmVtbJg9P9qzkvl\n' +
	        'FgPXQttzEOyooF8Pb2LCZO4kUz+1sbU7tHdr2YE+SXxt6D3SBv+Yf0FlvyWLiqVk\n' +
	        'GDEOlPPTDSjAWgKnqST8UJ0RDcZK/v1ixs7ayqQJU0GUQm1I7LGTErWXHMnCuHKe\n' +
	        'UKYuiSZwmTcJ06NgdhcCnGZgPq13ryMDqxPeltQc3n5eO7f1cL9ERYLDLOzm6A9P\n' +
	        'oQ3MfcVOsbHgGHZWaPSeNrQRN9xefqBXH0ZPasgcH9WJdsLlEjVUXoultaHOKx3b\n' +
	        'UCCb+d3EfqF6pRT488ippOL6bk7zNubwhRa/+y4wjZtwe3kAX78ACJVcjPobH9jZ\n' +
	        'ErySads5zdQeaoee5wRKdp3TOfvuCe4bwLRdhOLCHWzEcXzY3g/6+ppLvNom8o+h\n' +
	        'Bh5X26G6KSfr9tqhQ3O9IcbARjnuPbvtJnoPY0gz3EHHGPhy0RNW8i2gl3nUp0ah\n' +
	        'PtjwbKW0hYAhIttT0Q==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICtzCCAj2gAwIBAgIQQRBQTs6Y3H1DDbpHGta3lzAKBggqhkjOPQQDAzCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDYxMTAwMTI0M1oYDzIxMjEwNjExMDExMjQzWjCBmzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\n' +
	        'b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEs0942Xj4m/gKA+WA6F5h\n' +
	        'AHYuek9eGpzTRoLJddM4rEV1T3eSueytMVKOSlS3Ub9IhyQrH2D8EHsLYk9ktnGR\n' +
	        'pATk0kCYTqFbB7onNo070lmMJmGT/Q7NgwC8cySChFxbo0IwQDAPBgNVHRMBAf8E\n' +
	        'BTADAQH/MB0GA1UdDgQWBBQ20iKBKiNkcbIZRu0y1uoF1yJTEzAOBgNVHQ8BAf8E\n' +
	        'BAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIwYv0wTSrpQTaPaarfLN8Xcqrqu3hzl07n\n' +
	        'FrESIoRw6Cx77ZscFi2/MV6AFyjCV/TlAjEAhpwJ3tpzPXpThRML8DMJYZ3YgMh3\n' +
	        'CMuLqhPpla3cL0PhybrD27hJWl29C4el6aMO\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrDCCAjOgAwIBAgIQGcztRyV40pyMKbNeSN+vXTAKBggqhkjOPQQDAzCBljEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\n' +
	        'b24gUkRTIHVzLWVhc3QtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTAgFw0yMTA1MjEyMzE1NTZaGA8yMTIxMDUyMjAwMTU1NlowgZYxCzAJBgNV\n' +
	        'BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\n' +
	        'VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\n' +
	        'UyB1cy1lYXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\n' +
	        'djAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfDcv+GGRESD9wT+I5YIPRsD3L+/jsiIis\n' +
	        'Tr7t9RSbFl+gYpO7ZbDXvNbV5UGOC5lMJo/SnqFRTC6vL06NF7qOHfig3XO8QnQz\n' +
	        '6T5uhhrhnX2RSY3/10d2kTyHq3ZZg3+jQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\n' +
	        'VR0OBBYEFLDyD3PRyNXpvKHPYYxjHXWOgfPnMA4GA1UdDwEB/wQEAwIBhjAKBggq\n' +
	        'hkjOPQQDAwNnADBkAjB20HQp6YL7CqYD82KaLGzgw305aUKw2aMrdkBR29J183jY\n' +
	        '6Ocj9+Wcif9xnRMS+7oCMAvrt03rbh4SU9BohpRUcQ2Pjkh7RoY0jDR4Xq4qzjNr\n' +
	        '5UFr3BXpFvACxXF51BksGQ==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjWgAwIBAgIQeKbS5zvtqDvRtwr5H48cAjAKBggqhkjOPQQDAzCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTIwMTcxOTU1WhgPMjEyMTA1MjAxODE5NTVaMIGXMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
	        'RFMgbWUtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
	        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABEKjgUaAPmUlRMEQdBC7BScAGosJ1zRV\n' +
	        'LDd38qTBjzgmwBfQJ5ZfGIvyEK5unB09MB4e/3qqK5I/L6Qn5Px/n5g4dq0c7MQZ\n' +
	        'u7G9GBYm90U3WRJBf7lQrPStXaRnS4A/O6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
	        'BgNVHQ4EFgQUNKcAbGEIn03/vkwd8g6jNyiRdD4wDgYDVR0PAQH/BAQDAgGGMAoG\n' +
	        'CCqGSM49BAMDA2cAMGQCMHIeTrjenCSYuGC6txuBt/0ZwnM/ciO9kHGWVCoK8QLs\n' +
	        'jGghb5/YSFGZbmQ6qpGlSAIwVOQgdFfTpEfe5i+Vs9frLJ4QKAfc27cTNYzRIM0I\n' +
	        'E+AJgK4C4+DiyyMzOpiCfmvq\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGCDCCA/CgAwIBAgIQSFkEUzu9FYgC5dW+5lnTgjANBgkqhkiG9w0BAQwFADCB\n' +
	        'nDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\n' +
	        'bWF6b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\n' +
	        'A1UEBwwHU2VhdHRsZTAgFw0yMTA2MTEwMDA4MzZaGA8yMTIxMDYxMTAxMDgzNlow\n' +
	        'gZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\n' +
	        'QW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO\n' +
	        'BgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDx\n' +
	        'my5Qmd8zdwaI/KOKV9Xar9oNbhJP5ED0JCiigkuvCkg5qM36klszE8JhsUj40xpp\n' +
	        'vQw9wkYW4y+C8twBpzKGBvakqMnoaVUV7lOCKx0RofrnNwkZCboTBB4X/GCZ3fIl\n' +
	        'YTybS7Ehi1UuiaZspIT5A2jidoA8HiBPk+mTg1UUkoWS9h+MEAPa8L4DY6fGf4pO\n' +
	        'J1Gk2cdePuNzzIrpm2yPto+I8MRROwZ3ha7ooyymOXKtz2c7jEHHJ314boCXAv9G\n' +
	        'cdo27WiebewZkHHH7Zx9iTIVuuk2abyVSzvLVeGv7Nuy4lmSqa5clWYqWsGXxvZ2\n' +
	        '0fZC5Gd+BDUMW1eSpW7QDTk3top6x/coNoWuLSfXiC5ZrJkIKimSp9iguULgpK7G\n' +
	        'abMMN4PR+O+vhcB8E879hcwmS2yd3IwcPTl3QXxufqeSV58/h2ibkqb/W4Bvggf6\n' +
	        '5JMHQPlPHOqMCVFIHP1IffIo+Of7clb30g9FD2j3F4qgV3OLwEDNg/zuO1DiAvH1\n' +
	        'L+OnmGHkfbtYz+AVApkAZrxMWwoYrwpauyBusvSzwRE24vLTd2i80ZDH422QBLXG\n' +
	        'rN7Zas8rwIiBKacJLYtBYETw8mfsNt8gb72aIQX6cZOsphqp6hUtKaiMTVgGazl7\n' +
	        'tBXqbB+sIv3S9X6bM4cZJKkMJOXbnyCCLZFYv8TurwIDAQABo0IwQDAPBgNVHRMB\n' +
	        'Af8EBTADAQH/MB0GA1UdDgQWBBTOVtaS1b/lz6yJDvNk65vEastbQTAOBgNVHQ8B\n' +
	        'Af8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBABEONg+TmMZM/PrYGNAfB4S41zp1\n' +
	        '3CVjslZswh/pC4kgXSf8cPJiUOzMwUevuFQj7tCqxQtJEygJM2IFg4ViInIah2kh\n' +
	        'xlRakEGGw2dEVlxZAmmLWxlL1s1lN1565t5kgVwM0GVfwYM2xEvUaby6KDVJIkD3\n' +
	        'aM6sFDBshvVA70qOggM6kU6mwTbivOROzfoIQDnVaT+LQjHqY/T+ok6IN0YXXCWl\n' +
	        'Favai8RDjzLDFwXSRvgIK+1c49vlFFY4W9Efp7Z9tPSZU1TvWUcKdAtV8P2fPHAS\n' +
	        'vAZ+g9JuNfeawhEibjXkwg6Z/yFUueQCQOs9TRXYogzp5CMMkfdNJF8byKYqHscs\n' +
	        'UosIcETnHwqwban99u35sWcoDZPr6aBIrz7LGKTJrL8Nis8qHqnqQBXu/fsQEN8u\n' +
	        'zJ2LBi8sievnzd0qI0kaWmg8GzZmYH1JCt1GXSqOFkI8FMy2bahP7TUQR1LBUKQ3\n' +
	        'hrOSqldkhN+cSAOnvbQcFzLr+iEYEk34+NhcMIFVE+51KJ1n6+zISOinr6mI3ckX\n' +
	        '6p2tmiCD4Shk2Xx/VTY/KGvQWKFcQApWezBSvDNlGe0yV71LtLf3dr1pr4ofo7cE\n' +
	        'rYucCJ40bfxEU/fmzYdBF32xP7AOD9U0FbOR3Mcthc6Z6w20WFC+zru8FGY08gPf\n' +
	        'WT1QcNdw7ntUJP/w\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrzCCAjWgAwIBAgIQARky6+5PNFRkFVOp3Ob1CTAKBggqhkjOPQQDAzCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjIwNTIzMTg0MTI4WhgPMjEyMjA1MjMxOTQxMjdaMIGXMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
	        'RFMgZXUtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
	        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABNVGL5oF7cfIBxKyWd2PVK/S5yQfaJY3\n' +
	        'QFHWvEdt6951n9JhiiPrHzfVHsxZp1CBjILRMzjgRbYWmc8qRoLkgGE7htGdwudJ\n' +
	        'Fa/WuKzO574Prv4iZXUnVGTboC7JdvKbh6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
	        'BgNVHQ4EFgQUgDeIIEKynwUbNXApdIPnmRWieZwwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
	        'CCqGSM49BAMDA2gAMGUCMEOOJfucrST+FxuqJkMZyCM3gWGZaB+/w6+XUAJC6hFM\n' +
	        'uSTY0F44/bERkA4XhH+YGAIxAIpJQBakCA1/mXjsTnQ+0El9ty+LODp8ibkn031c\n' +
	        '8DKDS7pR9UK7ZYdR6zFg3ZCjQw==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjOgAwIBAgIQJvkWUcYLbnxtuwnyjMmntDAKBggqhkjOPQQDAzCBljEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\n' +
	        'b24gUkRTIGV1LXdlc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTAgFw0yMTA1MjUyMjI2MTJaGA8yMTIxMDUyNTIzMjYxMlowgZYxCzAJBgNV\n' +
	        'BAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\n' +
	        'VQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\n' +
	        'UyBldS13ZXN0LTMgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\n' +
	        'djAQBgcqhkjOPQIBBgUrgQQAIgNiAARENn8uHCyjn1dFax4OeXxvbV861qsXFD9G\n' +
	        'DshumTmFzWWHN/69WN/AOsxy9XN5S7Cgad4gQgeYYYgZ5taw+tFo/jQvCLY//uR5\n' +
	        'uihcLuLJ78opvRPvD9kbWZ6oXfBtFkWjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\n' +
	        'VR0OBBYEFKiK3LpoF+gDnqPldGSwChBPCYciMA4GA1UdDwEB/wQEAwIBhjAKBggq\n' +
	        'hkjOPQQDAwNpADBmAjEA+7qfvRlnvF1Aosyp9HzxxCbN7VKu+QXXPhLEBWa5oeWW\n' +
	        'UOcifunf/IVLC4/FGCsLAjEAte1AYp+iJyOHDB8UYkhBE/1sxnFaTiEPbvQBU0wZ\n' +
	        'SuwWVLhu2wWDuSW+K7tTuL8p\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/zCCAuegAwIBAgIRAKeDpqX5WFCGNo94M4v69sUwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyBldS13ZXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyNTIyMTgzM1oYDzIwNjEwNTI1MjMxODMzWjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCcKOTEMTfzvs4H\n' +
	        'WtJR8gI7GXN6xesulWtZPv21oT+fLGwJ+9Bv8ADCGDDrDxfeH/HxJmzG9hgVAzVn\n' +
	        '4g97Bn7q07tGZM5pVi96/aNp11velZT7spOJKfJDZTlGns6DPdHmx48whpdO+dOb\n' +
	        '6+eR0VwCIv+Vl1fWXgoACXYCoKjhxJs+R+fwY//0JJ1YG8yjZ+ghLCJmvlkOJmE1\n' +
	        'TCPUyIENaEONd6T+FHGLVYRRxC2cPO65Jc4yQjsXvvQypoGgx7FwD5voNJnFMdyY\n' +
	        '754JGPOOe/SZdepN7Tz7UEq8kn7NQSbhmCsgA/Hkjkchz96qN/YJ+H/okiQUTNB0\n' +
	        'eG9ogiVFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFjayw9Y\n' +
	        'MjbxfF14XAhMM2VPl0PfMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
	        'AQEAAtmx6d9+9CWlMoU0JCirtp4dSS41bBfb9Oor6GQ8WIr2LdfZLL6uES/ubJPE\n' +
	        '1Sh5Vu/Zon5/MbqLMVrfniv3UpQIof37jKXsjZJFE1JVD/qQfRzG8AlBkYgHNEiS\n' +
	        'VtD4lFxERmaCkY1tjKB4Dbd5hfhdrDy29618ZjbSP7NwAfnwb96jobCmMKgxVGiH\n' +
	        'UqsLSiEBZ33b2hI7PJ6iTJnYBWGuiDnsWzKRmheA4nxwbmcQSfjbrNwa93w3caL2\n' +
	        'v/4u54Kcasvcu3yFsUwJygt8z43jsGAemNZsS7GWESxVVlW93MJRn6M+MMakkl9L\n' +
	        'tWaXdHZ+KUV7LhfYLb0ajvb40w==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBDCCAuygAwIBAgIQJ5oxPEjefCsaESSwrxk68DANBgkqhkiG9w0BAQsFADCB\n' +
	        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
	        'bWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUwIBcNMjIwNjA2MjExNzA1WhgPMjA2MjA2MDYyMjE3MDVaMIGa\n' +
	        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
	        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
	        'YXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALTQt5eX\n' +
	        'g+VP3BjO9VBkWJhE0GfLrU/QIk32I6WvrnejayTrlup9H1z4QWlXF7GNJrqScRMY\n' +
	        'KhJHlcP05aPsx1lYco6pdFOf42ybXyWHHJdShj4A5glU81GTT+VrXGzHSarLmtua\n' +
	        'eozkQgPpDsSlPt0RefyTyel7r3Cq+5K/4vyjCTcIqbfgaGwTU36ffjM1LaPCuE4O\n' +
	        'nINMeD6YuImt2hU/mFl20FZ+IZQUIFZZU7pxGLqTRz/PWcH8tDDxnkYg7tNuXOeN\n' +
	        'JbTpXrw7St50/E9ZQ0llGS+MxJD8jGRAa/oL4G/cwnV8P2OEPVVkgN9xDDQeieo0\n' +
	        '3xkzolkDkmeKOnUCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU\n' +
	        'bwu8635iQGQMRanekesORM8Hkm4wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB\n' +
	        'CwUAA4IBAQAgN6LE9mUgjsj6xGCX1afYE69fnmCjjb0rC6eEe1mb/QZNcyw4XBIW\n' +
	        '6+zTXo4mjZ4ffoxb//R0/+vdTE7IvaLgfAZgFsLKJCtYDDstXZj8ujQnGR9Pig3R\n' +
	        'W+LpNacvOOSJSawNQq0Xrlcu55AU4buyD5VjcICnfF1dqBMnGTnh27m/scd/ZMx/\n' +
	        'kapHZ/fMoK2mAgSX/NvUKF3UkhT85vSSM2BTtET33DzCPDQTZQYxFBa4rFRmFi4c\n' +
	        'BLlmIReiCGyh3eJhuUUuYAbK6wLaRyPsyEcIOLMQmZe1+gAFm1+1/q5Ke9ugBmjf\n' +
	        'PbTWjsi/lfZ5CdVAhc5lmZj/l5aKqwaS\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjSgAwIBAgIRAKKPTYKln9L4NTx9dpZGUjowCgYIKoZIzj0EAwMwgZYx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
	        'em9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTIxMjI1NTIxWhgPMjEyMTA1MjEyMzU1MjFaMIGWMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
	        'RFMgZXUtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
	        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE/owTReDvaRqdmbtTzXbyRmEpKCETNj6O\n' +
	        'hZMKH0F8oU9Tmn8RU7kQQj6xUKEyjLPrFBN7c+26TvrVO1KmJAvbc8bVliiJZMbc\n' +
	        'C0yV5PtJTalvlMZA1NnciZuhxaxrzlK1o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
	        'A1UdDgQWBBT4i5HaoHtrs7Mi8auLhMbKM1XevDAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
	        'KoZIzj0EAwMDaAAwZQIxAK9A+8/lFdX4XJKgfP+ZLy5ySXC2E0Spoy12Gv2GdUEZ\n' +
	        'p1G7c1KbWVlyb1d6subzkQIwKyH0Naf/3usWfftkmq8SzagicKz5cGcEUaULq4tO\n' +
	        'GzA/AMpr63IDBAqkZbMDTCmH\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrzCCAjWgAwIBAgIQTgIvwTDuNWQo0Oe1sOPQEzAKBggqhkjOPQQDAzCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTI0MjEwNjM4WhgPMjEyMTA1MjQyMjA2MzhaMIGXMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\n' +
	        'RFMgZXUtbm9ydGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\n' +
	        'ZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABJuzXLU8q6WwSKXBvx8BbdIi3mPhb7Xo\n' +
	        'rNJBfuMW1XRj5BcKH1ZoGaDGw+BIIwyBJg8qNmCK8kqIb4cH8/Hbo3Y+xBJyoXq/\n' +
	        'cuk8aPrxiNoRsKWwiDHCsVxaK9L7GhHHAqNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\n' +
	        'BgNVHQ4EFgQUYgcsdU4fm5xtuqLNppkfTHM2QMYwDgYDVR0PAQH/BAQDAgGGMAoG\n' +
	        'CCqGSM49BAMDA2gAMGUCMQDz/Rm89+QJOWJecYAmYcBWCcETASyoK1kbr4vw7Hsg\n' +
	        '7Ew3LpLeq4IRmTyuiTMl0gMCMAa0QSjfAnxBKGhAnYxcNJSntUyyMpaXzur43ec0\n' +
	        '3D8npJghwC4DuICtKEkQiI5cSg==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGATCCA+mgAwIBAgIRAORIGqQXLTcbbYT2upIsSnQwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
	        'QW1hem9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMjA1MjMxODM0MjJaGA8yMTIyMDUyMzE5MzQyMlowgZgx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
	        'em9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
	        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAPKukwsW2s/h\n' +
	        '1k+Hf65pOP0knVBnOnMQyT1mopp2XHGdXznj9xS49S30jYoUnWccyXgD983A1bzu\n' +
	        'w4fuJRHg4MFdz/NWTgXvy+zy0Roe83OPIJjUmXnnzwUHQcBa9vl6XUO65iQ3pbSi\n' +
	        'fQfNDFXD8cvuXbkezeADoy+iFAlzhXTzV9MD44GTuo9Z3qAXNGHQCrgRSCL7uRYt\n' +
	        't1nfwboCbsVRnElopn2cTigyVXE62HzBUmAw1GTbAZeFAqCn5giBWYAfHwTUldRL\n' +
	        '6eEa6atfsS2oPNus4ZENa1iQxXq7ft+pMdNt0qKXTCZiiCZjmLkY0V9kWwHTRRF8\n' +
	        'r+75oSL//3di43QnuSCgjwMRIeWNtMud5jf3eQzSBci+9njb6DrrSUbx7blP0srg\n' +
	        '94/C/fYOp/0/EHH34w99Th14VVuGWgDgKahT9/COychLOubXUT6vD1As47S9KxTv\n' +
	        'yYleVKwJnF9cVjepODN72fNlEf74BwzgSIhUmhksmZSeJBabrjSUj3pdyo/iRZN/\n' +
	        'CiYz9YPQ29eXHPQjBZVIUqWbOVfdwsx0/Xu5T1e7yyXByQ3/oDulahtcoKPAFQ3J\n' +
	        'ee6NJK655MdS7pM9hJnU2Rzu3qZ/GkM6YK7xTlMXVouPUZov/VbiaCKbqYDs8Dg+\n' +
	        'UKdeNXAT6+BMleGQzly1X7vjhgeA8ugVAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
	        'Af8wHQYDVR0OBBYEFJdaPwpCf78UolFTEn6GO85/QwUIMA4GA1UdDwEB/wQEAwIB\n' +
	        'hjANBgkqhkiG9w0BAQwFAAOCAgEAWkxHIT3mers5YnZRSVjmpxCLivGj1jMB9VYC\n' +
	        'iKqTAeIvD0940L0YaZgivQll5pue8UUcQ6M2uCdVVAsNJdmQ5XHIYiGOknYPtxzO\n' +
	        'aO+bnZp7VIZw/vJ49hvH6RreA2bbxYMZO/ossYdcWsWbOKHFrRmAw0AhtK/my51g\n' +
	        'obV7eQg+WmlE5Iqc75ycUsoZdc3NimkjBi7LQoNP1HMvlLHlF71UZhQDdq+/WdV7\n' +
	        '0zmg+epkki1LjgMmuPyb+xWuYkFKT1/faX+Xs62hIm5BY+aI4if4RuQ+J//0pOSs\n' +
	        'UajrjTo+jLGB8A96jAe8HaFQenbwMjlaHRDAF0wvbkYrMr5a6EbneAB37V05QD0Y\n' +
	        'Rh4L4RrSs9DX2hbSmS6iLDuPEjanHKzglF5ePEvnItbRvGGkynqDVlwF+Bqfnw8l\n' +
	        '0i8Hr1f1/LP1c075UjkvsHlUnGgPbLqA0rDdcxF8Fdlv1BunUjX0pVlz10Ha5M6P\n' +
	        'AdyWUOneOfaA5G7jjv7i9qg3r99JNs1/Lmyg/tV++gnWTAsSPFSSEte81kmPhlK3\n' +
	        '2UtAO47nOdTtk+q4VIRAwY1MaOR7wTFZPfer1mWs4RhKNu/odp8urEY87iIzbMWT\n' +
	        'QYO/4I6BGj9rEWNGncvR5XTowwIthMCj2KWKM3Z/JxvjVFylSf+s+FFfO1bNIm6h\n' +
	        'u3UBpZI=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICtDCCAjmgAwIBAgIQenQbcP/Zbj9JxvZ+jXbRnTAKBggqhkjOPQQDAzCBmTEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTIwMAYDVQQDDClBbWF6\n' +
	        'b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwH\n' +
	        'U2VhdHRsZTAgFw0yMTA1MjEyMjMzMjRaGA8yMTIxMDUyMTIzMzMyNFowgZkxCzAJ\n' +
	        'BgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMw\n' +
	        'EQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1hem9u\n' +
	        'IFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATlBHiEM9LoEb1Hdnd5j2VpCDOU\n' +
	        '5nGuFoBD8ROUCkFLFh5mHrHfPXwBc63heW9WrP3qnDEm+UZEUvW7ROvtWCTPZdLz\n' +
	        'Z4XaqgAlSqeE2VfUyZOZzBSgUUJk7OlznXfkCMOjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
	        'Af8wHQYDVR0OBBYEFDT/ThjQZl42Nv/4Z/7JYaPNMly2MA4GA1UdDwEB/wQEAwIB\n' +
	        'hjAKBggqhkjOPQQDAwNpADBmAjEAnZWmSgpEbmq+oiCa13l5aGmxSlfp9h12Orvw\n' +
	        'Dq/W5cENJz891QD0ufOsic5oGq1JAjEAp5kSJj0MxJBTHQze1Aa9gG4sjHBxXn98\n' +
	        '4MP1VGsQuhfndNHQb4V0Au7OWnOeiobq\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/zCCAuegAwIBAgIRAMgnyikWz46xY6yRgiYwZ3swDQYJKoZIhvcNAQELBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyMDE2NDkxMloYDzIwNjEwNTIwMTc0OTEyWjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCi8JYOc9cYSgZH\n' +
	        'gYPxLk6Xcc7HqzamvsnjYU98Dcb98y6iDqS46Ra2Ne02MITtU5MDL+qjxb8WGDZV\n' +
	        'RUA9ZS69tkTO3gldW8QdiSh3J6hVNJQW81F0M7ZWgV0gB3n76WCmfT4IWos0AXHM\n' +
	        '5v7M/M4tqVmCPViQnZb2kdVlM3/Xc9GInfSMCgNfwHPTXl+PXX+xCdNBePaP/A5C\n' +
	        '5S0oK3HiXaKGQAy3K7VnaQaYdiv32XUatlM4K2WS4AMKt+2cw3hTCjlmqKRHvYFQ\n' +
	        'veWCXAuc+U5PQDJ9SuxB1buFJZhT4VP3JagOuZbh5NWpIbOTxlAJOb5pGEDuJTKi\n' +
	        '1gQQQVEFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNXm+N87\n' +
	        'OFxK9Af/bjSxDCiulGUzMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\n' +
	        'AQEAkqIbkgZ45spvrgRQ6n9VKzDLvNg+WciLtmVrqyohwwJbj4pYvWwnKQCkVc7c\n' +
	        'hUOSBmlSBa5REAPbH5o8bdt00FPRrD6BdXLXhaECKgjsHe1WW08nsequRKD8xVmc\n' +
	        '8bEX6sw/utBeBV3mB+3Zv7ejYAbDFM4vnRsWtO+XqgReOgrl+cwdA6SNQT9oW3e5\n' +
	        'rSQ+VaXgJtl9NhkiIysq9BeYigxqS/A13pHQp0COMwS8nz+kBPHhJTsajHCDc8F4\n' +
	        'HfLi6cgs9G0gaRhT8FCH66OdGSqn196sE7Y3bPFFFs/3U+vxvmQgoZC6jegQXAg5\n' +
	        'Prxd+VNXtNI/azitTysQPumH7A==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEBTCCAu2gAwIBAgIRAO8bekN7rUReuNPG8pSTKtEwDQYJKoZIhvcNAQELBQAw\n' +
	        'gZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\n' +
	        'QW1hem9uIFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD\n' +
	        'VQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMjM0N1oYDzIwNjEwNTIxMjMyMzQ3WjCB\n' +
	        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
	        'bWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCTTYds\n' +
	        'Tray+Q9VA5j5jTh5TunHKFQzn68ZbOzdqaoi/Rq4ohfC0xdLrxCpfqn2TGDHN6Zi\n' +
	        '2qGK1tWJZEd1H0trhzd9d1CtGK+3cjabUmz/TjSW/qBar7e9MA67/iJ74Gc+Ww43\n' +
	        'A0xPNIWcL4aLrHaLm7sHgAO2UCKsrBUpxErOAACERScVYwPAfu79xeFcX7DmcX+e\n' +
	        'lIqY16pQAvK2RIzrekSYfLFxwFq2hnlgKHaVgZ3keKP+nmXcXmRSHQYUUr72oYNZ\n' +
	        'HcNYl2+gxCc9ccPEHM7xncVEKmb5cWEWvVoaysgQ+osi5f5aQdzgC2X2g2daKbyA\n' +
	        'XL/z5FM9GHpS5BJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\n' +
	        'FBDAiJ7Py9/A9etNa/ebOnx5l5MGMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B\n' +
	        'AQsFAAOCAQEALMh/+81fFPdJV/RrJUeoUvFCGMp8iaANu97NpeJyKitNOv7RoeVP\n' +
	        'WjivS0KcCqZaDBs+p6IZ0sLI5ZH098LDzzytcfZg0PsGqUAb8a0MiU/LfgDCI9Ee\n' +
	        'jsOiwaFB8k0tfUJK32NPcIoQYApTMT2e26lPzYORSkfuntme2PTHUnuC7ikiQrZk\n' +
	        'P+SZjWgRuMcp09JfRXyAYWIuix4Gy0eZ4rpRuaTK6mjAb1/LYoNK/iZ/gTeIqrNt\n' +
	        'l70OWRsWW8jEmSyNTIubGK/gGGyfuZGSyqoRX6OKHESkP6SSulbIZHyJ5VZkgtXo\n' +
	        '2XvyRyJ7w5pFyoofrL3Wv0UF8yt/GDszmg==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/zCCA+egAwIBAgIRAMDk/F+rrhdn42SfE+ghPC8wDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyMTIyNTEyMloYDzIxMjEwNTIxMjM1MTIyWjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2twMALVg9vRVu\n' +
	        'VNqsr6N8thmp3Dy8jEGTsm3GCQ+C5P2YcGlD/T/5icfWW84uF7Sx3ezcGlvsqFMf\n' +
	        'Ukj9sQyqtz7qfFFugyy7pa/eH9f48kWFHLbQYm9GEgbYBIrWMp1cy3vyxuMCwQN4\n' +
	        'DCncqU+yNpy0CprQJEha3PzY+3yJOjDQtc3zr99lyECCFJTDUucxHzyQvX89eL74\n' +
	        'uh8la0lKH3v9wPpnEoftbrwmm5jHNFdzj7uXUHUJ41N7af7z7QUfghIRhlBDiKtx\n' +
	        '5lYZemPCXajTc3ryDKUZC/b+B6ViXZmAeMdmQoPE0jwyEp/uaUcdp+FlUQwCfsBk\n' +
	        'ayPFEApTWgPiku2isjdeTVmEgL8bJTDUZ6FYFR7ZHcYAsDzcwHgIu3GGEMVRS3Uf\n' +
	        'ILmioiyly9vcK4Sa01ondARmsi/I0s7pWpKflaekyv5boJKD/xqwz9lGejmJHelf\n' +
	        '8Od2TyqJScMpB7Q8c2ROxBwqwB72jMCEvYigB+Wnbb8RipliqNflIGx938FRCzKL\n' +
	        'UQUBmNAznR/yRRL0wHf9UAE/8v9a09uZABeiznzOFAl/frHpgdAbC00LkFlnwwgX\n' +
	        'g8YfEFlkp4fLx5B7LtoO6uVNFVimLxtwirpyKoj3G4M/kvSTux8bTw0heBCmWmKR\n' +
	        '57MS6k7ODzbv+Kpeht2hqVZCNFMxoQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
	        'MB0GA1UdDgQWBBRuMnDhJjoj7DcKALj+HbxEqj3r6jAOBgNVHQ8BAf8EBAMCAYYw\n' +
	        'DQYJKoZIhvcNAQEMBQADggIBALSnXfx72C3ldhBP5kY4Mo2DDaGQ8FGpTOOiD95d\n' +
	        '0rf7I9LrsBGVqu/Nir+kqqP80PB70+Jy9fHFFigXwcPBX3MpKGxK8Cel7kVf8t1B\n' +
	        '4YD6A6bqlzP+OUL0uGWfZpdpDxwMDI2Flt4NEldHgXWPjvN1VblEKs0+kPnKowyg\n' +
	        'jhRMgBbD/y+8yg0fIcjXUDTAw/+INcp21gWaMukKQr/8HswqC1yoqW9in2ijQkpK\n' +
	        '2RB9vcQ0/gXR0oJUbZQx0jn0OH8Agt7yfMAnJAdnHO4M3gjvlJLzIC5/4aGrRXZl\n' +
	        'JoZKfJ2fZRnrFMi0nhAYDeInoS+Rwx+QzaBk6fX5VPyCj8foZ0nmqvuYoydzD8W5\n' +
	        'mMlycgxFqS+DUmO+liWllQC4/MnVBlHGB1Cu3wTj5kgOvNs/k+FW3GXGzD3+rpv0\n' +
	        'QTLuwSbMr+MbEThxrSZRSXTCQzKfehyC+WZejgLb+8ylLJUA10e62o7H9PvCrwj+\n' +
	        'ZDVmN7qj6amzvndCP98sZfX7CFZPLfcBd4wVIjHsFjSNEwWHOiFyLPPG7cdolGKA\n' +
	        'lOFvonvo4A1uRc13/zFeP0Xi5n5OZ2go8aOOeGYdI2vB2sgH9R2IASH/jHmr0gvY\n' +
	        '0dfBCcfXNgrS0toq0LX/y+5KkKOxh52vEYsJLdhqrveuZhQnsFEm/mFwjRXkyO7c\n' +
	        '2jpC\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGADCCA+igAwIBAgIQYe0HgSuFFP9ivYM2vONTrTANBgkqhkiG9w0BAQwFADCB\n' +
	        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
	        'bWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUxOTE4MzMyMVoYDzIxMjEwNTE5MTkzMzIxWjCBmDEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
	        'b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuO7QPKfPMTo2\n' +
	        'POQWvzDLwi5f++X98hGjORI1zkN9kotCYH5pAzSBwBPoMNaIfedgmsIxGHj2fq5G\n' +
	        '4oXagNhNuGP79Zl6uKW5H7S74W7aWM8C0s8zuxMOI4GZy5h2IfQk3m/3AzZEX5w8\n' +
	        'UtNPkzo2feDVOkerHT+j+vjXgAxZ4wHnuMDcRT+K4r9EXlAH6X9b/RO0JlfEwmNz\n' +
	        'xlqqGxocq9qRC66N6W0HF2fNEAKP84n8H80xcZBOBthQORRi8HSmKcPdmrvwCuPz\n' +
	        'M+L+j18q6RAVaA0ABbD0jMWcTf0UvjUfBStn5mvu/wGlLjmmRkZsppUTRukfwqXK\n' +
	        'yltUsTq0tOIgCIpne5zA4v+MebbR5JBnsvd4gdh5BI01QH470yB7BkUefZ9bobOm\n' +
	        'OseAAVXcYFJKe4DAA6uLDrqOfFSxV+CzVvEp3IhLRaik4G5MwI/h2c/jEYDqkg2J\n' +
	        'HMflxc2gcSMdk7E5ByLz5f6QrFfSDFk02ZJTs4ssbbUEYohht9znPMQEaWVqATWE\n' +
	        '3n0VspqZyoBNkH/agE5GiGZ/k/QyeqzMNj+c9kr43Upu8DpLrz8v2uAp5xNj3YVg\n' +
	        'ihaeD6GW8+PQoEjZ3mrCmH7uGLmHxh7Am59LfEyNrDn+8Rq95WvkmbyHSVxZnBmo\n' +
	        'h/6O3Jk+0/QhIXZ2hryMflPcYWeRGH0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB\n' +
	        '/zAdBgNVHQ4EFgQU2eFK7+R3x/me8roIBNxBrplkM6EwDgYDVR0PAQH/BAQDAgGG\n' +
	        'MA0GCSqGSIb3DQEBDAUAA4ICAQB5gWFe5s7ObQFj1fTO9L6gYgtFhnwdmxU0q8Ke\n' +
	        'HWCrdFmyXdC39qdAFOwM5/7fa9zKmiMrZvy9HNvCXEp4Z7z9mHhBmuqPZQx0qPgU\n' +
	        'uLdP8wGRuWryzp3g2oqkX9t31Z0JnkbIdp7kfRT6ME4I4VQsaY5Y3mh+hIHOUvcy\n' +
	        'p+98i3UuEIcwJnVAV9wTTzrWusZl9iaQ1nSYbmkX9bBssJ2GmtW+T+VS/1hJ/Q4f\n' +
	        'AlE3dOQkLFoPPb3YRWBHr2n1LPIqMVwDNAuWavRA2dSfaLl+kzbn/dua7HTQU5D4\n' +
	        'b2Fu2vLhGirwRJe+V7zdef+tI7sngXqjgObyOeG5O2BY3s+um6D4fS0Th3QchMO7\n' +
	        '0+GwcIgSgcjIjlrt6/xJwJLE8cRkUUieYKq1C4McpZWTF30WnzOPUzRzLHkcNzNA\n' +
	        '0A7sKMK6QoYWo5Rmo8zewUxUqzc9oQSrYADP7PEwGncLtFe+dlRFx+PA1a+lcIgo\n' +
	        '1ZGfXigYtQ3VKkcknyYlJ+hN4eCMBHtD81xDy9iP2MLE41JhLnoB2rVEtewO5diF\n' +
	        '7o95Mwl84VMkLhhHPeGKSKzEbBtYYBifHNct+Bst8dru8UumTltgfX6urH3DN+/8\n' +
	        'JF+5h3U8oR2LL5y76cyeb+GWDXXy9zoQe2QvTyTy88LwZq1JzujYi2k8QiLLhFIf\n' +
	        'FEv9Bg==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICsDCCAjagAwIBAgIRAMgApnfGYPpK/fD0dbN2U4YwCgYIKoZIzj0EAwMwgZcx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwnQW1h\n' +
	        'em9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMCAXDTIxMDUxOTE4MzgxMVoYDzIxMjEwNTE5MTkzODExWjCBlzELMAkG\n' +
	        'A1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzAR\n' +
	        'BgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6b24g\n' +
	        'UkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0\n' +
	        'bGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfEWl6d4qSuIoECdZPp+39LaKsfsX7\n' +
	        'THs3/RrtT0+h/jl3bjZ7Qc68k16x+HGcHbaayHfqD0LPdzH/kKtNSfQKqemdxDQh\n' +
	        'Z4pwkixJu8T1VpXZ5zzCvBXCl75UqgEFS92jQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
	        'HQYDVR0OBBYEFFPrSNtWS5JU+Tvi6ABV231XbjbEMA4GA1UdDwEB/wQEAwIBhjAK\n' +
	        'BggqhkjOPQQDAwNoADBlAjEA+a7hF1IrNkBd2N/l7IQYAQw8chnRZDzh4wiGsZsC\n' +
	        '6A83maaKFWUKIb3qZYXFSi02AjAbp3wxH3myAmF8WekDHhKcC2zDvyOiKLkg9Y6v\n' +
	        'ZVmyMR043dscQbcsVoacOYv198c=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICtDCCAjqgAwIBAgIRAPhVkIsQ51JFhD2kjFK5uAkwCgYIKoZIzj0EAwMwgZkx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\n' +
	        'em9uIFJEUyBldS1jZW50cmFsLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjIwNjA2MjEyOTE3WhgPMjEyMjA2MDYyMjI5MTdaMIGZMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\n' +
	        'biBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEA5xnIEBtG5b2nmbj49UEwQza\n' +
	        'yX0844fXjccYzZ8xCDUe9dS2XOUi0aZlGblgSe/3lwjg8fMcKXLObGGQfgIx1+5h\n' +
	        'AIBjORis/dlyN5q/yH4U5sjS8tcR0GDGVHrsRUZCo0IwQDAPBgNVHRMBAf8EBTAD\n' +
	        'AQH/MB0GA1UdDgQWBBRK+lSGutXf4DkTjR3WNfv4+KeNFTAOBgNVHQ8BAf8EBAMC\n' +
	        'AYYwCgYIKoZIzj0EAwMDaAAwZQIxAJ4NxQ1Gerqr70ZrnUqc62Vl8NNqTzInamCG\n' +
	        'Kce3FTsMWbS9qkgrjZkO9QqOcGIw/gIwSLrwUT+PKr9+H9eHyGvpq9/3AIYSnFkb\n' +
	        'Cf3dyWPiLKoAtLFwjzB/CkJlsAS1c8dS\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/jCCA+agAwIBAgIQGZH12Q7x41qIh9vDu9ikTjANBgkqhkiG9w0BAQwFADCB\n' +
	        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
	        'bWF6b24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTI1MjIyMjMzWhgPMjEyMTA1MjUyMzIyMzNaMIGXMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
	        'biBSRFMgZXUtd2VzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMqE47sHXWzdpuqj\n' +
	        'JHb+6jM9tDbQLDFnYjDWpq4VpLPZhb7xPNh9gnYYTPKG4avG421EblAHqzy9D2pN\n' +
	        '1z90yKbIfUb/Sy2MhQbmZomsObhONEra06fJ0Dydyjswf1iYRp2kwpx5AgkVoNo7\n' +
	        '3dlws73zFjD7ImKvUx2C7B75bhnw2pJWkFnGcswl8fZt9B5Yt95sFOKEz2MSJE91\n' +
	        'kZlHtya19OUxZ/cSGci4MlOySzqzbGwUqGxEIDlY8I39VMwXaYQ8uXUN4G780VcL\n' +
	        'u46FeyRGxZGz2n3hMc805WAA1V5uir87vuirTvoSVREET97HVRGVVNJJ/FM6GXr1\n' +
	        'VKtptybbo81nefYJg9KBysxAa2Ao2x2ry/2ZxwhS6VZ6v1+90bpZA1BIYFEDXXn/\n' +
	        'dW07HSCFnYSlgPtSc+Muh15mdr94LspYeDqNIierK9i4tB6ep7llJAnq0BU91fM2\n' +
	        'JPeqyoTtc3m06QhLf68ccSxO4l8Hmq9kLSHO7UXgtdjfRVaffngopTNk8qK7bIb7\n' +
	        'LrgkqhiQw/PRCZjUdyXL153/fUcsj9nFNe25gM4vcFYwH6c5trd2tUl31NTi1MfG\n' +
	        'Mgp3d2dqxQBIYANkEjtBDMy3SqQLIo9EymqmVP8xx2A/gCBgaxvMAsI6FSWRoC7+\n' +
	        'hqJ8XH4mFnXSHKtYMe6WPY+/XZgtAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\n' +
	        'HQYDVR0OBBYEFIkXqTnllT/VJnI2NqipA4XV8rh1MA4GA1UdDwEB/wQEAwIBhjAN\n' +
	        'BgkqhkiG9w0BAQwFAAOCAgEAKjSle8eenGeHgT8pltWCw/HzWyQruVKhfYIBfKJd\n' +
	        'MhV4EnH5BK7LxBIvpXGsFUrb0ThzSw0fn0zoA9jBs3i/Sj6KyeZ9qUF6b8ycDXd+\n' +
	        'wHonmJiQ7nk7UuMefaYAfs06vosgl1rI7eBHC0itexIQmKh0aX+821l4GEgEoSMf\n' +
	        'loMFTLXv2w36fPHHCsZ67ODldgcZbKNnpCTX0YrCwEYO3Pz/L398btiRcWGrewrK\n' +
	        'jdxAAyietra8DRno1Zl87685tfqc6HsL9v8rVw58clAo9XAQvT+fmSOFw/PogRZ7\n' +
	        'OMHUat3gu/uQ1M5S64nkLLFsKu7jzudBuoNmcJysPlzIbqJ7vYc82OUGe9ucF3wi\n' +
	        '3tbKQ983hdJiTExVRBLX/fYjPsGbG3JtPTv89eg2tjWHlPhCDMMxyRKl6isu2RTq\n' +
	        '6VT489Z2zQrC33MYF8ZqO1NKjtyMAMIZwxVu4cGLkVsqFmEV2ScDHa5RadDyD3Ok\n' +
	        'm+mqybhvEVm5tPgY6p0ILPMN3yvJsMSPSvuBXhO/X5ppNnpw9gnxpwbjQKNhkFaG\n' +
	        'M5pkADZ14uRguOLM4VthSwUSEAr5VQYCFZhEwK+UOyJAGiB/nJz6IxL5XBNUXmRM\n' +
	        'Hl8Xvz4riq48LMQbjcVQj0XvH941yPh+P8xOi00SGaQRaWp55Vyr4YKGbV0mEDz1\n' +
	        'r1o=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIF/zCCA+egAwIBAgIRAKwYju1QWxUZpn6D1gOtwgQwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\n' +
	        'QW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyMDE2NTM1NFoYDzIxMjEwNTIwMTc1MzU0WjCBlzEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\n' +
	        'b24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCKdBP1U4lqWWkc\n' +
	        'Cb25/BKRTsvNVnISiKocva8GAzJyKfcGRa85gmgu41U+Hz6+39K+XkRfM0YS4BvQ\n' +
	        'F1XxWT0bNyypuvwCvmYShSTjN1TY0ltncDddahTajE/4MdSOZb/c98u0yt03cH+G\n' +
	        'hVwRyT50h0v/UEol50VfwcVAEZEgcQQYhf1IFUFlIvKpmDOqLuFakOnc7c9akK+i\n' +
	        'ivST+JO1tgowbnNkn2iLlSSgUWgb1gjaOsNfysagv1RXdlyPw3EyfwkFifAQvF2P\n' +
	        'Q0ayYZfYS640cccv7efM1MSVyFHR9PrrDsF/zr2S2sGPbeHr7R/HwLl+S5J/l9N9\n' +
	        'y0rk6IHAWV4dEkOvgpnuJKURwA48iu1Hhi9e4moNS6eqoK2KmY3VFpuiyWcA73nH\n' +
	        'GSmyaH+YuMrF7Fnuu7GEHZL/o6+F5cL3mj2SJJhL7sz0ryf5Cs5R4yN9BIEj/f49\n' +
	        'wh84pM6nexoI0Q4wiSFCxWiBpjSmOK6h7z6+2utaB5p20XDZHhxAlmlx4vMuWtjh\n' +
	        'XckgRFxc+ZpVMU3cAHUpVEoO49e/+qKEpPzp8Xg4cToKw2+AfTk3cmyyXQfGwXMQ\n' +
	        'ZUHNZ3w9ILMWihGCM2aGUsLcGDRennvNmnmin/SENsOQ8Ku0/a3teEzwV9cmmdYz\n' +
	        '5iYs1YtgPvKFobY6+T2RXXh+A5kprwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n' +
	        'MB0GA1UdDgQWBBSyUrsQVnKmA8z6/2Ech0rCvqpNmTAOBgNVHQ8BAf8EBAMCAYYw\n' +
	        'DQYJKoZIhvcNAQEMBQADggIBAFlj3IFmgiFz5lvTzFTRizhVofhTJsGr14Yfkuc7\n' +
	        'UrXPuXOwJomd4uot2d/VIeGJpfnuS84qGdmQyGewGTJ9inatHsGZgHl9NHNWRwKZ\n' +
	        'lTKTbBiq7aqgtUSFa06v202wpzU+1kadxJJePrbABxiXVfOmIW/a1a4hPNcT3syH\n' +
	        'FIEg1+CGsp71UNjBuwg3JTKWna0sLSKcxLOSOvX1fzxK5djzVpEsvQMB4PSAzXca\n' +
	        'vENgg2ErTwgTA+4s6rRtiBF9pAusN1QVuBahYP3ftrY6f3ycS4K65GnqscyfvKt5\n' +
	        'YgjtEKO3ZeeX8NpubMbzC+0Z6tVKfPFk/9TXuJtwvVeqow0YMrLLyRiYvK7EzJ97\n' +
	        'rrkxoKnHYQSZ+rH2tZ5SE392/rfk1PJL0cdHnkpDkUDO+8cKsFjjYKAQSNC52sKX\n' +
	        '74AVh6wMwxYwVZZJf2/2XxkjMWWhKNejsZhUkTISSmiLs+qPe3L67IM7GyKm9/m6\n' +
	        'R3r8x6NGjhTsKH64iYJg7AeKeax4b2e4hBb6GXFftyOs7unpEOIVkJJgM6gh3mwn\n' +
	        'R7v4gwFbLKADKt1vHuerSZMiTuNTGhSfCeDM53XI/mjZl2HeuCKP1mCDLlaO+gZR\n' +
	        'Q/G+E0sBKgEX4xTkAc3kgkuQGfExdGtnN2U2ehF80lBHB8+2y2E+xWWXih/ZyIcW\n' +
	        'wOx+\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGBDCCA+ygAwIBAgIQM4C8g5iFRucSWdC8EdqHeDANBgkqhkiG9w0BAQwFADCB\n' +
	        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
	        'bWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUwIBcNMjEwNTIxMjIyODI2WhgPMjEyMTA1MjEyMzI4MjZaMIGa\n' +
	        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
	        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
	        'YXpvbiBSRFMgZXUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANeTsD/u\n' +
	        '6saPiY4Sg0GlJlMXMBltnrcGAEkwq34OKQ0bCXqcoNJ2rcAMmuFC5x9Ho1Y3YzB7\n' +
	        'NO2GpIh6bZaO76GzSv4cnimcv9n/sQSYXsGbPD+bAtnN/RvNW1avt4C0q0/ghgF1\n' +
	        'VFS8JihIrgPYIArAmDtGNEdl5PUrdi9y6QGggbRfidMDdxlRdZBe1C18ZdgERSEv\n' +
	        'UgSTPRlVczONG5qcQkUGCH83MMqL5MKQiby/Br5ZyPq6rxQMwRnQ7tROuElzyYzL\n' +
	        '7d6kke+PNzG1mYy4cbYdjebwANCtZ2qYRSUHAQsOgybRcSoarv2xqcjO9cEsDiRU\n' +
	        'l97ToadGYa4VVERuTaNZxQwrld4mvzpyKuirqZltOqg0eoy8VUsaRPL3dc5aChR0\n' +
	        'dSrBgRYmSAClcR2/2ZCWpXemikwgt031Dsc0A/+TmVurrsqszwbr0e5xqMow9LzO\n' +
	        'MI/JtLd0VFtoOkL/7GG2tN8a+7gnLFxpv+AQ0DH5n4k/BY/IyS+H1erqSJhOTQ11\n' +
	        'vDOFTM5YplB9hWV9fp5PRs54ILlHTlZLpWGs3I2BrJwzRtg/rOlvsosqcge9ryai\n' +
	        'AKm2j+JBg5wJ19R8oxRy8cfrNTftZePpISaLTyV2B16w/GsSjqixjTQe9LRN2DHk\n' +
	        'cC+HPqYyzW2a3pUVyTGHhW6a7YsPBs9yzt6hAgMBAAGjQjBAMA8GA1UdEwEB/wQF\n' +
	        'MAMBAf8wHQYDVR0OBBYEFIqA8QkOs2cSirOpCuKuOh9VDfJfMA4GA1UdDwEB/wQE\n' +
	        'AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOUI90mEIsa+vNJku0iUwdBMnHiO4gm7E\n' +
	        '5JloP7JG0xUr7d0hypDorMM3zVDAL+aZRHsq8n934Cywj7qEp1304UF6538ByGdz\n' +
	        'tkfacJsUSYfdlNJE9KbA4T+U+7SNhj9jvePpVjdQbhgzxITE9f8CxY/eM40yluJJ\n' +
	        'PhbaWvOiRagzo74wttlcDerzLT6Y/JrVpWhnB7IY8HvzK+BwAdaCsBUPC3HF+kth\n' +
	        'CIqLq7J3YArTToejWZAp5OOI6DLPM1MEudyoejL02w0jq0CChmZ5i55ElEMnapRX\n' +
	        '7GQTARHmjgAOqa95FjbHEZzRPqZ72AtZAWKFcYFNk+grXSeWiDgPFOsq6mDg8DDB\n' +
	        '0kfbYwKLFFCC9YFmYzR2YrWw2NxAScccUc2chOWAoSNHiqBbHR8ofrlJSWrtmKqd\n' +
	        'YRCXzn8wqXnTS3NNHNccqJ6dN+iMr9NGnytw8zwwSchiev53Fpc1mGrJ7BKTWH0t\n' +
	        'ZrA6m32wzpMymtKozlOPYoE5mtZEzrzHEXfa44Rns7XIHxVQSXVWyBHLtIsZOrvW\n' +
	        'U5F41rQaFEpEeUQ7sQvqUoISfTUVRNDn6GK6YaccEhCji14APLFIvhRQUDyYMIiM\n' +
	        '4vll0F/xgVRHTgDVQ8b8sxdhSYlqB4Wc2Ym41YRz+X2yPqk3typEZBpc4P5Tt1/N\n' +
	        '89cEIGdbjsA=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEADCCAuigAwIBAgIQYjbPSg4+RNRD3zNxO1fuKDANBgkqhkiG9w0BAQsFADCB\n' +
	        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
	        'bWF6b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUyNDIwNTkyMVoYDzIwNjEwNTI0MjE1OTIxWjCBmDEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
	        'b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA179eQHxcV0YL\n' +
	        'XMkqEmhSBazHhnRVd8yICbMq82PitE3BZcnv1Z5Zs/oOgNmMkOKae4tCXO/41JCX\n' +
	        'wAgbs/eWWi+nnCfpQ/FqbLPg0h3dqzAgeszQyNl9IzTzX4Nd7JFRBVJXPIIKzlRf\n' +
	        '+GmFsAhi3rYgDgO27pz3ciahVSN+CuACIRYnA0K0s9lhYdddmrW/SYeWyoB7jPa2\n' +
	        'LmWpAs7bDOgS4LlP2H3eFepBPgNufRytSQUVA8f58lsE5w25vNiUSnrdlvDrIU5n\n' +
	        'Qwzc7NIZCx4qJpRbSKWrUtbyJriWfAkGU7i0IoainHLn0eHp9bWkwb9D+C/tMk1X\n' +
	        'ERZw2PDGkwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSFmR7s\n' +
	        'dAblusFN+xhf1ae0KUqhWTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
	        'ggEBAHsXOpjPMyH9lDhPM61zYdja1ebcMVgfUvsDvt+w0xKMKPhBzYDMs/cFOi1N\n' +
	        'Q8LV79VNNfI2NuvFmGygcvTIR+4h0pqqZ+wjWl3Kk5jVxCrbHg3RBX02QLumKd/i\n' +
	        'kwGcEtTUvTssn3SM8bgM0/1BDXgImZPC567ciLvWDo0s/Fe9dJJC3E0G7d/4s09n\n' +
	        'OMdextcxFuWBZrBm/KK3QF0ByA8MG3//VXaGO9OIeeOJCpWn1G1PjT1UklYhkg61\n' +
	        'EbsTiZVA2DLd1BGzfU4o4M5mo68l0msse/ndR1nEY6IywwpgIFue7+rEleDh6b9d\n' +
	        'PYkG1rHVw2I0XDG4o17aOn5E94I=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEADCCAuigAwIBAgIQC6W4HFghUkkgyQw14a6JljANBgkqhkiG9w0BAQsFADCB\n' +
	        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
	        'bWF6b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIyMDUyMzE4MTYzMloYDzIwNjIwNTIzMTkxNjMyWjCBmDEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
	        'b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiM/t4FV2R9Nx\n' +
	        'UQG203UY83jInTa/6TMq0SPyg617FqYZxvz2kkx09x3dmxepUg9ttGMlPgjsRZM5\n' +
	        'LCFEi1FWk+hxHzt7vAdhHES5tdjwds3aIkgNEillmRDVrUsbrDwufLaa+MMDO2E1\n' +
	        'wQ/JYFXw16WBCCi2g1EtyQ2Xp+tZDX5IWOTnvhZpW8vVDptZ2AcJ5rMhfOYO3OsK\n' +
	        '5EF0GGA5ldzuezP+BkrBYGJ4wVKGxeaq9+5AT8iVZrypjwRkD7Y5CurywK3+aBwm\n' +
	        's9Q5Nd8t45JCOUzYp92rFKsCriD86n/JnEvgDfdP6Hvtm0/DkwXK40Wz2q0Zrd0k\n' +
	        'mjP054NRPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRR7yqd\n' +
	        'SfKcX2Q8GzhcVucReIpewTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
	        'ggEBAEszBRDwXcZyNm07VcFwI1Im94oKwKccuKYeJEsizTBsVon8VpEiMwDs+yGu\n' +
	        '3p8kBhvkLwWybkD/vv6McH7T5b9jDX2DoOudqYnnaYeypsPH/00Vh3LvKagqzQza\n' +
	        'orWLx+0tLo8xW4BtU+Wrn3JId8LvAhxyYXTn9bm+EwPcStp8xGLwu53OPD1RXYuy\n' +
	        'uu+3ps/2piP7GVfou7H6PRaqbFHNfiGg6Y+WA0HGHiJzn8uLmrRJ5YRdIOOG9/xi\n' +
	        'qTmAZloUNM7VNuurcMM2hWF494tQpsQ6ysg2qPjbBqzlGoOt3GfBTOZmqmwmqtam\n' +
	        'K7juWM/mdMQAJ3SMlE5wI8nVdx4=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIICrjCCAjSgAwIBAgIRAL9SdzVPcpq7GOpvdGoM80IwCgYIKoZIzj0EAwMwgZYx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\n' +
	        'em9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\n' +
	        'YXR0bGUwIBcNMjEwNTIwMTY1ODA3WhgPMjEyMTA1MjAxNzU4MDdaMIGWMQswCQYD\n' +
	        'VQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\n' +
	        'A1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\n' +
	        'RFMgZXUtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\n' +
	        'MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEJWDgXebvwjR+Ce+hxKOLbnsfN5W5dOlP\n' +
	        'Zn8kwWnD+SLkU81Eac/BDJsXGrMk6jFD1vg16PEkoSevsuYWlC8xR6FmT6F6pmeh\n' +
	        'fsMGOyJpfK4fyoEPhKeQoT23lFIc5Orjo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n' +
	        'A1UdDgQWBBSVNAN1CHAz0eZ77qz2adeqjm31TzAOBgNVHQ8BAf8EBAMCAYYwCgYI\n' +
	        'KoZIzj0EAwMDaAAwZQIxAMlQeHbcjor49jqmcJ9gRLWdEWpXG8thIf6zfYQ/OEAg\n' +
	        'd7GDh4fR/OUk0VfjsBUN/gIwZB0bGdXvK38s6AAE/9IT051cz/wMe9GIrX1MnL1T\n' +
	        '1F5OqnXJdiwfZRRTHsRQ/L00\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGBDCCA+ygAwIBAgIQalr16vDfX4Rsr+gfQ4iVFDANBgkqhkiG9w0BAQwFADCB\n' +
	        'mjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\n' +
	        'bWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\n' +
	        'BAcMB1NlYXR0bGUwIBcNMjIwNjA2MjEyNTIzWhgPMjEyMjA2MDYyMjI1MjNaMIGa\n' +
	        'MQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\n' +
	        'LjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\n' +
	        'YXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANbHbFg7\n' +
	        '2VhZor1YNtez0VlNFaobS3PwOMcEn45BE3y7HONnElIIWXGQa0811M8V2FnyqnE8\n' +
	        'Z5aO1EuvijvWf/3D8DPZkdmAkIfh5hlZYY6Aatr65kEOckwIAm7ZZzrwFogYuaFC\n' +
	        'z/q0CW+8gxNK+98H/zeFx+IxiVoPPPX6UlrLvn+R6XYNERyHMLNgoZbbS5gGHk43\n' +
	        'KhENVv3AWCCcCc85O4rVd+DGb2vMVt6IzXdTQt6Kih28+RGph+WDwYmf+3txTYr8\n' +
	        'xMcCBt1+whyCPlMbC+Yn/ivtCO4LRf0MPZDRQrqTTrFf0h/V0BGEUmMGwuKgmzf5\n' +
	        'Kl9ILdWv6S956ioZin2WgAxhcn7+z//sN++zkqLreSf90Vgv+A7xPRqIpTdJ/nWG\n' +
	        'JaAOUofBfsDsk4X4SUFE7xJa1FZAiu2lqB/E+y7jnWOvFRalzxVJ2Y+D/ZfUfrnK\n' +
	        '4pfKtyD1C6ni1celrZrAwLrJ3PoXPSg4aJKh8+CHex477SRsGj8KP19FG8r0P5AG\n' +
	        '8lS1V+enFCNvT5KqEBpDZ/Y5SQAhAYFUX+zH4/n4ql0l/emS+x23kSRrF+yMkB9q\n' +
	        'lhC/fMk6Pi3tICBjrDQ8XAxv56hfud9w6+/ljYB2uQ1iUYtlE3JdIiuE+3ws26O8\n' +
	        'i7PLMD9zQmo+sVi12pLHfBHQ6RRHtdVRXbXRAgMBAAGjQjBAMA8GA1UdEwEB/wQF\n' +
	        'MAMBAf8wHQYDVR0OBBYEFBFot08ipEL9ZUXCG4lagmF53C0/MA4GA1UdDwEB/wQE\n' +
	        'AwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAi2mcZi6cpaeqJ10xzMY0F3L2eOKYnlEQ\n' +
	        'h6QyhmNKCUF05q5u+cok5KtznzqMwy7TFOZtbVHl8uUX+xvgq/MQCxqFAnuStBXm\n' +
	        'gr2dg1h509ZwvTdk7TDxGdftvPCfnPNJBFbMSq4CZtNcOFBg9Rj8c3Yj+Qvwd56V\n' +
	        'zWs65BUkDNJrXmxdvhJZjUkMa9vi/oFN+M84xXeZTaC5YDYNZZeW9706QqDbAVES\n' +
	        '5ulvKLavB8waLI/lhRBK5/k0YykCMl0A8Togt8D1QsQ0eWWbIM8/HYJMPVFhJ8Wj\n' +
	        'vT1p/YVeDA3Bo1iKDOttgC5vILf5Rw1ZEeDxjf/r8A7VS13D3OLjBmc31zxRTs3n\n' +
	        'XvHKP9MieQHn9GE44tEYPjK3/yC6BDFzCBlvccYHmqGb+jvDEXEBXKzimdC9mcDl\n' +
	        'f4BBQWGJBH5jkbU9p6iti19L/zHhz7qU6UJWbxY40w92L9jS9Utljh4A0LCTjlnR\n' +
	        'NQUgjnGC6K+jkw8hj0LTC5Ip87oqoT9w7Av5EJ3VJ4hcnmNMXJJ1DkWYdnytcGpO\n' +
	        'DMVITQzzDZRwhbitCVPHagTN2wdi9TEuYE33J0VmFeTc6FSI50wP2aOAZ0Q1/8Aj\n' +
	        'bxeM5jS25eaHc2CQAuhrc/7GLnxOcPwdWQb2XWT8eHudhMnoRikVv/KSK3mf6om4\n' +
	        '1YfpdH2jp30=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID/jCCAuagAwIBAgIQTDc+UgTRtYO7ZGTQ8UWKDDANBgkqhkiG9w0BAQsFADCB\n' +
	        'lzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\n' +
	        'bWF6b24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\n' +
	        'B1NlYXR0bGUwIBcNMjEwNTIxMjI0NjI0WhgPMjA2MTA1MjEyMzQ2MjRaMIGXMQsw\n' +
	        'CQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\n' +
	        'MBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\n' +
	        'biBSRFMgZXUtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\n' +
	        'dHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM1oGtthQ1YiVIC2\n' +
	        'i4u4swMAGxAjc/BZp0yq0eP5ZQFaxnxs7zFAPabEWsrjeDzrRhdVO0h7zskrertP\n' +
	        'gblGhfD20JfjvCHdP1RUhy/nzG+T+hn6Takan/GIgs8grlBMRHMgBYHW7tklhjaH\n' +
	        '3F7LujhceAHhhgp6IOrpb6YTaTTaJbF3GTmkqxSJ3l1LtEoWz8Al/nL/Ftzxrtez\n' +
	        'Vs6ebpvd7sw37sxmXBWX2OlvUrPCTmladw9OrllGXtCFw4YyLe3zozBlZ3cHzQ0q\n' +
	        'lINhpRcajTMfZrsiGCkQtoJT+AqVJPS2sHjqsEH8yiySW9Jbq4zyMbM1yqQ2vnnx\n' +
	        'MJgoYMcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUaQG88UnV\n' +
	        'JPTI+Pcti1P+q3H7pGYwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\n' +
	        'AQBAkgr75V0sEJimC6QRiTVWEuj2Khy7unjSfudbM6zumhXEU2/sUaVLiYy6cA/x\n' +
	        '3v0laDle6T07x9g64j5YastE/4jbzrGgIINFlY0JnaYmR3KZEjgi1s1fkRRf3llL\n' +
	        'PJm9u4Q1mbwAMQK/ZjLuuRcL3uRIHJek18nRqT5h43GB26qXyvJqeYYpYfIjL9+/\n' +
	        'YiZAbSRRZG+Li23cmPWrbA1CJY121SB+WybCbysbOXzhD3Sl2KSZRwSw4p2HrFtV\n' +
	        '1Prk0dOBtZxCG9luf87ultuDZpfS0w6oNBAMXocgswk24ylcADkkFxBWW+7BETn1\n' +
	        'EpK+t1Lm37mU4sxtuha00XAi\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIEADCCAuigAwIBAgIQcY44/8NUvBwr6LlHfRy7KjANBgkqhkiG9w0BAQsFADCB\n' +
	        'mDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\n' +
	        'Yy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\n' +
	        'bWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\n' +
	        'DAdTZWF0dGxlMCAXDTIxMDUxOTE4MjcxOFoYDzIwNjEwNTE5MTkyNzE4WjCBmDEL\n' +
	        'MAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\n' +
	        'EzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\n' +
	        'b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\n' +
	        'ZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0UaBeC+Usalu\n' +
	        'EtXnV7+PnH+gi7/71tI/jkKVGKuhD2JDVvqLVoqbMHRh3+wGMvqKCjbHPcC2XMWv\n' +
	        '566fpAj4UZ9CLB5fVzss+QVNTl+FH2XhEzigopp+872ajsNzcZxrMkifxGb4i0U+\n' +
	        't0Zi+UrbL5tsfP2JonKR1crOrbS6/DlzHBjIiJazGOQcMsJjNuTOItLbMohLpraA\n' +
	        '/nApa3kOvI7Ufool1/34MG0+wL3UUA4YkZ6oBJVxjZvvs6tI7Lzz/SnhK2widGdc\n' +
	        'snbLqBpHNIZQSorVoiwcFaRBGYX/uzYkiw44Yfa4cK2V/B5zgu1Fbr0gbI2am4eh\n' +
	        'yVYyg4jPawIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS9gM1m\n' +
	        'IIjyh9O5H/7Vj0R/akI7UzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\n' +
	        'ggEBAF0Sm9HC2AUyedBVnwgkVXMibnYChOzz7T+0Y+fOLXYAEXex2s8oqGeZdGYX\n' +
	        'JHkjBn7JXu7LM+TpTbPbFFDoc1sgMguD/ls+8XsqAl1CssW+amryIL+jfcfbgQ+P\n' +
	        'ICwEUD9hGdjBgJ5WcuS+qqxHsEIlFNci3HxcxfBa9VsWs5TjI7Vsl4meL5lf7ZyL\n' +
	        'wDV7dHRuU+cImqG1MIvPRIlvPnT7EghrCYi2VCPhP2pM/UvShuwVnkz4MJ29ebIk\n' +
	        'WR9kpblFxFdE92D5UUvMCjC2kmtgzNiErvTcwIvOO9YCbBHzRB1fFiWrXUHhJWq9\n' +
	        'IkaxR5icb/IpAV0A1lYZEWMVsfQ=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIGATCCA+mgAwIBAgIRAMa0TPL+QgbWfUPpYXQkf8wwDQYJKoZIhvcNAQEMBQAw\n' +
	        'gZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\n' +
	        'bmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\n' +
	        'QW1hem9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\n' +
	        'BwwHU2VhdHRsZTAgFw0yMTA1MjQyMTAzMjBaGA8yMTIxMDUyNDIyMDMyMFowgZgx\n' +
	        'CzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\n' +
	        'MRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\n' +
	        'em9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\n' +
	        'U2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANhS9LJVJyWp\n' +
	        '6Rudy9t47y6kzvgnFYDrvJVtgEK0vFn5ifdlHE7xqMz4LZqWBFTnS+3oidwVRqo7\n' +
	        'tqsuuElsouStO8m315/YUzKZEPmkw8h5ufWt/lg3NTCoUZNkB4p4skr7TspyMUwE\n' +
	        'VdlKQuWTCOLtofwmWT+BnFF3To6xTh3XPlT3ssancw27Gob8kJegD7E0TSMVsecP\n' +
	        'B8je65+3b8CGwcD3QB3kCTGLy87tXuS2+07pncHvjMRMBdDQQQqhXWsRSeUNg0IP\n' +
	        'xdHTWcuwMldYPWK5zus9M4dCNBDlmZjKdcZZVUOKeBBAm7Uo7CbJCk8r/Fvfr6mw\n' +
	        'nXXDtuWhqn/WhJiI/y0QU27M+Hy5CQMxBwFsfAjJkByBpdXmyYxUgTmMpLf43p7H\n' +
	        'oWfH1xN0cT0OQEVmAQjMakauow4AQLNkilV+X6uAAu3STQVFRSrpvMen9Xx3EPC3\n' +
	        'G9flHueTa71bU65Xe8ZmEmFhGeFYHY0GrNPAFhq9RThPRY0IPyCZe0Th8uGejkek\n' +
	        'jQjm0FHPOqs5jc8CD8eJs4jSEFt9lasFLVDcAhx0FkacLKQjGHvKAnnbRwhN/dF3\n' +
	        'xt4oL8Z4JGPCLau056gKnYaEyviN7PgO+IFIVOVIdKEBu2ASGE8/+QJB5bcHefNj\n' +
	        '04hEkDW0UYJbSfPpVbGAR0gFI/QpycKnAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
	        'Af8wHQYDVR0OBBYEFFMXvvjoaGGUcul8GA3FT05DLbZcMA4GA1UdDwEB/wQEAwIB\n' +
	        'hjANBgkqhkiG9w0BAQwFAAOCAgEAQLwFhd2JKn4K/6salLyIA4mP58qbA/9BTB/r\n' +
	        'D9l0bEwDlVPSdY7R3gZCe6v7SWLfA9RjE5tdWDrQMi5IU6W2OVrVsZS/yGJfwnwe\n' +
	        'a/9iUAYprA5QYKDg37h12XhVsDKlYCekHdC+qa5WwB1SL3YUprDLPWeaIQdg+Uh2\n' +
	        '+LxvpZGoxoEbca0fc7flwq9ke/3sXt/3V4wJDyY6AL2YNdjFzC+FtYjHHx8rYxHs\n' +
	        'aesP7yunuN17KcfOZBBnSFRrx96k+Xm95VReTEEpwiBqAECqEpMbd+R0mFAayMb1\n' +
	        'cE77GaK5yeC2f67NLYGpkpIoPbO9p9rzoXLE5GpSizMjimnz6QCbXPFAFBDfSzim\n' +
	        'u6azp40kEUO6kWd7rBhqRwLc43D3TtNWQYxMve5mTRG4Od+eMKwYZmQz89BQCeqm\n' +
	        'aZiJP9y9uwJw4p/A5V3lYHTDQqzmbOyhGUk6OdpdE8HXs/1ep1xTT20QDYOx3Ekt\n' +
	        'r4mmNYfH/8v9nHNRlYJOqFhmoh1i85IUl5IHhg6OT5ZTTwsGTSxvgQQXrmmHVrgZ\n' +
	        'rZIqyBKllCgVeB9sMEsntn4bGLig7CS/N1y2mYdW/745yCLZv2gj0NXhPqgEIdVV\n' +
	        'f9DhFD4ohE1C63XP0kOQee+LYg/MY5vH8swpCSWxQgX5icv5jVDz8YTdCKgUc5u8\n' +
	        'rM2p0kk=\n' +
	        '-----END CERTIFICATE-----\n',
	];
	return defaults;
}

var proxies = {};

var hasRequiredProxies;

function requireProxies () {
	if (hasRequiredProxies) return proxies;
	hasRequiredProxies = 1;
	Object.defineProperty(proxies, "__esModule", { value: true });
	proxies.proxies = void 0;
	/**
	 * CA Certificates for **Amazon RDS Proxy** (2024)
	 *
	 * - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.howitworks.html#rds-proxy-security.tls
	 * - https://www.amazontrust.com/repository/
	 */
	proxies.proxies = [
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF\n' +
	        'ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\n' +
	        'b24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL\n' +
	        'MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\n' +
	        'b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj\n' +
	        'ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM\n' +
	        '9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw\n' +
	        'IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6\n' +
	        'VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L\n' +
	        '93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm\n' +
	        'jgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\n' +
	        'AYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA\n' +
	        'A4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI\n' +
	        'U5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs\n' +
	        'N+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv\n' +
	        'o/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU\n' +
	        '5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy\n' +
	        'rqXRfboQnoZsG4q5WTP468SQvvG5\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIFQTCCAymgAwIBAgITBmyf0pY1hp8KD+WGePhbJruKNzANBgkqhkiG9w0BAQwF\n' +
	        'ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\n' +
	        'b24gUm9vdCBDQSAyMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTEL\n' +
	        'MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\n' +
	        'b3QgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK2Wny2cSkxK\n' +
	        'gXlRmeyKy2tgURO8TW0G/LAIjd0ZEGrHJgw12MBvIITplLGbhQPDW9tK6Mj4kHbZ\n' +
	        'W0/jTOgGNk3Mmqw9DJArktQGGWCsN0R5hYGCrVo34A3MnaZMUnbqQ523BNFQ9lXg\n' +
	        '1dKmSYXpN+nKfq5clU1Imj+uIFptiJXZNLhSGkOQsL9sBbm2eLfq0OQ6PBJTYv9K\n' +
	        '8nu+NQWpEjTj82R0Yiw9AElaKP4yRLuH3WUnAnE72kr3H9rN9yFVkE8P7K6C4Z9r\n' +
	        '2UXTu/Bfh+08LDmG2j/e7HJV63mjrdvdfLC6HM783k81ds8P+HgfajZRRidhW+me\n' +
	        'z/CiVX18JYpvL7TFz4QuK/0NURBs+18bvBt+xa47mAExkv8LV/SasrlX6avvDXbR\n' +
	        '8O70zoan4G7ptGmh32n2M8ZpLpcTnqWHsFcQgTfJU7O7f/aS0ZzQGPSSbtqDT6Zj\n' +
	        'mUyl+17vIWR6IF9sZIUVyzfpYgwLKhbcAS4y2j5L9Z469hdAlO+ekQiG+r5jqFoz\n' +
	        '7Mt0Q5X5bGlSNscpb/xVA1wf+5+9R+vnSUeVC06JIglJ4PVhHvG/LopyboBZ/1c6\n' +
	        '+XUyo05f7O0oYtlNc/LMgRdg7c3r3NunysV+Ar3yVAhU/bQtCSwXVEqY0VThUWcI\n' +
	        '0u1ufm8/0i2BWSlmy5A5lREedCf+3euvAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\n' +
	        'Af8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSwDPBMMPQFWAJI/TPlUq9LhONm\n' +
	        'UjANBgkqhkiG9w0BAQwFAAOCAgEAqqiAjw54o+Ci1M3m9Zh6O+oAA7CXDpO8Wqj2\n' +
	        'LIxyh6mx/H9z/WNxeKWHWc8w4Q0QshNabYL1auaAn6AFC2jkR2vHat+2/XcycuUY\n' +
	        '+gn0oJMsXdKMdYV2ZZAMA3m3MSNjrXiDCYZohMr/+c8mmpJ5581LxedhpxfL86kS\n' +
	        'k5Nrp+gvU5LEYFiwzAJRGFuFjWJZY7attN6a+yb3ACfAXVU3dJnJUH/jWS5E4ywl\n' +
	        '7uxMMne0nxrpS10gxdr9HIcWxkPo1LsmmkVwXqkLN1PiRnsn/eBG8om3zEK2yygm\n' +
	        'btmlyTrIQRNg91CMFa6ybRoVGld45pIq2WWQgj9sAq+uEjonljYE1x2igGOpm/Hl\n' +
	        'urR8FLBOybEfdF849lHqm/osohHUqS0nGkWxr7JOcQ3AWEbWaQbLU8uz/mtBzUF+\n' +
	        'fUwPfHJ5elnNXkoOrJupmHN5fLT0zLm4BwyydFy4x2+IoZCn9Kr5v2c69BoVYh63\n' +
	        'n749sSmvZ6ES8lgQGVMDMBu4Gon2nL2XA46jCfMdiyHxtN/kHNGfZQIG6lzWE7OE\n' +
	        '76KlXIx3KadowGuuQNKotOrN8I1LOJwZmhsoVLiJkO/KdYE+HvJkJMcYr07/R54H\n' +
	        '9jVlpNMKVv/1F2Rs76giJUmTtt8AF9pYfl3uxRuw0dFfIRDH+fO6AgonB8Xx1sfT\n' +
	        '4PsJYGw=\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5\n' +
	        'MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\n' +
	        'Um9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG\n' +
	        'A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg\n' +
	        'Q0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl\n' +
	        'ui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j\n' +
	        'QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr\n' +
	        'ttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr\n' +
	        'BqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM\n' +
	        'YyRIHN8wfdVoOw==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIIB8jCCAXigAwIBAgITBmyf18G7EEwpQ+Vxe3ssyBrBDjAKBggqhkjOPQQDAzA5\n' +
	        'MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\n' +
	        'Um9vdCBDQSA0MB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG\n' +
	        'A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg\n' +
	        'Q0EgNDB2MBAGByqGSM49AgEGBSuBBAAiA2IABNKrijdPo1MN/sGKe0uoe0ZLY7Bi\n' +
	        '9i0b2whxIdIA6GO9mif78DluXeo9pcmBqqNbIJhFXRbb/egQbeOc4OO9X4Ri83Bk\n' +
	        'M6DLJC9wuoihKqB1+IGuYgbEgds5bimwHvouXKNCMEAwDwYDVR0TAQH/BAUwAwEB\n' +
	        '/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFNPsxzplbszh2naaVvuc84ZtV+WB\n' +
	        'MAoGCCqGSM49BAMDA2gAMGUCMDqLIfG9fhGt0O9Yli/W651+kI0rz2ZVwyzjKKlw\n' +
	        'CkcO8DdZEv8tmZQoTipPNU0zWgIxAOp1AE47xDqUEpHJWEadIRNyp4iciuRMStuW\n' +
	        '1KyLa2tJElMzrdfkviT8tQp21KW8EA==\n' +
	        '-----END CERTIFICATE-----\n',
	    '-----BEGIN CERTIFICATE-----\n' +
	        'MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx\n' +
	        'EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\n' +
	        'HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs\n' +
	        'ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5\n' +
	        'MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD\n' +
	        'VQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy\n' +
	        'ZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy\n' +
	        'dmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI\n' +
	        'hvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p\n' +
	        'OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2\n' +
	        '8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K\n' +
	        'Ts9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe\n' +
	        'hRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk\n' +
	        '6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw\n' +
	        'DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q\n' +
	        'AdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI\n' +
	        'bw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB\n' +
	        've6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z\n' +
	        'qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd\n' +
	        'iEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn\n' +
	        '0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN\n' +
	        'sSi6\n' +
	        '-----END CERTIFICATE-----\n',
	];
	return proxies;
}

var lib = lib$1.exports;

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$1.exports;
	hasRequiredLib = 1;
	Object.defineProperty(lib, "__esModule", { value: true });
	const defaults_js_1 = /*@__PURE__*/ requireDefaults();
	const proxies_js_1 = /*@__PURE__*/ requireProxies();
	const proxyBundle = {
	    ca: proxies_js_1.proxies,
	};
	const profiles = {
	    ca: [...defaults_js_1.defaults, ...proxies_js_1.proxies],
	};
	lib$1.exports = profiles;
	lib$1.exports.proxyBundle = proxyBundle;
	lib$1.exports.default = profiles;
	return lib$1.exports;
}

var hasRequiredSsl_profiles;

function requireSsl_profiles () {
	if (hasRequiredSsl_profiles) return ssl_profiles;
	hasRequiredSsl_profiles = 1;
	(function (exports$1) {

		const awsCaBundle = /*@__PURE__*/ requireLib();

		/**
		 * @deprecated
		 * Please, use [**aws-ssl-profiles**](https://github.com/mysqljs/aws-ssl-profiles).
		 */
		exports$1['Amazon RDS'] = {
		  ca: awsCaBundle.ca,
		}; 
	} (ssl_profiles));
	return ssl_profiles;
}

const { URL: URL$1 } = require$$7$2;
const ClientConstants = client;
const Charsets = /*@__PURE__*/ requireCharsets();
const { version } = require$$3;
let SSLProfiles = null;

const validOptions = {
  authPlugins: 1,
  authSwitchHandler: 1,
  bigNumberStrings: 1,
  charset: 1,
  charsetNumber: 1,
  compress: 1,
  connectAttributes: 1,
  connectTimeout: 1,
  database: 1,
  dateStrings: 1,
  debug: 1,
  decimalNumbers: 1,
  enableKeepAlive: 1,
  flags: 1,
  host: 1,
  insecureAuth: 1,
  infileStreamFactory: 1,
  isServer: 1,
  keepAliveInitialDelay: 1,
  localAddress: 1,
  maxPreparedStatements: 1,
  multipleStatements: 1,
  namedPlaceholders: 1,
  nestTables: 1,
  password: 1,
  // with multi-factor authentication, the main password (used for the first
  // authentication factor) can be provided via password1
  password1: 1,
  password2: 1,
  password3: 1,
  passwordSha1: 1,
  pool: 1,
  port: 1,
  queryFormat: 1,
  rowsAsArray: 1,
  socketPath: 1,
  ssl: 1,
  stream: 1,
  stringifyObjects: 1,
  supportBigNumbers: 1,
  timezone: 1,
  trace: 1,
  typeCast: 1,
  uri: 1,
  user: 1,
  disableEval: 1,
  // These options are used for Pool
  connectionLimit: 1,
  maxIdle: 1,
  idleTimeout: 1,
  Promise: 1,
  queueLimit: 1,
  waitForConnections: 1,
  jsonStrings: 1,
  gracefulEnd: 1,
};

let ConnectionConfig$3 = class ConnectionConfig {
  constructor(options) {
    if (typeof options === 'string') {
      options = ConnectionConfig.parseUrl(options);
    } else if (options && options.uri) {
      const uriOptions = ConnectionConfig.parseUrl(options.uri);
      for (const key in uriOptions) {
        if (!Object.prototype.hasOwnProperty.call(uriOptions, key)) continue;
        if (options[key]) continue;
        options[key] = uriOptions[key];
      }
    }
    for (const key in options) {
      if (!Object.prototype.hasOwnProperty.call(options, key)) continue;
      if (validOptions[key] !== 1) {
        // REVIEW: Should this be emitted somehow?
        // eslint-disable-next-line no-console
        console.error(
          `Ignoring invalid configuration option passed to Connection: ${key}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`
        );
      }
    }
    this.isServer = options.isServer;
    this.stream = options.stream;
    this.host = options.host || 'localhost';
    this.port =
      (typeof options.port === 'string'
        ? parseInt(options.port, 10)
        : options.port) || 3306;
    this.localAddress = options.localAddress;
    this.socketPath = options.socketPath;
    this.user = options.user || undefined;
    // for the purpose of multi-factor authentication, or not, the main
    // password (used for the 1st authentication factor) can also be
    // provided via the "password1" option
    this.password = options.password || options.password1 || undefined;
    this.password2 = options.password2 || undefined;
    this.password3 = options.password3 || undefined;
    this.passwordSha1 = options.passwordSha1 || undefined;
    this.database = options.database;
    this.connectTimeout = isNaN(options.connectTimeout)
      ? 10 * 1000
      : options.connectTimeout;
    this.insecureAuth = options.insecureAuth || false;
    this.infileStreamFactory = options.infileStreamFactory || undefined;
    this.supportBigNumbers = options.supportBigNumbers || false;
    this.bigNumberStrings = options.bigNumberStrings || false;
    this.decimalNumbers = options.decimalNumbers || false;
    this.dateStrings = options.dateStrings || false;
    this.debug = options.debug;
    this.trace = options.trace !== false;
    this.stringifyObjects = options.stringifyObjects || false;
    this.enableKeepAlive = options.enableKeepAlive !== false;
    this.keepAliveInitialDelay = options.keepAliveInitialDelay;
    if (
      options.timezone &&
      !/^(?:local|Z|[ +-]\d\d:\d\d)$/.test(options.timezone)
    ) {
      // strictly supports timezones specified by mysqljs/mysql:
      // https://github.com/mysqljs/mysql#user-content-connection-options
      // eslint-disable-next-line no-console
      console.error(
        `Ignoring invalid timezone passed to Connection: ${options.timezone}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`
      );
      // SqlStrings falls back to UTC on invalid timezone
      this.timezone = 'Z';
    } else {
      this.timezone = options.timezone || 'local';
    }
    this.queryFormat = options.queryFormat;
    this.pool = options.pool || undefined;
    this.ssl =
      typeof options.ssl === 'string'
        ? ConnectionConfig.getSSLProfile(options.ssl)
        : options.ssl || false;
    this.multipleStatements = options.multipleStatements || false;
    this.rowsAsArray = options.rowsAsArray || false;
    this.namedPlaceholders = options.namedPlaceholders || false;
    this.nestTables =
      options.nestTables === undefined ? undefined : options.nestTables;
    this.typeCast = options.typeCast === undefined ? true : options.typeCast;
    this.disableEval = Boolean(options.disableEval);
    if (this.timezone[0] === ' ') {
      // "+" is a url encoded char for space so it
      // gets translated to space when giving a
      // connection string..
      this.timezone = `+${this.timezone.slice(1)}`;
    }
    if (this.ssl) {
      if (typeof this.ssl !== 'object') {
        throw new TypeError(
          `SSL profile must be an object, instead it's a ${typeof this.ssl}`
        );
      }
      // Default rejectUnauthorized to true
      this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;
    }
    this.maxPacketSize = 0;
    this.charsetNumber = options.charset
      ? ConnectionConfig.getCharsetNumber(options.charset)
      : options.charsetNumber || Charsets.UTF8MB4_UNICODE_CI;
    this.compress = options.compress || false;
    this.authPlugins = options.authPlugins;
    this.authSwitchHandler = options.authSwitchHandler;
    this.clientFlags = ConnectionConfig.mergeFlags(
      ConnectionConfig.getDefaultFlags(options),
      options.flags || ''
    );
    // Default connection attributes
    // https://dev.mysql.com/doc/refman/8.0/en/performance-schema-connection-attribute-tables.html
    const defaultConnectAttributes = {
      _client_name: 'Node-MySQL-2',
      _client_version: version,
    };
    this.connectAttributes = {
      ...defaultConnectAttributes,
      ...(options.connectAttributes || {}),
    };
    this.maxPreparedStatements = options.maxPreparedStatements || 16000;
    this.jsonStrings = options.jsonStrings || false;
    this.gracefulEnd = options.gracefulEnd || false;
  }

  static mergeFlags(default_flags, user_flags) {
    let flags = 0x0,
      i;
    if (!Array.isArray(user_flags)) {
      user_flags = String(user_flags || '')
        .toUpperCase()
        .split(/\s*,+\s*/);
    }
    // add default flags unless "blacklisted"
    for (i in default_flags) {
      if (user_flags.indexOf(`-${default_flags[i]}`) >= 0) {
        continue;
      }
      flags |= ClientConstants[default_flags[i]] || 0x0;
    }
    // add user flags unless already already added
    for (i in user_flags) {
      if (user_flags[i][0] === '-') {
        continue;
      }
      if (default_flags.indexOf(user_flags[i]) >= 0) {
        continue;
      }
      flags |= ClientConstants[user_flags[i]] || 0x0;
    }
    return flags;
  }

  static getDefaultFlags(options) {
    const defaultFlags = [
      'LONG_PASSWORD',
      'FOUND_ROWS',
      'LONG_FLAG',
      'CONNECT_WITH_DB',
      'ODBC',
      'LOCAL_FILES',
      'IGNORE_SPACE',
      'PROTOCOL_41',
      'IGNORE_SIGPIPE',
      'TRANSACTIONS',
      'RESERVED',
      'SECURE_CONNECTION',
      'MULTI_RESULTS',
      'TRANSACTIONS',
      'SESSION_TRACK',
      'CONNECT_ATTRS',
    ];
    if (options && options.multipleStatements) {
      defaultFlags.push('MULTI_STATEMENTS');
    }
    defaultFlags.push('PLUGIN_AUTH');
    defaultFlags.push('PLUGIN_AUTH_LENENC_CLIENT_DATA');

    return defaultFlags;
  }

  static getCharsetNumber(charset) {
    const num = Charsets[charset.toUpperCase()];
    if (num === undefined) {
      throw new TypeError(`Unknown charset '${charset}'`);
    }
    return num;
  }

  static getSSLProfile(name) {
    if (!SSLProfiles) {
      SSLProfiles = /*@__PURE__*/ requireSsl_profiles();
    }
    const ssl = SSLProfiles[name];
    if (ssl === undefined) {
      throw new TypeError(`Unknown SSL profile '${name}'`);
    }
    return ssl;
  }

  static parseUrl(url) {
    const parsedUrl = new URL$1(url);
    const options = {
      host: decodeURIComponent(parsedUrl.hostname),
      port: parseInt(parsedUrl.port, 10),
      database: decodeURIComponent(parsedUrl.pathname.slice(1)),
      user: decodeURIComponent(parsedUrl.username),
      password: decodeURIComponent(parsedUrl.password),
    };
    parsedUrl.searchParams.forEach((value, key) => {
      try {
        // Try to parse this as a JSON expression first
        options[key] = JSON.parse(value);
      } catch (err) {
        // Otherwise assume it is a plain string
        options[key] = value;
      }
    });
    return options;
  }
};

var connection_config = ConnectionConfig$3;

var namedPlaceholders = {exports: {}};

var hasRequiredNamedPlaceholders;

function requireNamedPlaceholders () {
	if (hasRequiredNamedPlaceholders) return namedPlaceholders.exports;
	hasRequiredNamedPlaceholders = 1;

	// based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332
	// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE

	const RE_PARAM = /(?:\?)|(?::(\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,
	  DQUOTE = 34,
	  SQUOTE = 39,
	  BSLASH = 92;

	function parse(query) {
	  let ppos = RE_PARAM.exec(query);
	  let curpos = 0;
	  let start = 0;
	  let end;
	  const parts = [];
	  let inQuote = false;
	  let escape = false;
	  let qchr;
	  const tokens = [];
	  let qcnt = 0;
	  let lastTokenEndPos = 0;
	  let i;

	  if (ppos) {
	    do {
	      for (i = curpos, end = ppos.index; i < end; ++i) {
	        const chr = query.charCodeAt(i);
	        if (chr === BSLASH) escape = !escape;
	        else {
	          if (escape) {
	            escape = false;
	            continue;
	          }
	          if (inQuote && chr === qchr) {
	            if (query.charCodeAt(i + 1) === qchr) {
	              // quote escaped via "" or ''
	              ++i;
	              continue;
	            }
	            inQuote = false;
	          } else if (!inQuote && (chr === DQUOTE || chr === SQUOTE)) {
	            inQuote = true;
	            qchr = chr;
	          }
	        }
	      }
	      if (!inQuote) {
	        parts.push(query.substring(start, end));
	        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);
	        start = end + ppos[0].length;
	        lastTokenEndPos = start;
	      }
	      curpos = end + ppos[0].length;
	    } while ((ppos = RE_PARAM.exec(query)));

	    if (tokens.length) {
	      if (curpos < query.length) {
	        parts.push(query.substring(lastTokenEndPos));
	      }
	      return [parts, tokens];
	    }
	  }
	  return [query];
	}

	function createCompiler(config) {
	  if (!config) config = {};
	  if (!config.placeholder) {
	    config.placeholder = '?';
	  }
	  let ncache = 100;
	  let cache;
	  if (typeof config.cache === 'number') {
	    ncache = config.cache;
	  }
	  if (typeof config.cache === 'object') {
	    cache = config.cache;
	  }
	  if (config.cache !== false && !cache) {
	    cache = require$$7$1.createLRU({ max: ncache });
	  }

	  function toArrayParams(tree, params) {
	    const arr = [];
	    if (tree.length === 1) {
	      return [tree[0], []];
	    }

	    if (typeof params === 'undefined')
	      throw new Error(
	        'Named query contains placeholders, but parameters object is undefined'
	      );

	    const tokens = tree[1];
	    for (let i = 0; i < tokens.length; ++i) {
	      arr.push(params[tokens[i]]);
	    }
	    return [tree[0], arr];
	  }

	  function noTailingSemicolon(s) {
	    if (s.slice(-1) === ':') {
	      return s.slice(0, -1);
	    }
	    return s;
	  }

	  function join(tree) {
	    if (tree.length === 1) {
	      return tree;
	    }

	    let unnamed = noTailingSemicolon(tree[0][0]);
	    for (let i = 1; i < tree[0].length; ++i) {
	      if (tree[0][i - 1].slice(-1) === ':') {
	        unnamed += config.placeholder;
	      }
	      unnamed += config.placeholder;
	      unnamed += noTailingSemicolon(tree[0][i]);
	    }

	    const last = tree[0][tree[0].length - 1];
	    if (tree[0].length === tree[1].length) {
	      if (last.slice(-1) === ':') {
	        unnamed += config.placeholder;
	      }
	      unnamed += config.placeholder;
	    }
	    return [unnamed, tree[1]];
	  }

	  function compile(query, paramsObj) {
	    let tree;
	    if (cache && (tree = cache.get(query))) {
	      return toArrayParams(tree, paramsObj);
	    }
	    tree = join(parse(query));
	    if (cache) {
	      cache.set(query, tree);
	    }
	    return toArrayParams(tree, paramsObj);
	  }

	  compile.parse = parse;
	  return compile;
	}

	// named :one :two to postgres-style numbered $1 $2 $3
	function toNumbered(q, params) {
	  const tree = parse(q);
	  const paramsArr = [];
	  if (tree.length === 1) {
	    return [tree[0], paramsArr];
	  }

	  const pIndexes = {};
	  let pLastIndex = 0;
	  let qs = '';
	  let varIndex;
	  const varNames = [];
	  for (let i = 0; i < tree[0].length; ++i) {
	    varIndex = pIndexes[tree[1][i]];
	    if (!varIndex) {
	      varIndex = ++pLastIndex;
	      pIndexes[tree[1][i]] = varIndex;
	    }
	    if (tree[1][i]) {
	      varNames[varIndex - 1] = tree[1][i];
	      qs += `${tree[0][i]}$${varIndex}`;
	    } else {
	      qs += tree[0][i];
	    }
	  }
	  return [qs, varNames.map((n) => params[n])];
	}

	namedPlaceholders.exports = createCompiler;
	namedPlaceholders.exports.toNumbered = toNumbered;
	return namedPlaceholders.exports;
}

const Net = require$$3$2;
const Tls = require$$4$1;
const Timers = require$$2$3;
const EventEmitter$4 = require$$0$6.EventEmitter;
const Readable = require$$2$2.Readable;
const Queue$1 = denque;
const SqlString$1 = sqlstring;
const { createLRU } = require$$7$1;
const PacketParser = packet_parser;
const Packets = packetsExports;
const Commands = commands;
const ConnectionConfig$2 = connection_config;
const CharsetToEncoding = /*@__PURE__*/ requireCharset_encodings();

let _connectionId = 0;

let convertNamedPlaceholders = null;

let BaseConnection$4 = class BaseConnection extends EventEmitter$4 {
  constructor(opts) {
    super();
    this.config = opts.config;
    // TODO: fill defaults
    // if no params, connect to /var/lib/mysql/mysql.sock ( /tmp/mysql.sock on OSX )
    // if host is given, connect to host:3306
    // TODO: use `/usr/local/mysql/bin/mysql_config --socket` output? as default socketPath
    // if there is no host/port and no socketPath parameters?
    if (!opts.config.stream) {
      if (opts.config.socketPath) {
        this.stream = Net.connect(opts.config.socketPath);
      } else {
        this.stream = Net.connect(opts.config.port, opts.config.host);

        // Optionally enable keep-alive on the socket.
        if (this.config.enableKeepAlive) {
          this.stream.on('connect', () => {
            this.stream.setKeepAlive(true, this.config.keepAliveInitialDelay);
          });
        }

        // Enable TCP_NODELAY flag. This is needed so that the network packets
        // are sent immediately to the server
        this.stream.setNoDelay(true);
      }
      // if stream is a function, treat it as "stream agent / factory"
    } else if (typeof opts.config.stream === 'function') {
      this.stream = opts.config.stream(opts);
    } else {
      this.stream = opts.config.stream;
    }

    this._internalId = _connectionId++;
    this._commands = new Queue$1();
    this._command = null;
    this._paused = false;
    this._paused_packets = new Queue$1();
    this._statements = createLRU({
      max: this.config.maxPreparedStatements,
      onEviction: function (_, statement) {
        statement.close();
      },
    });
    this.serverCapabilityFlags = 0;
    this.authorized = false;
    this.sequenceId = 0;
    this.compressedSequenceId = 0;
    this.threadId = null;
    this._handshakePacket = null;
    this._fatalError = null;
    this._protocolError = null;
    this._outOfOrderPackets = [];
    this.clientEncoding = CharsetToEncoding[this.config.charsetNumber];
    this.stream.on('error', this._handleNetworkError.bind(this));
    // see https://gist.github.com/khoomeister/4985691#use-that-instead-of-bind
    this.packetParser = new PacketParser((p) => {
      this.handlePacket(p);
    });
    this.stream.on('data', (data) => {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      this.packetParser.execute(data);
    });
    this.stream.on('end', () => {
      // emit the end event so that the pooled connection can close the connection
      this.emit('end');
    });
    this.stream.on('close', () => {
      // we need to set this flag everywhere where we want connection to close
      if (this._closing) {
        return;
      }
      if (!this._protocolError) {
        // no particular error message before disconnect
        this._protocolError = new Error(
          'Connection lost: The server closed the connection.'
        );
        this._protocolError.fatal = true;
        this._protocolError.code = 'PROTOCOL_CONNECTION_LOST';
      }
      this._notifyError(this._protocolError);
    });
    let handshakeCommand;
    if (!this.config.isServer) {
      handshakeCommand = new Commands.ClientHandshake(this.config.clientFlags);
      handshakeCommand.on('end', () => {
        // this happens when handshake finishes early either because there was
        // some fatal error or the server sent an error packet instead of
        // an hello packet (for example, 'Too many connections' error)
        if (
          !handshakeCommand.handshake ||
          this._fatalError ||
          this._protocolError
        ) {
          return;
        }
        this._handshakePacket = handshakeCommand.handshake;
        this.threadId = handshakeCommand.handshake.connectionId;
        this.emit('connect', handshakeCommand.handshake);
      });
      handshakeCommand.on('error', (err) => {
        this._closing = true;
        this._notifyError(err);
      });
      this.addCommand(handshakeCommand);
    }
    // in case there was no initial handshake but we need to read sting, assume it utf-8
    // most common example: "Too many connections" error ( packet is sent immediately on connection attempt, we don't know server encoding yet)
    // will be overwritten with actual encoding value as soon as server handshake packet is received
    this.serverEncoding = 'utf8';
    if (this.config.connectTimeout) {
      const timeoutHandler = this._handleTimeoutError.bind(this);
      this.connectTimeout = Timers.setTimeout(
        timeoutHandler,
        this.config.connectTimeout
      );
    }
  }

  _addCommandClosedState(cmd) {
    const err = new Error(
      "Can't add new command when connection is in closed state"
    );
    err.fatal = true;
    if (cmd.onResult) {
      cmd.onResult(err);
    } else {
      this.emit('error', err);
    }
  }

  _handleFatalError(err) {
    err.fatal = true;
    // stop receiving packets
    this.stream.removeAllListeners('data');
    this.addCommand = this._addCommandClosedState;
    this.write = () => {
      this.emit('error', new Error("Can't write in closed state"));
    };
    this._notifyError(err);
    this._fatalError = err;
  }

  _handleNetworkError(err) {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    // Do not throw an error when a connection ends with a RST,ACK packet
    if (err.code === 'ECONNRESET' && this._closing) {
      return;
    }
    this._handleFatalError(err);
  }

  _handleTimeoutError() {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    this.stream.destroy && this.stream.destroy();
    const err = new Error('connect ETIMEDOUT');
    err.errorno = 'ETIMEDOUT';
    err.code = 'ETIMEDOUT';
    err.syscall = 'connect';
    this._handleNetworkError(err);
  }

  // notify all commands in the queue and bubble error as connection "error"
  // called on stream error or unexpected termination
  _notifyError(err) {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    // prevent from emitting 'PROTOCOL_CONNECTION_LOST' after EPIPE or ECONNRESET
    if (this._fatalError) {
      return;
    }
    let command;
    // if there is no active command, notify connection
    // if there are commands and all of them have callbacks, pass error via callback
    let bubbleErrorToConnection = !this._command;
    if (this._command && this._command.onResult) {
      this._command.onResult(err);
      this._command = null;
      // connection handshake is special because we allow it to be implicit
      // if error happened during handshake, but there are others commands in queue
      // then bubble error to other commands and not to connection
    } else if (
      !(
        this._command &&
        this._command.constructor === Commands.ClientHandshake &&
        this._commands.length > 0
      )
    ) {
      bubbleErrorToConnection = true;
    }
    while ((command = this._commands.shift())) {
      if (command.onResult) {
        command.onResult(err);
      } else {
        bubbleErrorToConnection = true;
      }
    }
    // notify connection if some comands in the queue did not have callbacks
    // or if this is pool connection ( so it can be removed from pool )
    if (bubbleErrorToConnection || this._pool) {
      this.emit('error', err);
    }
    // close connection after emitting the event in case of a fatal error
    if (err.fatal) {
      this.close();
    }
  }

  write(buffer) {
    const result = this.stream.write(buffer, (err) => {
      if (err) {
        this._handleNetworkError(err);
      }
    });

    if (!result) {
      this.stream.emit('pause');
    }
  }

  // http://dev.mysql.com/doc/internals/en/sequence-id.html
  //
  // The sequence-id is incremented with each packet and may wrap around.
  // It starts at 0 and is reset to 0 when a new command
  // begins in the Command Phase.
  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html
  _resetSequenceId() {
    this.sequenceId = 0;
    this.compressedSequenceId = 0;
  }

  _bumpCompressedSequenceId(numPackets) {
    this.compressedSequenceId += numPackets;
    this.compressedSequenceId %= 256;
  }

  _bumpSequenceId(numPackets) {
    this.sequenceId += numPackets;
    this.sequenceId %= 256;
  }

  writePacket(packet) {
    const MAX_PACKET_LENGTH = 16777215;
    const length = packet.length();
    let chunk, offset, header;
    if (length < MAX_PACKET_LENGTH) {
      packet.writeHeader(this.sequenceId);
      if (this.config.debug) {
        console.log(
          `${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[this.sequenceId, packet._name, packet.length()].join(',')})`
        );
        console.log(
          `${this._internalId} ${this.connectionId} <== ${packet.buffer.toString('hex')}`
        );
      }
      this._bumpSequenceId(1);
      this.write(packet.buffer);
    } else {
      if (this.config.debug) {
        console.log(
          `${this._internalId} ${this.connectionId} <== Writing large packet, raw content not written:`
        );
        console.log(
          `${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[this.sequenceId, packet._name, packet.length()].join(',')})`
        );
      }
      for (offset = 4; offset < 4 + length; offset += MAX_PACKET_LENGTH) {
        chunk = packet.buffer.slice(offset, offset + MAX_PACKET_LENGTH);
        if (chunk.length === MAX_PACKET_LENGTH) {
          header = Buffer.from([0xff, 0xff, 0xff, this.sequenceId]);
        } else {
          header = Buffer.from([
            chunk.length & 0xff,
            (chunk.length >> 8) & 0xff,
            (chunk.length >> 16) & 0xff,
            this.sequenceId,
          ]);
        }
        this._bumpSequenceId(1);
        this.write(header);
        this.write(chunk);
      }
    }
  }

  // 0.11+ environment
  startTLS(onSecure) {
    if (this.config.debug) {
      console.log('Upgrading connection to TLS');
    }
    const secureContext = Tls.createSecureContext({
      ca: this.config.ssl.ca,
      cert: this.config.ssl.cert,
      ciphers: this.config.ssl.ciphers,
      key: this.config.ssl.key,
      passphrase: this.config.ssl.passphrase,
      minVersion: this.config.ssl.minVersion,
      maxVersion: this.config.ssl.maxVersion,
    });
    const rejectUnauthorized = this.config.ssl.rejectUnauthorized;
    const verifyIdentity = this.config.ssl.verifyIdentity;
    const servername = Net.isIP(this.config.host)
      ? undefined
      : this.config.host;

    let secureEstablished = false;
    this.stream.removeAllListeners('data');
    const secureSocket = Tls.connect(
      {
        rejectUnauthorized,
        requestCert: rejectUnauthorized,
        checkServerIdentity: verifyIdentity
          ? Tls.checkServerIdentity
          : function () {
              return undefined;
            },
        secureContext,
        isServer: false,
        socket: this.stream,
        servername,
      },
      () => {
        secureEstablished = true;
        if (rejectUnauthorized) {
          if (typeof servername === 'string' && verifyIdentity) {
            const cert = secureSocket.getPeerCertificate(true);
            const serverIdentityCheckError = Tls.checkServerIdentity(
              servername,
              cert
            );
            if (serverIdentityCheckError) {
              onSecure(serverIdentityCheckError);
              return;
            }
          }
        }
        onSecure();
      }
    );
    // error handler for secure socket
    secureSocket.on('error', (err) => {
      if (secureEstablished) {
        this._handleNetworkError(err);
      } else {
        onSecure(err);
      }
    });
    secureSocket.on('data', (data) => {
      this.packetParser.execute(data);
    });
    this.stream = secureSocket;
  }

  protocolError(message, code) {
    // Starting with MySQL 8.0.24, if the client closes the connection
    // unexpectedly, the server will send a last ERR Packet, which we can
    // safely ignore.
    // https://dev.mysql.com/worklog/task/?id=12999
    if (this._closing) {
      return;
    }

    const err = new Error(message);
    err.fatal = true;
    err.code = code || 'PROTOCOL_ERROR';
    this.emit('error', err);
  }

  get state() {
    // Error state has highest priority
    if (this._fatalError || this._protocolError) {
      return 'error';
    }

    // Closing state has second priority
    if (this._closing || (this.stream && this.stream.destroyed)) {
      return 'disconnected';
    }

    // Authenticated state has third priority
    if (this.authorized) {
      return 'authenticated';
    }

    // Connected state: handshake completed but not yet authorized
    // This matches the original mysql driver's 'connected' state
    if (this._handshakePacket) {
      return 'connected';
    }

    // Protocol handshake state: connection established, handshake in progress
    if (this.stream && !this.stream.destroyed) {
      return 'protocol_handshake';
    }

    // Default: not connected
    return 'disconnected';
  }

  get fatalError() {
    return this._fatalError;
  }

  handlePacket(packet) {
    if (this._paused) {
      this._paused_packets.push(packet);
      return;
    }
    if (this.config.debug) {
      if (packet) {
        console.log(
          ` raw: ${packet.buffer
            .slice(packet.offset, packet.offset + packet.length())
            .toString('hex')}`
        );
        console.trace();
        const commandName = this._command
          ? this._command._commandName
          : '(no command)';
        const stateName = this._command
          ? this._command.stateName()
          : '(no command)';
        console.log(
          `${this._internalId} ${this.connectionId} ==> ${commandName}#${stateName}(${[packet.sequenceId, packet.type(), packet.length()].join(',')})`
        );
      }
    }
    if (!this._command) {
      const marker = packet.peekByte();
      // If it's an Err Packet, we should use it.
      if (marker === 0xff) {
        const error = Packets.Error.fromPacket(packet);
        this.protocolError(error.message, error.code);
      } else {
        // Otherwise, it means it's some other unexpected packet.
        this.protocolError(
          'Unexpected packet while no commands in the queue',
          'PROTOCOL_UNEXPECTED_PACKET'
        );
      }
      this.close();
      return;
    }
    if (packet) {
      // Note: when server closes connection due to inactivity, Err packet ER_CLIENT_INTERACTION_TIMEOUT from MySQL 8.0.24, sequenceId will be 0
      if (this.sequenceId !== packet.sequenceId) {
        const err = new Error(
          `Warning: got packets out of order. Expected ${this.sequenceId} but received ${packet.sequenceId}`
        );
        err.expected = this.sequenceId;
        err.received = packet.sequenceId;
        this.emit('warn', err); // REVIEW
        console.error(err.message);
      }
      this._bumpSequenceId(packet.numPackets);
    }
    try {
      if (this._fatalError) {
        // skip remaining packets after client is in the error state
        return;
      }
      const done = this._command.execute(packet, this);
      if (done) {
        this._command = this._commands.shift();
        if (this._command) {
          this.sequenceId = 0;
          this.compressedSequenceId = 0;
          this.handlePacket();
        }
      }
    } catch (err) {
      this._handleFatalError(err);
      this.stream.destroy();
    }
  }

  addCommand(cmd) {
    // this.compressedSequenceId = 0;
    // this.sequenceId = 0;
    if (this.config.debug) {
      const commandName = cmd.constructor.name;
      console.log(`Add command: ${commandName}`);
      cmd._commandName = commandName;
    }
    if (!this._command) {
      this._command = cmd;
      this.handlePacket();
    } else {
      this._commands.push(cmd);
    }
    return cmd;
  }

  format(sql, values) {
    if (typeof this.config.queryFormat === 'function') {
      return this.config.queryFormat.call(
        this,
        sql,
        values,
        this.config.timezone
      );
    }
    const opts = {
      sql: sql,
      values: values,
    };
    this._resolveNamedPlaceholders(opts);
    return SqlString$1.format(
      opts.sql,
      opts.values,
      this.config.stringifyObjects,
      this.config.timezone
    );
  }

  escape(value) {
    return SqlString$1.escape(value, false, this.config.timezone);
  }

  escapeId(value) {
    return SqlString$1.escapeId(value, false);
  }

  raw(sql) {
    return SqlString$1.raw(sql);
  }

  _resolveNamedPlaceholders(options) {
    let unnamed;
    if (this.config.namedPlaceholders || options.namedPlaceholders) {
      if (Array.isArray(options.values)) {
        // if an array is provided as the values, assume the conversion is not necessary.
        // this allows the usage of unnamed placeholders even if the namedPlaceholders flag is enabled.
        return;
      }
      if (convertNamedPlaceholders === null) {
        convertNamedPlaceholders = /*@__PURE__*/ requireNamedPlaceholders()();
      }
      unnamed = convertNamedPlaceholders(options.sql, options.values);
      options.sql = unnamed[0];
      options.values = unnamed[1];
    }
  }

  query(sql, values, cb) {
    let cmdQuery;
    if (sql.constructor === Commands.Query) {
      cmdQuery = sql;
    } else {
      cmdQuery = BaseConnection.createQuery(sql, values, cb, this.config);
    }
    this._resolveNamedPlaceholders(cmdQuery);
    const rawSql = this.format(
      cmdQuery.sql,
      cmdQuery.values !== undefined ? cmdQuery.values : []
    );
    cmdQuery.sql = rawSql;
    return this.addCommand(cmdQuery);
  }

  pause() {
    this._paused = true;
    this.stream.pause();
  }

  resume() {
    let packet;
    this._paused = false;
    while ((packet = this._paused_packets.shift())) {
      this.handlePacket(packet);
      // don't resume if packet handler paused connection
      if (this._paused) {
        return;
      }
    }
    this.stream.resume();
  }

  // TODO: named placeholders support
  prepare(options, cb) {
    if (typeof options === 'string') {
      options = { sql: options };
    }
    return this.addCommand(new Commands.Prepare(options, cb));
  }

  unprepare(sql) {
    let options = {};
    if (typeof sql === 'object') {
      options = sql;
    } else {
      options.sql = sql;
    }
    const key = BaseConnection.statementKey(options);
    const stmt = this._statements.get(key);
    if (stmt) {
      this._statements.delete(key);
      stmt.close();
    }
    return stmt;
  }

  execute(sql, values, cb) {
    let options = {
      infileStreamFactory: this.config.infileStreamFactory,
    };
    if (typeof sql === 'object') {
      // execute(options, cb)
      options = {
        ...options,
        ...sql,
        sql: sql.sql,
        values: sql.values,
      };
      if (typeof values === 'function') {
        cb = values;
      } else {
        options.values = options.values || values;
      }
    } else if (typeof values === 'function') {
      // execute(sql, cb)
      cb = values;
      options.sql = sql;
      options.values = undefined;
    } else {
      // execute(sql, values, cb)
      options.sql = sql;
      options.values = values;
    }
    this._resolveNamedPlaceholders(options);
    // check for values containing undefined
    if (options.values) {
      //If namedPlaceholder is not enabled and object is passed as bind parameters
      if (!Array.isArray(options.values)) {
        throw new TypeError(
          'Bind parameters must be array if namedPlaceholders parameter is not enabled'
        );
      }
      options.values.forEach((val) => {
        //If namedPlaceholder is not enabled and object is passed as bind parameters
        if (!Array.isArray(options.values)) {
          throw new TypeError(
            'Bind parameters must be array if namedPlaceholders parameter is not enabled'
          );
        }
        if (val === undefined) {
          throw new TypeError(
            'Bind parameters must not contain undefined. To pass SQL NULL specify JS null'
          );
        }
        if (typeof val === 'function') {
          throw new TypeError(
            'Bind parameters must not contain function(s). To pass the body of a function as a string call .toString() first'
          );
        }
      });
    }
    const executeCommand = new Commands.Execute(options, cb);
    const prepareCommand = new Commands.Prepare(options, (err, stmt) => {
      if (err) {
        // skip execute command if prepare failed, we have main
        // combined callback here
        executeCommand.start = function () {
          return null;
        };
        if (cb) {
          cb(err);
        } else {
          executeCommand.emit('error', err);
        }
        executeCommand.emit('end');
        return;
      }
      executeCommand.statement = stmt;
    });
    this.addCommand(prepareCommand);
    this.addCommand(executeCommand);
    return executeCommand;
  }

  changeUser(options, callback) {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = {};
    }
    const charsetNumber = options.charset
      ? ConnectionConfig$2.getCharsetNumber(options.charset)
      : this.config.charsetNumber;
    return this.addCommand(
      new Commands.ChangeUser(
        {
          user: options.user || this.config.user,
          // for the purpose of multi-factor authentication, or not, the main
          // password (used for the 1st authentication factor) can also be
          // provided via the "password1" option
          password:
            options.password ||
            options.password1 ||
            this.config.password ||
            this.config.password1,
          password2: options.password2 || this.config.password2,
          password3: options.password3 || this.config.password3,
          passwordSha1: options.passwordSha1 || this.config.passwordSha1,
          database: options.database || this.config.database,
          timeout: options.timeout,
          charsetNumber: charsetNumber,
          currentConfig: this.config,
        },
        (err) => {
          if (err) {
            err.fatal = true;
          }
          if (callback) {
            callback(err);
          }
        }
      )
    );
  }

  // transaction helpers
  beginTransaction(cb) {
    return this.query('START TRANSACTION', cb);
  }

  commit(cb) {
    return this.query('COMMIT', cb);
  }

  rollback(cb) {
    return this.query('ROLLBACK', cb);
  }

  ping(cb) {
    return this.addCommand(new Commands.Ping(cb));
  }

  _registerSlave(opts, cb) {
    return this.addCommand(new Commands.RegisterSlave(opts, cb));
  }

  _binlogDump(opts, cb) {
    return this.addCommand(new Commands.BinlogDump(opts, cb));
  }

  // currently just alias to close
  destroy() {
    this.close();
  }

  close() {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    this._closing = true;
    this.stream.end();
    this.addCommand = this._addCommandClosedState;
  }

  createBinlogStream(opts) {
    // TODO: create proper stream class
    // TODO: use through2
    let test = 1;
    const stream = new Readable({ objectMode: true });
    stream._read = function () {
      return {
        data: test++,
      };
    };
    this._registerSlave(opts, () => {
      const dumpCmd = this._binlogDump(opts);
      dumpCmd.on('event', (ev) => {
        stream.push(ev);
      });
      dumpCmd.on('eof', () => {
        stream.push(null);
        // if non-blocking, then close stream to prevent errors
        if (opts.flags && opts.flags & 0x01) {
          this.close();
        }
      });
      // TODO: pipe errors as well
    });
    return stream;
  }

  connect(cb) {
    if (!cb) {
      return;
    }
    if (this._fatalError || this._protocolError) {
      return cb(this._fatalError || this._protocolError);
    }
    if (this._handshakePacket) {
      return cb(null, this);
    }
    let connectCalled = 0;
    function callbackOnce(isErrorHandler) {
      return function (param) {
        if (!connectCalled) {
          if (isErrorHandler) {
            cb(param);
          } else {
            cb(null, param);
          }
        }
        connectCalled = 1;
      };
    }
    this.once('error', callbackOnce(true));
    this.once('connect', callbackOnce(false));
  }

  // ===================================
  // outgoing server connection methods
  // ===================================
  writeColumns(columns) {
    this.writePacket(Packets.ResultSetHeader.toPacket(columns.length));
    columns.forEach((column) => {
      this.writePacket(
        Packets.ColumnDefinition.toPacket(column, this.serverConfig.encoding)
      );
    });
    this.writeEof();
  }

  // row is array of columns, not hash
  writeTextRow(column) {
    this.writePacket(
      Packets.TextRow.toPacket(column, this.serverConfig.encoding)
    );
  }

  writeBinaryRow(column) {
    this.writePacket(
      Packets.BinaryRow.toPacket(column, this.serverConfig.encoding)
    );
  }

  writeTextResult(rows, columns, binary = false) {
    this.writeColumns(columns);
    rows.forEach((row) => {
      const arrayRow = new Array(columns.length);
      columns.forEach((column) => {
        arrayRow.push(row[column.name]);
      });
      if (binary) {
        this.writeBinaryRow(arrayRow);
      } else this.writeTextRow(arrayRow);
    });
    this.writeEof();
  }

  writeEof(warnings, statusFlags) {
    this.writePacket(Packets.EOF.toPacket(warnings, statusFlags));
  }

  writeOk(args) {
    if (!args) {
      args = { affectedRows: 0 };
    }
    this.writePacket(Packets.OK.toPacket(args, this.serverConfig.encoding));
  }

  writeError(args) {
    // if we want to send error before initial hello was sent, use default encoding
    const encoding = this.serverConfig ? this.serverConfig.encoding : 'cesu8';
    this.writePacket(Packets.Error.toPacket(args, encoding));
  }

  serverHandshake(args) {
    this.serverConfig = args;
    this.serverConfig.encoding =
      CharsetToEncoding[this.serverConfig.characterSet];
    return this.addCommand(new Commands.ServerHandshake(args));
  }

  // ===============================================================
  end(callback) {
    if (this.config.isServer) {
      this._closing = true;
      const quitCmd = new EventEmitter$4();
      setImmediate(() => {
        this.stream.end();
        quitCmd.emit('end');
      });
      return quitCmd;
    }
    // trigger error if more commands enqueued after end command
    const quitCmd = this.addCommand(new Commands.Quit(callback));
    this.addCommand = this._addCommandClosedState;
    return quitCmd;
  }

  static createQuery(sql, values, cb, config) {
    let options = {
      rowsAsArray: config.rowsAsArray,
      infileStreamFactory: config.infileStreamFactory,
    };
    if (typeof sql === 'object') {
      // query(options, cb)
      options = {
        ...options,
        ...sql,
        sql: sql.sql,
        values: sql.values,
      };
      if (typeof values === 'function') {
        cb = values;
      } else if (values !== undefined) {
        options.values = values;
      }
    } else if (typeof values === 'function') {
      // query(sql, cb)
      cb = values;
      options.sql = sql;
      options.values = undefined;
    } else {
      // query(sql, values, cb)
      options.sql = sql;
      options.values = values;
    }
    return new Commands.Query(options, cb);
  }

  static statementKey(options) {
    return `${typeof options.nestTables}/${options.nestTables}/${options.rowsAsArray}${options.sql}`;
  }
};

var connection$2 = BaseConnection$4;

const BaseConnection$3 = connection$2;

let BasePoolConnection$2 = class BasePoolConnection extends BaseConnection$3 {
  constructor(pool, options) {
    super(options);
    this._pool = pool;
    // The last active time of this connection
    this.lastActiveTime = Date.now();
    // When a fatal error occurs the connection's protocol ends, which will cause
    // the connection to end as well, thus we only need to watch for the end event
    // and we will be notified of disconnects.
    // REVIEW: Moved to `once`
    this.once('end', () => {
      this._removeFromPool();
    });
    this.once('error', () => {
      this._removeFromPool();
    });
  }

  release() {
    if (!this._pool || this._pool._closed) {
      return;
    }
    // update last active time
    this.lastActiveTime = Date.now();
    this._pool.releaseConnection(this);
  }

  end() {
    if (this.config.gracefulEnd) {
      this._removeFromPool();
      super.end();

      return;
    }

    const err = new Error(
      'Calling conn.end() to release a pooled connection is ' +
        'deprecated. In next version calling conn.end() will be ' +
        'restored to default conn.end() behavior. Use ' +
        'conn.release() instead.'
    );
    this.emit('warn', err);
    console.warn(err.message);
    this.release();
  }

  destroy() {
    this._removeFromPool();
    super.destroy();
  }

  _removeFromPool() {
    if (!this._pool || this._pool._closed) {
      return;
    }
    const pool = this._pool;
    this._pool = null;
    pool._removeConnection(this);
  }
};

BasePoolConnection$2.statementKey = BaseConnection$3.statementKey;
var pool_connection$2 = BasePoolConnection$2;

// TODO: Remove this when we are removing PoolConnection#end
BasePoolConnection$2.prototype._realEnd = BaseConnection$3.prototype.end;

function makeDoneCb$4(resolve, reject, localErr) {
  return function (err, rows, fields) {
    if (err) {
      localErr.message = err.message;
      localErr.code = err.code;
      localErr.errno = err.errno;
      localErr.sql = err.sql;
      localErr.sqlState = err.sqlState;
      localErr.sqlMessage = err.sqlMessage;
      reject(localErr);
    } else {
      resolve([rows, fields]);
    }
  };
}

var make_done_cb = makeDoneCb$4;

const makeDoneCb$3 = make_done_cb;

let PromisePreparedStatementInfo$1 = class PromisePreparedStatementInfo {
  constructor(statement, promiseImpl) {
    this.statement = statement;
    this.Promise = promiseImpl;
  }

  execute(parameters) {
    const s = this.statement;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb$3(resolve, reject, localErr);
      if (parameters) {
        s.execute(parameters, done);
      } else {
        s.execute(done);
      }
    });
  }

  close() {
    return new this.Promise((resolve) => {
      this.statement.close();
      resolve();
    });
  }
};

var prepared_statement_info = PromisePreparedStatementInfo$1;

function inheritEvents$2(source, target, events) {
  const listeners = {};
  target
    .on('newListener', (eventName) => {
      if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
        source.on(
          eventName,
          (listeners[eventName] = function () {
            const args = [].slice.call(arguments);
            args.unshift(eventName);

            target.emit.apply(target, args);
          })
        );
      }
    })
    .on('removeListener', (eventName) => {
      if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
        source.removeListener(eventName, listeners[eventName]);
        delete listeners[eventName];
      }
    });
}

var inherit_events = inheritEvents$2;

const EventEmitter$3 = require$$0$6.EventEmitter;
const PromisePreparedStatementInfo = prepared_statement_info;
const makeDoneCb$2 = make_done_cb;
const inheritEvents$1 = inherit_events;
const BaseConnection$2 = connection$2;

let PromiseConnection$1 = class PromiseConnection extends EventEmitter$3 {
  constructor(connection, promiseImpl) {
    super();
    this.connection = connection;
    this.Promise = promiseImpl || Promise;
    inheritEvents$1(connection, this, [
      'error',
      'drain',
      'connect',
      'end',
      'enqueue',
    ]);
  }

  release() {
    this.connection.release();
  }

  query(query, params) {
    const c = this.connection;
    const localErr = new Error();
    if (typeof params === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb$2(resolve, reject, localErr);
      if (params !== undefined) {
        c.query(query, params, done);
      } else {
        c.query(query, done);
      }
    });
  }

  execute(query, params) {
    const c = this.connection;
    const localErr = new Error();
    if (typeof params === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb$2(resolve, reject, localErr);
      if (params !== undefined) {
        c.execute(query, params, done);
      } else {
        c.execute(query, done);
      }
    });
  }

  end() {
    return new this.Promise((resolve) => {
      this.connection.end(resolve);
    });
  }

  beginTransaction() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb$2(resolve, reject, localErr);
      c.beginTransaction(done);
    });
  }

  commit() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb$2(resolve, reject, localErr);
      c.commit(done);
    });
  }

  rollback() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb$2(resolve, reject, localErr);
      c.rollback(done);
    });
  }

  ping() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      c.ping((err) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve(true);
        }
      });
    });
  }

  connect() {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      c.connect((err, param) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve(param);
        }
      });
    });
  }

  prepare(options) {
    const c = this.connection;
    const promiseImpl = this.Promise;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      c.prepare(options, (err, statement) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          const wrappedStatement = new PromisePreparedStatementInfo(
            statement,
            promiseImpl
          );
          resolve(wrappedStatement);
        }
      });
    });
  }

  changeUser(options) {
    const c = this.connection;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      c.changeUser(options, (err) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve();
        }
      });
    });
  }

  get config() {
    return this.connection.config;
  }

  get threadId() {
    return this.connection.threadId;
  }
};
// patching PromiseConnection
// create facade functions for prototype functions on "Connection" that are not yet
// implemented with PromiseConnection

// proxy synchronous functions only
(function (functionsToWrap) {
  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
    const func = functionsToWrap[i];

    if (
      typeof BaseConnection$2.prototype[func] === 'function' &&
      PromiseConnection$1.prototype[func] === undefined
    ) {
      PromiseConnection$1.prototype[func] = (function factory(funcName) {
        return function () {
          return BaseConnection$2.prototype[funcName].apply(
            this.connection,
            arguments
          );
        };
      })(func);
    }
  }
})([
  // synchronous functions
  'close',
  'createBinlogStream',
  'destroy',
  'escape',
  'escapeId',
  'format',
  'pause',
  'pipe',
  'resume',
  'unprepare',
]);

var connection$1 = PromiseConnection$1;

const PromiseConnection = connection$1;
const BasePoolConnection$1 = pool_connection$2;

let PromisePoolConnection$2 = class PromisePoolConnection extends PromiseConnection {
  constructor(connection, promiseImpl) {
    super(connection, promiseImpl);
  }

  destroy() {
    return BasePoolConnection$1.prototype.destroy.apply(
      this.connection,
      arguments
    );
  }
};

var pool_connection$1 = PromisePoolConnection$2;

const BasePoolConnection = pool_connection$2;

let PoolConnection$1 = class PoolConnection extends BasePoolConnection {
  promise(promiseImpl) {
    const PromisePoolConnection = pool_connection$1;
    return new PromisePoolConnection(this, promiseImpl);
  }
};

var pool_connection = PoolConnection$1;

const process$2 = require$$0$1;
const SqlString = sqlstring;
const EventEmitter$2 = require$$0$6.EventEmitter;
const PoolConnection = pool_connection;
const Queue = denque;
const BaseConnection$1 = connection$2;

function spliceConnection(queue, connection) {
  const len = queue.length;
  for (let i = 0; i < len; i++) {
    if (queue.get(i) === connection) {
      queue.removeOne(i);
      break;
    }
  }
}

let BasePool$2 = class BasePool extends EventEmitter$2 {
  constructor(options) {
    super();
    this.config = options.config;
    this.config.connectionConfig.pool = this;
    this._allConnections = new Queue();
    this._freeConnections = new Queue();
    this._connectionQueue = new Queue();
    this._closed = false;
    if (this.config.maxIdle < this.config.connectionLimit) {
      // create idle connection timeout automatically release job
      this._removeIdleTimeoutConnections();
    }
  }

  getConnection(cb) {
    if (this._closed) {
      return process$2.nextTick(() => cb(new Error('Pool is closed.')));
    }
    let connection;
    if (this._freeConnections.length > 0) {
      connection = this._freeConnections.pop();
      this.emit('acquire', connection);
      return process$2.nextTick(() => cb(null, connection));
    }
    if (
      this.config.connectionLimit === 0 ||
      this._allConnections.length < this.config.connectionLimit
    ) {
      connection = new PoolConnection(this, {
        config: this.config.connectionConfig,
      });
      this._allConnections.push(connection);
      return connection.connect((err) => {
        if (this._closed) {
          return cb(new Error('Pool is closed.'));
        }
        if (err) {
          return cb(err);
        }
        this.emit('connection', connection);
        this.emit('acquire', connection);
        return cb(null, connection);
      });
    }
    if (!this.config.waitForConnections) {
      return process$2.nextTick(() => cb(new Error('No connections available.')));
    }
    if (
      this.config.queueLimit &&
      this._connectionQueue.length >= this.config.queueLimit
    ) {
      return cb(new Error('Queue limit reached.'));
    }
    this.emit('enqueue');
    return this._connectionQueue.push(cb);
  }

  releaseConnection(connection) {
    let cb;
    if (!connection._pool) {
      // The connection has been removed from the pool and is no longer good.
      if (this._connectionQueue.length) {
        cb = this._connectionQueue.shift();
        process$2.nextTick(this.getConnection.bind(this, cb));
      }
    } else if (this._connectionQueue.length) {
      cb = this._connectionQueue.shift();
      process$2.nextTick(cb.bind(null, null, connection));
    } else {
      this._freeConnections.push(connection);
      this.emit('release', connection);
    }
  }

  end(cb) {
    this._closed = true;
    clearTimeout(this._removeIdleTimeoutConnectionsTimer);
    if (typeof cb !== 'function') {
      cb = function (err) {
        if (err) {
          throw err;
        }
      };
    }
    let calledBack = false;
    let closedConnections = 0;
    let connection;
    const endCB = function (err) {
      if (calledBack) {
        return;
      }
      if (err || ++closedConnections >= this._allConnections.length) {
        calledBack = true;
        cb(err);
        return;
      }
    }.bind(this);
    if (this._allConnections.length === 0) {
      endCB();
      return;
    }
    for (let i = 0; i < this._allConnections.length; i++) {
      connection = this._allConnections.get(i);
      connection._realEnd(endCB);
    }
  }

  query(sql, values, cb) {
    const cmdQuery = BaseConnection$1.createQuery(
      sql,
      values,
      cb,
      this.config.connectionConfig
    );
    if (typeof cmdQuery.namedPlaceholders === 'undefined') {
      cmdQuery.namedPlaceholders =
        this.config.connectionConfig.namedPlaceholders;
    }
    this.getConnection((err, conn) => {
      if (err) {
        if (typeof cmdQuery.onResult === 'function') {
          cmdQuery.onResult(err);
        } else {
          cmdQuery.emit('error', err);
        }
        return;
      }
      try {
        conn.query(cmdQuery).once('end', () => {
          conn.release();
        });
      } catch (e) {
        conn.release();
        throw e;
      }
    });
    return cmdQuery;
  }

  execute(sql, values, cb) {
    // TODO construct execute command first here and pass it to connection.execute
    // so that polymorphic arguments logic is there in one place
    if (typeof values === 'function') {
      cb = values;
      values = [];
    }
    this.getConnection((err, conn) => {
      if (err) {
        return cb(err);
      }
      try {
        conn.execute(sql, values, cb).once('end', () => {
          conn.release();
        });
      } catch (e) {
        conn.release();
        return cb(e);
      }
    });
  }

  _removeConnection(connection) {
    // Remove connection from all connections
    spliceConnection(this._allConnections, connection);
    // Remove connection from free connections
    spliceConnection(this._freeConnections, connection);
    this.releaseConnection(connection);
  }

  _removeIdleTimeoutConnections() {
    if (this._removeIdleTimeoutConnectionsTimer) {
      clearTimeout(this._removeIdleTimeoutConnectionsTimer);
    }

    this._removeIdleTimeoutConnectionsTimer = setTimeout(() => {
      try {
        while (
          this._freeConnections.length > this.config.maxIdle ||
          (this._freeConnections.length > 0 &&
            Date.now() - this._freeConnections.get(0).lastActiveTime >
              this.config.idleTimeout)
        ) {
          if (this.config.connectionConfig.gracefulEnd) {
            this._freeConnections.get(0).end();
          } else {
            this._freeConnections.get(0).destroy();
          }
        }
      } finally {
        this._removeIdleTimeoutConnections();
      }
    }, 1000);
  }

  format(sql, values) {
    return SqlString.format(
      sql,
      values,
      this.config.connectionConfig.stringifyObjects,
      this.config.connectionConfig.timezone
    );
  }

  escape(value) {
    return SqlString.escape(
      value,
      this.config.connectionConfig.stringifyObjects,
      this.config.connectionConfig.timezone
    );
  }

  escapeId(value) {
    return SqlString.escapeId(value, false);
  }
};

var pool$3 = BasePool$2;

const EventEmitter$1 = require$$0$6.EventEmitter;
const makeDoneCb$1 = make_done_cb;
const PromisePoolConnection$1 = pool_connection$1;
const inheritEvents = inherit_events;
const BasePool$1 = pool$3;

class PromisePool extends EventEmitter$1 {
  constructor(pool, thePromise) {
    super();
    this.pool = pool;
    this.Promise = thePromise || Promise;
    inheritEvents(pool, this, ['acquire', 'connection', 'enqueue', 'release']);
  }

  getConnection() {
    const corePool = this.pool;
    return new this.Promise((resolve, reject) => {
      corePool.getConnection((err, coreConnection) => {
        if (err) {
          reject(err);
        } else {
          resolve(new PromisePoolConnection$1(coreConnection, this.Promise));
        }
      });
    });
  }

  releaseConnection(connection) {
    if (connection instanceof PromisePoolConnection$1) connection.release();
  }

  query(sql, args) {
    const corePool = this.pool;
    const localErr = new Error();
    if (typeof args === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb$1(resolve, reject, localErr);
      if (args !== undefined) {
        corePool.query(sql, args, done);
      } else {
        corePool.query(sql, done);
      }
    });
  }

  execute(sql, args) {
    const corePool = this.pool;
    const localErr = new Error();
    if (typeof args === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb$1(resolve, reject, localErr);
      if (args) {
        corePool.execute(sql, args, done);
      } else {
        corePool.execute(sql, done);
      }
    });
  }

  end() {
    const corePool = this.pool;
    const localErr = new Error();
    return new this.Promise((resolve, reject) => {
      corePool.end((err) => {
        if (err) {
          localErr.message = err.message;
          localErr.code = err.code;
          localErr.errno = err.errno;
          localErr.sqlState = err.sqlState;
          localErr.sqlMessage = err.sqlMessage;
          reject(localErr);
        } else {
          resolve();
        }
      });
    });
  }
}

(function (functionsToWrap) {
  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
    const func = functionsToWrap[i];

    if (
      typeof BasePool$1.prototype[func] === 'function' &&
      PromisePool.prototype[func] === undefined
    ) {
      PromisePool.prototype[func] = (function factory(funcName) {
        return function () {
          return BasePool$1.prototype[funcName].apply(this.pool, arguments);
        };
      })(func);
    }
  }
})([
  // synchronous functions
  'escape',
  'escapeId',
  'format',
]);

var pool$2 = PromisePool;

const BasePool = pool$3;

let Pool$2 = class Pool extends BasePool {
  promise(promiseImpl) {
    const PromisePool = pool$2;
    return new PromisePool(this, promiseImpl);
  }
};

var pool$1 = Pool$2;

const ConnectionConfig$1 = connection_config;

let PoolConfig$2 = class PoolConfig {
  constructor(options) {
    if (typeof options === 'string') {
      options = ConnectionConfig$1.parseUrl(options);
    }
    this.connectionConfig = new ConnectionConfig$1(options);
    this.waitForConnections =
      options.waitForConnections === undefined
        ? true
        : Boolean(options.waitForConnections);
    this.connectionLimit = isNaN(options.connectionLimit)
      ? 10
      : Number(options.connectionLimit);
    this.maxIdle = isNaN(options.maxIdle)
      ? this.connectionLimit
      : Number(options.maxIdle);
    this.idleTimeout = isNaN(options.idleTimeout)
      ? 60000
      : Number(options.idleTimeout);
    this.queueLimit = isNaN(options.queueLimit)
      ? 0
      : Number(options.queueLimit);
  }
};

var pool_config = PoolConfig$2;

const BaseConnection = connection$2;

let Connection$2 = class Connection extends BaseConnection {
  promise(promiseImpl) {
    const PromiseConnection = connection$1;
    return new PromiseConnection(this, promiseImpl);
  }
};

var connection = Connection$2;

const process$1 = require$$0$1;

const Pool$1 = pool$1;
const PoolConfig$1 = pool_config;
const Connection$1 = connection;
const EventEmitter = require$$0$6.EventEmitter;

/**
 * Selector
 */
const makeSelector = {
  RR() {
    let index = 0;
    return (clusterIds) => clusterIds[index++ % clusterIds.length];
  },
  RANDOM() {
    return (clusterIds) =>
      clusterIds[Math.floor(Math.random() * clusterIds.length)];
  },
  ORDER() {
    return (clusterIds) => clusterIds[0];
  },
};

const getMonotonicMilliseconds = function () {
  let ms;

  if (typeof process$1.hrtime === 'function') {
    ms = process$1.hrtime();
    ms = ms[0] * 1e3 + ms[1] * 1e-6;
  } else {
    ms = process$1.uptime() * 1000;
  }

  return Math.floor(ms);
};

const patternRegExp = function (pattern) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  const source = pattern
    .replace(/([.+?^=!:${}()|[\]/\\])/g, '\\$1')
    .replace(/\*/g, '.*');

  return new RegExp(`^${source}$`);
};

class PoolNamespace {
  constructor(cluster, pattern, selector) {
    this._cluster = cluster;
    this._pattern = pattern;
    this._selector = makeSelector[selector]();
  }

  getConnection(cb) {
    const clusterNode = this._getClusterNode();
    if (clusterNode === null) {
      let err = new Error('Pool does Not exist.');
      err.code = 'POOL_NOEXIST';

      if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
        err = new Error('Pool does Not have online node.');
        err.code = 'POOL_NONEONLINE';
      }

      return cb(err);
    }
    return this._cluster._getConnection(clusterNode, (err, connection) => {
      if (err) {
        if (
          this._cluster._canRetry &&
          this._cluster._findNodeIds(this._pattern).length !== 0
        ) {
          this._cluster.emit('warn', err);
          return this.getConnection(cb);
        }

        return cb(err);
      }
      return cb(null, connection);
    });
  }

  /**
   * pool cluster query
   * @param {*} sql
   * @param {*} values
   * @param {*} cb
   * @returns query
   */
  query(sql, values, cb) {
    const query = Connection$1.createQuery(sql, values, cb, {});
    this.getConnection((err, conn) => {
      if (err) {
        if (typeof query.onResult === 'function') {
          query.onResult(err);
        } else {
          query.emit('error', err);
        }
        return;
      }
      try {
        conn.query(query).once('end', () => {
          conn.release();
        });
      } catch (e) {
        conn.release();
        throw e;
      }
    });
    return query;
  }

  /**
   * pool cluster execute
   * @param {*} sql
   * @param {*} values
   * @param {*} cb
   */
  execute(sql, values, cb) {
    if (typeof values === 'function') {
      cb = values;
      values = [];
    }
    this.getConnection((err, conn) => {
      if (err) {
        return cb(err);
      }
      try {
        conn.execute(sql, values, cb).once('end', () => {
          conn.release();
        });
      } catch (e) {
        conn.release();
        throw e;
      }
    });
  }

  _getClusterNode() {
    const foundNodeIds = this._cluster._findNodeIds(this._pattern);
    if (foundNodeIds.length === 0) {
      return null;
    }
    const nodeId =
      foundNodeIds.length === 1
        ? foundNodeIds[0]
        : this._selector(foundNodeIds);
    return this._cluster._getNode(nodeId);
  }
}

let PoolCluster$1 = class PoolCluster extends EventEmitter {
  constructor(config) {
    super();
    config = config || {};
    this._canRetry =
      typeof config.canRetry === 'undefined' ? true : config.canRetry;
    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;
    this._restoreNodeTimeout = config.restoreNodeTimeout || 0;
    this._defaultSelector = config.defaultSelector || 'RR';
    this._closed = false;
    this._lastId = 0;
    this._nodes = {};
    this._serviceableNodeIds = [];
    this._namespaces = {};
    this._findCaches = {};
  }

  of(pattern, selector) {
    pattern = pattern || '*';
    selector = selector || this._defaultSelector;
    selector = selector.toUpperCase();
    if (!makeSelector[selector] === 'undefined') {
      selector = this._defaultSelector;
    }
    const key = pattern + selector;
    if (typeof this._namespaces[key] === 'undefined') {
      this._namespaces[key] = new PoolNamespace(this, pattern, selector);
    }
    return this._namespaces[key];
  }

  add(id, config) {
    if (typeof id === 'object') {
      config = id;
      id = `CLUSTER::${++this._lastId}`;
    }
    if (typeof this._nodes[id] === 'undefined') {
      this._nodes[id] = {
        id: id,
        errorCount: 0,
        pool: new Pool$1({ config: new PoolConfig$1(config) }),
        _offlineUntil: 0,
      };
      this._serviceableNodeIds.push(id);
      this._clearFindCaches();
    }
  }

  remove(pattern) {
    const foundNodeIds = this._findNodeIds(pattern, true);

    for (let i = 0; i < foundNodeIds.length; i++) {
      const node = this._getNode(foundNodeIds[i]);

      if (node) {
        this._removeNode(node);
      }
    }
  }

  getConnection(pattern, selector, cb) {
    let namespace;
    if (typeof pattern === 'function') {
      cb = pattern;
      namespace = this.of();
    } else {
      if (typeof selector === 'function') {
        cb = selector;
        selector = this._defaultSelector;
      }
      namespace = this.of(pattern, selector);
    }
    namespace.getConnection(cb);
  }

  end(callback) {
    const cb =
      callback !== undefined
        ? callback
        : (err) => {
            if (err) {
              throw err;
            }
          };
    if (this._closed) {
      process$1.nextTick(cb);
      return;
    }

    this._closed = true;

    let calledBack = false;
    let waitingClose = 0;
    const onEnd = (err) => {
      if (!calledBack && (err || --waitingClose <= 0)) {
        calledBack = true;
        return cb(err);
      }
    };

    for (const id in this._nodes) {
      waitingClose++;
      this._nodes[id].pool.end(onEnd);
    }

    if (waitingClose === 0) {
      process$1.nextTick(onEnd);
    }
  }

  _findNodeIds(pattern, includeOffline) {
    let currentTime = 0;
    let foundNodeIds = this._findCaches[pattern];

    if (foundNodeIds === undefined) {
      const expression = patternRegExp(pattern);

      foundNodeIds = this._serviceableNodeIds.filter((id) =>
        id.match(expression)
      );
    }

    this._findCaches[pattern] = foundNodeIds;

    if (includeOffline) {
      return foundNodeIds;
    }

    return foundNodeIds.filter((nodeId) => {
      const node = this._getNode(nodeId);

      if (!node._offlineUntil) {
        return true;
      }

      if (!currentTime) {
        currentTime = getMonotonicMilliseconds();
      }

      return node._offlineUntil <= currentTime;
    });
  }

  _getNode(id) {
    return this._nodes[id] || null;
  }

  _increaseErrorCount(node) {
    const errorCount = ++node.errorCount;

    if (this._removeNodeErrorCount > errorCount) {
      return;
    }

    if (this._restoreNodeTimeout > 0) {
      node._offlineUntil =
        getMonotonicMilliseconds() + this._restoreNodeTimeout;
      this.emit('offline', node.id);
      return;
    }

    this._removeNode(node);
    this.emit('remove', node.id);
  }

  _decreaseErrorCount(node) {
    let errorCount = node.errorCount;

    if (errorCount > this._removeNodeErrorCount) {
      errorCount = this._removeNodeErrorCount;
    }

    if (errorCount < 1) {
      errorCount = 1;
    }

    node.errorCount = errorCount - 1;

    if (node._offlineUntil) {
      node._offlineUntil = 0;
      this.emit('online', node.id);
    }
  }

  _getConnection(node, cb) {
    node.pool.getConnection((err, connection) => {
      if (err) {
        this._increaseErrorCount(node);
        return cb(err);
      }
      this._decreaseErrorCount(node);

      connection._clusterId = node.id;
      return cb(null, connection);
    });
  }

  _removeNode(node) {
    const index = this._serviceableNodeIds.indexOf(node.id);
    if (index !== -1) {
      this._serviceableNodeIds.splice(index, 1);
      delete this._nodes[node.id];
      this._clearFindCaches();
      node.pool.end();
    }
  }

  _clearFindCaches() {
    this._findCaches = {};
  }
};

var pool_cluster$1 = PoolCluster$1;

const Connection = connection;
const ConnectionConfig = connection_config;

function createConnection(opts) {
  return new Connection({ config: new ConnectionConfig(opts) });
}

var create_connection = createConnection;

const Pool = pool$1;
const PoolConfig = pool_config;

function createPool(config) {
  return new Pool({ config: new PoolConfig(config) });
}

var create_pool = createPool;

const PoolCluster = pool_cluster$1;

function createPoolCluster(config) {
  return new PoolCluster(config);
}

var create_pool_cluster = createPoolCluster;

const PromisePoolConnection = pool_connection$1;
const makeDoneCb = make_done_cb;

class PromisePoolNamespace {
  constructor(poolNamespace, thePromise) {
    this.poolNamespace = poolNamespace;
    this.Promise = thePromise || Promise;
  }

  getConnection() {
    const corePoolNamespace = this.poolNamespace;
    return new this.Promise((resolve, reject) => {
      corePoolNamespace.getConnection((err, coreConnection) => {
        if (err) {
          reject(err);
        } else {
          resolve(new PromisePoolConnection(coreConnection, this.Promise));
        }
      });
    });
  }

  query(sql, values) {
    const corePoolNamespace = this.poolNamespace;
    const localErr = new Error();
    if (typeof values === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      corePoolNamespace.query(sql, values, done);
    });
  }

  execute(sql, values) {
    const corePoolNamespace = this.poolNamespace;
    const localErr = new Error();
    if (typeof values === 'function') {
      throw new Error(
        'Callback function is not available with promise clients.'
      );
    }
    return new this.Promise((resolve, reject) => {
      const done = makeDoneCb(resolve, reject, localErr);
      corePoolNamespace.execute(sql, values, done);
    });
  }
}

var pool_cluster = PromisePoolNamespace;

(function (exports$1) {

	const SqlString = sqlstring;
	const EventEmitter = require$$0$6.EventEmitter;
	const parserCache = parser_cache;
	const PoolCluster = pool_cluster$1;
	const createConnection = create_connection;
	const createPool = create_pool;
	const createPoolCluster = create_pool_cluster;
	const PromiseConnection = connection$1;
	const PromisePool = pool$2;
	const makeDoneCb = make_done_cb;
	const PromisePoolConnection = pool_connection$1;
	const inheritEvents = inherit_events;
	const PromisePoolNamespace = pool_cluster;

	function createConnectionPromise(opts) {
	  const coreConnection = createConnection(opts);
	  const createConnectionErr = new Error();
	  const thePromise = opts.Promise || Promise;
	  if (!thePromise) {
	    throw new Error(
	      'no Promise implementation available.' +
	        'Use promise-enabled node version or pass userland Promise' +
	        " implementation as parameter, for example: { Promise: require('bluebird') }"
	    );
	  }
	  return new thePromise((resolve, reject) => {
	    coreConnection.once('connect', () => {
	      resolve(new PromiseConnection(coreConnection, thePromise));
	    });
	    coreConnection.once('error', (err) => {
	      createConnectionErr.message = err.message;
	      createConnectionErr.code = err.code;
	      createConnectionErr.errno = err.errno;
	      createConnectionErr.sqlState = err.sqlState;
	      reject(createConnectionErr);
	    });
	  });
	}

	// note: the callback of "changeUser" is not called on success
	// hence there is no possibility to call "resolve"

	function createPromisePool(opts) {
	  const corePool = createPool(opts);
	  const thePromise = opts.Promise || Promise;
	  if (!thePromise) {
	    throw new Error(
	      'no Promise implementation available.' +
	        'Use promise-enabled node version or pass userland Promise' +
	        " implementation as parameter, for example: { Promise: require('bluebird') }"
	    );
	  }

	  return new PromisePool(corePool, thePromise);
	}

	class PromisePoolCluster extends EventEmitter {
	  constructor(poolCluster, thePromise) {
	    super();
	    this.poolCluster = poolCluster;
	    this.Promise = thePromise || Promise;
	    inheritEvents(poolCluster, this, ['warn', 'remove', 'online', 'offline']);
	  }

	  getConnection(pattern, selector) {
	    const corePoolCluster = this.poolCluster;
	    return new this.Promise((resolve, reject) => {
	      corePoolCluster.getConnection(
	        pattern,
	        selector,
	        (err, coreConnection) => {
	          if (err) {
	            reject(err);
	          } else {
	            resolve(new PromisePoolConnection(coreConnection, this.Promise));
	          }
	        }
	      );
	    });
	  }

	  query(sql, args) {
	    const corePoolCluster = this.poolCluster;
	    const localErr = new Error();
	    if (typeof args === 'function') {
	      throw new Error(
	        'Callback function is not available with promise clients.'
	      );
	    }
	    return new this.Promise((resolve, reject) => {
	      const done = makeDoneCb(resolve, reject, localErr);
	      corePoolCluster.query(sql, args, done);
	    });
	  }

	  execute(sql, args) {
	    const corePoolCluster = this.poolCluster;
	    const localErr = new Error();
	    if (typeof args === 'function') {
	      throw new Error(
	        'Callback function is not available with promise clients.'
	      );
	    }
	    return new this.Promise((resolve, reject) => {
	      const done = makeDoneCb(resolve, reject, localErr);
	      corePoolCluster.execute(sql, args, done);
	    });
	  }

	  of(pattern, selector) {
	    return new PromisePoolNamespace(
	      this.poolCluster.of(pattern, selector),
	      this.Promise
	    );
	  }

	  end() {
	    const corePoolCluster = this.poolCluster;
	    const localErr = new Error();
	    return new this.Promise((resolve, reject) => {
	      corePoolCluster.end((err) => {
	        if (err) {
	          localErr.message = err.message;
	          localErr.code = err.code;
	          localErr.errno = err.errno;
	          localErr.sqlState = err.sqlState;
	          localErr.sqlMessage = err.sqlMessage;
	          reject(localErr);
	        } else {
	          resolve();
	        }
	      });
	    });
	  }
	}

	/**
	 * proxy poolCluster synchronous functions
	 */
	(function (functionsToWrap) {
	  for (let i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
	    const func = functionsToWrap[i];

	    if (
	      typeof PoolCluster.prototype[func] === 'function' &&
	      PromisePoolCluster.prototype[func] === undefined
	    ) {
	      PromisePoolCluster.prototype[func] = (function factory(funcName) {
	        return function () {
	          return PoolCluster.prototype[funcName].apply(
	            this.poolCluster,
	            arguments
	          );
	        };
	      })(func);
	    }
	  }
	})(['add', 'remove']);

	function createPromisePoolCluster(opts) {
	  const corePoolCluster = createPoolCluster(opts);
	  const thePromise = (opts && opts.Promise) || Promise;
	  if (!thePromise) {
	    throw new Error(
	      'no Promise implementation available.' +
	        'Use promise-enabled node version or pass userland Promise' +
	        " implementation as parameter, for example: { Promise: require('bluebird') }"
	    );
	  }
	  return new PromisePoolCluster(corePoolCluster, thePromise);
	}

	exports$1.createConnection = createConnectionPromise;
	exports$1.createPool = createPromisePool;
	exports$1.createPoolCluster = createPromisePoolCluster;
	exports$1.escape = SqlString.escape;
	exports$1.escapeId = SqlString.escapeId;
	exports$1.format = SqlString.format;
	exports$1.raw = SqlString.raw;
	exports$1.PromisePool = PromisePool;
	exports$1.PromiseConnection = PromiseConnection;
	exports$1.PromisePoolConnection = PromisePoolConnection;

	exports$1.__defineGetter__('Types', () => /*@__PURE__*/ requireTypes());

	exports$1.__defineGetter__('Charsets', () =>
	  /*@__PURE__*/ requireCharsets()
	);

	exports$1.__defineGetter__('CharsetToEncoding', () =>
	  /*@__PURE__*/ requireCharset_encodings()
	);

	exports$1.setMaxParserCache = function (max) {
	  parserCache.setMaxCache(max);
	};

	exports$1.clearParserCache = function () {
	  parserCache.clearCache();
	}; 
} (promise));

const mysql = /*@__PURE__*/getDefaultExportFromCjs(promise);

let pool = null;
function getDatabase() {
  const config = useRuntimeConfig$1();
  if (!pool) {
    const connectionConfig = {
      database: config.dbName,
      user: config.dbUser,
      password: config.dbPassword,
      waitForConnections: true,
      connectionLimit: parseInt(process.env.DB_CONNECTION_LIMIT || "50"),
      //  Increased from 10 to 50 for better concurrency
      queueLimit: 0,
      acquireTimeout: 6e4,
      //  60 seconds timeout
      timeout: 6e4,
      //  60 seconds query timeout
      timezone: "+07:00",
      // Asia/Bangkok
      dateStrings: false,
      enableKeepAlive: true,
      //  Keep connections alive
      keepAliveInitialDelay: 0
    };
    if (process.env.DB_SOCKET) {
      connectionConfig.socketPath = process.env.DB_SOCKET;
      console.log("[Database] \u2705 Using socket connection:", process.env.DB_SOCKET);
    } else {
      connectionConfig.host = config.dbHost || "localhost";
      connectionConfig.port = config.dbPort || 3307;
      console.log("[Database] \u2705 Using TCP connection:", `${connectionConfig.host}:${connectionConfig.port}`);
    }
    pool = mysql.createPool(connectionConfig);
  }
  return pool;
}
async function query(sql, params) {
  try {
    const db = getDatabase();
    const [rows] = await db.execute(sql, params || []);
    return rows;
  } catch (error) {
    console.error("[Database] Query error:", {
      sql,
      params,
      message: error.message,
      code: error.code,
      sqlState: error.sqlState,
      sqlMessage: error.sqlMessage
    });
    throw error;
  }
}
async function queryOne(sql, params) {
  const results = await query(sql, params);
  return results[0] || null;
}
async function execute(sql, params) {
  const db = getDatabase();
  const [result] = await db.execute(sql, params);
  return result;
}

const db = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  execute: execute,
  getDatabase: getDatabase,
  query: query,
  queryOne: queryOne
}, Symbol.toStringTag, { value: 'Module' }));

var UserStatus = /* @__PURE__ */ ((UserStatus2) => {
  UserStatus2["ACTIVE"] = "active";
  UserStatus2["INACTIVE"] = "inactive";
  UserStatus2["SUSPENDED"] = "suspended";
  return UserStatus2;
})(UserStatus || {});
var UserRole = /* @__PURE__ */ ((UserRole2) => {
  UserRole2["STUDENT"] = "student";
  UserRole2["TUTOR"] = "tutor";
  UserRole2["PARENT"] = "parent";
  UserRole2["BRANCH_ADMIN"] = "branch_admin";
  UserRole2["ADMIN"] = "admin";
  UserRole2["OWNER"] = "owner";
  UserRole2["SYSTEM_ADMIN"] = "system_admin";
  return UserRole2;
})(UserRole || {});
const ROLE_PRIORITY = {
  ["system_admin" /* SYSTEM_ADMIN */]: 1,
  ["owner" /* OWNER */]: 2,
  ["admin" /* ADMIN */]: 3,
  ["branch_admin" /* BRANCH_ADMIN */]: 4,
  ["tutor" /* TUTOR */]: 5,
  ["parent" /* PARENT */]: 6,
  ["student" /* STUDENT */]: 7
};
function getHighestPriorityRole(roles) {
  if (!roles || roles.length === 0) return null;
  return roles.reduce((highest, role) => {
    const currentPriority = ROLE_PRIORITY[role] || 999;
    const highestPriority = ROLE_PRIORITY[highest] || 999;
    return currentPriority < highestPriority ? role : highest;
  });
}
function hasRoleOrHigher(userRoles, minRole) {
  if (!userRoles || userRoles.length === 0) return false;
  const minPriority = ROLE_PRIORITY[minRole] || 999;
  return userRoles.some((role) => {
    const rolePriority = ROLE_PRIORITY[role] || 999;
    return rolePriority <= minPriority;
  });
}

const user_types = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  ROLE_PRIORITY: ROLE_PRIORITY,
  UserRole: UserRole,
  UserStatus: UserStatus,
  getHighestPriorityRole: getHighestPriorityRole,
  hasRoleOrHigher: hasRoleOrHigher
}, Symbol.toStringTag, { value: 'Module' }));

async function findUserByEmail(email) {
  return queryOne(
    "SELECT * FROM users WHERE email = ?",
    [email]
  );
}
async function findUserByIdentifier(identifier) {
  return queryOne(
    "SELECT * FROM users WHERE username = ? OR email = ?",
    [identifier, identifier]
  );
}
async function findUserById(id) {
  return queryOne(
    "SELECT * FROM users WHERE id = ?",
    [id]
  );
}
async function getUserRoles(userId) {
  const roles = await query(
    `SELECT r.name 
     FROM user_roles ur
     JOIN roles r ON ur.role_id = r.id
     WHERE ur.user_id = ?`,
    [userId]
  );
  return roles.map((r) => r.name);
}
async function getUserWithRoles(userId) {
  const user = await findUserById(userId);
  if (!user) return null;
  const roles = await getUserRoles(userId);
  const { password_hash, ...publicUser } = user;
  return { ...publicUser, roles };
}
async function createUser(data, defaultRole = UserRole.STUDENT) {
  const passwordHash = await bcrypt.hash(data.password, 12);
  const result = await execute(
    `INSERT INTO users (username, email, password_hash, first_name, last_name, phone, status)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [
      data.username,
      data.email || null,
      passwordHash,
      data.first_name,
      data.last_name,
      data.phone || null,
      UserStatus.ACTIVE
    ]
  );
  const role = await queryOne(
    "SELECT id FROM roles WHERE name = ?",
    [defaultRole]
  );
  if (role) {
    await execute(
      "INSERT INTO user_roles (user_id, role_id) VALUES (?, ?)",
      [result.insertId, role.id]
    );
  }
  const user = await findUserById(result.insertId);
  if (!user) throw createError$2({ statusCode: 500, message: "Failed to create user" });
  return user;
}
async function verifyPassword(password, hash) {
  return bcrypt.compare(password, hash);
}
async function login(credentials) {
  console.log("[Auth Service] Finding user by identifier:", credentials.username);
  const user = await findUserByIdentifier(credentials.username);
  if (!user) {
    console.log("[Auth Service] User not found:", credentials.username);
    throw createError$2({
      statusCode: 401,
      message: "\u0E2D\u0E35\u0E40\u0E21\u0E25\u0E4C\u0E2B\u0E23\u0E37\u0E2D\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07"
    });
  }
  console.log("[Auth Service] User found:", user.id, user.username, user.status);
  if (user.status !== UserStatus.ACTIVE) {
    console.log("[Auth Service] Account is not active:", user.status);
    throw createError$2({
      statusCode: 403,
      message: "Account is not active"
    });
  }
  console.log("[Auth Service] Getting password hash for user:", user.id);
  const userWithPassword = await queryOne(
    "SELECT password_hash FROM users WHERE id = ?",
    [user.id]
  );
  if (!userWithPassword) {
    console.log("[Auth Service] Password hash not found for user:", user.id);
    throw createError$2({
      statusCode: 401,
      message: "\u0E2D\u0E35\u0E40\u0E21\u0E25\u0E4C\u0E2B\u0E23\u0E37\u0E2D\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07"
    });
  }
  console.log("[Auth Service] Verifying password...");
  const isValid = await verifyPassword(credentials.password, userWithPassword.password_hash);
  if (!isValid) {
    console.log("[Auth Service] Password verification failed");
    throw createError$2({
      statusCode: 401,
      message: "\u0E2D\u0E35\u0E40\u0E21\u0E25\u0E4C\u0E2B\u0E23\u0E37\u0E2D\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07"
    });
  }
  console.log("[Auth Service] Password verified successfully");
  const userWithRoles = await getUserWithRoles(user.id);
  if (!userWithRoles) {
    throw createError$2({
      statusCode: 500,
      message: "Failed to get user roles"
    });
  }
  const accessToken = generateAccessToken(userWithRoles);
  const refreshToken = generateRefreshToken(user.id);
  const expiresAt = /* @__PURE__ */ new Date();
  expiresAt.setDate(expiresAt.getDate() + 7);
  await execute(
    `INSERT INTO refresh_tokens (user_id, token, expires_at)
     VALUES (?, ?, ?)`,
    [user.id, refreshToken, expiresAt]
  );
  return {
    user: userWithRoles,
    accessToken,
    refreshToken
  };
}

const auth_service = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  createUser: createUser,
  findUserByEmail: findUserByEmail,
  findUserById: findUserById,
  findUserByIdentifier: findUserByIdentifier,
  getUserRoles: getUserRoles,
  getUserWithRoles: getUserWithRoles,
  login: login,
  verifyPassword: verifyPassword
}, Symbol.toStringTag, { value: 'Module' }));

async function getUserChatRooms(userId) {
  const rooms = await query(`
    SELECT 
      cr.*,
      c.title as course_title,
      c.code as course_code,
      s.first_name as student_first_name,
      s.last_name as student_last_name,
      s.avatar_url as student_avatar_url,
      t.first_name as tutor_first_name,
      t.last_name as tutor_last_name,
      t.avatar_url as tutor_avatar_url,
      (
        SELECT COUNT(*) 
        FROM chat_messages cm 
        WHERE cm.room_id = cr.id 
        AND cm.sender_id != ? 
        AND cm.is_read = FALSE
      ) as unread_count
    FROM chat_rooms cr
    INNER JOIN courses c ON cr.course_id = c.id
    INNER JOIN users s ON cr.student_id = s.id
    INNER JOIN users t ON cr.tutor_id = t.id
    WHERE (cr.student_id = ? OR cr.tutor_id = ?)
    AND cr.status = 'active'
    ORDER BY cr.last_message_at DESC, cr.created_at DESC
  `, [userId, userId, userId]);
  return rooms.map((room) => ({
    id: room.id,
    course_id: room.course_id,
    student_id: room.student_id,
    tutor_id: room.tutor_id,
    status: room.status,
    last_message_at: room.last_message_at,
    created_at: room.created_at,
    updated_at: room.updated_at,
    course: {
      id: room.course_id,
      title: room.course_title,
      code: room.course_code
    },
    student: {
      id: room.student_id,
      first_name: room.student_first_name,
      last_name: room.student_last_name,
      avatar_url: room.student_avatar_url
    },
    tutor: {
      id: room.tutor_id,
      first_name: room.tutor_first_name,
      last_name: room.tutor_last_name,
      avatar_url: room.tutor_avatar_url
    },
    unread_count: parseInt(room.unread_count) || 0
  }));
}
async function getChatRoom(roomId) {
  const rooms = await query(`
    SELECT 
      cr.*,
      c.title as course_title,
      c.code as course_code,
      s.first_name as student_first_name,
      s.last_name as student_last_name,
      s.avatar_url as student_avatar_url,
      t.first_name as tutor_first_name,
      t.last_name as tutor_last_name,
      t.avatar_url as tutor_avatar_url
    FROM chat_rooms cr
    INNER JOIN courses c ON cr.course_id = c.id
    INNER JOIN users s ON cr.student_id = s.id
    INNER JOIN users t ON cr.tutor_id = t.id
    WHERE cr.id = ?
  `, [roomId]);
  if (!rooms || rooms.length === 0) return null;
  const room = rooms[0];
  return {
    id: room.id,
    course_id: room.course_id,
    student_id: room.student_id,
    tutor_id: room.tutor_id,
    status: room.status,
    last_message_at: room.last_message_at,
    created_at: room.created_at,
    updated_at: room.updated_at,
    course: {
      id: room.course_id,
      title: room.course_title,
      code: room.course_code
    },
    student: {
      id: room.student_id,
      first_name: room.student_first_name,
      last_name: room.student_last_name,
      avatar_url: room.student_avatar_url
    },
    tutor: {
      id: room.tutor_id,
      first_name: room.tutor_first_name,
      last_name: room.tutor_last_name,
      avatar_url: room.tutor_avatar_url
    }
  };
}
async function verifyRoomAccess(userId, roomId) {
  const rooms = await query(
    'SELECT student_id, tutor_id FROM chat_rooms WHERE id = ? AND status = "active"',
    [roomId]
  );
  if (!rooms || rooms.length === 0) return false;
  const room = rooms[0];
  return room.student_id === userId || room.tutor_id === userId;
}
async function createChatRoom(studentId, data) {
  const existingRooms = await query(
    'SELECT id FROM chat_rooms WHERE student_id = ? AND tutor_id = ? AND course_id = ? AND status = "active"',
    [studentId, data.tutor_id, data.course_id]
  );
  if (existingRooms && existingRooms.length > 0) {
    const room2 = await getChatRoom(existingRooms[0].id);
    if (room2) return room2;
    throw new Error("Failed to retrieve existing room");
  }
  const enrollments = await query(
    'SELECT id FROM enrollments WHERE student_id = ? AND course_id = ? AND status IN ("active", "completed")',
    [studentId, data.course_id]
  );
  if (!enrollments || enrollments.length === 0) {
    throw new Error("Student is not enrolled in this course");
  }
  const tutorCourses = await query(`
    SELECT tc.id 
    FROM tutor_courses tc
    INNER JOIN tutors t ON tc.tutor_id = t.id
    WHERE t.user_id = ? AND tc.course_id = ?
  `, [data.tutor_id, data.course_id]);
  if (!tutorCourses || tutorCourses.length === 0) {
    throw new Error("Tutor does not teach this course");
  }
  const result = await execute(
    'INSERT INTO chat_rooms (course_id, student_id, tutor_id, status) VALUES (?, ?, ?, "active")',
    [data.course_id, studentId, data.tutor_id]
  );
  const room = await getChatRoom(result.insertId);
  if (!room) throw new Error("Failed to create room");
  await execute(
    'INSERT INTO chat_room_participants (room_id, user_id, role) VALUES (?, ?, "student"), (?, ?, "tutor")',
    [room.id, studentId, room.id, data.tutor_id]
  );
  if (data.initial_message) {
    await saveMessage({
      room_id: room.id,
      sender_id: studentId,
      content: data.initial_message,
      message_type: "text"
    });
  }
  return room;
}
async function saveMessage(data) {
  const result = await execute(
    `INSERT INTO chat_messages 
     (room_id, sender_id, message_type, content, file_url, file_name, file_size, file_type, reply_to_id, is_read)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, FALSE)`,
    [
      data.room_id,
      data.sender_id,
      data.message_type,
      data.content,
      data.file_url || null,
      data.file_name || null,
      data.file_size || null,
      data.file_type || null,
      data.reply_to_id || null
    ]
  );
  await execute(
    "UPDATE chat_rooms SET last_message_at = NOW() WHERE id = ?",
    [data.room_id]
  );
  const messages = await query(`
    SELECT cm.*,
           u.first_name as sender_first_name,
           u.last_name as sender_last_name,
           u.avatar_url as sender_avatar_url,
           reply_to.id as reply_to_id_exists,
           reply_to.content as reply_to_content,
           reply_to.file_name as reply_to_file_name,
           reply_to.message_type as reply_to_message_type,
           reply_user.first_name as reply_to_sender_first_name,
           reply_user.last_name as reply_to_sender_last_name
    FROM chat_messages cm
    INNER JOIN users u ON cm.sender_id = u.id
    LEFT JOIN chat_messages reply_to ON cm.reply_to_id = reply_to.id
    LEFT JOIN users reply_user ON reply_to.sender_id = reply_user.id
    WHERE cm.id = ?
  `, [result.insertId]);
  if (!messages || messages.length === 0) throw new Error("Failed to retrieve message");
  const message = messages[0];
  const formattedMessage = {
    id: message.id,
    room_id: message.room_id,
    sender_id: message.sender_id,
    message_type: message.message_type,
    content: message.content,
    file_name: message.file_name,
    file_size: message.file_size,
    file_type: message.file_type,
    file_url: message.file_url,
    is_read: message.is_read,
    read_at: message.read_at,
    created_at: message.created_at,
    reply_to_id: message.reply_to_id || null,
    is_pinned: message.is_pinned || false,
    sender: {
      id: message.sender_id,
      first_name: message.sender_first_name,
      last_name: message.sender_last_name,
      avatar_url: message.sender_avatar_url
    }
  };
  if (message.reply_to_id_exists) {
    formattedMessage.reply_to = {
      id: message.reply_to_id_exists,
      room_id: message.room_id,
      sender_id: 0,
      // Will be filled if needed
      message_type: message.reply_to_message_type,
      content: message.reply_to_content,
      file_name: message.reply_to_file_name,
      is_read: false,
      read_at: null,
      created_at: "",
      sender: {
        id: 0,
        first_name: message.reply_to_sender_first_name || "",
        last_name: message.reply_to_sender_last_name || ""
      }
    };
  }
  return formattedMessage;
}
async function getChatMessages(roomId, limit = 50, offset = 0) {
  try {
    const limitValue = Math.max(1, Math.min(limit, 100));
    const offsetValue = Math.max(0, offset);
    const messages = await query(`
      SELECT cm.*,
             u.first_name as sender_first_name,
             u.last_name as sender_last_name,
             u.avatar_url as sender_avatar_url,
             reply_to.id as reply_to_id_exists,
             reply_to.content as reply_to_content,
             reply_to.file_name as reply_to_file_name,
             reply_to.message_type as reply_to_message_type,
             reply_user.first_name as reply_to_sender_first_name,
             reply_user.last_name as reply_to_sender_last_name
      FROM chat_messages cm
      INNER JOIN users u ON cm.sender_id = u.id
      LEFT JOIN chat_messages reply_to ON cm.reply_to_id = reply_to.id
      LEFT JOIN users reply_user ON reply_to.sender_id = reply_user.id
      WHERE cm.room_id = ?
      ORDER BY cm.created_at DESC
      LIMIT ${limitValue} OFFSET ${offsetValue}
    `, [roomId]);
    if (!messages || messages.length === 0) {
      return [];
    }
    return messages.reverse().map((msg) => {
      const formatted = {
        id: msg.id,
        room_id: msg.room_id,
        sender_id: msg.sender_id,
        message_type: msg.message_type,
        content: msg.content,
        file_name: msg.file_name,
        file_size: msg.file_size,
        file_type: msg.file_type,
        file_url: msg.file_url,
        is_read: msg.is_read === 1 || msg.is_read === true,
        read_at: msg.read_at,
        created_at: msg.created_at,
        reply_to_id: msg.reply_to_id || null,
        is_pinned: msg.is_pinned === 1 || msg.is_pinned === true || false,
        sender: {
          id: msg.sender_id,
          first_name: msg.sender_first_name || "",
          last_name: msg.sender_last_name || "",
          avatar_url: msg.sender_avatar_url
        }
      };
      if (msg.reply_to_id_exists) {
        formatted.reply_to = {
          id: msg.reply_to_id_exists,
          room_id: msg.room_id,
          sender_id: 0,
          message_type: msg.reply_to_message_type,
          content: msg.reply_to_content,
          file_name: msg.reply_to_file_name,
          is_read: false,
          read_at: null,
          created_at: "",
          sender: {
            id: 0,
            first_name: msg.reply_to_sender_first_name || "",
            last_name: msg.reply_to_sender_last_name || ""
          }
        };
      }
      return formatted;
    });
  } catch (error) {
    console.error("[Chat Service] Error in getChatMessages:", error);
    console.error("[Chat Service] Error details:", {
      message: error.message,
      code: error.code,
      sqlState: error.sqlState,
      sqlMessage: error.sqlMessage,
      roomId,
      limit,
      offset
    });
    throw error;
  }
}
async function markMessagesAsRead(roomId, userId, messageId) {
  if (messageId) {
    await execute(
      "UPDATE chat_messages SET is_read = TRUE, read_at = NOW() WHERE id = ? AND room_id = ? AND sender_id != ?",
      [messageId, roomId, userId]
    );
  } else {
    await execute(
      "UPDATE chat_messages SET is_read = TRUE, read_at = NOW() WHERE room_id = ? AND sender_id != ? AND is_read = FALSE",
      [roomId, userId]
    );
  }
  await execute(
    "UPDATE chat_room_participants SET last_read_at = NOW() WHERE room_id = ? AND user_id = ?",
    [roomId, userId]
  );
}
async function getTutorCourses(userId) {
  const courses = await query(`
    SELECT DISTINCT tc.course_id
    FROM tutor_courses tc
    INNER JOIN tutors t ON tc.tutor_id = t.id
    WHERE t.user_id = ?
  `, [userId]);
  return courses.map((c) => c.course_id);
}
async function getStudentCourses(userId) {
  const courses = await query(`
    SELECT DISTINCT course_id
    FROM enrollments
    WHERE student_id = ? 
    AND status IN ('active', 'completed')
  `, [userId]);
  return courses.map((c) => c.course_id);
}
async function getAllChatRooms(limit = 50, offset = 0, filters) {
  var _a;
  let whereConditions = [];
  let params = [];
  if (filters == null ? void 0 : filters.status) {
    whereConditions.push("cr.status = ?");
    params.push(filters.status);
  } else {
    whereConditions.push('cr.status = "active"');
  }
  if (filters == null ? void 0 : filters.courseId) {
    whereConditions.push("cr.course_id = ?");
    params.push(filters.courseId);
  }
  if (filters == null ? void 0 : filters.studentId) {
    whereConditions.push("cr.student_id = ?");
    params.push(filters.studentId);
  }
  if (filters == null ? void 0 : filters.tutorId) {
    whereConditions.push("cr.tutor_id = ?");
    params.push(filters.tutorId);
  }
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : 'WHERE cr.status = "active"';
  const totalResults = await query(
    `SELECT COUNT(*) as count FROM chat_rooms cr ${whereClause}`,
    params
  );
  const total = ((_a = totalResults[0]) == null ? void 0 : _a.count) || 0;
  const limitValue = Math.max(1, Math.min(limit, 100));
  const offsetValue = Math.max(0, offset);
  const rooms = await query(`
    SELECT 
      cr.*,
      c.title as course_title,
      c.code as course_code,
      s.first_name as student_first_name,
      s.last_name as student_last_name,
      s.avatar_url as student_avatar_url,
      t.first_name as tutor_first_name,
      t.last_name as tutor_last_name,
      t.avatar_url as tutor_avatar_url
    FROM chat_rooms cr
    INNER JOIN courses c ON cr.course_id = c.id
    INNER JOIN users s ON cr.student_id = s.id
    INNER JOIN users t ON cr.tutor_id = t.id
    ${whereClause}
    ORDER BY cr.last_message_at DESC, cr.created_at DESC
    LIMIT ${limitValue} OFFSET ${offsetValue}
  `, params);
  return {
    rooms: rooms.map((room) => ({
      id: room.id,
      course_id: room.course_id,
      student_id: room.student_id,
      tutor_id: room.tutor_id,
      status: room.status,
      last_message_at: room.last_message_at,
      created_at: room.created_at,
      updated_at: room.updated_at,
      course: {
        id: room.course_id,
        title: room.course_title,
        code: room.course_code
      },
      student: {
        id: room.student_id,
        first_name: room.student_first_name,
        last_name: room.student_last_name,
        avatar_url: room.student_avatar_url
      },
      tutor: {
        id: room.tutor_id,
        first_name: room.tutor_first_name,
        last_name: room.tutor_last_name,
        avatar_url: room.tutor_avatar_url
      }
    })),
    total
  };
}

const _jLNx1CnX5kcf2dl0xeVeazMHB59Nl5Q8ozwYoiMDEY = defineNitroPlugin((nitroApp) => {
  const engine = new engine_io.Server();
  const io = new Server();
  io.bind(engine);
  io.use(async (socket, next) => {
    var _a;
    try {
      const token = socket.handshake.auth.token || ((_a = socket.handshake.headers.authorization) == null ? void 0 : _a.replace("Bearer ", "")) || socket.handshake.query.token;
      if (!token) {
        return next(new Error("Authentication error: No token provided"));
      }
      const payload = verifyAccessToken(token);
      const user = await getUserWithRoles(payload.userId);
      if (!user) {
        return next(new Error("Authentication error: User not found"));
      }
      socket.data.user = user;
      socket.data.userId = user.id;
      next();
    } catch (error) {
      console.error("[Socket.IO] Authentication error:", error);
      next(new Error("Authentication error: Invalid token"));
    }
  });
  io.on("connection", async (socket) => {
    const user = socket.data.user;
    const userId = user.id;
    console.log(`[Socket.IO] \u2705 User connected: ${userId} (${user.first_name} ${user.last_name})`);
    console.log(`[Socket.IO] \u{1F50C} Socket ID: ${socket.id}`);
    socket.join(`user:${userId}`);
    console.log(`[Socket.IO] \u{1F464} User ${userId} joined personal room: user:${userId}`);
    try {
      const rooms = await getUserChatRooms(userId);
      for (const room of rooms) {
        socket.join(`room:${room.id}`);
        console.log(`[Socket.IO] \u{1F3E0} User ${userId} joined room ${room.id} (course ${room.course_id}, student ${room.student_id}, tutor ${room.tutor_id})`);
      }
      console.log(`[Socket.IO] \u2705 User ${userId} joined ${rooms.length} chat room(s)`);
      const userRoles = await getUserRoles(userId);
      const isTutor = userRoles.includes("tutor");
      const isStudent = userRoles.includes("student");
      if (isTutor) {
        try {
          const tutorCourses = await getTutorCourses(userId);
          for (const courseId of tutorCourses) {
            socket.join(`course:${courseId}`);
            console.log(`[Socket.IO] \u{1F4DA} Tutor ${userId} joined course room: course:${courseId}`);
          }
          console.log(`[Socket.IO] \u2705 Tutor ${userId} joined ${tutorCourses.length} course room(s)`);
        } catch (error) {
          console.error(`[Socket.IO] Error loading tutor courses for user ${userId}:`, error);
        }
      }
      if (isStudent) {
        try {
          const studentCourses = await getStudentCourses(userId);
          for (const courseId of studentCourses) {
            socket.join(`course:${courseId}`);
            console.log(`[Socket.IO] \u{1F4DA} Student ${userId} joined course room: course:${courseId}`);
          }
          console.log(`[Socket.IO] \u2705 Student ${userId} joined ${studentCourses.length} course room(s)`);
        } catch (error) {
          console.error(`[Socket.IO] Error loading student courses for user ${userId}:`, error);
        }
      }
      const socketRooms = Array.from(socket.rooms);
      console.log(`[Socket.IO] \u{1F4CB} User ${userId} is in ${socketRooms.length} room(s):`, socketRooms);
    } catch (error) {
      console.error(`[Socket.IO] Error loading rooms for user ${userId}:`, error);
    }
    socket.on("join_room", async (data) => {
      try {
        console.log(`[Socket.IO] \u{1F4E5} join_room event received from user ${userId} for room ${data.roomId}`);
        const hasAccess = await verifyRoomAccess(userId, data.roomId);
        if (hasAccess) {
          socket.join(`room:${data.roomId}`);
          const socketRooms = Array.from(socket.rooms);
          const isInRoom = socketRooms.includes(`room:${data.roomId}`);
          console.log(`[Socket.IO] \u2705 User ${userId} joined room ${data.roomId}`, {
            socketId: socket.id,
            isInRoom,
            allRooms: socketRooms
          });
          socket.emit("room_joined", { roomId: data.roomId });
        } else {
          console.warn(`[Socket.IO] \u274C Access denied: User ${userId} cannot join room ${data.roomId}`);
          socket.emit("error", { message: "Access denied to this room" });
        }
      } catch (error) {
        console.error(`[Socket.IO] \u274C Error joining room ${data.roomId} for user ${userId}:`, error);
        socket.emit("error", { message: "Failed to join room" });
      }
    });
    socket.on("leave_room", (data) => {
      socket.leave(`room:${data.roomId}`);
      socket.emit("room_left", { roomId: data.roomId });
      console.log(`[Socket.IO] User ${userId} left room ${data.roomId}`);
    });
    socket.on("typing", (data) => {
      socket.to(`room:${data.roomId}`).emit("user_typing", {
        userId,
        userName: `${user.first_name} ${user.last_name}`,
        roomId: data.roomId
      });
    });
    socket.on("stop_typing", (data) => {
      socket.to(`room:${data.roomId}`).emit("stop_typing", {
        userId,
        roomId: data.roomId
      });
    });
    socket.on("mark_read", async (data) => {
      try {
        await markMessagesAsRead(data.roomId, userId, data.messageId);
        io.to(`room:${data.roomId}`).emit("messages_read", {
          roomId: data.roomId,
          userId
        });
      } catch (error) {
        console.error(`[Socket.IO] Error marking messages as read:`, error);
      }
    });
    socket.on("disconnect", (reason) => {
      console.log(`[Socket.IO] \u26A0\uFE0F  User disconnected: ${userId}, reason: ${reason}`);
    });
    socket.on("error", (error) => {
      if (error.code !== "ECONNRESET" && error.message !== "read ECONNRESET") {
        console.error(`[Socket.IO] Socket error for user ${userId}:`, error);
      }
    });
    socket.on("disconnecting", (reason) => {
      console.log(`[Socket.IO] User ${userId} disconnecting, reason: ${reason}`);
    });
  });
  nitroApp.io = io;
  nitroApp.router.use("/socket.io/", defineEventHandler({
    handler(event) {
      try {
        engine.handleRequest(event.node.req, event.node.res);
        event._handled = true;
      } catch (error) {
        if (error.code !== "ECONNRESET" && error.message !== "read ECONNRESET") {
          console.error("[Socket.IO] Error handling request:", error);
        }
      }
    },
    websocket: {
      open(peer) {
        try {
          engine.prepare(peer._internal.nodeReq);
          engine.onWebSocket(peer._internal.nodeReq, peer._internal.nodeReq.socket, peer.websocket);
        } catch (error) {
          if (error.code !== "ECONNRESET" && error.message !== "read ECONNRESET") {
            console.error("[Socket.IO] Error opening WebSocket:", error);
          }
        }
      },
      close(peer) {
      },
      error(peer, error) {
        if (error.code !== "ECONNRESET" && error.message !== "read ECONNRESET") {
          console.error("[Socket.IO] WebSocket error:", error);
        }
      }
    }
  }));
  console.log("[Socket.IO] \u2705 Plugin initialized and ready");
});

const plugins$1 = [
  _jLNx1CnX5kcf2dl0xeVeazMHB59Nl5Q8ozwYoiMDEY
];

const assets = {
  "/uploads/.gitkeep": {
    "type": "text/plain; charset=utf-8",
    "etag": "\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"",
    "mtime": "2025-12-20T13:42:01.644Z",
    "size": 0,
    "path": "../public/uploads/.gitkeep"
  },
  "/_nuxt/0JwXLbdW.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"13f0-kjdELbO7f7qQNHul6L01oU9MaOo\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 5104,
    "path": "../public/_nuxt/0JwXLbdW.js"
  },
  "/_nuxt/8aee2ZTh.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"75e-SeJV9Smjndi8hBqJ4IuiEt8DAcY\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 1886,
    "path": "../public/_nuxt/8aee2ZTh.js"
  },
  "/_nuxt/8smeP2F2.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"250-CPnADmYx/AnACdCdZklbTr2IUKo\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 592,
    "path": "../public/_nuxt/8smeP2F2.js"
  },
  "/_nuxt/9LjQvTqj.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1a8c-k6TwgMFl7GYIWlj8GosIY0gS0nA\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 6796,
    "path": "../public/_nuxt/9LjQvTqj.js"
  },
  "/_nuxt/B-X30aoF.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-pdeiaxGfeEK2QnUISadccljMgfM\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 78,
    "path": "../public/_nuxt/B-X30aoF.js"
  },
  "/_nuxt/B1BO9a0J.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"165b-ReZGcheiMOmsmKfqC9toVWOobGE\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 5723,
    "path": "../public/_nuxt/B1BO9a0J.js"
  },
  "/_nuxt/B2mp1wD8.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"8db-mt0+cSepOhG2eduStBRWogl/gtA\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 2267,
    "path": "../public/_nuxt/B2mp1wD8.js"
  },
  "/_nuxt/B3Z3RBrt.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"43c7-HaxCOnkwxuhkFJhQzn7UwGbVUi8\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 17351,
    "path": "../public/_nuxt/B3Z3RBrt.js"
  },
  "/_nuxt/B49HIcoT.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"6334-K7YAXO53DaYwCOyplcBQHl/RCOo\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 25396,
    "path": "../public/_nuxt/B49HIcoT.js"
  },
  "/_nuxt/BALXvQ8s.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2f52-US8A8Kk4KuG0z9fG7QVV968nsXc\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 12114,
    "path": "../public/_nuxt/BALXvQ8s.js"
  },
  "/_nuxt/BCw_uuzn.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"a0d-/yrKWRvpg1oL2duy5dDfz2S0Eqs\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 2573,
    "path": "../public/_nuxt/BCw_uuzn.js"
  },
  "/_nuxt/BEBU9Hil.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2da1-Q8JyN64Vev1+GqhiCagPyJc5sm4\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 11681,
    "path": "../public/_nuxt/BEBU9Hil.js"
  },
  "/_nuxt/BFsmL2mK.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1c07-kZkEd6nW+bEIDcAH/nf3SUQKQXw\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 7175,
    "path": "../public/_nuxt/BFsmL2mK.js"
  },
  "/_nuxt/BHSDNIxN.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"d9c-f7R2zWCnBeTpA6W6DfSQhb4Lhw8\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 3484,
    "path": "../public/_nuxt/BHSDNIxN.js"
  },
  "/_nuxt/BJCjXCMr.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"110-MnHUe3glZd+oMpc1aTR/FFe4SxA\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 272,
    "path": "../public/_nuxt/BJCjXCMr.js"
  },
  "/_nuxt/BKpWv-2O.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-czRqwgPrUqKa6beUtS0Mmg3u1XM\"",
    "mtime": "2025-12-27T09:06:32.192Z",
    "size": 78,
    "path": "../public/_nuxt/BKpWv-2O.js"
  },
  "/_nuxt/BOBs1G3d.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1d20-nPglM6NlVz5YngwtAWfZipJKNCw\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 7456,
    "path": "../public/_nuxt/BOBs1G3d.js"
  },
  "/_nuxt/BQPERQYg.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1e36-CRhVLJp6RMXLB7abD4IeHbbkaTQ\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 7734,
    "path": "../public/_nuxt/BQPERQYg.js"
  },
  "/_nuxt/BTopoM6U.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"90-Vsi2vzKSFNwCby2DNfj1fyN58J8\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 144,
    "path": "../public/_nuxt/BTopoM6U.js"
  },
  "/_nuxt/BTqLQgnH.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-mvyvFla/ok8Ttbo+JzZp2LEDbHc\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 78,
    "path": "../public/_nuxt/BTqLQgnH.js"
  },
  "/_nuxt/BZUAIYhA.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"256-5BQ8w0zjel6S4Zz3e5qRVlyiBtU\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 598,
    "path": "../public/_nuxt/BZUAIYhA.js"
  },
  "/_nuxt/B_w0QKyd.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1fb2-DHJGELXKkBkWKD62c9Ybafi08WE\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 8114,
    "path": "../public/_nuxt/B_w0QKyd.js"
  },
  "/_nuxt/Bc4y1aXM.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"33eb-j6UrbD4vXRi18kujWMRgJl1NHDo\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 13291,
    "path": "../public/_nuxt/Bc4y1aXM.js"
  },
  "/_nuxt/BcKj8Aeq.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-ynOujaDuP/BCvsnVNw9CHu2309k\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 78,
    "path": "../public/_nuxt/BcKj8Aeq.js"
  },
  "/_nuxt/BdJkXebB.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"b33-uTzp7fA05KKT77vrU3FZ+dAg6Os\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 2867,
    "path": "../public/_nuxt/BdJkXebB.js"
  },
  "/_nuxt/BdNG13rv.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"24d6-gOc4PubjNnOJ+irWBGSMmz1SF+c\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 9430,
    "path": "../public/_nuxt/BdNG13rv.js"
  },
  "/_nuxt/Be9nsAj3.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2deb-PfRQQ2HqLBrl5jnxjv3viGe/oC8\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 11755,
    "path": "../public/_nuxt/Be9nsAj3.js"
  },
  "/_nuxt/BeJ1R-XH.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1b43-Gk+2h3Cmwd4DTGNYk5brJRztzNk\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 6979,
    "path": "../public/_nuxt/BeJ1R-XH.js"
  },
  "/_nuxt/BgJoX-5C.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"e8-oXYN/XYhtjmeTz1PCZj/AN6acN4\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 232,
    "path": "../public/_nuxt/BgJoX-5C.js"
  },
  "/_nuxt/BiBmy0vu.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"5c30-i/fk/gr4lfslrzTxJr77jprTfKo\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 23600,
    "path": "../public/_nuxt/BiBmy0vu.js"
  },
  "/_nuxt/BmYQ950h.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1389-uLENR0KNTifqszbxbenIESBzY/8\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 5001,
    "path": "../public/_nuxt/BmYQ950h.js"
  },
  "/_nuxt/Bo53vrEk.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"d3e-0+FwyaioCw2PD79kkZP6RWOCZss\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 3390,
    "path": "../public/_nuxt/Bo53vrEk.js"
  },
  "/_nuxt/Bw0amrgs.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1711-OEb7TtYm8r6LOBWq5LfAKGp1joE\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 5905,
    "path": "../public/_nuxt/Bw0amrgs.js"
  },
  "/_nuxt/BwweZmaY.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-MxGe8CyxvgvLv+4SgdzdhTCEdQU\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 78,
    "path": "../public/_nuxt/BwweZmaY.js"
  },
  "/_nuxt/C-BNIxyI.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1152-OtoJnL2O9aO+pxFPY1MU6XcCk8c\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 4434,
    "path": "../public/_nuxt/C-BNIxyI.js"
  },
  "/_nuxt/C-arVmPL.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1e25-GrRbFpXb9dRM6JDswFcElYBGrrY\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 7717,
    "path": "../public/_nuxt/C-arVmPL.js"
  },
  "/_nuxt/C2YKbQDp.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1b03-XZw7rIPHEFr9rGJb+6SK8nitEbk\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 6915,
    "path": "../public/_nuxt/C2YKbQDp.js"
  },
  "/_nuxt/C4BNzpKP.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"27c4-8AWy7kU2AgHkIGv5ERZ/VUYDTpo\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 10180,
    "path": "../public/_nuxt/C4BNzpKP.js"
  },
  "/_nuxt/C51Wn5Mq.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"155-mOnZvMUBV9RCULjfg826IteKi78\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 341,
    "path": "../public/_nuxt/C51Wn5Mq.js"
  },
  "/_nuxt/C5VP7iu_.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"86e-mgClQucCyS+tUXoKM+zXierk8eI\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 2158,
    "path": "../public/_nuxt/C5VP7iu_.js"
  },
  "/_nuxt/C6b0ety_.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2848-+yZg5/djM53fYYHpmtfzA1QQPrQ\"",
    "mtime": "2025-12-27T09:06:32.193Z",
    "size": 10312,
    "path": "../public/_nuxt/C6b0ety_.js"
  },
  "/_nuxt/C7vjBmAo.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"9f8-sttIaTCAKJMmcrO58vixgxji4Eo\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 2552,
    "path": "../public/_nuxt/C7vjBmAo.js"
  },
  "/_nuxt/C8uZPu3n.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"13a0-Sgrcd999VrFRk6QIYKd1JqKRFw0\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 5024,
    "path": "../public/_nuxt/C8uZPu3n.js"
  },
  "/_nuxt/CDjH4OLA.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2bdb-jic3CTi3g1WbI9wdHb0oBgTHPx4\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 11227,
    "path": "../public/_nuxt/CDjH4OLA.js"
  },
  "/_nuxt/CIjPKTSB.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"59ff-LzCPMhvhoOqQCBuaVyxeo24OcnE\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 23039,
    "path": "../public/_nuxt/CIjPKTSB.js"
  },
  "/_nuxt/CPO0it5h.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1585-e/YMUIDkUjTZJRjVmmiVPU04WRA\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 5509,
    "path": "../public/_nuxt/CPO0it5h.js"
  },
  "/_nuxt/CPo-A71o.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"a0a-nBGbpN8utEfhU/a9ykiO6QTyDp8\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 2570,
    "path": "../public/_nuxt/CPo-A71o.js"
  },
  "/_nuxt/CPokQ-Z0.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1831-wFr3ZSlODtKTLlkWsUpFK9aZiTc\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 6193,
    "path": "../public/_nuxt/CPokQ-Z0.js"
  },
  "/_nuxt/CRIXk28M.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-HfDOenTqKVmXmDs8kmeqnGZPf4Q\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 78,
    "path": "../public/_nuxt/CRIXk28M.js"
  },
  "/_nuxt/CTEk1XwB.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-uev5DGETjvSeTC97V1Qjc43Keb4\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 78,
    "path": "../public/_nuxt/CTEk1XwB.js"
  },
  "/_nuxt/CWJWjr3c.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"3a6b-lWcRpoUSV3lVOhxZH2mXNo87/To\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 14955,
    "path": "../public/_nuxt/CWJWjr3c.js"
  },
  "/_nuxt/CX4WDIMJ.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"33906-wMYzHPlGOrJwBRt+DR2Gx15USTk\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 211206,
    "path": "../public/_nuxt/CX4WDIMJ.js"
  },
  "/_nuxt/CYB17nq9.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"acc-kIWdj1VKACY+tMPqqGHA2+gK3uU\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 2764,
    "path": "../public/_nuxt/CYB17nq9.js"
  },
  "/_nuxt/C_uIs32I.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"347f-bjLvJ5nFhyrcomLUru/BQuMkqXI\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 13439,
    "path": "../public/_nuxt/C_uIs32I.js"
  },
  "/_nuxt/CaK-Jlu2.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"111d-It4SGzXULeU9NgwwFJBeBaKkynU\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 4381,
    "path": "../public/_nuxt/CaK-Jlu2.js"
  },
  "/_nuxt/CasXnXPt.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"cf5-ms9yx51kssp2Gy4mPTlDNrC5ik0\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 3317,
    "path": "../public/_nuxt/CasXnXPt.js"
  },
  "/_nuxt/Cb3Vbygw.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"64-1d0DBDIvxmUSJu0l68hNQQyQJ84\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 100,
    "path": "../public/_nuxt/Cb3Vbygw.js"
  },
  "/_nuxt/CeAJt_oh.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"19287-s8SUmnWdpRZBxjs1/2r+hOqfrkE\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 103047,
    "path": "../public/_nuxt/CeAJt_oh.js"
  },
  "/_nuxt/CfAzB1GA.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"a6b-enAr1jc9/mu+0S1yLW4lLxVw2xM\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 2667,
    "path": "../public/_nuxt/CfAzB1GA.js"
  },
  "/_nuxt/CfuytIrk.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2df0-iGK6inJsM6bdiwk537fDZNlfzow\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 11760,
    "path": "../public/_nuxt/CfuytIrk.js"
  },
  "/_nuxt/CiM0_A9B.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"410d-7u24RpjrtclZ8sUvj8TrG4k2vCk\"",
    "mtime": "2025-12-27T09:06:32.194Z",
    "size": 16653,
    "path": "../public/_nuxt/CiM0_A9B.js"
  },
  "/_nuxt/CjwhNx0b.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"49a9-tv6chodic4+RTKhrbrsTkt8eb60\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 18857,
    "path": "../public/_nuxt/CjwhNx0b.js"
  },
  "/_nuxt/CkyQOW3s.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2075-MnQwVuv2ViyihRqhfk8QHwNwIZU\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 8309,
    "path": "../public/_nuxt/CkyQOW3s.js"
  },
  "/_nuxt/CllNs7J-.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"507-4FfAuRvdMRt4hN2JeJ1BmsueyMU\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 1287,
    "path": "../public/_nuxt/CllNs7J-.js"
  },
  "/_nuxt/CmxfT9SS.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2b1d-KyKuDtabUNZO1e7mIddLTINFv+k\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 11037,
    "path": "../public/_nuxt/CmxfT9SS.js"
  },
  "/_nuxt/CqRDv-_f.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1f4a-79ck41FFa5HRf6zGdyvMWIY+nF8\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 8010,
    "path": "../public/_nuxt/CqRDv-_f.js"
  },
  "/_nuxt/CtteXIPZ.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1d4b-n+6XLx7jf+hymyeeImj/RfeD//I\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 7499,
    "path": "../public/_nuxt/CtteXIPZ.js"
  },
  "/_nuxt/Cxo8nhUx.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"9fe-2q7U8QlnZi8+T+Mfab5ZIaDTtAk\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 2558,
    "path": "../public/_nuxt/Cxo8nhUx.js"
  },
  "/_nuxt/CyzirTAB.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"44ae-LPpRP10srj+kvd0D+aDz3p667kc\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 17582,
    "path": "../public/_nuxt/CyzirTAB.js"
  },
  "/_nuxt/D4wADBKf.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"b91-x/IAjQCLS+2C5ggdAfzS9iJwBb0\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 2961,
    "path": "../public/_nuxt/D4wADBKf.js"
  },
  "/_nuxt/D7CgXfyH.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"14d14-iNX4E8VHSMKHYyL6F65V5nZ37wc\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 85268,
    "path": "../public/_nuxt/D7CgXfyH.js"
  },
  "/_nuxt/D8WKMr8o.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"28b5-j//1PN/ijVIl6jDfUxCh84HGKfg\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 10421,
    "path": "../public/_nuxt/D8WKMr8o.js"
  },
  "/_nuxt/DBq6vxy0.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-3pIE3GvddfDNKRBng2IpsDb+OiA\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 78,
    "path": "../public/_nuxt/DBq6vxy0.js"
  },
  "/_nuxt/DCX2gqgQ.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2cc5-uQhDNANzTG67xQ0sS2qeGnC5tek\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 11461,
    "path": "../public/_nuxt/DCX2gqgQ.js"
  },
  "/_nuxt/DClwBoeE.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-VHjLaTFu+qbii7DFMw5g1Xs+EPw\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 78,
    "path": "../public/_nuxt/DClwBoeE.js"
  },
  "/_nuxt/DDbQURS5.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"16e4-2uu5gtyYT2oKu+zJgCTfDf41cFw\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 5860,
    "path": "../public/_nuxt/DDbQURS5.js"
  },
  "/_nuxt/DDxt_u6O.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"d6-adHr6PNgNZycFmWoZyAl935WE3A\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 214,
    "path": "../public/_nuxt/DDxt_u6O.js"
  },
  "/_nuxt/DE0tsH7x.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"d86-Muitx8FXarD/8QZwv468fxmFVMo\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 3462,
    "path": "../public/_nuxt/DE0tsH7x.js"
  },
  "/_nuxt/DE9j9Y27.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1658-N9yuhbtt/WmvdWt5h0sWAeXJOyw\"",
    "mtime": "2025-12-27T09:06:32.195Z",
    "size": 5720,
    "path": "../public/_nuxt/DE9j9Y27.js"
  },
  "/_nuxt/DJ1b1eKD.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-c+EvgVnxl42Cl3GgrZ64Cg38/A4\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 78,
    "path": "../public/_nuxt/DJ1b1eKD.js"
  },
  "/_nuxt/DOCv56iD.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-9cWT0pm41JDzkj2Ib8kMKXDLdZQ\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 78,
    "path": "../public/_nuxt/DOCv56iD.js"
  },
  "/_nuxt/DOaAHroO.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-AATiIAUrS8nJdcY0gqmre2BmeA0\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 78,
    "path": "../public/_nuxt/DOaAHroO.js"
  },
  "/_nuxt/DVLQ4A6n.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1070-gz2kcNSW/1CAXQWIoJdawK8p0mA\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 4208,
    "path": "../public/_nuxt/DVLQ4A6n.js"
  },
  "/_nuxt/DWL7QY8Q.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-8Au9UBmjdCuW001xDbhM1OK/9wM\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 78,
    "path": "../public/_nuxt/DWL7QY8Q.js"
  },
  "/_nuxt/DaQcxvqW.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2d8b-VUzdWAUbNQ65MSaHz2bV7oppFgA\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 11659,
    "path": "../public/_nuxt/DaQcxvqW.js"
  },
  "/_nuxt/Dac6oD3c.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1118-yPUHGZZQQF4NH3yTZGY1VFqYlsc\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 4376,
    "path": "../public/_nuxt/Dac6oD3c.js"
  },
  "/_nuxt/DbIPe0gX.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1b96-KssgJiCcP4sEPzc/mruiWakJgXg\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 7062,
    "path": "../public/_nuxt/DbIPe0gX.js"
  },
  "/_nuxt/Dd9IFq5w.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-V9syLhTJ60nku+NklabR4lrQJjM\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 78,
    "path": "../public/_nuxt/Dd9IFq5w.js"
  },
  "/_nuxt/DfgEv0ug.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"64-pDgUm2bmIDJVeYJ+/B4aqUthTpY\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 100,
    "path": "../public/_nuxt/DfgEv0ug.js"
  },
  "/_nuxt/Dfn2J_7j.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1025-jBCY2A2q1dxNDk782fULr81Jk5s\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 4133,
    "path": "../public/_nuxt/Dfn2J_7j.js"
  },
  "/_nuxt/DhtnrIcc.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-O35sImZb1Xo4SgmtlML3B3kbjp8\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 78,
    "path": "../public/_nuxt/DhtnrIcc.js"
  },
  "/_nuxt/DjKcNith.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1b7c-CfqBOCo0Fi+zT4KO5UUfMSfxZSM\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 7036,
    "path": "../public/_nuxt/DjKcNith.js"
  },
  "/_nuxt/DjwPAIHw.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"45c-p7janz67RU9db+I8C5MkRmVlyL0\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 1116,
    "path": "../public/_nuxt/DjwPAIHw.js"
  },
  "/_nuxt/Dm9QA4UA.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"cce-fTFUfLmlnZvN9cJJIPMpj13bC9M\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 3278,
    "path": "../public/_nuxt/Dm9QA4UA.js"
  },
  "/_nuxt/DwxO8qxn.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"32a-YzWTD/9Ab895i6xPCmWDBzyD+XI\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 810,
    "path": "../public/_nuxt/DwxO8qxn.js"
  },
  "/_nuxt/DxDEv_3r.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"a2a-25yo3iWcg1ZHg0N+fqwkJdGOpms\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 2602,
    "path": "../public/_nuxt/DxDEv_3r.js"
  },
  "/_nuxt/Dz_cw2Mu.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"267e-U2NZHLqUy0kjix/RPA2Ri/wPpwQ\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 9854,
    "path": "../public/_nuxt/Dz_cw2Mu.js"
  },
  "/_nuxt/DzoPbhfs.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1f1a-WB2CiDIx4/FOUEPhLYlrIk7dUsI\"",
    "mtime": "2025-12-27T09:06:32.196Z",
    "size": 7962,
    "path": "../public/_nuxt/DzoPbhfs.js"
  },
  "/_nuxt/EIWeQM0D.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"b5c-kIVNZfJqhZZ9lzg09Lt5yahwkL8\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 2908,
    "path": "../public/_nuxt/EIWeQM0D.js"
  },
  "/_nuxt/H1WKJ1ey.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"ac5-VLb/GSfhNrNsdg3Q9uUkjElhXwc\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 2757,
    "path": "../public/_nuxt/H1WKJ1ey.js"
  },
  "/_nuxt/LiZfZJ8V.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"282-XUFM75EvjkBL/7r0nKyrjia8KsE\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 642,
    "path": "../public/_nuxt/LiZfZJ8V.js"
  },
  "/_nuxt/MEG3hhrh.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"248-pYxjyPbKEWIvgemQ0PlV4TYMfRo\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 584,
    "path": "../public/_nuxt/MEG3hhrh.js"
  },
  "/_nuxt/NoIg-Coj.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"4e-OpIeyjK7MWntDFq0UfF0rcc6BTk\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 78,
    "path": "../public/_nuxt/NoIg-Coj.js"
  },
  "/_nuxt/PItv745k.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1850-6Qa7QWSL0p+lAtrzdQ3pW8wf/T0\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 6224,
    "path": "../public/_nuxt/PItv745k.js"
  },
  "/_nuxt/PJD1JfRC.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1606-2imETT2wQ+y+QgIMEW/Xl/BgRQQ\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 5638,
    "path": "../public/_nuxt/PJD1JfRC.js"
  },
  "/_nuxt/Qwhilmll.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"3616-q2CXlJ/B4/vavSJGKKxnqTsT+Wo\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 13846,
    "path": "../public/_nuxt/Qwhilmll.js"
  },
  "/_nuxt/RichTextEditor.9N-AczwR.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"35d-16ezpV9kQ3ACp9OAennGdDokKbg\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 861,
    "path": "../public/_nuxt/RichTextEditor.9N-AczwR.css"
  },
  "/_nuxt/_slug_.CGAP6FWb.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"4f5-cTvGHHQrKxkAKLuS2gh7EuwUiWY\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 1269,
    "path": "../public/_nuxt/_slug_.CGAP6FWb.css"
  },
  "/_nuxt/about.CscaCdTE.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"286-r2cYeAvqcBQ30dyTG0VHsg6rFsQ\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 646,
    "path": "../public/_nuxt/about.CscaCdTE.css"
  },
  "/_nuxt/cL3ZD5Hb.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"87b-xEMmXYiEHdQW1WO0DDAq+HOHVYY\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 2171,
    "path": "../public/_nuxt/cL3ZD5Hb.js"
  },
  "/_nuxt/careers.tQ6S07Om.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"286-LztnEgkmHL8f2CBhYd7Lmk2A5D0\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 646,
    "path": "../public/_nuxt/careers.tQ6S07Om.css"
  },
  "/_nuxt/contact.BQWmQK7z.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"286-hvl2Fy9Ah5R3InVzJY4cJtXC4+4\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 646,
    "path": "../public/_nuxt/contact.BQWmQK7z.css"
  },
  "/_nuxt/entry.DLS_FDRg.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"aa0c-RShZy5EyPTM04vZCg8iMt3r0kQg\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 43532,
    "path": "../public/_nuxt/entry.DLS_FDRg.css"
  },
  "/_nuxt/help.DlSzpRFm.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"286-RHCPwk3rTGZU4UuDBT+KWRWZ6gU\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 646,
    "path": "../public/_nuxt/help.DlSzpRFm.css"
  },
  "/_nuxt/index.C94WdXjb.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"ac-6Iy0kKNjx6DA7pn/EmXNxX2HN0o\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 172,
    "path": "../public/_nuxt/index.C94WdXjb.css"
  },
  "/_nuxt/index.CA3aPy--.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"e7-Gob4Pyj1F3df2nHgIUjnFeg2kbk\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 231,
    "path": "../public/_nuxt/index.CA3aPy--.css"
  },
  "/_nuxt/jfJEL8rP.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"427a-GVfOIEs9j+8rGcqeGonYQMLrup0\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 17018,
    "path": "../public/_nuxt/jfJEL8rP.js"
  },
  "/_nuxt/m998VyF-.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"5751-egftUFtSIvJBzVg2o+i2njXr9HE\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 22353,
    "path": "../public/_nuxt/m998VyF-.js"
  },
  "/_nuxt/rQp7WoB7.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"1364-H/bTnzZFU8W+ydtn8INZJOmwf2U\"",
    "mtime": "2025-12-27T09:06:32.198Z",
    "size": 4964,
    "path": "../public/_nuxt/rQp7WoB7.js"
  },
  "/_nuxt/rSZ_nZDf.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"fc9-nNtYfkJxz4q9qO8R17ONtfcPKTU\"",
    "mtime": "2025-12-27T09:06:32.197Z",
    "size": 4041,
    "path": "../public/_nuxt/rSZ_nZDf.js"
  },
  "/_nuxt/support.7nip7fuj.css": {
    "type": "text/css; charset=utf-8",
    "etag": "\"286-BpLsFZdOT17eA16qj1dKumEM9sI\"",
    "mtime": "2025-12-27T09:06:32.198Z",
    "size": 646,
    "path": "../public/_nuxt/support.7nip7fuj.css"
  },
  "/_nuxt/v-KwyajG.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"5ab86-6v8RrFyFEI6WblCxU7ClXztFvF4\"",
    "mtime": "2025-12-27T09:06:32.198Z",
    "size": 371590,
    "path": "../public/_nuxt/v-KwyajG.js"
  },
  "/_nuxt/xJo2gTVb.js": {
    "type": "text/javascript; charset=utf-8",
    "etag": "\"2cd-9VMn52b/m7sM5zl0oJrKCvLwS+0\"",
    "mtime": "2025-12-27T09:06:32.198Z",
    "size": 717,
    "path": "../public/_nuxt/xJo2gTVb.js"
  },
  "/uploads/courses/.gitkeep": {
    "type": "text/plain; charset=utf-8",
    "etag": "\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"",
    "mtime": "2025-12-20T13:42:01.644Z",
    "size": 0,
    "path": "../public/uploads/courses/.gitkeep"
  },
  "/_nuxt/builds/latest.json": {
    "type": "application/json",
    "etag": "\"47-ft7Ht0TW7RlFV9bsHrV5MYfSMQA\"",
    "mtime": "2025-12-27T09:06:32.181Z",
    "size": 71,
    "path": "../public/_nuxt/builds/latest.json"
  },
  "/uploads/courses/1/thumbnail.png": {
    "type": "image/png",
    "etag": "\"40beb-3UURiio74LxC4tSrULv6UoMI9S0\"",
    "mtime": "2025-12-27T09:06:32.204Z",
    "size": 265195,
    "path": "../public/uploads/courses/1/thumbnail.png"
  },
  "/uploads/courses/7/thumbnail.png": {
    "type": "image/png",
    "etag": "\"805f9-OnBfTtnNqO0IEOSfrFaUu7TL8EQ\"",
    "mtime": "2025-12-27T09:06:32.205Z",
    "size": 525817,
    "path": "../public/uploads/courses/7/thumbnail.png"
  },
  "/uploads/courses/_unmapped/1766238411723-82u7nqfw8a7.jpeg": {
    "type": "image/jpeg",
    "etag": "\"d2fd-ryBYWON8BLJI1GpA7HAwZOQIwqI\"",
    "mtime": "2025-12-27T09:06:32.203Z",
    "size": 54013,
    "path": "../public/uploads/courses/_unmapped/1766238411723-82u7nqfw8a7.jpeg"
  },
  "/uploads/courses/_unmapped/1766238429948-wutivqmymgc.jpg": {
    "type": "image/jpeg",
    "etag": "\"4fd0-+Bm/QXsOzR3v5yXiitNla4hr6Xs\"",
    "mtime": "2025-12-27T09:06:32.205Z",
    "size": 20432,
    "path": "../public/uploads/courses/_unmapped/1766238429948-wutivqmymgc.jpg"
  },
  "/uploads/courses/_unmapped/1766330431095-jshytm39who.png": {
    "type": "image/png",
    "etag": "\"805f9-OnBfTtnNqO0IEOSfrFaUu7TL8EQ\"",
    "mtime": "2025-12-27T09:06:32.204Z",
    "size": 525817,
    "path": "../public/uploads/courses/_unmapped/1766330431095-jshytm39who.png"
  },
  "/uploads/courses/_unmapped/1766330640831-0xnt8fswz2d.png": {
    "type": "image/png",
    "etag": "\"805f9-OnBfTtnNqO0IEOSfrFaUu7TL8EQ\"",
    "mtime": "2025-12-27T09:06:32.206Z",
    "size": 525817,
    "path": "../public/uploads/courses/_unmapped/1766330640831-0xnt8fswz2d.png"
  },
  "/_nuxt/builds/meta/c56e8ffe-2a3b-4e5e-bffa-d3756b0e67a8.json": {
    "type": "application/json",
    "etag": "\"8b-zObK+D+lF2W/+SP8xvROcVRypvA\"",
    "mtime": "2025-12-27T09:06:32.179Z",
    "size": 139,
    "path": "../public/_nuxt/builds/meta/c56e8ffe-2a3b-4e5e-bffa-d3756b0e67a8.json"
  }
};

const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};
const dirname = function(p) {
  const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
    segments[0] += "/";
  }
  return segments.join("/") || (isAbsolute(p) ? "/" : ".");
};

function readAsset (id) {
  const serverDir = dirname(fileURLToPath(globalThis._importMeta_.url));
  return promises.readFile(resolve(serverDir, assets[id].path))
}

const publicAssetBases = {"/_nuxt/builds/meta/":{"maxAge":31536000},"/_nuxt/builds/":{"maxAge":1},"/_nuxt/":{"maxAge":31536000}};

function isPublicAssetURL(id = '') {
  if (assets[id]) {
    return true
  }
  for (const base in publicAssetBases) {
    if (id.startsWith(base)) { return true }
  }
  return false
}

function getAsset (id) {
  return assets[id]
}

const METHODS = /* @__PURE__ */ new Set(["HEAD", "GET"]);
const EncodingMap = { gzip: ".gz", br: ".br" };
const _pIXDZ7 = eventHandler((event) => {
  if (event.method && !METHODS.has(event.method)) {
    return;
  }
  let id = decodePath(
    withLeadingSlash(withoutTrailingSlash(parseURL(event.path).pathname))
  );
  let asset;
  const encodingHeader = String(
    getRequestHeader(event, "accept-encoding") || ""
  );
  const encodings = [
    ...encodingHeader.split(",").map((e) => EncodingMap[e.trim()]).filter(Boolean).sort(),
    ""
  ];
  if (encodings.length > 1) {
    appendResponseHeader(event, "Vary", "Accept-Encoding");
  }
  for (const encoding of encodings) {
    for (const _id of [id + encoding, joinURL(id, "index.html" + encoding)]) {
      const _asset = getAsset(_id);
      if (_asset) {
        asset = _asset;
        id = _id;
        break;
      }
    }
  }
  if (!asset) {
    if (isPublicAssetURL(id)) {
      removeResponseHeader(event, "Cache-Control");
      throw createError$2({ statusCode: 404 });
    }
    return;
  }
  const ifNotMatch = getRequestHeader(event, "if-none-match") === asset.etag;
  if (ifNotMatch) {
    setResponseStatus(event, 304, "Not Modified");
    return "";
  }
  const ifModifiedSinceH = getRequestHeader(event, "if-modified-since");
  const mtimeDate = new Date(asset.mtime);
  if (ifModifiedSinceH && asset.mtime && new Date(ifModifiedSinceH) >= mtimeDate) {
    setResponseStatus(event, 304, "Not Modified");
    return "";
  }
  if (asset.type && !getResponseHeader(event, "Content-Type")) {
    setResponseHeader(event, "Content-Type", asset.type);
  }
  if (asset.etag && !getResponseHeader(event, "ETag")) {
    setResponseHeader(event, "ETag", asset.etag);
  }
  if (asset.mtime && !getResponseHeader(event, "Last-Modified")) {
    setResponseHeader(event, "Last-Modified", mtimeDate.toUTCString());
  }
  if (asset.encoding && !getResponseHeader(event, "Content-Encoding")) {
    setResponseHeader(event, "Content-Encoding", asset.encoding);
  }
  if (asset.size > 0 && !getResponseHeader(event, "Content-Length")) {
    setResponseHeader(event, "Content-Length", asset.size);
  }
  return readAsset(id);
});

const _SxA8c9 = defineEventHandler(() => {});

const _lazy_XFSqTC = () => Promise.resolve().then(function () { return articles_get$3; });
const _lazy_mZX4Nt = () => Promise.resolve().then(function () { return articles_post$1; });
const _lazy_RC49rn = () => Promise.resolve().then(function () { return _id__delete$t; });
const _lazy_JlkU9f = () => Promise.resolve().then(function () { return _id__put$v; });
const _lazy_VbjLHg = () => Promise.resolve().then(function () { return branches_get$5; });
const _lazy_19oFzR = () => Promise.resolve().then(function () { return rooms_get$3; });
const _lazy_RFi39G = () => Promise.resolve().then(function () { return _roomId__get$3; });
const _lazy_TmE9Pd = () => Promise.resolve().then(function () { return contentPages_get$1; });
const _lazy_G6BXjf = () => Promise.resolve().then(function () { return contentPages_post$1; });
const _lazy_TQ8M9q = () => Promise.resolve().then(function () { return _id__delete$r; });
const _lazy_yjg6Xg = () => Promise.resolve().then(function () { return _id__put$t; });
const _lazy_JA5fIe = () => Promise.resolve().then(function () { return courses_get$3; });
const _lazy_faO8iE = () => Promise.resolve().then(function () { return courses_post$1; });
const _lazy_plGDIN = () => Promise.resolve().then(function () { return _id__delete$p; });
const _lazy_LDvrIr = () => Promise.resolve().then(function () { return _id__get$d; });
const _lazy_a6NdeO = () => Promise.resolve().then(function () { return _id__put$r; });
const _lazy_XSsU2q = () => Promise.resolve().then(function () { return images_post$1; });
const _lazy_zBz3GV = () => Promise.resolve().then(function () { return _imageId__delete$1; });
const _lazy_KpGVS_ = () => Promise.resolve().then(function () { return status_patch$9; });
const _lazy_mgTDg4 = () => Promise.resolve().then(function () { return dashboard_get$1; });
const _lazy_5b10_Z = () => Promise.resolve().then(function () { return enrollments_get$1; });
const _lazy_7vq2nt = () => Promise.resolve().then(function () { return enrollments_post$1; });
const _lazy_gbzB1Y = () => Promise.resolve().then(function () { return _id__delete$n; });
const _lazy_XjPagp = () => Promise.resolve().then(function () { return _id__get$b; });
const _lazy_oVTenK = () => Promise.resolve().then(function () { return _id__put$p; });
const _lazy_ufTBDS = () => Promise.resolve().then(function () { return status_patch$7; });
const _lazy_GaDvql = () => Promise.resolve().then(function () { return menus_get$1; });
const _lazy_tuLmUM = () => Promise.resolve().then(function () { return branches_get$3; });
const _lazy_2pH841 = () => Promise.resolve().then(function () { return branches_post$1; });
const _lazy_9V5lbP = () => Promise.resolve().then(function () { return _id__delete$l; });
const _lazy_W7nbQ_ = () => Promise.resolve().then(function () { return _id__put$n; });
const _lazy_D7r5nS = () => Promise.resolve().then(function () { return status_patch$5; });
const _lazy_iIB9q1 = () => Promise.resolve().then(function () { return smtp_get$1; });
const _lazy_ATxTFm = () => Promise.resolve().then(function () { return smtp_put$1; });
const _lazy_Ubdx3j = () => Promise.resolve().then(function () { return templates_get$1; });
const _lazy_ZsMGQN = () => Promise.resolve().then(function () { return _id__get$9; });
const _lazy_3_Qgj2 = () => Promise.resolve().then(function () { return _id__put$l; });
const _lazy_1f_NhZ = () => Promise.resolve().then(function () { return gradeLevels_get$1; });
const _lazy_uv8NM7 = () => Promise.resolve().then(function () { return gradeLevels_post$1; });
const _lazy_lC3u8Q = () => Promise.resolve().then(function () { return _id__delete$j; });
const _lazy_fjXgeX = () => Promise.resolve().then(function () { return _id__put$j; });
const _lazy_o0l7LY = () => Promise.resolve().then(function () { return inclusions_get$1; });
const _lazy_qnVXLM = () => Promise.resolve().then(function () { return inclusions_post$1; });
const _lazy_njWjSe = () => Promise.resolve().then(function () { return _id__delete$h; });
const _lazy_4Y_hLQ = () => Promise.resolve().then(function () { return _id__put$h; });
const _lazy_xcOnKW = () => Promise.resolve().then(function () { return paymentMethods_get$1; });
const _lazy_SovD6D = () => Promise.resolve().then(function () { return paymentMethods_post$1; });
const _lazy_nyuOPO = () => Promise.resolve().then(function () { return _id__delete$f; });
const _lazy_e5P9Ck = () => Promise.resolve().then(function () { return _id__get$7; });
const _lazy_LXx0yD = () => Promise.resolve().then(function () { return _id__put$f; });
const _lazy_nT0uml = () => Promise.resolve().then(function () { return bankAccounts_get$1; });
const _lazy_8ibiTM = () => Promise.resolve().then(function () { return bankAccounts_post$1; });
const _lazy_l8auPL = () => Promise.resolve().then(function () { return _accountId__delete$1; });
const _lazy_zfKhht = () => Promise.resolve().then(function () { return _accountId__put$1; });
const _lazy_Ndrixr = () => Promise.resolve().then(function () { return gateway_get$1; });
const _lazy_GFxP96 = () => Promise.resolve().then(function () { return gateway_put$1; });
const _lazy_DWxyvQ = () => Promise.resolve().then(function () { return status_patch$3; });
const _lazy_uM19ep = () => Promise.resolve().then(function () { return roles_get$1; });
const _lazy_rMaMLg = () => Promise.resolve().then(function () { return roles_post$1; });
const _lazy_IQo0F8 = () => Promise.resolve().then(function () { return _id__delete$d; });
const _lazy_majcj0 = () => Promise.resolve().then(function () { return _id__put$d; });
const _lazy_IVIGjo = () => Promise.resolve().then(function () { return subjects_get$1; });
const _lazy_t8CZkN = () => Promise.resolve().then(function () { return subjects_post$1; });
const _lazy_EGOtIJ = () => Promise.resolve().then(function () { return _id__delete$b; });
const _lazy_eMcI1v = () => Promise.resolve().then(function () { return _id__put$b; });
const _lazy_YGHbm_ = () => Promise.resolve().then(function () { return system_get$1; });
const _lazy_nY8ggT = () => Promise.resolve().then(function () { return system_put$1; });
const _lazy_lS0LbE = () => Promise.resolve().then(function () { return _key__get$1; });
const _lazy_p4ar8w = () => Promise.resolve().then(function () { return _key__put$1; });
const _lazy_ywMEru = () => Promise.resolve().then(function () { return students_get$1; });
const _lazy_qZsaWS = () => Promise.resolve().then(function () { return _id__get$5; });
const _lazy_YTC0Qj = () => Promise.resolve().then(function () { return parents_post$1; });
const _lazy_oiuenP = () => Promise.resolve().then(function () { return _parentId__delete$1; });
const _lazy_DjDv0k = () => Promise.resolve().then(function () { return _parentId__patch$1; });
const _lazy_idAxo9 = () => Promise.resolve().then(function () { return payments_get$1; });
const _lazy_zeAf1d = () => Promise.resolve().then(function () { return testimonials_get$3; });
const _lazy__gID8h = () => Promise.resolve().then(function () { return testimonials_post$1; });
const _lazy_kP9vkf = () => Promise.resolve().then(function () { return _id__delete$9; });
const _lazy_ywARbL = () => Promise.resolve().then(function () { return _id__put$9; });
const _lazy_LeZwbf = () => Promise.resolve().then(function () { return schedules_get$1; });
const _lazy_J8TWAU = () => Promise.resolve().then(function () { return upload_post$3; });
const _lazy_aEVvUX = () => Promise.resolve().then(function () { return users_get$1; });
const _lazy_vcX3xh = () => Promise.resolve().then(function () { return users_post$1; });
const _lazy_N6qNbA = () => Promise.resolve().then(function () { return _id__delete$7; });
const _lazy_6e8gYz = () => Promise.resolve().then(function () { return _id__put$7; });
const _lazy_O6D1Ql = () => Promise.resolve().then(function () { return status_patch$1; });
const _lazy_BLDcZ_ = () => Promise.resolve().then(function () { return addresses_get$1; });
const _lazy_vAM8JV = () => Promise.resolve().then(function () { return addresses_post$1; });
const _lazy_oCNQhf = () => Promise.resolve().then(function () { return _addressId__delete$1; });
const _lazy_bLHU6H = () => Promise.resolve().then(function () { return _addressId__put$1; });
const _lazy_txoNJG = () => Promise.resolve().then(function () { return setDefault_patch$1; });
const _lazy_fDieN1 = () => Promise.resolve().then(function () { return articles_get$1; });
const _lazy_gmZiww = () => Promise.resolve().then(function () { return _slug__get$3; });
const _lazy_UkyYGn = () => Promise.resolve().then(function () { return forgotPassword_post$1; });
const _lazy_i6bqw6 = () => Promise.resolve().then(function () { return login_post$1; });
const _lazy_iawmGj = () => Promise.resolve().then(function () { return me_get$1; });
const _lazy_e9Kohi = () => Promise.resolve().then(function () { return callback_post$1; });
const _lazy_axtPzH = () => Promise.resolve().then(function () { return url_post$1; });
const _lazy_ua5kZa = () => Promise.resolve().then(function () { return register_post$1; });
const _lazy_DI5yXO = () => Promise.resolve().then(function () { return branches_get$1; });
const _lazy_Hc9lGB = () => Promise.resolve().then(function () { return appointments_get$1; });
const _lazy_Xk3UmJ = () => Promise.resolve().then(function () { return appointments_post$1; });
const _lazy_upvjGF = () => Promise.resolve().then(function () { return _id__delete$5; });
const _lazy_wPzQ1k = () => Promise.resolve().then(function () { return _id__put$5; });
const _lazy_DrvAAJ = () => Promise.resolve().then(function () { return events_get$3; });
const _lazy_pzhaVs = () => Promise.resolve().then(function () { return events_post$1; });
const _lazy_uqKNVP = () => Promise.resolve().then(function () { return _id__delete$3; });
const _lazy_vbCMRY = () => Promise.resolve().then(function () { return _id__get$3; });
const _lazy_lZt1Rd = () => Promise.resolve().then(function () { return _id__put$3; });
const _lazy_mPjfwH = () => Promise.resolve().then(function () { return tasks_get$1; });
const _lazy_lzgNHX = () => Promise.resolve().then(function () { return tasks_post$1; });
const _lazy_qGaz5o = () => Promise.resolve().then(function () { return _id__delete$1; });
const _lazy_iqFo1A = () => Promise.resolve().then(function () { return _id__put$1; });
const _lazy_MMmdRs = () => Promise.resolve().then(function () { return events_get$1; });
const _lazy_ffI4A9 = () => Promise.resolve().then(function () { return subscribe_post$1; });
const _lazy_6_KiFE = () => Promise.resolve().then(function () { return rooms_get$1; });
const _lazy_RzIjua = () => Promise.resolve().then(function () { return rooms_post$1; });
const _lazy_TvpHbc = () => Promise.resolve().then(function () { return _roomId__get$1; });
const _lazy_EJ6pJR = () => Promise.resolve().then(function () { return messages_get$1; });
const _lazy_315NNl = () => Promise.resolve().then(function () { return messages_post$1; });
const _lazy_9jC0PB = () => Promise.resolve().then(function () { return read_post$1; });
const _lazy_3MA1wu = () => Promise.resolve().then(function () { return notes_get$1; });
const _lazy_6j0NJg = () => Promise.resolve().then(function () { return notes_post$1; });
const _lazy_2W3AJk = () => Promise.resolve().then(function () { return _noteId__put$1; });
const _lazy_0JpYFT = () => Promise.resolve().then(function () { return tags_get$1; });
const _lazy_4NydRk = () => Promise.resolve().then(function () { return tags_post$1; });
const _lazy_vyASc6 = () => Promise.resolve().then(function () { return typing_post$1; });
const _lazy_ghfekQ = () => Promise.resolve().then(function () { return stop_post$1; });
const _lazy_idmILl = () => Promise.resolve().then(function () { return upload_post$1; });
const _lazy_2NT1du = () => Promise.resolve().then(function () { return _slug__get$1; });
const _lazy_mx8Aex = () => Promise.resolve().then(function () { return courses_get$1; });
const _lazy_oTk_6L = () => Promise.resolve().then(function () { return _id__get$1; });
const _lazy_9kdm43 = () => Promise.resolve().then(function () { return health_get$1; });
const _lazy_T3RIcs = () => Promise.resolve().then(function () { return availableChats_get$1; });
const _lazy_XwZV5m = () => Promise.resolve().then(function () { return myCourses_get$1; });
const _lazy_RY2uvW = () => Promise.resolve().then(function () { return testimonials_get$1; });
const _lazy_US9tyS = () => Promise.resolve().then(function () { return renderer$1; });

const handlers = [
  { route: '', handler: _pIXDZ7, lazy: false, middleware: true, method: undefined },
  { route: '/api/admin/articles', handler: _lazy_XFSqTC, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/articles', handler: _lazy_mZX4Nt, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/articles/:id', handler: _lazy_RC49rn, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/articles/:id', handler: _lazy_JlkU9f, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/branches', handler: _lazy_VbjLHg, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/chat/rooms', handler: _lazy_19oFzR, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/chat/rooms/:roomId', handler: _lazy_RFi39G, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/content-pages', handler: _lazy_TmE9Pd, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/content-pages', handler: _lazy_G6BXjf, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/content-pages/:id', handler: _lazy_TQ8M9q, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/content-pages/:id', handler: _lazy_yjg6Xg, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/courses', handler: _lazy_JA5fIe, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/courses', handler: _lazy_faO8iE, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/courses/:id', handler: _lazy_plGDIN, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/courses/:id', handler: _lazy_LDvrIr, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/courses/:id', handler: _lazy_a6NdeO, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/courses/:id/images', handler: _lazy_XSsU2q, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/courses/:id/images/:imageId', handler: _lazy_zBz3GV, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/courses/:id/status', handler: _lazy_KpGVS_, lazy: true, middleware: false, method: "patch" },
  { route: '/api/admin/dashboard', handler: _lazy_mgTDg4, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/enrollments', handler: _lazy_5b10_Z, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/enrollments', handler: _lazy_7vq2nt, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/enrollments/:id', handler: _lazy_gbzB1Y, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/enrollments/:id', handler: _lazy_XjPagp, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/enrollments/:id', handler: _lazy_oVTenK, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/enrollments/:id/status', handler: _lazy_ufTBDS, lazy: true, middleware: false, method: "patch" },
  { route: '/api/admin/menus', handler: _lazy_GaDvql, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/branches', handler: _lazy_tuLmUM, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/branches', handler: _lazy_2pH841, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/settings/branches/:id', handler: _lazy_9V5lbP, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/settings/branches/:id', handler: _lazy_W7nbQ_, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/branches/:id/status', handler: _lazy_D7r5nS, lazy: true, middleware: false, method: "patch" },
  { route: '/api/admin/settings/email/smtp', handler: _lazy_iIB9q1, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/email/smtp', handler: _lazy_ATxTFm, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/email/templates', handler: _lazy_Ubdx3j, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/email/templates/:id', handler: _lazy_ZsMGQN, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/email/templates/:id', handler: _lazy_3_Qgj2, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/grade-levels', handler: _lazy_1f_NhZ, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/grade-levels', handler: _lazy_uv8NM7, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/settings/grade-levels/:id', handler: _lazy_lC3u8Q, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/settings/grade-levels/:id', handler: _lazy_fjXgeX, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/inclusions', handler: _lazy_o0l7LY, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/inclusions', handler: _lazy_qnVXLM, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/settings/inclusions/:id', handler: _lazy_njWjSe, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/settings/inclusions/:id', handler: _lazy_4Y_hLQ, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/payment-methods', handler: _lazy_xcOnKW, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/payment-methods', handler: _lazy_SovD6D, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/settings/payment-methods/:id', handler: _lazy_nyuOPO, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/settings/payment-methods/:id', handler: _lazy_e5P9Ck, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/payment-methods/:id', handler: _lazy_LXx0yD, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/payment-methods/:id/bank-accounts', handler: _lazy_nT0uml, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/payment-methods/:id/bank-accounts', handler: _lazy_8ibiTM, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/settings/payment-methods/:id/bank-accounts/:accountId', handler: _lazy_l8auPL, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/settings/payment-methods/:id/bank-accounts/:accountId', handler: _lazy_zfKhht, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/payment-methods/:id/gateway', handler: _lazy_Ndrixr, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/payment-methods/:id/gateway', handler: _lazy_GFxP96, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/payment-methods/:id/status', handler: _lazy_DWxyvQ, lazy: true, middleware: false, method: "patch" },
  { route: '/api/admin/settings/roles', handler: _lazy_uM19ep, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/roles', handler: _lazy_rMaMLg, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/settings/roles/:id', handler: _lazy_IQo0F8, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/settings/roles/:id', handler: _lazy_majcj0, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/subjects', handler: _lazy_IVIGjo, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/subjects', handler: _lazy_t8CZkN, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/settings/subjects/:id', handler: _lazy_EGOtIJ, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/settings/subjects/:id', handler: _lazy_eMcI1v, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/system', handler: _lazy_YGHbm_, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/system', handler: _lazy_nY8ggT, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/settings/system/:key', handler: _lazy_lS0LbE, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/settings/system/:key', handler: _lazy_p4ar8w, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/students', handler: _lazy_ywMEru, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/students/:id', handler: _lazy_qZsaWS, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/students/:id/parents', handler: _lazy_YTC0Qj, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/students/:id/parents/:parentId', handler: _lazy_oiuenP, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/students/:id/parents/:parentId', handler: _lazy_DjDv0k, lazy: true, middleware: false, method: "patch" },
  { route: '/api/admin/students/:id/payments', handler: _lazy_idAxo9, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/testimonials', handler: _lazy_zeAf1d, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/testimonials', handler: _lazy__gID8h, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/testimonials/:id', handler: _lazy_kP9vkf, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/testimonials/:id', handler: _lazy_ywARbL, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/tutor/schedules', handler: _lazy_LeZwbf, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/upload', handler: _lazy_J8TWAU, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/users', handler: _lazy_aEVvUX, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/users', handler: _lazy_vcX3xh, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/users/:id', handler: _lazy_N6qNbA, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/users/:id', handler: _lazy_6e8gYz, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/users/:id/status', handler: _lazy_O6D1Ql, lazy: true, middleware: false, method: "patch" },
  { route: '/api/admin/users/:userId/addresses', handler: _lazy_BLDcZ_, lazy: true, middleware: false, method: "get" },
  { route: '/api/admin/users/:userId/addresses', handler: _lazy_vAM8JV, lazy: true, middleware: false, method: "post" },
  { route: '/api/admin/users/:userId/addresses/:addressId', handler: _lazy_oCNQhf, lazy: true, middleware: false, method: "delete" },
  { route: '/api/admin/users/:userId/addresses/:addressId', handler: _lazy_bLHU6H, lazy: true, middleware: false, method: "put" },
  { route: '/api/admin/users/:userId/addresses/:addressId/set-default', handler: _lazy_txoNJG, lazy: true, middleware: false, method: "patch" },
  { route: '/api/articles', handler: _lazy_fDieN1, lazy: true, middleware: false, method: "get" },
  { route: '/api/articles/:slug', handler: _lazy_gmZiww, lazy: true, middleware: false, method: "get" },
  { route: '/api/auth/forgot-password', handler: _lazy_UkyYGn, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/login', handler: _lazy_i6bqw6, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/me', handler: _lazy_iawmGj, lazy: true, middleware: false, method: "get" },
  { route: '/api/auth/oauth/:provider/callback', handler: _lazy_e9Kohi, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/oauth/:provider/url', handler: _lazy_axtPzH, lazy: true, middleware: false, method: "post" },
  { route: '/api/auth/register', handler: _lazy_ua5kZa, lazy: true, middleware: false, method: "post" },
  { route: '/api/branches', handler: _lazy_DI5yXO, lazy: true, middleware: false, method: "get" },
  { route: '/api/calendar/appointments', handler: _lazy_Hc9lGB, lazy: true, middleware: false, method: "get" },
  { route: '/api/calendar/appointments', handler: _lazy_Xk3UmJ, lazy: true, middleware: false, method: "post" },
  { route: '/api/calendar/appointments/:id', handler: _lazy_upvjGF, lazy: true, middleware: false, method: "delete" },
  { route: '/api/calendar/appointments/:id', handler: _lazy_wPzQ1k, lazy: true, middleware: false, method: "put" },
  { route: '/api/calendar/events', handler: _lazy_DrvAAJ, lazy: true, middleware: false, method: "get" },
  { route: '/api/calendar/events', handler: _lazy_pzhaVs, lazy: true, middleware: false, method: "post" },
  { route: '/api/calendar/events/:id', handler: _lazy_uqKNVP, lazy: true, middleware: false, method: "delete" },
  { route: '/api/calendar/events/:id', handler: _lazy_vbCMRY, lazy: true, middleware: false, method: "get" },
  { route: '/api/calendar/events/:id', handler: _lazy_lZt1Rd, lazy: true, middleware: false, method: "put" },
  { route: '/api/calendar/tasks', handler: _lazy_mPjfwH, lazy: true, middleware: false, method: "get" },
  { route: '/api/calendar/tasks', handler: _lazy_lzgNHX, lazy: true, middleware: false, method: "post" },
  { route: '/api/calendar/tasks/:id', handler: _lazy_qGaz5o, lazy: true, middleware: false, method: "delete" },
  { route: '/api/calendar/tasks/:id', handler: _lazy_iqFo1A, lazy: true, middleware: false, method: "put" },
  { route: '/api/chat/events', handler: _lazy_MMmdRs, lazy: true, middleware: false, method: "get" },
  { route: '/api/chat/events/subscribe', handler: _lazy_ffI4A9, lazy: true, middleware: false, method: "post" },
  { route: '/api/chat/rooms', handler: _lazy_6_KiFE, lazy: true, middleware: false, method: "get" },
  { route: '/api/chat/rooms', handler: _lazy_RzIjua, lazy: true, middleware: false, method: "post" },
  { route: '/api/chat/rooms/:roomId', handler: _lazy_TvpHbc, lazy: true, middleware: false, method: "get" },
  { route: '/api/chat/rooms/:roomId/messages', handler: _lazy_EJ6pJR, lazy: true, middleware: false, method: "get" },
  { route: '/api/chat/rooms/:roomId/messages', handler: _lazy_315NNl, lazy: true, middleware: false, method: "post" },
  { route: '/api/chat/rooms/:roomId/messages/read', handler: _lazy_9jC0PB, lazy: true, middleware: false, method: "post" },
  { route: '/api/chat/rooms/:roomId/notes', handler: _lazy_3MA1wu, lazy: true, middleware: false, method: "get" },
  { route: '/api/chat/rooms/:roomId/notes', handler: _lazy_6j0NJg, lazy: true, middleware: false, method: "post" },
  { route: '/api/chat/rooms/:roomId/notes/:noteId', handler: _lazy_2W3AJk, lazy: true, middleware: false, method: "put" },
  { route: '/api/chat/rooms/:roomId/tags', handler: _lazy_0JpYFT, lazy: true, middleware: false, method: "get" },
  { route: '/api/chat/rooms/:roomId/tags', handler: _lazy_4NydRk, lazy: true, middleware: false, method: "post" },
  { route: '/api/chat/rooms/:roomId/typing', handler: _lazy_vyASc6, lazy: true, middleware: false, method: "post" },
  { route: '/api/chat/rooms/:roomId/typing/stop', handler: _lazy_ghfekQ, lazy: true, middleware: false, method: "post" },
  { route: '/api/chat/upload', handler: _lazy_idmILl, lazy: true, middleware: false, method: "post" },
  { route: '/api/content-pages/:slug', handler: _lazy_2NT1du, lazy: true, middleware: false, method: "get" },
  { route: '/api/courses', handler: _lazy_mx8Aex, lazy: true, middleware: false, method: "get" },
  { route: '/api/courses/:id', handler: _lazy_oTk_6L, lazy: true, middleware: false, method: "get" },
  { route: '/api/health', handler: _lazy_9kdm43, lazy: true, middleware: false, method: "get" },
  { route: '/api/learning/available-chats', handler: _lazy_T3RIcs, lazy: true, middleware: false, method: "get" },
  { route: '/api/learning/my-courses', handler: _lazy_XwZV5m, lazy: true, middleware: false, method: "get" },
  { route: '/api/testimonials', handler: _lazy_RY2uvW, lazy: true, middleware: false, method: "get" },
  { route: '/__nuxt_error', handler: _lazy_US9tyS, lazy: true, middleware: false, method: undefined },
  { route: '/__nuxt_island/**', handler: _SxA8c9, lazy: false, middleware: false, method: undefined },
  { route: '/**', handler: _lazy_US9tyS, lazy: true, middleware: false, method: undefined }
];

function createNitroApp() {
  const config = useRuntimeConfig$1();
  const hooks = createHooks();
  const captureError = (error, context = {}) => {
    const promise = hooks.callHookParallel("error", error, context).catch((error_) => {
      console.error("Error while capturing another error", error_);
    });
    if (context.event && isEvent(context.event)) {
      const errors = context.event.context.nitro?.errors;
      if (errors) {
        errors.push({ error, context });
      }
      if (context.event.waitUntil) {
        context.event.waitUntil(promise);
      }
    }
  };
  const h3App = createApp({
    debug: destr(false),
    onError: (error, event) => {
      captureError(error, { event, tags: ["request"] });
      return errorHandler(error, event);
    },
    onRequest: async (event) => {
      event.context.nitro = event.context.nitro || { errors: [] };
      const fetchContext = event.node.req?.__unenv__;
      if (fetchContext?._platform) {
        event.context = {
          _platform: fetchContext?._platform,
          // #3335
          ...fetchContext._platform,
          ...event.context
        };
      }
      if (!event.context.waitUntil && fetchContext?.waitUntil) {
        event.context.waitUntil = fetchContext.waitUntil;
      }
      event.fetch = (req, init) => fetchWithEvent(event, req, init, { fetch: localFetch });
      event.$fetch = (req, init) => fetchWithEvent(event, req, init, {
        fetch: $fetch
      });
      event.waitUntil = (promise) => {
        if (!event.context.nitro._waitUntilPromises) {
          event.context.nitro._waitUntilPromises = [];
        }
        event.context.nitro._waitUntilPromises.push(promise);
        if (event.context.waitUntil) {
          event.context.waitUntil(promise);
        }
      };
      event.captureError = (error, context) => {
        captureError(error, { event, ...context });
      };
      await nitroApp$1.hooks.callHook("request", event).catch((error) => {
        captureError(error, { event, tags: ["request"] });
      });
    },
    onBeforeResponse: async (event, response) => {
      await nitroApp$1.hooks.callHook("beforeResponse", event, response).catch((error) => {
        captureError(error, { event, tags: ["request", "response"] });
      });
    },
    onAfterResponse: async (event, response) => {
      await nitroApp$1.hooks.callHook("afterResponse", event, response).catch((error) => {
        captureError(error, { event, tags: ["request", "response"] });
      });
    }
  });
  const router = createRouter({
    preemptive: true
  });
  const nodeHandler = toNodeListener(h3App);
  const localCall = (aRequest) => b(
    nodeHandler,
    aRequest
  );
  const localFetch = (input, init) => {
    if (!input.toString().startsWith("/")) {
      return globalThis.fetch(input, init);
    }
    return C(
      nodeHandler,
      input,
      init
    ).then((response) => normalizeFetchResponse(response));
  };
  const $fetch = createFetch({
    fetch: localFetch,
    Headers: Headers$1,
    defaults: { baseURL: config.app.baseURL }
  });
  globalThis.$fetch = $fetch;
  h3App.use(createRouteRulesHandler({ localFetch }));
  for (const h of handlers) {
    let handler = h.lazy ? lazyEventHandler(h.handler) : h.handler;
    if (h.middleware || !h.route) {
      const middlewareBase = (config.app.baseURL + (h.route || "/")).replace(
        /\/+/g,
        "/"
      );
      h3App.use(middlewareBase, handler);
    } else {
      const routeRules = getRouteRulesForPath(
        h.route.replace(/:\w+|\*\*/g, "_")
      );
      if (routeRules.cache) {
        handler = cachedEventHandler(handler, {
          group: "nitro/routes",
          ...routeRules.cache
        });
      }
      router.use(h.route, handler, h.method);
    }
  }
  h3App.use(config.app.baseURL, router.handler);
  const app = {
    hooks,
    h3App,
    router,
    localCall,
    localFetch,
    captureError
  };
  return app;
}
function runNitroPlugins(nitroApp2) {
  for (const plugin of plugins$1) {
    try {
      plugin(nitroApp2);
    } catch (error) {
      nitroApp2.captureError(error, { tags: ["plugin"] });
      throw error;
    }
  }
}
const nitroApp$1 = createNitroApp();
function useNitroApp() {
  return nitroApp$1;
}
runNitroPlugins(nitroApp$1);

function defineRenderHandler(render) {
  const runtimeConfig = useRuntimeConfig$1();
  return eventHandler(async (event) => {
    const nitroApp = useNitroApp();
    const ctx = { event, render, response: void 0 };
    await nitroApp.hooks.callHook("render:before", ctx);
    if (!ctx.response) {
      if (event.path === `${runtimeConfig.app.baseURL}favicon.ico`) {
        setResponseHeader(event, "Content-Type", "image/x-icon");
        return send(
          event,
          "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
        );
      }
      ctx.response = await ctx.render(event);
      if (!ctx.response) {
        const _currentStatus = getResponseStatus(event);
        setResponseStatus(event, _currentStatus === 200 ? 500 : _currentStatus);
        return send(
          event,
          "No response returned from render handler: " + event.path
        );
      }
    }
    await nitroApp.hooks.callHook("render:response", ctx.response, ctx);
    if (ctx.response.headers) {
      setResponseHeaders(event, ctx.response.headers);
    }
    if (ctx.response.statusCode || ctx.response.statusMessage) {
      setResponseStatus(
        event,
        ctx.response.statusCode,
        ctx.response.statusMessage
      );
    }
    return ctx.response.body;
  });
}

function parse(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  const obj = {};
  const opt = options || {};
  const dec = opt.decode || decode;
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if (opt?.filter && !opt?.filter(key)) {
      index = endIdx + 1;
      continue;
    }
    if (void 0 === obj[key]) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.codePointAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
}
function decode(str) {
  return str.includes("%") ? decodeURIComponent(str) : str;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch {
    return str;
  }
}

const debug = (...args) => {
};
function GracefulShutdown(server, opts) {
  opts = opts || {};
  const options = Object.assign(
    {
      signals: "SIGINT SIGTERM",
      timeout: 3e4,
      development: false,
      forceExit: true,
      onShutdown: (signal) => Promise.resolve(signal),
      preShutdown: (signal) => Promise.resolve(signal)
    },
    opts
  );
  let isShuttingDown = false;
  const connections = {};
  let connectionCounter = 0;
  const secureConnections = {};
  let secureConnectionCounter = 0;
  let failed = false;
  let finalRun = false;
  function onceFactory() {
    let called = false;
    return (emitter, events, callback) => {
      function call() {
        if (!called) {
          called = true;
          return Reflect.apply(callback, this, arguments);
        }
      }
      for (const e of events) {
        emitter.on(e, call);
      }
    };
  }
  const signals = options.signals.split(" ").map((s) => s.trim()).filter((s) => s.length > 0);
  const once = onceFactory();
  once(process, signals, (signal) => {
    debug("received shut down signal", signal);
    shutdown(signal).then(() => {
      if (options.forceExit) {
        process.exit(failed ? 1 : 0);
      }
    }).catch((error) => {
      debug("server shut down error occurred", error);
      process.exit(1);
    });
  });
  function isFunction(functionToCheck) {
    const getType = Object.prototype.toString.call(functionToCheck);
    return /^\[object\s([A-Za-z]+)?Function]$/.test(getType);
  }
  function destroy(socket, force = false) {
    if (socket._isIdle && isShuttingDown || force) {
      socket.destroy();
      if (socket.server instanceof http$4.Server) {
        delete connections[socket._connectionId];
      } else {
        delete secureConnections[socket._connectionId];
      }
    }
  }
  function destroyAllConnections(force = false) {
    debug("Destroy Connections : " + (force ? "forced close" : "close"));
    let counter = 0;
    let secureCounter = 0;
    for (const key of Object.keys(connections)) {
      const socket = connections[key];
      const serverResponse = socket._httpMessage;
      if (serverResponse && !force) {
        if (!serverResponse.headersSent) {
          serverResponse.setHeader("connection", "close");
        }
      } else {
        counter++;
        destroy(socket);
      }
    }
    debug("Connections destroyed : " + counter);
    debug("Connection Counter    : " + connectionCounter);
    for (const key of Object.keys(secureConnections)) {
      const socket = secureConnections[key];
      const serverResponse = socket._httpMessage;
      if (serverResponse && !force) {
        if (!serverResponse.headersSent) {
          serverResponse.setHeader("connection", "close");
        }
      } else {
        secureCounter++;
        destroy(socket);
      }
    }
    debug("Secure Connections destroyed : " + secureCounter);
    debug("Secure Connection Counter    : " + secureConnectionCounter);
  }
  server.on("request", (req, res) => {
    req.socket._isIdle = false;
    if (isShuttingDown && !res.headersSent) {
      res.setHeader("connection", "close");
    }
    res.on("finish", () => {
      req.socket._isIdle = true;
      destroy(req.socket);
    });
  });
  server.on("connection", (socket) => {
    if (isShuttingDown) {
      socket.destroy();
    } else {
      const id = connectionCounter++;
      socket._isIdle = true;
      socket._connectionId = id;
      connections[id] = socket;
      socket.once("close", () => {
        delete connections[socket._connectionId];
      });
    }
  });
  server.on("secureConnection", (socket) => {
    if (isShuttingDown) {
      socket.destroy();
    } else {
      const id = secureConnectionCounter++;
      socket._isIdle = true;
      socket._connectionId = id;
      secureConnections[id] = socket;
      socket.once("close", () => {
        delete secureConnections[socket._connectionId];
      });
    }
  });
  process.on("close", () => {
    debug("closed");
  });
  function shutdown(sig) {
    function cleanupHttp() {
      destroyAllConnections();
      debug("Close http server");
      return new Promise((resolve, reject) => {
        server.close((err) => {
          if (err) {
            return reject(err);
          }
          return resolve(true);
        });
      });
    }
    debug("shutdown signal - " + sig);
    if (options.development) {
      debug("DEV-Mode - immediate forceful shutdown");
      return process.exit(0);
    }
    function finalHandler() {
      if (!finalRun) {
        finalRun = true;
        if (options.finally && isFunction(options.finally)) {
          debug("executing finally()");
          options.finally();
        }
      }
      return Promise.resolve();
    }
    function waitForReadyToShutDown(totalNumInterval) {
      debug(`waitForReadyToShutDown... ${totalNumInterval}`);
      if (totalNumInterval === 0) {
        debug(
          `Could not close connections in time (${options.timeout}ms), will forcefully shut down`
        );
        return Promise.resolve(true);
      }
      const allConnectionsClosed = Object.keys(connections).length === 0 && Object.keys(secureConnections).length === 0;
      if (allConnectionsClosed) {
        debug("All connections closed. Continue to shutting down");
        return Promise.resolve(false);
      }
      debug("Schedule the next waitForReadyToShutdown");
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(waitForReadyToShutDown(totalNumInterval - 1));
        }, 250);
      });
    }
    if (isShuttingDown) {
      return Promise.resolve();
    }
    debug("shutting down");
    return options.preShutdown(sig).then(() => {
      isShuttingDown = true;
      cleanupHttp();
    }).then(() => {
      const pollIterations = options.timeout ? Math.round(options.timeout / 250) : 0;
      return waitForReadyToShutDown(pollIterations);
    }).then((force) => {
      debug("Do onShutdown now");
      if (force) {
        destroyAllConnections(force);
      }
      return options.onShutdown(sig);
    }).then(finalHandler).catch((error) => {
      const errString = typeof error === "string" ? error : JSON.stringify(error);
      debug(errString);
      failed = true;
      throw errString;
    });
  }
  function shutdownManual() {
    return shutdown("manual");
  }
  return shutdownManual;
}

function getGracefulShutdownConfig() {
  return {
    disabled: !!process.env.NITRO_SHUTDOWN_DISABLED,
    signals: (process.env.NITRO_SHUTDOWN_SIGNALS || "SIGTERM SIGINT").split(" ").map((s) => s.trim()),
    timeout: Number.parseInt(process.env.NITRO_SHUTDOWN_TIMEOUT || "", 10) || 3e4,
    forceExit: !process.env.NITRO_SHUTDOWN_NO_FORCE_EXIT
  };
}
function setupGracefulShutdown(listener, nitroApp) {
  const shutdownConfig = getGracefulShutdownConfig();
  if (shutdownConfig.disabled) {
    return;
  }
  GracefulShutdown(listener, {
    signals: shutdownConfig.signals.join(" "),
    timeout: shutdownConfig.timeout,
    forceExit: shutdownConfig.forceExit,
    onShutdown: async () => {
      await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          console.warn("Graceful shutdown timeout, force exiting...");
          resolve();
        }, shutdownConfig.timeout);
        nitroApp.hooks.callHook("close").catch((error) => {
          console.error(error);
        }).finally(() => {
          clearTimeout(timeout);
          resolve();
        });
      });
    }
  });
}

const cert = process.env.NITRO_SSL_CERT;
const key = process.env.NITRO_SSL_KEY;
const nitroApp = useNitroApp();
const server$1 = cert && key ? new Server$2({ key, cert }, toNodeListener(nitroApp.h3App)) : new Server$3(toNodeListener(nitroApp.h3App));
const port = destr(process.env.NITRO_PORT || process.env.PORT) || 3e3;
const host = process.env.NITRO_HOST || process.env.HOST;
const path = process.env.NITRO_UNIX_SOCKET;
const listener = server$1.listen(path ? { path } : { port, host }, (err) => {
  if (err) {
    console.error(err);
    process.exit(1);
  }
  const protocol = cert && key ? "https" : "http";
  const addressInfo = listener.address();
  if (typeof addressInfo === "string") {
    console.log(`Listening on unix socket ${addressInfo}`);
    return;
  }
  const baseURL = (useRuntimeConfig$1().app.baseURL || "").replace(/\/$/, "");
  const url = `${protocol}://${addressInfo.family === "IPv6" ? `[${addressInfo.address}]` : addressInfo.address}:${addressInfo.port}${baseURL}`;
  console.log(`Listening on ${url}`);
});
trapUnhandledNodeErrors();
setupGracefulShutdown(listener, nitroApp);
{
  const { handleUpgrade } = nodeAdapter(nitroApp.h3App.websocket);
  server$1.on("upgrade", handleUpgrade);
}
const nodeServer = {};

const _messages = { "appName": "Nuxt", "statusCode": 500, "statusMessage": "Internal server error", "description": "This page is temporarily unavailable.", "refresh": "Refresh this page" };
const template$1 = (messages) => {
  messages = { ..._messages, ...messages };
  return '<!DOCTYPE html><html lang="en"><head><title>' + escapeHtml(messages.statusCode) + " - " + escapeHtml(messages.statusMessage) + " | " + escapeHtml(messages.appName) + `</title><meta charset="utf-8"><meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport"><script>!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();<\/script><style>*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1,h2{font-size:inherit;font-weight:inherit}h1,h2,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }.grid{display:grid}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.max-w-520px{max-width:520px}.min-h-screen{min-height:100vh}.place-content-center{place-content:center}.overflow-hidden{overflow:hidden}.bg-white{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.px-2{padding-left:.5rem;padding-right:.5rem}.text-center{text-align:center}.text-\\[80px\\]{font-size:80px}.text-2xl{font-size:1.5rem;line-height:2rem}.text-\\[\\#020420\\]{--un-text-opacity:1;color:rgb(2 4 32/var(--un-text-opacity))}.text-\\[\\#64748B\\]{--un-text-opacity:1;color:rgb(100 116 139/var(--un-text-opacity))}.font-semibold{font-weight:600}.leading-none{line-height:1}.tracking-wide{letter-spacing:.025em}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.tabular-nums{--un-numeric-spacing:tabular-nums;font-variant-numeric:var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media(prefers-color-scheme:dark){.dark\\:bg-\\[\\#020420\\]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:text-white{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media(min-width:640px){.sm\\:text-\\[110px\\]{font-size:110px}.sm\\:text-3xl{font-size:1.875rem;line-height:2.25rem}}</style></head><body class="antialiased bg-white dark:bg-[#020420] dark:text-white font-sans grid min-h-screen overflow-hidden place-content-center text-[#020420] tracking-wide"><div class="max-w-520px text-center"><h1 class="font-semibold leading-none mb-4 sm:text-[110px] tabular-nums text-[80px]">` + escapeHtml(messages.statusCode) + '</h1><h2 class="font-semibold mb-2 sm:text-3xl text-2xl">' + escapeHtml(messages.statusMessage) + '</h2><p class="mb-4 px-2 text-[#64748B] text-md">' + escapeHtml(messages.description) + "</p></div></body></html>";
};

const error500 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  template: template$1
}, Symbol.toStringTag, { value: 'Module' }));

async function requireAuth(event) {
  var _a;
  const token = getCookie(event, "access_token") || ((_a = getHeader(event, "authorization")) == null ? void 0 : _a.replace("Bearer ", ""));
  if (!token) {
    throw createError$2({
      statusCode: 401,
      message: "Authentication required"
    });
  }
  try {
    const payload = verifyAccessToken(token);
    event.context.user = payload;
    return payload;
  } catch (error) {
    throw createError$2({
      statusCode: 401,
      message: "Session expired due to inactivity"
    });
  }
}

const articles_get$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  const status = queryParams.status;
  const category = queryParams.category;
  let sql = `
    SELECT 
      a.id,
      a.title,
      a.slug,
      a.excerpt,
      a.category,
      a.icon,
      a.featured_image_url,
      a.status,
      a.is_featured,
      a.view_count,
      a.display_order,
      a.published_at,
      a.created_at,
      a.updated_at,
      u.first_name as author_first_name,
      u.last_name as author_last_name
    FROM articles a
    LEFT JOIN users u ON a.author_id = u.id
    WHERE 1=1
  `;
  const params = [];
  if (search) {
    sql += ` AND (a.title LIKE ? OR a.excerpt LIKE ? OR a.content LIKE ?)`;
    const searchPattern = `%${search}%`;
    params.push(searchPattern, searchPattern, searchPattern);
  }
  if (status) {
    sql += ` AND a.status = ?`;
    params.push(status);
  }
  if (category) {
    sql += ` AND a.category = ?`;
    params.push(category);
  }
  sql += ` ORDER BY a.display_order ASC, a.created_at DESC`;
  try {
    const articles = await query(sql, params);
    return {
      success: true,
      data: articles
    };
  } catch (error) {
    console.error("Error fetching articles:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch articles"
    });
  }
});

const articles_get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: articles_get$2
}, Symbol.toStringTag, { value: 'Module' }));

function generateSlug$1(title) {
  return title.toLowerCase().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").trim();
}
const articles_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const body = await readBody();
  if (!body.title || !body.content) {
    throw createError$2({
      statusCode: 400,
      message: "Title and content are required"
    });
  }
  let slug = body.slug || generateSlug$1(body.title);
  let uniqueSlug = slug;
  let counter = 1;
  while (true) {
    const existing = await query(
      "SELECT id FROM articles WHERE slug = ?",
      [uniqueSlug]
    );
    if (existing.length === 0) break;
    uniqueSlug = `${slug}-${counter}`;
    counter++;
  }
  const validStatuses = ["draft", "published", "archived"];
  const status = body.status && validStatuses.includes(body.status) ? body.status : "draft";
  let publishedAt = body.published_at ? new Date(body.published_at) : null;
  if (status === "published" && !publishedAt) {
    publishedAt = /* @__PURE__ */ new Date();
  }
  if (status !== "published") {
    publishedAt = null;
  }
  try {
    const result = await execute(
      `INSERT INTO articles (
        title, slug, excerpt, content, category, icon, 
        featured_image_url, author_id, status, is_featured, 
        display_order, published_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        body.title,
        uniqueSlug,
        body.excerpt || null,
        body.content,
        body.category || null,
        body.icon || null,
        body.featured_image_url || null,
        auth.userId,
        status,
        body.is_featured || false,
        body.display_order || 0,
        publishedAt
      ]
    );
    return {
      success: true,
      data: {
        id: result.insertId,
        slug: uniqueSlug
      }
    };
  } catch (error) {
    console.error("Error creating article:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to create article"
    });
  }
});

const articles_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: articles_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$s = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const articleId = parseInt(getRouterParam(event, "id") || "0");
  if (!articleId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid article ID"
    });
  }
  const existing = await query(
    "SELECT id FROM articles WHERE id = ?",
    [articleId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Article not found"
    });
  }
  try {
    await execute("DELETE FROM articles WHERE id = ?", [articleId]);
    return {
      success: true,
      message: "Article deleted successfully"
    };
  } catch (error) {
    console.error("Error deleting article:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete article"
    });
  }
});

const _id__delete$t = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$s
}, Symbol.toStringTag, { value: 'Module' }));

function generateSlug(title) {
  return title.toLowerCase().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").trim();
}
const _id__put$u = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const articleId = parseInt(getRouterParam(event, "id") || "0");
  if (!articleId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid article ID"
    });
  }
  const body = await readBody();
  const existing = await query(
    "SELECT id, slug, title FROM articles WHERE id = ?",
    [articleId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Article not found"
    });
  }
  let slug = body.slug;
  if (body.title && !body.slug) {
    slug = generateSlug(body.title);
  }
  if (slug && slug !== existing[0].slug) {
    let uniqueSlug = slug;
    let counter = 1;
    while (true) {
      const slugCheck = await query(
        "SELECT id FROM articles WHERE slug = ? AND id != ?",
        [uniqueSlug, articleId]
      );
      if (slugCheck.length === 0) break;
      uniqueSlug = `${slug}-${counter}`;
      counter++;
    }
    slug = uniqueSlug;
  }
  const validStatuses = ["draft", "published", "archived"];
  let status = body.status;
  if (status && !validStatuses.includes(status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid status"
    });
  }
  let publishedAt = null;
  if (body.published_at) {
    publishedAt = new Date(body.published_at);
  } else if (status === "published") {
    const currentArticle = await query(
      "SELECT published_at, status FROM articles WHERE id = ?",
      [articleId]
    );
    if (currentArticle.length > 0 && !currentArticle[0].published_at) {
      publishedAt = /* @__PURE__ */ new Date();
    }
  }
  const updates = [];
  const values = [];
  if (body.title !== void 0) {
    updates.push("title = ?");
    values.push(body.title);
  }
  if (slug !== void 0) {
    updates.push("slug = ?");
    values.push(slug);
  }
  if (body.excerpt !== void 0) {
    updates.push("excerpt = ?");
    values.push(body.excerpt);
  }
  if (body.content !== void 0) {
    updates.push("content = ?");
    values.push(body.content);
  }
  if (body.category !== void 0) {
    updates.push("category = ?");
    values.push(body.category);
  }
  if (body.icon !== void 0) {
    updates.push("icon = ?");
    values.push(body.icon);
  }
  if (body.featured_image_url !== void 0) {
    updates.push("featured_image_url = ?");
    values.push(body.featured_image_url);
  }
  if (status !== void 0) {
    updates.push("status = ?");
    values.push(status);
  }
  if (body.is_featured !== void 0) {
    updates.push("is_featured = ?");
    values.push(body.is_featured);
  }
  if (body.display_order !== void 0) {
    updates.push("display_order = ?");
    values.push(body.display_order);
  }
  if (publishedAt !== void 0) {
    updates.push("published_at = ?");
    values.push(publishedAt);
  }
  if (updates.length === 0) {
    throw createError$2({
      statusCode: 400,
      message: "No fields to update"
    });
  }
  values.push(articleId);
  try {
    await execute(
      `UPDATE articles SET ${updates.join(", ")} WHERE id = ?`,
      values
    );
    return {
      success: true,
      message: "Article updated successfully"
    };
  } catch (error) {
    console.error("Error updating article:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update article"
    });
  }
});

const _id__put$v = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$u
}, Symbol.toStringTag, { value: 'Module' }));

const branches_get$4 = defineEventHandler(async (event) => {
  await requireAuth(event);
  try {
    const branches = await query(
      `SELECT 
        id,
        name,
        code,
        address,
        phone,
        email,
        status,
        created_at,
        updated_at
      FROM branches
      WHERE status = 'active'
      ORDER BY name ASC`
    );
    return {
      success: true,
      data: branches
    };
  } catch (error) {
    console.error("Error fetching branches:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch branches"
    });
  }
});

const branches_get$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: branches_get$4
}, Symbol.toStringTag, { value: 'Module' }));

const rooms_get$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const user = await getUserWithRoles(auth.userId);
  const adminRoles = [UserRole.SYSTEM_ADMIN, UserRole.OWNER, UserRole.ADMIN];
  if (!user || !adminRoles.some((role) => user.roles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const query = getQuery(event);
  const limit = parseInt(query.limit) || 50;
  const offset = parseInt(query.offset) || 0;
  const filters = {};
  if (query.status) {
    filters.status = query.status;
  }
  if (query.courseId) {
    filters.courseId = parseInt(query.courseId);
  }
  if (query.studentId) {
    filters.studentId = parseInt(query.studentId);
  }
  if (query.tutorId) {
    filters.tutorId = parseInt(query.tutorId);
  }
  try {
    const result = await getAllChatRooms(limit, offset, filters);
    return {
      success: true,
      data: result.rooms,
      pagination: {
        total: result.total,
        limit,
        offset,
        totalPages: Math.ceil(result.total / limit)
      }
    };
  } catch (error) {
    console.error("[API] Error fetching chat rooms (admin):", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch chat rooms"
    });
  }
});

const rooms_get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: rooms_get$2
}, Symbol.toStringTag, { value: 'Module' }));

const _roomId__get$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const user = await getUserWithRoles(auth.userId);
  const adminRoles = [UserRole.SYSTEM_ADMIN, UserRole.OWNER, UserRole.ADMIN];
  if (!user || !adminRoles.some((role) => user.roles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  try {
    const room = await getChatRoom(roomId);
    if (!room) {
      throw createError$2({
        statusCode: 404,
        message: "Chat room not found"
      });
    }
    return {
      success: true,
      data: room
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("[API] Error fetching chat room (admin):", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch chat room"
    });
  }
});

const _roomId__get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _roomId__get$2
}, Symbol.toStringTag, { value: 'Module' }));

const contentPages_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = [UserRole.SYSTEM_ADMIN, UserRole.OWNER, UserRole.ADMIN];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  try {
    const pages = await query(
      "SELECT id, slug, title, content, meta_title, meta_description, meta_keywords, is_active, display_order, created_by, created_at, updated_at FROM content_pages ORDER BY display_order ASC, title ASC"
    );
    return {
      success: true,
      data: pages
    };
  } catch (error) {
    console.error("Error fetching content pages:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch content pages"
    });
  }
});

const contentPages_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: contentPages_get
}, Symbol.toStringTag, { value: 'Module' }));

const contentPages_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = [UserRole.SYSTEM_ADMIN, UserRole.OWNER, UserRole.ADMIN];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const body = await readBody(event);
  const { slug, title, content, meta_title, meta_description, meta_keywords, is_active, display_order } = body;
  if (!slug || !title) {
    throw createError$2({
      statusCode: 400,
      message: "Slug and title are required"
    });
  }
  const existing = await query(
    "SELECT id FROM content_pages WHERE slug = ? LIMIT 1",
    [slug]
  );
  if (existing.length > 0) {
    throw createError$2({
      statusCode: 400,
      message: "Page with this slug already exists"
    });
  }
  try {
    const result = await query(
      `INSERT INTO content_pages (slug, title, content, meta_title, meta_description, meta_keywords, is_active, display_order, created_by)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        slug,
        title,
        content || null,
        meta_title || null,
        meta_description || null,
        meta_keywords || null,
        is_active !== void 0 ? is_active : true,
        display_order || 0,
        auth.userId
      ]
    );
    const [newPage] = await query(
      "SELECT * FROM content_pages WHERE id = ? LIMIT 1",
      [result.insertId]
    );
    return {
      success: true,
      data: newPage
    };
  } catch (error) {
    console.error("Error creating content page:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to create content page"
    });
  }
});

const contentPages_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: contentPages_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$q = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = [UserRole.SYSTEM_ADMIN, UserRole.OWNER, UserRole.ADMIN];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const id = parseInt(getRouterParam(event, "id") || "0");
  if (!id || isNaN(id)) {
    throw createError$2({
      statusCode: 400,
      message: "Valid ID is required"
    });
  }
  const existing = await query(
    "SELECT id FROM content_pages WHERE id = ? LIMIT 1",
    [id]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Page not found"
    });
  }
  try {
    await query("DELETE FROM content_pages WHERE id = ?", [id]);
    return {
      success: true,
      message: "Page deleted successfully"
    };
  } catch (error) {
    console.error("Error deleting content page:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete content page"
    });
  }
});

const _id__delete$r = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$q
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$s = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = [UserRole.SYSTEM_ADMIN, UserRole.OWNER, UserRole.ADMIN];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const id = parseInt(getRouterParam(event, "id") || "0");
  if (!id || isNaN(id)) {
    throw createError$2({
      statusCode: 400,
      message: "Valid ID is required"
    });
  }
  const body = await readBody(event);
  const { slug, title, content, meta_title, meta_description, meta_keywords, is_active, display_order } = body;
  if (!slug || !title) {
    throw createError$2({
      statusCode: 400,
      message: "Slug and title are required"
    });
  }
  const existing = await query(
    "SELECT id, slug FROM content_pages WHERE id = ? LIMIT 1",
    [id]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Page not found"
    });
  }
  if (slug !== existing[0].slug) {
    const slugCheck = await query(
      "SELECT id FROM content_pages WHERE slug = ? AND id != ? LIMIT 1",
      [slug, id]
    );
    if (slugCheck.length > 0) {
      throw createError$2({
        statusCode: 400,
        message: "Page with this slug already exists"
      });
    }
  }
  try {
    await query(
      `UPDATE content_pages 
       SET slug = ?, title = ?, content = ?, meta_title = ?, meta_description = ?, meta_keywords = ?, 
           is_active = ?, display_order = ?, updated_at = CURRENT_TIMESTAMP
       WHERE id = ?`,
      [
        slug,
        title,
        content || null,
        meta_title || null,
        meta_description || null,
        meta_keywords || null,
        is_active !== void 0 ? is_active : true,
        display_order || 0,
        id
      ]
    );
    const [updatedPage] = await query(
      "SELECT * FROM content_pages WHERE id = ? LIMIT 1",
      [id]
    );
    return {
      success: true,
      data: updatedPage
    };
  } catch (error) {
    console.error("Error updating content page:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update content page"
    });
  }
});

const _id__put$t = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$s
}, Symbol.toStringTag, { value: 'Module' }));

const courses_get$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = [UserRole.SYSTEM_ADMIN, UserRole.OWNER, UserRole.ADMIN, UserRole.BRANCH_ADMIN, UserRole.TUTOR];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin or Tutor role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  const type = queryParams.type;
  const status = queryParams.status;
  const isSystemAdmin = roles.includes(UserRole.SYSTEM_ADMIN) || roles.includes(UserRole.OWNER);
  const isAdmin = roles.includes(UserRole.ADMIN);
  const isBranchAdmin = roles.includes(UserRole.BRANCH_ADMIN);
  const isTutor = roles.includes(UserRole.TUTOR);
  let courseIds = [];
  if (isTutor && !isSystemAdmin && !isAdmin && !isBranchAdmin) {
    const tutors = await query(
      "SELECT id FROM tutors WHERE user_id = ?",
      [auth.userId]
    );
    if (tutors.length === 0 || !tutors[0]) {
      return {
        success: true,
        data: []
      };
    }
    const tutorId = tutors[0].id;
    const tutorCourses = await query(
      "SELECT DISTINCT course_id FROM tutor_courses WHERE tutor_id = ?",
      [tutorId]
    );
    courseIds = tutorCourses.map((tc) => tc.course_id);
    if (courseIds.length === 0) {
      return {
        success: true,
        data: []
      };
    }
  }
  let sql = `
    SELECT 
      c.id,
      c.title,
      c.description,
      c.type,
      c.price,
      c.duration_hours,
      c.level,
      c.status,
      c.code,
      c.created_at,
      c.updated_at,
      u.first_name as created_by_name,
      u.last_name as created_by_last_name
    FROM courses c
    LEFT JOIN users u ON c.created_by = u.id
    WHERE 1=1
  `;
  const params = [];
  if (isTutor && !isSystemAdmin && !isAdmin && !isBranchAdmin && courseIds.length > 0) {
    sql += ` AND c.id IN (${courseIds.map(() => "?").join(",")})`;
    params.push(...courseIds);
  }
  if (search) {
    sql += ` AND (c.title LIKE ? OR c.code LIKE ? OR c.description LIKE ?)`;
    const searchPattern = `%${search}%`;
    params.push(searchPattern, searchPattern, searchPattern);
  }
  if (type) {
    sql += ` AND c.type = ?`;
    params.push(type);
  }
  if (status) {
    sql += ` AND c.status = ?`;
    params.push(status);
  }
  sql += ` ORDER BY c.created_at DESC`;
  try {
    const courses = await query(sql, params);
    return {
      success: true,
      data: courses
    };
  } catch (error) {
    console.error("Error fetching courses:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch courses"
    });
  }
});

const courses_get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: courses_get$2
}, Symbol.toStringTag, { value: 'Module' }));

const courses_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const body = await readBody(event);
  if (!body.title || !body.type || body.price === void 0) {
    throw createError$2({
      statusCode: 400,
      message: "Title, type, and price are required"
    });
  }
  const validTypes = ["live_online", "vod", "hybrid"];
  if (!validTypes.includes(body.type)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course type"
    });
  }
  const validStatuses = ["draft", "published", "archived"];
  if (body.status && !validStatuses.includes(body.status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course status"
    });
  }
  if (body.code) {
    const existing = await query(
      "SELECT id FROM courses WHERE code = ?",
      [body.code]
    );
    if (existing.length > 0) {
      throw createError$2({
        statusCode: 409,
        message: "Course code already exists"
      });
    }
  }
  if (body.branches && !Array.isArray(body.branches)) {
    throw createError$2({
      statusCode: 400,
      message: "Branches must be an array"
    });
  }
  if (body.branches && body.branches.length > 0) {
    const branchIds = body.branches.map((b) => {
      const id = typeof b === "object" ? b.branch_id : b;
      return id ? parseInt(id, 10) : null;
    }).filter((id) => id !== null && !isNaN(id));
    if (branchIds.length > 0) {
      const existingBranches = await query(
        `SELECT id FROM branches WHERE id IN (${branchIds.map(() => "?").join(",")}) AND status = "active"`,
        branchIds
      );
      if (existingBranches.length !== branchIds.length) {
        throw createError$2({
          statusCode: 400,
          message: "One or more branch IDs are invalid or inactive"
        });
      }
    }
  }
  try {
    const result = await execute(
      `INSERT INTO courses (
        title, description, thumbnail_url, type, price, duration_hours, level, status, code, created_by
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        body.title,
        body.description || null,
        body.thumbnail_url || null,
        body.type,
        body.price,
        body.duration_hours || null,
        body.level || null,
        body.status || "draft",
        body.code || null,
        auth.userId
      ]
    );
    const courseId = result.insertId;
    if (body.images && Array.isArray(body.images) && body.images.length > 0) {
      for (const image of body.images) {
        await execute(
          `INSERT INTO course_images (course_id, image_url, image_type, display_order, alt_text)
           VALUES (?, ?, ?, ?, ?)`,
          [
            courseId,
            image.image_url,
            image.image_type || "gallery",
            image.display_order || 0,
            image.alt_text || null
          ]
        );
      }
    }
    if (body.branches && Array.isArray(body.branches) && body.branches.length > 0) {
      for (const branch of body.branches) {
        const branchId = typeof branch === "object" ? branch.branch_id : branch;
        const seatLimit = typeof branch === "object" ? branch.seat_limit || null : null;
        const isAvailable = typeof branch === "object" ? branch.is_available !== void 0 ? branch.is_available : true : true;
        await execute(
          `INSERT INTO course_branches (course_id, branch_id, seat_limit, is_available)
           VALUES (?, ?, ?, ?)`,
          [courseId, branchId, seatLimit, isAvailable]
        );
      }
    }
    const course = await query(
      "SELECT * FROM courses WHERE id = ?",
      [courseId]
    );
    const courseBranches = await query(
      `SELECT 
        cb.id,
        cb.course_id,
        cb.branch_id,
        cb.seat_limit,
        cb.current_enrollments,
        cb.is_available,
        b.name as branch_name,
        b.code as branch_code
      FROM course_branches cb
      INNER JOIN branches b ON cb.branch_id = b.id
      WHERE cb.course_id = ?`,
      [courseId]
    );
    const courseImages = await query(
      `SELECT 
        id,
        course_id,
        image_url,
        image_type,
        display_order,
        alt_text,
        created_at
      FROM course_images
      WHERE course_id = ?
      ORDER BY display_order ASC, created_at ASC`,
      [courseId]
    );
    return {
      success: true,
      data: {
        ...course[0],
        branches: courseBranches.map((cb) => ({
          id: cb.id,
          branch_id: cb.branch_id,
          branch_name: cb.branch_name,
          branch_code: cb.branch_code,
          seat_limit: cb.seat_limit,
          current_enrollments: cb.current_enrollments,
          is_available: cb.is_available
        })),
        images: courseImages
      }
    };
  } catch (error) {
    console.error("Error creating course:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to create course"
    });
  }
});

const courses_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: courses_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$o = defineEventHandler(async (event) => {
  await requireAuth(event);
  const courseId = parseInt(getRouterParam(event, "id") || "0");
  if (!courseId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course ID"
    });
  }
  const existing = await query(
    "SELECT id FROM courses WHERE id = ?",
    [courseId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Course not found"
    });
  }
  const enrollments = await query(
    "SELECT id FROM enrollments WHERE course_id = ? LIMIT 1",
    [courseId]
  );
  if (enrollments.length > 0) {
    throw createError$2({
      statusCode: 409,
      message: "Cannot delete course with existing enrollments"
    });
  }
  try {
    await execute(
      "DELETE FROM courses WHERE id = ?",
      [courseId]
    );
    return {
      success: true,
      message: "Course deleted successfully"
    };
  } catch (error) {
    console.error("Error deleting course:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete course"
    });
  }
});

const _id__delete$p = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$o
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get$c = defineEventHandler(async (event) => {
  var _a;
  await requireAuth(event);
  const courseId = parseInt(getRouterParam(event, "id") || "0");
  if (!courseId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course ID"
    });
  }
  try {
    let courses;
    let thumbnailUrl = null;
    try {
      courses = await query(
        `SELECT 
          c.id,
          c.title,
          c.description,
          c.type,
          c.price,
          c.duration_hours,
          c.level,
          c.status,
          c.code,
          c.created_by,
          c.created_at,
          c.updated_at,
          c.thumbnail_url,
          u.first_name as created_by_name,
          u.last_name as created_by_last_name
        FROM courses c
        LEFT JOIN users u ON c.created_by = u.id
        WHERE c.id = ?`,
        [courseId]
      );
      thumbnailUrl = ((_a = courses[0]) == null ? void 0 : _a.thumbnail_url) || null;
    } catch (err) {
      if (err.code === "ER_BAD_FIELD_ERROR" && err.message.includes("thumbnail_url")) {
        courses = await query(
          `SELECT 
            c.id,
            c.title,
            c.description,
            c.type,
            c.price,
            c.duration_hours,
            c.level,
            c.status,
            c.code,
            c.created_by,
            c.created_at,
            c.updated_at,
            u.first_name as created_by_name,
            u.last_name as created_by_last_name
          FROM courses c
          LEFT JOIN users u ON c.created_by = u.id
          WHERE c.id = ?`,
          [courseId]
        );
        thumbnailUrl = null;
      } else {
        throw err;
      }
    }
    if (courses.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Course not found"
      });
    }
    const course = courses[0];
    const courseBranches = await query(
      `SELECT 
        cb.id,
        cb.course_id,
        cb.branch_id,
        cb.seat_limit,
        cb.current_enrollments,
        cb.is_available,
        b.name as branch_name,
        b.code as branch_code,
        b.status as branch_status
      FROM course_branches cb
      INNER JOIN branches b ON cb.branch_id = b.id
      WHERE cb.course_id = ?`,
      [courseId]
    );
    let courseImages = [];
    try {
      courseImages = await query(
        `SELECT 
          id,
          course_id,
          image_url,
          image_type,
          display_order,
          alt_text,
          created_at
        FROM course_images
        WHERE course_id = ?
        ORDER BY display_order ASC, created_at ASC`,
        [courseId]
      );
    } catch (imgError) {
      console.warn("course_images table may not exist yet:", imgError.message);
      courseImages = [];
    }
    const enrollments = await query(
      `SELECT 
        e.id,
        e.status,
        e.created_at as enrolled_at,
        s.id as student_id,
        s.username as student_username,
        s.first_name as student_first_name,
        s.last_name as student_last_name,
        s.email as student_email,
        b.id as branch_id,
        b.name as branch_name,
        b.code as branch_code
      FROM enrollments e
      INNER JOIN users s ON e.student_id = s.id
      INNER JOIN branches b ON e.branch_id = b.id
      WHERE e.course_id = ?
      ORDER BY e.created_at DESC`,
      [courseId]
    );
    return {
      success: true,
      data: {
        course: {
          id: course.id,
          title: course.title,
          description: course.description,
          thumbnail_url: thumbnailUrl,
          type: course.type,
          price: course.price,
          duration_hours: course.duration_hours,
          level: course.level,
          status: course.status,
          code: course.code,
          created_at: course.created_at,
          updated_at: course.updated_at,
          created_by_name: course.created_by_name,
          created_by_last_name: course.created_by_last_name
        },
        branches: courseBranches.map((cb) => ({
          id: cb.id,
          branch_id: cb.branch_id,
          branch_name: cb.branch_name,
          branch_code: cb.branch_code,
          branch_status: cb.branch_status,
          seat_limit: cb.seat_limit,
          current_enrollments: cb.current_enrollments,
          is_available: cb.is_available
        })),
        images: courseImages,
        enrollments: enrollments.map((e) => ({
          id: e.id,
          status: e.status,
          enrolled_at: e.enrolled_at,
          student: {
            id: e.student_id,
            username: e.student_username,
            first_name: e.student_first_name,
            last_name: e.student_last_name,
            email: e.student_email
          },
          branch: {
            id: e.branch_id,
            name: e.branch_name,
            code: e.branch_code
          }
        }))
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error fetching course detail:", error);
    console.error("Error details:", {
      message: error.message,
      code: error.code,
      sqlState: error.sqlState
    });
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to fetch course detail",
      data: {
        originalError: void 0
      }
    });
  }
});

const _id__get$d = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get$c
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$q = defineEventHandler(async (event) => {
  await requireAuth(event);
  const courseId = parseInt(getRouterParam(event, "id") || "0");
  if (!courseId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course ID"
    });
  }
  const body = await readBody(event);
  if (!body.title || !body.type || body.price === void 0) {
    throw createError$2({
      statusCode: 400,
      message: "Title, type, and price are required"
    });
  }
  const validTypes = ["live_online", "vod", "hybrid"];
  if (!validTypes.includes(body.type)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course type"
    });
  }
  const validStatuses = ["draft", "published", "archived"];
  if (body.status && !validStatuses.includes(body.status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course status"
    });
  }
  const existing = await query(
    "SELECT id FROM courses WHERE id = ?",
    [courseId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Course not found"
    });
  }
  if (body.code) {
    const codeCheck = await query(
      "SELECT id FROM courses WHERE code = ? AND id != ?",
      [body.code, courseId]
    );
    if (codeCheck.length > 0) {
      throw createError$2({
        statusCode: 409,
        message: "Course code already exists"
      });
    }
  }
  if (body.branches !== void 0) {
    if (!Array.isArray(body.branches)) {
      throw createError$2({
        statusCode: 400,
        message: "Branches must be an array"
      });
    }
    if (body.branches.length > 0) {
      const branchIds = body.branches.map((b) => {
        const id = typeof b === "object" ? b.branch_id : b;
        return id ? parseInt(id, 10) : null;
      }).filter((id) => id !== null && !isNaN(id));
      if (branchIds.length > 0) {
        const placeholders = branchIds.map(() => "?").join(",");
        const existingBranches = await query(
          `SELECT id FROM branches WHERE id IN (${placeholders}) AND status = "active"`,
          branchIds
        );
        if (existingBranches.length !== branchIds.length) {
          throw createError$2({
            statusCode: 400,
            message: "One or more branch IDs are invalid or inactive"
          });
        }
      }
    }
  }
  try {
    await execute(
      `UPDATE courses SET
        title = ?,
        description = ?,
        thumbnail_url = ?,
        type = ?,
        price = ?,
        duration_hours = ?,
        level = ?,
        status = ?,
        code = ?,
        updated_at = CURRENT_TIMESTAMP
      WHERE id = ?`,
      [
        body.title,
        body.description || null,
        body.thumbnail_url || null,
        body.type,
        body.price,
        body.duration_hours || null,
        body.level || null,
        body.status,
        body.code || null,
        courseId
      ]
    );
    if (body.branches !== void 0) {
      const currentBranches = await query(
        "SELECT branch_id FROM course_branches WHERE course_id = ?",
        [courseId]
      );
      const currentBranchIds = currentBranches.map((b) => b.branch_id);
      const requestedBranchIds = body.branches.map(
        (b) => typeof b === "object" ? b.branch_id : b
      ).filter(Boolean);
      const branchesToDelete = currentBranchIds.filter(
        (id) => !requestedBranchIds.includes(id)
      );
      const branchesToAdd = body.branches.filter((b) => {
        const branchId = typeof b === "object" ? b.branch_id : b;
        return !currentBranchIds.includes(branchId);
      });
      const branchesToUpdate = body.branches.filter((b) => {
        const branchId = typeof b === "object" ? b.branch_id : b;
        return currentBranchIds.includes(branchId);
      });
      if (branchesToDelete.length > 0) {
        const deletePlaceholders = branchesToDelete.map(() => "?").join(",");
        await execute(
          `DELETE FROM course_branches WHERE course_id = ? AND branch_id IN (${deletePlaceholders})`,
          [courseId, ...branchesToDelete]
        );
      }
      for (const branch of branchesToAdd) {
        const branchId = typeof branch === "object" ? branch.branch_id : branch;
        const seatLimit = typeof branch === "object" ? branch.seat_limit || null : null;
        const isAvailable = typeof branch === "object" ? branch.is_available !== void 0 ? branch.is_available : true : true;
        await execute(
          `INSERT INTO course_branches (course_id, branch_id, seat_limit, is_available)
           VALUES (?, ?, ?, ?)`,
          [courseId, branchId, seatLimit, isAvailable]
        );
      }
      for (const branch of branchesToUpdate) {
        const branchId = typeof branch === "object" ? branch.branch_id : branch;
        const seatLimit = typeof branch === "object" ? branch.seat_limit : null;
        const isAvailable = typeof branch === "object" ? branch.is_available !== void 0 ? branch.is_available : true : true;
        await execute(
          `UPDATE course_branches 
           SET seat_limit = ?, is_available = ?
           WHERE course_id = ? AND branch_id = ?`,
          [seatLimit, isAvailable, courseId, branchId]
        );
      }
    }
    if (body.images !== void 0) {
      try {
        await execute(
          "DELETE FROM course_images WHERE course_id = ?",
          [courseId]
        );
        if (Array.isArray(body.images) && body.images.length > 0) {
          for (const image of body.images) {
            await execute(
              `INSERT INTO course_images (course_id, image_url, image_type, display_order, alt_text)
               VALUES (?, ?, ?, ?, ?)`,
              [
                courseId,
                image.image_url,
                image.image_type || "gallery",
                image.display_order || 0,
                image.alt_text || null
              ]
            );
          }
        }
      } catch (error) {
        console.warn("course_images table not found, skipping image updates:", error.message);
      }
    }
    const course = await query(
      "SELECT * FROM courses WHERE id = ?",
      [courseId]
    );
    const courseBranches = await query(
      `SELECT 
        cb.id,
        cb.course_id,
        cb.branch_id,
        cb.seat_limit,
        cb.current_enrollments,
        cb.is_available,
        b.name as branch_name,
        b.code as branch_code
      FROM course_branches cb
      INNER JOIN branches b ON cb.branch_id = b.id
      WHERE cb.course_id = ?`,
      [courseId]
    );
    let courseImages = [];
    try {
      courseImages = await query(
        `SELECT 
          id,
          course_id,
          image_url,
          image_type,
          display_order,
          alt_text,
          created_at
        FROM course_images
        WHERE course_id = ?
        ORDER BY display_order ASC, created_at ASC`,
        [courseId]
      );
    } catch (error) {
      console.warn("course_images table not found, skipping:", error.message);
      courseImages = [];
    }
    return {
      success: true,
      data: {
        ...course[0],
        branches: courseBranches.map((cb) => ({
          id: cb.id,
          branch_id: cb.branch_id,
          branch_name: cb.branch_name,
          branch_code: cb.branch_code,
          seat_limit: cb.seat_limit,
          current_enrollments: cb.current_enrollments,
          is_available: cb.is_available
        })),
        images: courseImages
      }
    };
  } catch (error) {
    console.error("Error updating course:", error);
    console.error("Error stack:", error.stack);
    console.error("Error details:", {
      message: error.message,
      code: error.code,
      errno: error.errno,
      sqlState: error.sqlState,
      sqlMessage: error.sqlMessage
    });
    throw createError$2({
      statusCode: 500,
      message: error.sqlMessage || error.message || "Failed to update course"
    });
  }
});

const _id__put$r = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$q
}, Symbol.toStringTag, { value: 'Module' }));

const images_post = defineEventHandler(async (event) => {
  await requireAuth(event);
  const courseId = parseInt(getRouterParam(event, "id") || "0");
  if (!courseId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course ID"
    });
  }
  const body = await readBody(event);
  if (!body.image_url) {
    throw createError$2({
      statusCode: 400,
      message: "image_url is required"
    });
  }
  const existing = await query(
    "SELECT id FROM courses WHERE id = ?",
    [courseId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Course not found"
    });
  }
  try {
    const result = await execute(
      `INSERT INTO course_images (course_id, image_url, image_type, display_order, alt_text)
       VALUES (?, ?, ?, ?, ?)`,
      [
        courseId,
        body.image_url,
        body.image_type || "gallery",
        body.display_order || 0,
        body.alt_text || null
      ]
    );
    const image = await query(
      "SELECT * FROM course_images WHERE id = ?",
      [result.insertId]
    );
    return {
      success: true,
      data: image[0]
    };
  } catch (error) {
    console.error("Error adding course image:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to add course image"
    });
  }
});

const images_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: images_post
}, Symbol.toStringTag, { value: 'Module' }));

const _imageId__delete = defineEventHandler(async (event) => {
  await requireAuth(event);
  const courseId = parseInt(getRouterParam(event, "id") || "0");
  const imageId = parseInt(getRouterParam(event, "imageId") || "0");
  if (!courseId || !imageId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course ID or image ID"
    });
  }
  const existing = await query(
    "SELECT id FROM course_images WHERE id = ? AND course_id = ?",
    [imageId, courseId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Course image not found"
    });
  }
  try {
    await execute(
      "DELETE FROM course_images WHERE id = ? AND course_id = ?",
      [imageId, courseId]
    );
    return {
      success: true,
      message: "Course image deleted successfully"
    };
  } catch (error) {
    console.error("Error deleting course image:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete course image"
    });
  }
});

const _imageId__delete$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _imageId__delete
}, Symbol.toStringTag, { value: 'Module' }));

const status_patch$8 = defineEventHandler(async (event) => {
  await requireAuth(event);
  const courseId = parseInt(getRouterParam(event, "id") || "0");
  if (!courseId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course ID"
    });
  }
  const body = await readBody(event);
  if (!body.status) {
    throw createError$2({
      statusCode: 400,
      message: "Status is required"
    });
  }
  const validStatuses = ["draft", "published", "archived"];
  if (!validStatuses.includes(body.status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course status"
    });
  }
  const existing = await query(
    "SELECT id FROM courses WHERE id = ?",
    [courseId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Course not found"
    });
  }
  try {
    await execute(
      "UPDATE courses SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
      [body.status, courseId]
    );
    const course = await query(
      "SELECT * FROM courses WHERE id = ?",
      [courseId]
    );
    return {
      success: true,
      data: course[0]
    };
  } catch (error) {
    console.error("Error updating course status:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update course status"
    });
  }
});

const status_patch$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: status_patch$8
}, Symbol.toStringTag, { value: 'Module' }));

const dashboard_get = defineEventHandler(async (event) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
  try {
    const auth = await requireAuth(event);
    const userId = auth.userId;
    const roles = await getUserRoles(userId);
    if (!roles || roles.length === 0) {
      throw createError$2({
        statusCode: 403,
        message: "User has no roles"
      });
    }
    const primaryRole = getHighestPriorityRole(roles);
    if (!primaryRole) {
      throw createError$2({
        statusCode: 403,
        message: "Could not determine user role"
      });
    }
    let userBranchId = null;
    if (primaryRole === "branch_admin") {
      try {
        const branchAdmins = await query(
          "SELECT branch_id FROM branch_admins WHERE user_id = ? LIMIT 1",
          [userId]
        );
        if (branchAdmins && branchAdmins.length > 0 && branchAdmins[0].branch_id) {
          userBranchId = branchAdmins[0].branch_id;
        }
      } catch (error) {
      }
    }
    let tutorId = null;
    let tutorCourseIds = [];
    if (primaryRole === "tutor") {
      try {
        const tutors = await query(
          "SELECT id FROM tutors WHERE user_id = ? LIMIT 1",
          [userId]
        );
        if (tutors && tutors.length > 0) {
          tutorId = tutors[0].id;
          const tutorCourses = await query(
            "SELECT DISTINCT course_id FROM tutor_courses WHERE tutor_id = ?",
            [tutorId]
          );
          tutorCourseIds = tutorCourses.map((tc) => tc.course_id);
        }
      } catch (error) {
      }
    }
    const dashboardData = {
      stats: {},
      recentEnrollments: [],
      recentPayments: []
    };
    if (primaryRole === "system_admin" || primaryRole === "owner") {
      const [studentsResult] = await query(
        `SELECT COUNT(DISTINCT u.id) as total
         FROM users u
         INNER JOIN user_roles ur ON u.id = ur.user_id
         INNER JOIN roles r ON ur.role_id = r.id
         WHERE r.name IN ('student', 'parent')
         AND u.status = 'active'`
      );
      dashboardData.stats.totalStudents = ((_a = studentsResult == null ? void 0 : studentsResult[0]) == null ? void 0 : _a.total) || 0;
      const [coursesResult] = await query(
        `SELECT COUNT(*) as total FROM courses WHERE status = 'published'`
      );
      dashboardData.stats.totalCourses = ((_b = coursesResult == null ? void 0 : coursesResult[0]) == null ? void 0 : _b.total) || 0;
      const [enrollmentsResult] = await query(
        `SELECT COUNT(*) as total FROM enrollments WHERE status = 'active'`
      );
      dashboardData.stats.totalEnrollments = ((_c = enrollmentsResult == null ? void 0 : enrollmentsResult[0]) == null ? void 0 : _c.total) || 0;
      const currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      const [revenueResult] = await query(
        `SELECT COALESCE(SUM(p.amount), 0) as total
         FROM payments p
         WHERE MONTH(p.created_at) = ? AND YEAR(p.created_at) = ?
         AND p.status = 'completed'`,
        [currentMonth, currentYear]
      );
      dashboardData.stats.monthlyRevenue = parseFloat(((_d = revenueResult == null ? void 0 : revenueResult[0]) == null ? void 0 : _d.total) || "0");
      const [usersByRoleResult] = await query(
        `SELECT r.name as role, COUNT(DISTINCT u.id) as count
         FROM users u
         INNER JOIN user_roles ur ON u.id = ur.user_id
         INNER JOIN roles r ON ur.role_id = r.id
         WHERE u.status = 'active'
         GROUP BY r.name`
      );
      dashboardData.stats.usersByRole = usersByRoleResult || [];
      const [branchesResult] = await query(
        `SELECT COUNT(*) as total FROM branches WHERE status = 'active'`
      );
      dashboardData.stats.activeBranches = ((_e = branchesResult == null ? void 0 : branchesResult[0]) == null ? void 0 : _e.total) || 0;
    } else if (primaryRole === "admin") {
      const [studentsResult] = await query(
        `SELECT COUNT(DISTINCT u.id) as total
         FROM users u
         INNER JOIN user_roles ur ON u.id = ur.user_id
         INNER JOIN roles r ON ur.role_id = r.id
         WHERE r.name IN ('student', 'parent')
         AND u.status = 'active'`
      );
      dashboardData.stats.totalStudents = ((_f = studentsResult == null ? void 0 : studentsResult[0]) == null ? void 0 : _f.total) || 0;
      const [coursesResult] = await query(
        `SELECT COUNT(*) as total FROM courses WHERE status = 'published'`
      );
      dashboardData.stats.totalCourses = ((_g = coursesResult == null ? void 0 : coursesResult[0]) == null ? void 0 : _g.total) || 0;
      const [enrollmentsResult] = await query(
        `SELECT COUNT(*) as total FROM enrollments WHERE status = 'active'`
      );
      dashboardData.stats.totalEnrollments = ((_h = enrollmentsResult == null ? void 0 : enrollmentsResult[0]) == null ? void 0 : _h.total) || 0;
      const currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      const [revenueResult] = await query(
        `SELECT COALESCE(SUM(p.amount), 0) as total
         FROM payments p
         WHERE MONTH(p.created_at) = ? AND YEAR(p.created_at) = ?
         AND p.status = 'completed'`,
        [currentMonth, currentYear]
      );
      dashboardData.stats.monthlyRevenue = parseFloat(((_i = revenueResult == null ? void 0 : revenueResult[0]) == null ? void 0 : _i.total) || "0");
      const [pendingPaymentsResult] = await query(
        `SELECT COUNT(*) as total FROM payments WHERE status = 'pending'`
      );
      dashboardData.stats.pendingPayments = ((_j = pendingPaymentsResult == null ? void 0 : pendingPaymentsResult[0]) == null ? void 0 : _j.total) || 0;
    } else if (primaryRole === "tutor") {
      if (tutorId && tutorCourseIds.length > 0) {
        dashboardData.stats.myCourses = tutorCourseIds.length;
        const [studentsResult] = await query(
          `SELECT COUNT(DISTINCT e.student_id) as total
           FROM enrollments e
           WHERE e.course_id IN (${tutorCourseIds.map(() => "?").join(",")})
           AND e.status = 'active'`,
          tutorCourseIds
        );
        dashboardData.stats.myStudents = ((_k = studentsResult == null ? void 0 : studentsResult[0]) == null ? void 0 : _k.total) || 0;
        const [teachingHoursResult] = await query(
          `SELECT COALESCE(SUM(TIMESTAMPDIFF(HOUR, start_datetime, end_datetime)), 0) as total
           FROM course_schedules
           WHERE tutor_id = ? AND status IN ('completed', 'ongoing')`,
          [tutorId]
        );
        dashboardData.stats.teachingHours = ((_l = teachingHoursResult == null ? void 0 : teachingHoursResult[0]) == null ? void 0 : _l.total) || 0;
        const currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        const [teachingHoursMonthResult] = await query(
          `SELECT COALESCE(SUM(TIMESTAMPDIFF(HOUR, start_datetime, end_datetime)), 0) as total
           FROM course_schedules
           WHERE tutor_id = ? 
           AND MONTH(start_datetime) = ? 
           AND YEAR(start_datetime) = ?
           AND status IN ('completed', 'ongoing')`,
          [tutorId, currentMonth, currentYear]
        );
        dashboardData.stats.teachingHoursThisMonth = ((_m = teachingHoursMonthResult == null ? void 0 : teachingHoursMonthResult[0]) == null ? void 0 : _m.total) || 0;
        dashboardData.stats.pendingAssignments = 0;
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        const [upcomingClassesResult] = await query(
          `SELECT COUNT(*) as total
           FROM course_schedules
           WHERE tutor_id = ? 
           AND DATE(start_datetime) = ?
           AND status = 'scheduled'`,
          [tutorId, today]
        );
        dashboardData.stats.upcomingClassesToday = ((_n = upcomingClassesResult == null ? void 0 : upcomingClassesResult[0]) == null ? void 0 : _n.total) || 0;
      } else {
        dashboardData.stats.myCourses = 0;
        dashboardData.stats.myStudents = 0;
        dashboardData.stats.teachingHours = 0;
        dashboardData.stats.teachingHoursThisMonth = 0;
        dashboardData.stats.pendingAssignments = 0;
        dashboardData.stats.upcomingClassesToday = 0;
      }
    } else if (primaryRole === "branch_admin") {
      if (!userBranchId) {
        throw createError$2({
          statusCode: 400,
          message: "Branch admin must be assigned to a branch"
        });
      }
      const [studentsResult] = await query(
        `SELECT COUNT(DISTINCT e.student_id) as total
         FROM enrollments e
         INNER JOIN course_branches cb ON e.course_id = cb.course_id AND e.branch_id = cb.branch_id
         WHERE e.branch_id = ? AND e.status = 'active'`,
        [userBranchId]
      );
      dashboardData.stats.branchStudents = ((_o = studentsResult == null ? void 0 : studentsResult[0]) == null ? void 0 : _o.total) || 0;
      const [coursesResult] = await query(
        `SELECT COUNT(DISTINCT c.id) as total
         FROM courses c
         INNER JOIN course_branches cb ON c.id = cb.course_id
         WHERE cb.branch_id = ? AND c.status = 'published'`,
        [userBranchId]
      );
      dashboardData.stats.branchCourses = ((_p = coursesResult == null ? void 0 : coursesResult[0]) == null ? void 0 : _p.total) || 0;
      const [enrollmentsResult] = await query(
        `SELECT COUNT(*) as total 
         FROM enrollments 
         WHERE branch_id = ? AND status = 'active'`,
        [userBranchId]
      );
      dashboardData.stats.branchEnrollments = ((_q = enrollmentsResult == null ? void 0 : enrollmentsResult[0]) == null ? void 0 : _q.total) || 0;
      const currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      const [revenueResult] = await query(
        `SELECT COALESCE(SUM(p.amount), 0) as total
         FROM payments p
         INNER JOIN enrollments e ON p.enrollment_id = e.id
         WHERE e.branch_id = ?
         AND MONTH(p.created_at) = ? AND YEAR(p.created_at) = ?
         AND p.status = 'completed'`,
        [userBranchId, currentMonth, currentYear]
      );
      dashboardData.stats.branchRevenue = parseFloat(((_r = revenueResult == null ? void 0 : revenueResult[0]) == null ? void 0 : _r.total) || "0");
      const [pendingPaymentsResult] = await query(
        `SELECT COUNT(*) as total
         FROM payments p
         INNER JOIN enrollments e ON p.enrollment_id = e.id
         WHERE e.branch_id = ? AND p.status = 'pending'`,
        [userBranchId]
      );
      dashboardData.stats.pendingPayments = ((_s = pendingPaymentsResult == null ? void 0 : pendingPaymentsResult[0]) == null ? void 0 : _s.total) || 0;
      try {
        const [tutorsResult] = await query(
          `SELECT COUNT(DISTINCT t.id) as total
           FROM tutors t
           INNER JOIN users u ON t.user_id = u.id
           INNER JOIN tutor_branches tb ON t.id = tb.tutor_id
           WHERE tb.branch_id = ? AND t.status = 'active' AND u.status = 'active'`,
          [userBranchId]
        );
        dashboardData.stats.activeTutors = ((_t = tutorsResult == null ? void 0 : tutorsResult[0]) == null ? void 0 : _t.total) || 0;
      } catch (error) {
        dashboardData.stats.activeTutors = 0;
      }
      const [branchResult] = await query(
        "SELECT name FROM branches WHERE id = ?",
        [userBranchId]
      );
      dashboardData.branchName = ((_u = branchResult == null ? void 0 : branchResult[0]) == null ? void 0 : _u.name) || "Unknown";
    }
    let enrollmentsQuery = `
      SELECT 
        e.id,
        e.enrollment_date,
        e.status,
        u.first_name,
        u.last_name,
        u.username,
        c.title as course_title,
        c.price as course_price,
        b.name as branch_name
      FROM enrollments e
      INNER JOIN users u ON e.student_id = u.id
      INNER JOIN courses c ON e.course_id = c.id
      LEFT JOIN branches b ON e.branch_id = b.id
      WHERE 1=1
    `;
    const enrollmentsParams = [];
    if (primaryRole === "tutor" && tutorCourseIds.length > 0) {
      enrollmentsQuery += ` AND e.course_id IN (${tutorCourseIds.map(() => "?").join(",")})`;
      enrollmentsParams.push(...tutorCourseIds);
    } else if (primaryRole === "branch_admin" && userBranchId) {
      enrollmentsQuery += " AND e.branch_id = ?";
      enrollmentsParams.push(userBranchId);
    }
    enrollmentsQuery += " ORDER BY e.created_at DESC LIMIT 5";
    const recentEnrollments = await query(
      enrollmentsQuery,
      enrollmentsParams
    );
    dashboardData.recentEnrollments = (Array.isArray(recentEnrollments) ? recentEnrollments : []).map((row) => ({
      id: row.id,
      studentName: `${row.first_name} ${row.last_name}`,
      courseName: row.course_title,
      amount: parseFloat(row.course_price || "0"),
      date: new Date(row.enrollment_date).toLocaleDateString("th-TH"),
      branchName: row.branch_name,
      status: row.status
    }));
    let paymentsQuery = `
      SELECT 
        p.id,
        p.amount,
        p.status,
        p.created_at,
        u.first_name,
        u.last_name,
        c.title as course_title,
        b.name as branch_name
      FROM payments p
      INNER JOIN enrollments e ON p.enrollment_id = e.id
      INNER JOIN users u ON e.student_id = u.id
      INNER JOIN courses c ON e.course_id = c.id
      LEFT JOIN branches b ON e.branch_id = b.id
      WHERE 1=1
    `;
    const paymentsParams = [];
    if (primaryRole === "branch_admin" && userBranchId) {
      paymentsQuery += " AND e.branch_id = ?";
      paymentsParams.push(userBranchId);
    }
    if (primaryRole !== "tutor") {
      paymentsQuery += " ORDER BY p.created_at DESC LIMIT 5";
      const recentPayments = await query(
        paymentsQuery,
        paymentsParams
      );
      dashboardData.recentPayments = (Array.isArray(recentPayments) ? recentPayments : []).map((row) => ({
        id: row.id,
        studentName: `${row.first_name} ${row.last_name}`,
        courseName: row.course_title,
        amount: parseFloat(row.amount || "0"),
        date: new Date(row.created_at).toLocaleDateString("th-TH"),
        branchName: row.branch_name,
        status: row.status
      }));
    } else {
      dashboardData.recentPayments = [];
    }
    return {
      success: true,
      data: dashboardData,
      role: primaryRole
    };
  } catch (error) {
    console.error("[Dashboard API] Error:", error);
    if (error.statusCode) {
      throw error;
    }
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to fetch dashboard data"
    });
  }
});

const dashboard_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: dashboard_get
}, Symbol.toStringTag, { value: 'Module' }));

const enrollments_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  const status = queryParams.status;
  const courseId = queryParams.course_id;
  const studentId = queryParams.student_id;
  const branchId = queryParams.branch_id;
  const params = [];
  let hasEnrollmentType = false;
  let hasShippingAddress = false;
  try {
    const columnCheck = await query(
      `SELECT COLUMN_NAME 
       FROM INFORMATION_SCHEMA.COLUMNS 
       WHERE TABLE_SCHEMA = DATABASE() 
       AND TABLE_NAME = 'enrollments' 
       AND COLUMN_NAME IN ('enrollment_type', 'shipping_address_id')`
    );
    hasEnrollmentType = columnCheck.some((col) => col.COLUMN_NAME === "enrollment_type");
    hasShippingAddress = columnCheck.some((col) => col.COLUMN_NAME === "shipping_address_id");
  } catch (error) {
    console.log("[Enrollments API] Could not check column existence, assuming columns don't exist");
  }
  const enrollmentTypeSelect = hasEnrollmentType ? `COALESCE(e.enrollment_type, 'onsite') as enrollment_type` : `'onsite' as enrollment_type`;
  const shippingAddressSelect = hasShippingAddress ? `e.shipping_address_id` : `NULL as shipping_address_id`;
  let sql = `
    SELECT 
      e.id,
      e.student_id,
      e.course_id,
      e.branch_id,
      ${enrollmentTypeSelect},
      ${shippingAddressSelect},
      e.enrollment_date,
      e.status,
      e.payment_id,
      e.created_at,
      e.updated_at,
      s.username as student_username,
      s.first_name as student_first_name,
      s.last_name as student_last_name,
      s.email as student_email,
      c.title as course_title,
      c.code as course_code,
      c.price as course_price,
      b.name as branch_name,
      b.code as branch_code
    FROM enrollments e
    INNER JOIN users s ON e.student_id = s.id
    INNER JOIN courses c ON e.course_id = c.id
    LEFT JOIN branches b ON e.branch_id = b.id
    WHERE 1=1
  `;
  if (search) {
    sql += ` AND (
      s.username LIKE ? OR 
      s.first_name LIKE ? OR 
      s.last_name LIKE ? OR 
      s.email LIKE ? OR
      c.title LIKE ? OR 
      c.code LIKE ?
    )`;
    const searchPattern = `%${search}%`;
    params.push(searchPattern, searchPattern, searchPattern, searchPattern, searchPattern, searchPattern);
  }
  if (status) {
    sql += ` AND e.status = ?`;
    params.push(status);
  }
  if (courseId) {
    sql += ` AND e.course_id = ?`;
    params.push(parseInt(courseId));
  }
  if (studentId) {
    sql += ` AND e.student_id = ?`;
    params.push(parseInt(studentId));
  }
  if (branchId) {
    sql += ` AND e.branch_id = ?`;
    params.push(parseInt(branchId));
  }
  sql += ` ORDER BY e.created_at DESC`;
  try {
    const enrollments = await query(sql, params);
    return {
      success: true,
      data: enrollments
    };
  } catch (error) {
    console.error("Error fetching enrollments:", error);
    console.error("SQL:", sql);
    console.error("Error details:", {
      message: error.message,
      code: error.code,
      sqlState: error.sqlState
    });
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to fetch enrollments"
    });
  }
});

const enrollments_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: enrollments_get
}, Symbol.toStringTag, { value: 'Module' }));

const enrollments_post = defineEventHandler(async (event) => {
  await requireAuth(event);
  const body = await readBody(event);
  if (!body.student_id || !body.course_id) {
    throw createError$2({
      statusCode: 400,
      message: "Student ID and Course ID are required"
    });
  }
  const enrollmentType = body.enrollment_type || "onsite";
  if (!["onsite", "online"].includes(enrollmentType)) {
    throw createError$2({
      statusCode: 400,
      message: 'Invalid enrollment type. Must be "onsite" or "online"'
    });
  }
  if (enrollmentType === "onsite" && !body.branch_id) {
    throw createError$2({
      statusCode: 400,
      message: "Branch ID is required for onsite enrollment"
    });
  }
  if (enrollmentType === "online" && !body.shipping_address_id) {
    throw createError$2({
      statusCode: 400,
      message: "Shipping address ID is required for online enrollment"
    });
  }
  const validStatuses = ["pending", "active", "completed", "cancelled"];
  if (body.status && !validStatuses.includes(body.status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid enrollment status"
    });
  }
  try {
    const students = await query(
      "SELECT id FROM users WHERE id = ?",
      [body.student_id]
    );
    if (students.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Student not found"
      });
    }
    const courses = await query(
      "SELECT id FROM courses WHERE id = ?",
      [body.course_id]
    );
    if (courses.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Course not found"
      });
    }
    if (enrollmentType === "onsite") {
      const branches = await query(
        'SELECT id FROM branches WHERE id = ? AND status = "active"',
        [body.branch_id]
      );
      if (branches.length === 0) {
        throw createError$2({
          statusCode: 404,
          message: "Branch not found or inactive"
        });
      }
    }
    if (enrollmentType === "online") {
      const addresses = await query(
        "SELECT id FROM user_addresses WHERE id = ? AND user_id = ?",
        [body.shipping_address_id, body.student_id]
      );
      if (addresses.length === 0) {
        throw createError$2({
          statusCode: 404,
          message: "Shipping address not found or does not belong to student"
        });
      }
    }
    let existingQuery = "";
    let existingParams = [];
    if (enrollmentType === "onsite") {
      existingQuery = "SELECT id FROM enrollments WHERE student_id = ? AND course_id = ? AND branch_id = ? AND enrollment_type = ?";
      existingParams = [body.student_id, body.course_id, body.branch_id, enrollmentType];
    } else {
      existingQuery = "SELECT id FROM enrollments WHERE student_id = ? AND course_id = ? AND enrollment_type = ? AND shipping_address_id = ?";
      existingParams = [body.student_id, body.course_id, enrollmentType, body.shipping_address_id];
    }
    const existing = await query(existingQuery, existingParams);
    if (existing.length > 0) {
      throw createError$2({
        statusCode: 409,
        message: "Enrollment already exists for this student and course"
      });
    }
    const result = await execute(
      `INSERT INTO enrollments (
        student_id, course_id, branch_id, enrollment_type, shipping_address_id,
        enrollment_date, status, payment_id
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        body.student_id,
        body.course_id,
        enrollmentType === "onsite" ? body.branch_id : null,
        enrollmentType,
        enrollmentType === "online" ? body.shipping_address_id : null,
        body.enrollment_date || /* @__PURE__ */ new Date(),
        body.status || "pending",
        body.payment_id || null
      ]
    );
    const enrollmentId = result.insertId;
    if (body.status === "active" && enrollmentType === "onsite" && body.branch_id) {
      await execute(
        `UPDATE course_branches 
         SET current_enrollments = current_enrollments + 1 
         WHERE course_id = ? AND branch_id = ?`,
        [body.course_id, body.branch_id]
      );
    }
    let enrollmentQuery = `
      SELECT 
        e.id,
        e.student_id,
        e.course_id,
        e.branch_id,
        e.enrollment_type,
        e.shipping_address_id,
        e.enrollment_date,
        e.status,
        e.payment_id,
        e.created_at,
        e.updated_at,
        s.username as student_username,
        s.first_name as student_first_name,
        s.last_name as student_last_name,
        s.email as student_email,
        c.title as course_title,
        c.code as course_code,
        b.name as branch_name,
        b.code as branch_code
      FROM enrollments e
      INNER JOIN users s ON e.student_id = s.id
      INNER JOIN courses c ON e.course_id = c.id
      LEFT JOIN branches b ON e.branch_id = b.id
      WHERE e.id = ?
    `;
    const enrollment = await query(enrollmentQuery, [enrollmentId]);
    return {
      success: true,
      data: enrollment[0]
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error creating enrollment:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to create enrollment"
    });
  }
});

const enrollments_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: enrollments_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$m = defineEventHandler(async (event) => {
  await requireAuth(event);
  const enrollmentId = parseInt(getRouterParam(event, "id") || "0");
  if (!enrollmentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid enrollment ID"
    });
  }
  try {
    const enrollment = await query(
      "SELECT id, course_id, branch_id, status FROM enrollments WHERE id = ?",
      [enrollmentId]
    );
    if (enrollment.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Enrollment not found"
      });
    }
    const enrollmentData = enrollment[0];
    await execute(
      "DELETE FROM enrollments WHERE id = ?",
      [enrollmentId]
    );
    if (enrollmentData.status === "active") {
      await execute(
        `UPDATE course_branches 
         SET current_enrollments = GREATEST(0, current_enrollments - 1) 
         WHERE course_id = ? AND branch_id = ?`,
        [enrollmentData.course_id, enrollmentData.branch_id]
      );
    }
    return {
      success: true,
      message: "Enrollment deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error deleting enrollment:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete enrollment"
    });
  }
});

const _id__delete$n = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$m
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get$a = defineEventHandler(async (event) => {
  await requireAuth(event);
  const enrollmentId = parseInt(getRouterParam(event, "id") || "0");
  if (!enrollmentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid enrollment ID"
    });
  }
  try {
    const enrollments = await query(
      `SELECT 
        e.id,
        e.student_id,
        e.course_id,
        e.branch_id,
        e.enrollment_type,
        e.shipping_address_id,
        e.enrollment_date,
        e.status,
        e.payment_id,
        e.created_at,
        e.updated_at,
        s.username as student_username,
        s.first_name as student_first_name,
        s.last_name as student_last_name,
        s.email as student_email,
        s.phone as student_phone,
        c.title as course_title,
        c.code as course_code,
        c.description as course_description,
        c.type as course_type,
        c.price as course_price,
        c.duration_hours as course_duration_hours,
        c.level as course_level,
        c.status as course_status,
        b.name as branch_name,
        b.code as branch_code,
        b.address as branch_address,
        b.phone as branch_phone,
        b.email as branch_email,
        p.amount as payment_amount,
        p.status as payment_status,
        p.payment_method,
        p.transaction_id,
        p.invoice_number,
        p.paid_at
      FROM enrollments e
      INNER JOIN users s ON e.student_id = s.id
      INNER JOIN courses c ON e.course_id = c.id
      LEFT JOIN branches b ON e.branch_id = b.id
      LEFT JOIN payments p ON e.payment_id = p.id
      WHERE e.id = ?`,
      [enrollmentId]
    );
    if (enrollments.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Enrollment not found"
      });
    }
    const enrollment = enrollments[0];
    let learningRights = [];
    try {
      learningRights = await query(
        `SELECT 
          id,
          enrollment_id,
          access_type,
          expires_at,
          is_active,
          created_at
        FROM learning_rights
        WHERE enrollment_id = ?
        ORDER BY created_at DESC`,
        [enrollmentId]
      );
    } catch (lrError) {
      console.warn("learning_rights table may not exist yet:", lrError.message);
    }
    return {
      success: true,
      data: {
        enrollment: {
          id: enrollment.id,
          student_id: enrollment.student_id,
          course_id: enrollment.course_id,
          branch_id: enrollment.branch_id,
          enrollment_type: enrollment.enrollment_type || "onsite",
          shipping_address_id: enrollment.shipping_address_id,
          enrollment_date: enrollment.enrollment_date,
          status: enrollment.status,
          payment_id: enrollment.payment_id,
          created_at: enrollment.created_at,
          updated_at: enrollment.updated_at
        },
        student: {
          id: enrollment.student_id,
          username: enrollment.student_username,
          first_name: enrollment.student_first_name,
          last_name: enrollment.student_last_name,
          email: enrollment.student_email,
          phone: enrollment.student_phone
        },
        course: {
          id: enrollment.course_id,
          title: enrollment.course_title,
          code: enrollment.course_code,
          description: enrollment.course_description,
          type: enrollment.course_type,
          price: enrollment.course_price,
          duration_hours: enrollment.course_duration_hours,
          level: enrollment.course_level,
          status: enrollment.course_status
        },
        branch: enrollment.branch_id ? {
          id: enrollment.branch_id,
          name: enrollment.branch_name,
          code: enrollment.branch_code,
          address: enrollment.branch_address,
          phone: enrollment.branch_phone,
          email: enrollment.branch_email
        } : null,
        shipping_address: shippingAddress,
        payment: enrollment.payment_id ? {
          id: enrollment.payment_id,
          amount: enrollment.payment_amount,
          status: enrollment.payment_status,
          payment_method: enrollment.payment_method,
          transaction_id: enrollment.transaction_id,
          invoice_number: enrollment.invoice_number,
          paid_at: enrollment.paid_at
        } : null,
        learning_rights: learningRights
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error fetching enrollment detail:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch enrollment detail"
    });
  }
});

const _id__get$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get$a
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$o = defineEventHandler(async (event) => {
  await requireAuth(event);
  const enrollmentId = parseInt(getRouterParam(event, "id") || "0");
  if (!enrollmentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid enrollment ID"
    });
  }
  const body = await readBody(event);
  const existing = await query(
    "SELECT id, course_id, branch_id, status, enrollment_type, shipping_address_id FROM enrollments WHERE id = ?",
    [enrollmentId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Enrollment not found"
    });
  }
  const oldEnrollment = existing[0];
  const validStatuses = ["pending", "active", "completed", "cancelled"];
  if (body.status && !validStatuses.includes(body.status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid enrollment status"
    });
  }
  if (body.enrollment_type && !["onsite", "online"].includes(body.enrollment_type)) {
    throw createError$2({
      statusCode: 400,
      message: 'Invalid enrollment type. Must be "onsite" or "online"'
    });
  }
  const enrollmentType = body.enrollment_type !== void 0 ? body.enrollment_type : oldEnrollment.enrollment_type || "onsite";
  try {
    if (body.student_id) {
      const students = await query(
        "SELECT id FROM users WHERE id = ?",
        [body.student_id]
      );
      if (students.length === 0) {
        throw createError$2({
          statusCode: 404,
          message: "Student not found"
        });
      }
    }
    if (body.course_id) {
      const courses = await query(
        "SELECT id FROM courses WHERE id = ?",
        [body.course_id]
      );
      if (courses.length === 0) {
        throw createError$2({
          statusCode: 404,
          message: "Course not found"
        });
      }
    }
    if (body.branch_id && enrollmentType === "onsite") {
      const branches = await query(
        'SELECT id FROM branches WHERE id = ? AND status = "active"',
        [body.branch_id]
      );
      if (branches.length === 0) {
        throw createError$2({
          statusCode: 404,
          message: "Branch not found or inactive"
        });
      }
    }
    if (body.shipping_address_id && enrollmentType === "online") {
      const studentId = body.student_id || oldEnrollment.student_id;
      const addresses = await query(
        "SELECT id FROM user_addresses WHERE id = ? AND user_id = ?",
        [body.shipping_address_id, studentId]
      );
      if (addresses.length === 0) {
        throw createError$2({
          statusCode: 404,
          message: "Shipping address not found or does not belong to student"
        });
      }
    }
    const updates = [];
    const params = [];
    if (body.student_id !== void 0) {
      updates.push("student_id = ?");
      params.push(body.student_id);
    }
    if (body.course_id !== void 0) {
      updates.push("course_id = ?");
      params.push(body.course_id);
    }
    if (body.enrollment_type !== void 0) {
      updates.push("enrollment_type = ?");
      params.push(body.enrollment_type);
    }
    if (body.branch_id !== void 0) {
      if (enrollmentType === "online") {
        updates.push("branch_id = NULL");
      } else {
        updates.push("branch_id = ?");
        params.push(body.branch_id);
      }
    }
    if (body.shipping_address_id !== void 0) {
      if (enrollmentType === "onsite") {
        updates.push("shipping_address_id = NULL");
      } else {
        updates.push("shipping_address_id = ?");
        params.push(body.shipping_address_id);
      }
    }
    if (body.enrollment_date !== void 0) {
      updates.push("enrollment_date = ?");
      params.push(body.enrollment_date);
    }
    if (body.status !== void 0) {
      updates.push("status = ?");
      params.push(body.status);
    }
    if (body.payment_id !== void 0) {
      updates.push("payment_id = ?");
      params.push(body.payment_id);
    }
    if (updates.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updates.push("updated_at = CURRENT_TIMESTAMP");
    params.push(enrollmentId);
    await execute(
      `UPDATE enrollments SET ${updates.join(", ")} WHERE id = ?`,
      params
    );
    if (body.status && body.status !== oldEnrollment.status) {
      const finalEnrollmentType = body.enrollment_type !== void 0 ? body.enrollment_type : oldEnrollment.enrollment_type || "onsite";
      if (finalEnrollmentType === "onsite") {
        const courseId = body.course_id || oldEnrollment.course_id;
        const branchId = body.branch_id || oldEnrollment.branch_id;
        if (oldEnrollment.status === "active" && body.status !== "active") {
          await execute(
            `UPDATE course_branches 
             SET current_enrollments = GREATEST(0, current_enrollments - 1) 
             WHERE course_id = ? AND branch_id = ?`,
            [courseId, branchId]
          );
        } else if (oldEnrollment.status !== "active" && body.status === "active") {
          await execute(
            `UPDATE course_branches 
             SET current_enrollments = current_enrollments + 1 
             WHERE course_id = ? AND branch_id = ?`,
            [courseId, branchId]
          );
        }
      }
    }
    const enrollment = await query(
      `SELECT 
        e.id,
        e.student_id,
        e.course_id,
        e.branch_id,
        e.enrollment_type,
        e.shipping_address_id,
        e.enrollment_date,
        e.status,
        e.payment_id,
        e.created_at,
        e.updated_at,
        s.username as student_username,
        s.first_name as student_first_name,
        s.last_name as student_last_name,
        s.email as student_email,
        c.title as course_title,
        c.code as course_code,
        b.name as branch_name,
        b.code as branch_code
      FROM enrollments e
      INNER JOIN users s ON e.student_id = s.id
      INNER JOIN courses c ON e.course_id = c.id
      LEFT JOIN branches b ON e.branch_id = b.id
      WHERE e.id = ?`,
      [enrollmentId]
    );
    return {
      success: true,
      data: enrollment[0]
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error updating enrollment:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update enrollment"
    });
  }
});

const _id__put$p = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$o
}, Symbol.toStringTag, { value: 'Module' }));

const status_patch$6 = defineEventHandler(async (event) => {
  await requireAuth(event);
  const enrollmentId = parseInt(getRouterParam(event, "id") || "0");
  if (!enrollmentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid enrollment ID"
    });
  }
  const body = await readBody(event);
  if (!body.status) {
    throw createError$2({
      statusCode: 400,
      message: "Status is required"
    });
  }
  const validStatuses = ["pending", "active", "completed", "cancelled"];
  if (!validStatuses.includes(body.status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid enrollment status"
    });
  }
  try {
    const enrollment = await query(
      "SELECT id, course_id, branch_id, status FROM enrollments WHERE id = ?",
      [enrollmentId]
    );
    if (enrollment.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Enrollment not found"
      });
    }
    const oldStatus = enrollment[0].status;
    const courseId = enrollment[0].course_id;
    const branchId = enrollment[0].branch_id;
    await execute(
      "UPDATE enrollments SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
      [body.status, enrollmentId]
    );
    if (oldStatus === "active" && body.status !== "active") {
      await execute(
        `UPDATE course_branches 
         SET current_enrollments = GREATEST(0, current_enrollments - 1) 
         WHERE course_id = ? AND branch_id = ?`,
        [courseId, branchId]
      );
    } else if (oldStatus !== "active" && body.status === "active") {
      await execute(
        `UPDATE course_branches 
         SET current_enrollments = current_enrollments + 1 
         WHERE course_id = ? AND branch_id = ?`,
        [courseId, branchId]
      );
    }
    const updated = await query(
      `SELECT 
        e.id,
        e.student_id,
        e.course_id,
        e.branch_id,
        e.enrollment_date,
        e.status,
        e.payment_id,
        e.created_at,
        e.updated_at,
        s.username as student_username,
        s.first_name as student_first_name,
        s.last_name as student_last_name,
        s.email as student_email,
        c.title as course_title,
        c.code as course_code,
        b.name as branch_name,
        b.code as branch_code
      FROM enrollments e
      INNER JOIN users s ON e.student_id = s.id
      INNER JOIN courses c ON e.course_id = c.id
      INNER JOIN branches b ON e.branch_id = b.id
      WHERE e.id = ?`,
      [enrollmentId]
    );
    return {
      success: true,
      data: updated[0]
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error updating enrollment status:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update enrollment status"
    });
  }
});

const status_patch$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: status_patch$6
}, Symbol.toStringTag, { value: 'Module' }));

async function getAdminMenus(userRoles) {
  try {
    console.log("[Menu Service] Getting menus for roles:", userRoles);
    const allMenus = await query(
      `SELECT id, code, name, name_en, icon, href, parent_code, display_order, is_active, roles
       FROM admin_menus
       WHERE is_active = TRUE
       ORDER BY display_order ASC, name ASC`
    );
    console.log("[Menu Service] Total menus in DB:", allMenus.length);
    if (!allMenus || allMenus.length === 0) {
      console.warn("[Menu Service] No admin menus found in database. Please run migration: bun run db:migrate-menus");
      return [];
    }
    const filteredMenus = allMenus.filter((menu) => {
      if (!menu.roles) {
        console.log(`[Menu Service] Menu ${menu.code} has no roles restriction - allowing`);
        return true;
      }
      try {
        const allowedRoles = JSON.parse(menu.roles);
        const hasAccess = userRoles.some((role) => allowedRoles.includes(role));
        console.log(`[Menu Service] Menu ${menu.code} - Allowed roles: ${allowedRoles.join(", ")}, User has access: ${hasAccess}`);
        return hasAccess;
      } catch (error) {
        console.error(`[Menu Service] Error parsing roles for menu ${menu.code}:`, error);
        return true;
      }
    });
    console.log("[Menu Service] Filtered menus:", filteredMenus.length);
    const menuMap = /* @__PURE__ */ new Map();
    const rootMenus = [];
    filteredMenus.forEach((menu) => {
      menuMap.set(menu.code, { ...menu, children: [] });
    });
    filteredMenus.forEach((menu) => {
      const menuItem = menuMap.get(menu.code);
      if (menu.parent_code) {
        const parent = menuMap.get(menu.parent_code);
        if (parent) {
          if (!parent.children) {
            parent.children = [];
          }
          parent.children.push(menuItem);
        }
      } else {
        rootMenus.push(menuItem);
      }
    });
    const sortMenus = (menus) => {
      menus.sort((a, b) => a.display_order - b.display_order);
      menus.forEach((menu) => {
        if (menu.children && menu.children.length > 0) {
          sortMenus(menu.children);
        }
      });
    };
    sortMenus(rootMenus);
    return rootMenus;
  } catch (error) {
    if (error.code === "ER_NO_SUCH_TABLE") {
      console.error("admin_menus table does not exist. Please run migration: bun run db:migrate-menus");
      return [];
    }
    throw error;
  }
}

const menus_get = defineEventHandler(async (event) => {
  try {
    const auth = await requireAuth(event);
    const userId = auth.userId;
    console.log("[Admin Menus API] User ID:", userId);
    if (!userId) {
      throw createError$2({
        statusCode: 401,
        message: "Invalid token payload"
      });
    }
    const roles = await getUserRoles(userId);
    console.log("[Admin Menus API] User roles:", roles);
    if (!roles || roles.length === 0) {
      console.warn("[Admin Menus API] User has no roles");
      throw createError$2({
        statusCode: 403,
        message: "User has no roles"
      });
    }
    const menus = await getAdminMenus(roles);
    console.log("[Admin Menus API] Menus found:", menus.length);
    console.log("[Admin Menus API] Menu codes:", menus.map((m) => m.code));
    return {
      success: true,
      data: menus
    };
  } catch (error) {
    console.error("[Admin Menus API] Error fetching admin menus:", error);
    console.error("[Admin Menus API] Error details:", {
      message: error.message,
      statusCode: error.statusCode,
      stack: error.stack
    });
    if (error.statusCode) {
      throw error;
    }
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Failed to fetch menus"
    });
  }
});

const menus_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: menus_get
}, Symbol.toStringTag, { value: 'Module' }));

const branches_get$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  const status = queryParams.status;
  let whereConditions = [];
  const queryValues = [];
  if (search) {
    whereConditions.push(`(name LIKE ? OR code LIKE ? OR address LIKE ?)`);
    const searchPattern = `%${search}%`;
    queryValues.push(searchPattern, searchPattern, searchPattern);
  }
  if (status) {
    whereConditions.push(`status = ?`);
    queryValues.push(status);
  }
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
  try {
    const branches = await query(
      `SELECT 
        id,
        name,
        code,
        address,
        phone,
        email,
        status,
        created_at,
        updated_at
      FROM branches
      ${whereClause}
      ORDER BY name ASC`,
      queryValues
    );
    return {
      success: true,
      data: branches
    };
  } catch (error) {
    console.error("Error fetching branches:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch branches"
    });
  }
});

const branches_get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: branches_get$2
}, Symbol.toStringTag, { value: 'Module' }));

const branches_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody(event);
  if (!body.name || !body.code) {
    throw createError$2({
      statusCode: 400,
      message: "Name and code are required"
    });
  }
  const existing = await query(
    "SELECT id FROM branches WHERE code = ?",
    [body.code]
  );
  if (existing.length > 0) {
    throw createError$2({
      statusCode: 409,
      message: "Branch code already exists"
    });
  }
  const result = await execute(
    `INSERT INTO branches (name, code, address, phone, email, status)
     VALUES (?, ?, ?, ?, ?, ?)`,
    [
      body.name,
      body.code,
      body.address || null,
      body.phone || null,
      body.email || null,
      body.status || "active"
    ]
  );
  const branches = await query(
    "SELECT * FROM branches WHERE id = ?",
    [result.insertId]
  );
  return {
    success: true,
    data: branches[0],
    message: "Branch created successfully"
  };
});

const branches_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: branches_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$k = defineEventHandler(async (event) => {
  var _a;
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const branchId = parseInt(getRouterParam(event, "id") || "0");
  if (!branchId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid branch ID"
    });
  }
  const existing = await query("SELECT id FROM branches WHERE id = ?", [branchId]);
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Branch not found"
    });
  }
  const enrollments = await query(
    "SELECT COUNT(*) as count FROM enrollments WHERE branch_id = ?",
    [branchId]
  );
  if (((_a = enrollments[0]) == null ? void 0 : _a.count) > 0) {
    throw createError$2({
      statusCode: 400,
      message: "Cannot delete branch. It is being used in enrollments."
    });
  }
  await execute("DELETE FROM branches WHERE id = ?", [branchId]);
  return {
    success: true,
    message: "Branch deleted successfully"
  };
});

const _id__delete$l = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$k
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$m = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const branchId = parseInt(getRouterParam(event, "id") || "0");
  if (!branchId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid branch ID"
    });
  }
  const body = await readBody(event);
  const existing = await query("SELECT id FROM branches WHERE id = ?", [branchId]);
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Branch not found"
    });
  }
  if (body.code) {
    const codeCheck = await query(
      "SELECT id FROM branches WHERE code = ? AND id != ?",
      [body.code, branchId]
    );
    if (codeCheck.length > 0) {
      throw createError$2({
        statusCode: 409,
        message: "Branch code already exists"
      });
    }
  }
  const updateFields = [];
  const updateValues = [];
  if (body.name !== void 0) {
    updateFields.push("name = ?");
    updateValues.push(body.name);
  }
  if (body.code !== void 0) {
    updateFields.push("code = ?");
    updateValues.push(body.code);
  }
  if (body.address !== void 0) {
    updateFields.push("address = ?");
    updateValues.push(body.address);
  }
  if (body.phone !== void 0) {
    updateFields.push("phone = ?");
    updateValues.push(body.phone);
  }
  if (body.email !== void 0) {
    updateFields.push("email = ?");
    updateValues.push(body.email);
  }
  if (body.status !== void 0) {
    updateFields.push("status = ?");
    updateValues.push(body.status);
  }
  if (updateFields.length === 0) {
    throw createError$2({
      statusCode: 400,
      message: "No fields to update"
    });
  }
  updateValues.push(branchId);
  await execute(
    `UPDATE branches SET ${updateFields.join(", ")}, updated_at = NOW() WHERE id = ?`,
    updateValues
  );
  const branches = await query("SELECT * FROM branches WHERE id = ?", [branchId]);
  return {
    success: true,
    data: branches[0],
    message: "Branch updated successfully"
  };
});

const _id__put$n = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$m
}, Symbol.toStringTag, { value: 'Module' }));

const status_patch$4 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const branchId = parseInt(getRouterParam(event, "id") || "0");
  if (!branchId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid branch ID"
    });
  }
  const body = await readBody();
  if (!body.status || !["active", "inactive"].includes(body.status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid status. Must be active or inactive"
    });
  }
  const existing = await query("SELECT id FROM branches WHERE id = ?", [branchId]);
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Branch not found"
    });
  }
  await execute(
    "UPDATE branches SET status = ?, updated_at = NOW() WHERE id = ?",
    [body.status, branchId]
  );
  const branches = await query("SELECT * FROM branches WHERE id = ?", [branchId]);
  return {
    success: true,
    data: branches[0],
    message: `Branch status updated to ${body.status}`
  };
});

const status_patch$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: status_patch$4
}, Symbol.toStringTag, { value: 'Module' }));

const smtp_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  try {
    const smtpSettings = {
      host: process.env.SMTP_HOST || "",
      port: parseInt(process.env.SMTP_PORT || "587"),
      secure: process.env.SMTP_SECURE === "true",
      username: process.env.SMTP_USERNAME || "",
      password: "",
      // Never return password
      from_email: process.env.SMTP_FROM_EMAIL || "",
      from_name: process.env.SMTP_FROM_NAME || "",
      enabled: process.env.SMTP_ENABLED === "true"
    };
    return {
      success: true,
      data: smtpSettings
    };
  } catch (error) {
    console.error("Error fetching SMTP settings:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch SMTP settings"
    });
  }
});

const smtp_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: smtp_get
}, Symbol.toStringTag, { value: 'Module' }));

const smtp_put = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody();
  if (!body.host || !body.port || !body.from_email || !body.from_name) {
    throw createError$2({
      statusCode: 400,
      message: "Host, port, from email, and from name are required"
    });
  }
  if (body.port < 1 || body.port > 65535) {
    throw createError$2({
      statusCode: 400,
      message: "Port must be between 1 and 65535"
    });
  }
  try {
    const smtpSettings = {
      host: body.host,
      port: body.port,
      secure: body.secure || false,
      username: body.username,
      from_email: body.from_email,
      from_name: body.from_name,
      enabled: body.enabled || false
      // Don't store password here, handle separately in secure storage
    };
    return {
      success: true,
      data: smtpSettings,
      message: "SMTP settings updated successfully"
    };
  } catch (error) {
    console.error("Error updating SMTP settings:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update SMTP settings"
    });
  }
});

const smtp_put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: smtp_put
}, Symbol.toStringTag, { value: 'Module' }));

const templates_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  try {
    const templates = [
      {
        id: 1,
        code: "welcome",
        name: "Welcome Email",
        subject: "\u0E22\u0E34\u0E19\u0E14\u0E35\u0E15\u0E49\u0E2D\u0E19\u0E23\u0E31\u0E1A\u0E40\u0E02\u0E49\u0E32\u0E2A\u0E39\u0E48\u0E23\u0E30\u0E1A\u0E1A",
        body: "<p>\u0E2A\u0E27\u0E31\u0E2A\u0E14\u0E35 {{first_name}} {{last_name}},</p><p>\u0E22\u0E34\u0E19\u0E14\u0E35\u0E15\u0E49\u0E2D\u0E19\u0E23\u0E31\u0E1A\u0E40\u0E02\u0E49\u0E32\u0E2A\u0E39\u0E48\u0E23\u0E30\u0E1A\u0E1A\u0E02\u0E2D\u0E07\u0E40\u0E23\u0E32</p>",
        variables: ["first_name", "last_name", "email"],
        created_at: (/* @__PURE__ */ new Date()).toISOString(),
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      },
      {
        id: 2,
        code: "password_reset",
        name: "Password Reset",
        subject: "\u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19",
        body: "<p>\u0E2A\u0E27\u0E31\u0E2A\u0E14\u0E35 {{first_name}},</p><p>\u0E04\u0E25\u0E34\u0E01\u0E17\u0E35\u0E48\u0E25\u0E34\u0E07\u0E01\u0E4C\u0E19\u0E35\u0E49\u0E40\u0E1E\u0E37\u0E48\u0E2D\u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19: {{reset_link}}</p>",
        variables: ["first_name", "reset_link"],
        created_at: (/* @__PURE__ */ new Date()).toISOString(),
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      },
      {
        id: 3,
        code: "enrollment_confirmation",
        name: "Enrollment Confirmation",
        subject: "\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E01\u0E32\u0E23\u0E25\u0E07\u0E17\u0E30\u0E40\u0E1A\u0E35\u0E22\u0E19",
        body: "<p>\u0E2A\u0E27\u0E31\u0E2A\u0E14\u0E35 {{student_name}},</p><p>\u0E04\u0E38\u0E13\u0E44\u0E14\u0E49\u0E25\u0E07\u0E17\u0E30\u0E40\u0E1A\u0E35\u0E22\u0E19\u0E04\u0E2D\u0E23\u0E4C\u0E2A {{course_name}} \u0E40\u0E23\u0E35\u0E22\u0E1A\u0E23\u0E49\u0E2D\u0E22\u0E41\u0E25\u0E49\u0E27</p>",
        variables: ["student_name", "course_name", "enrollment_date"],
        created_at: (/* @__PURE__ */ new Date()).toISOString(),
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      }
    ];
    return {
      success: true,
      data: templates
    };
  } catch (error) {
    console.error("Error fetching email templates:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch email templates"
    });
  }
});

const templates_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: templates_get
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get$8 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const templateId = parseInt(getRouterParam(event, "id") || "0");
  if (!templateId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid template ID"
    });
  }
  try {
    const templates = {
      1: {
        id: 1,
        code: "welcome",
        name: "Welcome Email",
        subject: "\u0E22\u0E34\u0E19\u0E14\u0E35\u0E15\u0E49\u0E2D\u0E19\u0E23\u0E31\u0E1A\u0E40\u0E02\u0E49\u0E32\u0E2A\u0E39\u0E48\u0E23\u0E30\u0E1A\u0E1A",
        body: "<p>\u0E2A\u0E27\u0E31\u0E2A\u0E14\u0E35 {{first_name}} {{last_name}},</p><p>\u0E22\u0E34\u0E19\u0E14\u0E35\u0E15\u0E49\u0E2D\u0E19\u0E23\u0E31\u0E1A\u0E40\u0E02\u0E49\u0E32\u0E2A\u0E39\u0E48\u0E23\u0E30\u0E1A\u0E1A\u0E02\u0E2D\u0E07\u0E40\u0E23\u0E32</p>",
        variables: ["first_name", "last_name", "email"]
      },
      2: {
        id: 2,
        code: "password_reset",
        name: "Password Reset",
        subject: "\u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19",
        body: "<p>\u0E2A\u0E27\u0E31\u0E2A\u0E14\u0E35 {{first_name}},</p><p>\u0E04\u0E25\u0E34\u0E01\u0E17\u0E35\u0E48\u0E25\u0E34\u0E07\u0E01\u0E4C\u0E19\u0E35\u0E49\u0E40\u0E1E\u0E37\u0E48\u0E2D\u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19: {{reset_link}}</p>",
        variables: ["first_name", "reset_link"]
      },
      3: {
        id: 3,
        code: "enrollment_confirmation",
        name: "Enrollment Confirmation",
        subject: "\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E01\u0E32\u0E23\u0E25\u0E07\u0E17\u0E30\u0E40\u0E1A\u0E35\u0E22\u0E19",
        body: "<p>\u0E2A\u0E27\u0E31\u0E2A\u0E14\u0E35 {{student_name}},</p><p>\u0E04\u0E38\u0E13\u0E44\u0E14\u0E49\u0E25\u0E07\u0E17\u0E30\u0E40\u0E1A\u0E35\u0E22\u0E19\u0E04\u0E2D\u0E23\u0E4C\u0E2A {{course_name}} \u0E40\u0E23\u0E35\u0E22\u0E1A\u0E23\u0E49\u0E2D\u0E22\u0E41\u0E25\u0E49\u0E27</p>",
        variables: ["student_name", "course_name", "enrollment_date"]
      }
    };
    const template = templates[templateId];
    if (!template) {
      throw createError$2({
        statusCode: 404,
        message: "Template not found"
      });
    }
    return {
      success: true,
      data: template
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error fetching email template:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch email template"
    });
  }
});

const _id__get$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get$8
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$k = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const templateId = parseInt(getRouterParam(event, "id") || "0");
  if (!templateId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid template ID"
    });
  }
  const body = await readBody();
  if (!body.name && !body.subject && !body.body) {
    throw createError$2({
      statusCode: 400,
      message: "At least one field (name, subject, body) is required"
    });
  }
  try {
    const updatedTemplate = {
      id: templateId,
      ...body,
      updated_at: (/* @__PURE__ */ new Date()).toISOString()
    };
    return {
      success: true,
      data: updatedTemplate,
      message: "Email template updated successfully"
    };
  } catch (error) {
    console.error("Error updating email template:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update email template"
    });
  }
});

const _id__put$l = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$k
}, Symbol.toStringTag, { value: 'Module' }));

const gradeLevels_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  const levelType = queryParams.level_type;
  let whereConditions = [];
  const queryValues = [];
  if (search) {
    whereConditions.push(`(name LIKE ? OR code LIKE ?)`);
    const searchPattern = `%${search}%`;
    queryValues.push(searchPattern, searchPattern);
  }
  if (levelType) {
    whereConditions.push(`level_type = ?`);
    queryValues.push(levelType);
  }
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
  try {
    const gradeLevels = await query(
      `SELECT 
        id,
        code,
        name,
        level_type,
        grade_number,
        display_order,
        created_at
      FROM grade_levels
      ${whereClause}
      ORDER BY display_order ASC, grade_number ASC`,
      queryValues
    );
    return {
      success: true,
      data: gradeLevels
    };
  } catch (error) {
    console.error("Error fetching grade levels:", error);
    if (error.code === "ER_NO_SUCH_TABLE") {
      return {
        success: true,
        data: []
      };
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch grade levels"
    });
  }
});

const gradeLevels_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: gradeLevels_get
}, Symbol.toStringTag, { value: 'Module' }));

const gradeLevels_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody();
  if (!body.code || !body.name || !body.level_type || !body.grade_number) {
    throw createError$2({
      statusCode: 400,
      message: "Code, name, level_type, and grade_number are required"
    });
  }
  const existing = await query(
    "SELECT id FROM grade_levels WHERE code = ?",
    [body.code]
  );
  if (existing.length > 0) {
    throw createError$2({
      statusCode: 409,
      message: "Grade level code already exists"
    });
  }
  try {
    const result = await execute(
      `INSERT INTO grade_levels (code, name, level_type, grade_number, display_order)
       VALUES (?, ?, ?, ?, ?)`,
      [
        body.code,
        body.name,
        body.level_type,
        body.grade_number,
        body.display_order || 0
      ]
    );
    const gradeLevels = await query(
      "SELECT * FROM grade_levels WHERE id = ?",
      [result.insertId]
    );
    return {
      success: true,
      data: gradeLevels[0],
      message: "Grade level created successfully"
    };
  } catch (error) {
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Grade levels table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to create grade level"
    });
  }
});

const gradeLevels_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: gradeLevels_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$i = defineEventHandler(async (event) => {
  var _a;
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const gradeLevelId = parseInt(getRouterParam(event, "id") || "0");
  if (!gradeLevelId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid grade level ID"
    });
  }
  try {
    const existing = await query("SELECT id FROM grade_levels WHERE id = ?", [gradeLevelId]);
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Grade level not found"
      });
    }
    const usage = await query(
      "SELECT COUNT(*) as count FROM course_grade_levels WHERE grade_level_id = ?",
      [gradeLevelId]
    );
    if (((_a = usage[0]) == null ? void 0 : _a.count) > 0) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot delete grade level. It is being used in courses."
      });
    }
    await execute("DELETE FROM grade_levels WHERE id = ?", [gradeLevelId]);
    return {
      success: true,
      message: "Grade level deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Grade levels table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete grade level"
    });
  }
});

const _id__delete$j = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$i
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$i = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const gradeLevelId = parseInt(getRouterParam(event, "id") || "0");
  if (!gradeLevelId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid grade level ID"
    });
  }
  const body = await readBody();
  try {
    const existing = await query("SELECT id FROM grade_levels WHERE id = ?", [gradeLevelId]);
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Grade level not found"
      });
    }
    if (body.code) {
      const codeCheck = await query(
        "SELECT id FROM grade_levels WHERE code = ? AND id != ?",
        [body.code, gradeLevelId]
      );
      if (codeCheck.length > 0) {
        throw createError$2({
          statusCode: 409,
          message: "Grade level code already exists"
        });
      }
    }
    const updateFields = [];
    const updateValues = [];
    if (body.code !== void 0) {
      updateFields.push("code = ?");
      updateValues.push(body.code);
    }
    if (body.name !== void 0) {
      updateFields.push("name = ?");
      updateValues.push(body.name);
    }
    if (body.level_type !== void 0) {
      updateFields.push("level_type = ?");
      updateValues.push(body.level_type);
    }
    if (body.grade_number !== void 0) {
      updateFields.push("grade_number = ?");
      updateValues.push(body.grade_number);
    }
    if (body.display_order !== void 0) {
      updateFields.push("display_order = ?");
      updateValues.push(body.display_order);
    }
    if (updateFields.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updateValues.push(gradeLevelId);
    await execute(
      `UPDATE grade_levels SET ${updateFields.join(", ")} WHERE id = ?`,
      updateValues
    );
    const gradeLevels = await query("SELECT * FROM grade_levels WHERE id = ?", [gradeLevelId]);
    return {
      success: true,
      data: gradeLevels[0],
      message: "Grade level updated successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Grade levels table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to update grade level"
    });
  }
});

const _id__put$j = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$i
}, Symbol.toStringTag, { value: 'Module' }));

const inclusions_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  let whereConditions = [];
  const queryValues = [];
  if (search) {
    whereConditions.push(`(name LIKE ? OR code LIKE ? OR description LIKE ?)`);
    const searchPattern = `%${search}%`;
    queryValues.push(searchPattern, searchPattern, searchPattern);
  }
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
  try {
    const inclusions = await query(
      `SELECT 
        id,
        code,
        name,
        description,
        icon,
        created_at
      FROM inclusions
      ${whereClause}
      ORDER BY name ASC`,
      queryValues
    );
    return {
      success: true,
      data: inclusions
    };
  } catch (error) {
    console.error("Error fetching inclusions:", error);
    if (error.code === "ER_NO_SUCH_TABLE") {
      return {
        success: true,
        data: []
      };
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch inclusions"
    });
  }
});

const inclusions_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: inclusions_get
}, Symbol.toStringTag, { value: 'Module' }));

const inclusions_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody();
  if (!body.code || !body.name) {
    throw createError$2({
      statusCode: 400,
      message: "Code and name are required"
    });
  }
  try {
    const existing = await query(
      "SELECT id FROM inclusions WHERE code = ?",
      [body.code]
    );
    if (existing.length > 0) {
      throw createError$2({
        statusCode: 409,
        message: "Inclusion code already exists"
      });
    }
    const result = await execute(
      `INSERT INTO inclusions (code, name, description, icon)
       VALUES (?, ?, ?, ?)`,
      [
        body.code,
        body.name,
        body.description || null,
        body.icon || null
      ]
    );
    const inclusions = await query(
      "SELECT * FROM inclusions WHERE id = ?",
      [result.insertId]
    );
    return {
      success: true,
      data: inclusions[0],
      message: "Inclusion created successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Inclusions table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to create inclusion"
    });
  }
});

const inclusions_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: inclusions_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$g = defineEventHandler(async (event) => {
  var _a;
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const inclusionId = parseInt(getRouterParam(event, "id") || "0");
  if (!inclusionId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid inclusion ID"
    });
  }
  try {
    const existing = await query("SELECT id FROM inclusions WHERE id = ?", [inclusionId]);
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Inclusion not found"
      });
    }
    const usage = await query(
      "SELECT COUNT(*) as count FROM course_inclusions WHERE inclusion_id = ?",
      [inclusionId]
    );
    if (((_a = usage[0]) == null ? void 0 : _a.count) > 0) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot delete inclusion. It is being used in courses."
      });
    }
    await execute("DELETE FROM inclusions WHERE id = ?", [inclusionId]);
    return {
      success: true,
      message: "Inclusion deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Inclusions table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete inclusion"
    });
  }
});

const _id__delete$h = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$g
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$g = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const inclusionId = parseInt(getRouterParam(event, "id") || "0");
  if (!inclusionId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid inclusion ID"
    });
  }
  const body = await readBody();
  try {
    const existing = await query("SELECT id FROM inclusions WHERE id = ?", [inclusionId]);
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Inclusion not found"
      });
    }
    if (body.code) {
      const codeCheck = await query(
        "SELECT id FROM inclusions WHERE code = ? AND id != ?",
        [body.code, inclusionId]
      );
      if (codeCheck.length > 0) {
        throw createError$2({
          statusCode: 409,
          message: "Inclusion code already exists"
        });
      }
    }
    const updateFields = [];
    const updateValues = [];
    if (body.code !== void 0) {
      updateFields.push("code = ?");
      updateValues.push(body.code);
    }
    if (body.name !== void 0) {
      updateFields.push("name = ?");
      updateValues.push(body.name);
    }
    if (body.description !== void 0) {
      updateFields.push("description = ?");
      updateValues.push(body.description);
    }
    if (body.icon !== void 0) {
      updateFields.push("icon = ?");
      updateValues.push(body.icon);
    }
    if (updateFields.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updateValues.push(inclusionId);
    await execute(
      `UPDATE inclusions SET ${updateFields.join(", ")} WHERE id = ?`,
      updateValues
    );
    const inclusions = await query("SELECT * FROM inclusions WHERE id = ?", [inclusionId]);
    return {
      success: true,
      data: inclusions[0],
      message: "Inclusion updated successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Inclusions table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to update inclusion"
    });
  }
});

const _id__put$h = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$g
}, Symbol.toStringTag, { value: 'Module' }));

const paymentMethods_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  try {
    const paymentMethods = await query(
      `SELECT 
        id,
        code,
        name,
        name_en,
        type,
        description,
        icon,
        is_active,
        is_default,
        display_order,
        created_at,
        updated_at
      FROM payment_methods
      ORDER BY display_order, name`
    );
    return {
      success: true,
      data: paymentMethods
    };
  } catch (error) {
    console.error("Error fetching payment methods:", error);
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Payment methods table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch payment methods"
    });
  }
});

const paymentMethods_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: paymentMethods_get
}, Symbol.toStringTag, { value: 'Module' }));

const paymentMethods_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody();
  if (!body.code || !body.name || !body.type) {
    throw createError$2({
      statusCode: 400,
      message: "Code, name, and type are required"
    });
  }
  if (!/^[a-z0-9_]+$/.test(body.code)) {
    throw createError$2({
      statusCode: 400,
      message: "Code must contain only lowercase letters, numbers, and underscores"
    });
  }
  try {
    const existing = await query(
      "SELECT id FROM payment_methods WHERE code = ?",
      [body.code]
    );
    if (existing.length > 0) {
      throw createError$2({
        statusCode: 409,
        message: "Payment method with this code already exists"
      });
    }
    if (body.is_default) {
      await execute(
        "UPDATE payment_methods SET is_default = FALSE WHERE is_default = TRUE"
      );
    }
    await execute(
      `INSERT INTO payment_methods (
        code, name, name_en, type, description, icon,
        is_active, is_default, display_order
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        body.code,
        body.name,
        body.name_en || null,
        body.type,
        body.description || null,
        body.icon || null,
        body.is_active !== void 0 ? body.is_active : true,
        body.is_default !== void 0 ? body.is_default : false,
        body.display_order || 0
      ]
    );
    const [created] = await query(
      "SELECT * FROM payment_methods WHERE code = ?",
      [body.code]
    );
    return {
      success: true,
      data: created[0],
      message: "Payment method created successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error creating payment method:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to create payment method"
    });
  }
});

const paymentMethods_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: paymentMethods_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$e = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const id = parseInt(getRouterParam(event, "id") || "0");
  if (!id) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID is required"
    });
  }
  try {
    const existing = await query(
      "SELECT id, code, is_default FROM payment_methods WHERE id = ?",
      [id]
    );
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Payment method not found"
      });
    }
    const method = existing[0];
    if (method.is_default) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot delete default payment method"
      });
    }
    const payments = await query(
      "SELECT COUNT(*) as count FROM payments WHERE payment_method = ?",
      [method.code]
    );
    if (payments[0].count > 0) {
      throw createError$2({
        statusCode: 400,
        message: `Cannot delete payment method. There are ${payments[0].count} payments using this method.`
      });
    }
    await execute(
      "DELETE FROM payment_methods WHERE id = ?",
      [id]
    );
    return {
      success: true,
      message: "Payment method deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error deleting payment method:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to delete payment method"
    });
  }
});

const _id__delete$f = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$e
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get$6 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const id = parseInt(getRouterParam(event, "id") || "0");
  if (!id) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID is required"
    });
  }
  try {
    const methods = await query(
      "SELECT * FROM payment_methods WHERE id = ?",
      [id]
    );
    if (methods.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Payment method not found"
      });
    }
    return {
      success: true,
      data: methods[0]
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error fetching payment method:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch payment method"
    });
  }
});

const _id__get$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get$6
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$e = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const id = parseInt(getRouterParam(event, "id") || "0");
  if (!id) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID is required"
    });
  }
  const body = await readBody();
  try {
    const existing = await query(
      "SELECT id, code FROM payment_methods WHERE id = ?",
      [id]
    );
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Payment method not found"
      });
    }
    if (body.is_default) {
      await execute(
        "UPDATE payment_methods SET is_default = FALSE WHERE is_default = TRUE AND id != ?",
        [id]
      );
    }
    const updates = [];
    const values = [];
    if (body.name !== void 0) {
      updates.push("name = ?");
      values.push(body.name);
    }
    if (body.name_en !== void 0) {
      updates.push("name_en = ?");
      values.push(body.name_en || null);
    }
    if (body.description !== void 0) {
      updates.push("description = ?");
      values.push(body.description || null);
    }
    if (body.icon !== void 0) {
      updates.push("icon = ?");
      values.push(body.icon || null);
    }
    if (body.is_active !== void 0) {
      updates.push("is_active = ?");
      values.push(body.is_active);
    }
    if (body.is_default !== void 0) {
      updates.push("is_default = ?");
      values.push(body.is_default);
    }
    if (body.display_order !== void 0) {
      updates.push("display_order = ?");
      values.push(body.display_order);
    }
    if (updates.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updates.push("updated_at = NOW()");
    values.push(id);
    await execute(
      `UPDATE payment_methods SET ${updates.join(", ")} WHERE id = ?`,
      values
    );
    const updated = await query(
      "SELECT * FROM payment_methods WHERE id = ?",
      [id]
    );
    return {
      success: true,
      data: updated[0],
      message: "Payment method updated successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error updating payment method:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to update payment method"
    });
  }
});

const _id__put$f = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$e
}, Symbol.toStringTag, { value: 'Module' }));

const bankAccounts_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const paymentMethodId = parseInt(getRouterParam(event, "id") || "0");
  if (!paymentMethodId) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID is required"
    });
  }
  try {
    const methods = await query(
      "SELECT id, type FROM payment_methods WHERE id = ?",
      [paymentMethodId]
    );
    if (methods.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Payment method not found"
      });
    }
    if (methods[0].type !== "bank_transfer") {
      throw createError$2({
        statusCode: 400,
        message: "Bank accounts are only available for bank_transfer payment methods"
      });
    }
    const accounts = await query(
      `SELECT 
        id,
        payment_method_id,
        bank_name,
        account_name,
        account_number,
        account_type,
        branch_name,
        qr_code_url,
        is_active,
        is_default,
        display_order,
        created_at,
        updated_at
      FROM bank_accounts
      WHERE payment_method_id = ?
      ORDER BY display_order, bank_name, account_name`,
      [paymentMethodId]
    );
    return {
      success: true,
      data: accounts
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error fetching bank accounts:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch bank accounts"
    });
  }
});

const bankAccounts_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: bankAccounts_get
}, Symbol.toStringTag, { value: 'Module' }));

const bankAccounts_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const paymentMethodId = parseInt(getRouterParam(event, "id") || "0");
  if (!paymentMethodId) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID is required"
    });
  }
  const body = await readBody();
  if (!body.bank_name || !body.account_name || !body.account_number) {
    throw createError$2({
      statusCode: 400,
      message: "Bank name, account name, and account number are required"
    });
  }
  try {
    const methods = await query(
      "SELECT id, type FROM payment_methods WHERE id = ?",
      [paymentMethodId]
    );
    if (methods.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Payment method not found"
      });
    }
    if (methods[0].type !== "bank_transfer") {
      throw createError$2({
        statusCode: 400,
        message: "Bank accounts are only available for bank_transfer payment methods"
      });
    }
    if (body.is_default) {
      await execute(
        "UPDATE bank_accounts SET is_default = FALSE WHERE payment_method_id = ? AND is_default = TRUE",
        [paymentMethodId]
      );
    }
    await execute(
      `INSERT INTO bank_accounts (
        payment_method_id, bank_name, account_name, account_number,
        account_type, branch_name, qr_code_url,
        is_active, is_default, display_order
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        paymentMethodId,
        body.bank_name,
        body.account_name,
        body.account_number,
        body.account_type || "savings",
        body.branch_name || null,
        body.qr_code_url || null,
        body.is_active !== void 0 ? body.is_active : true,
        body.is_default !== void 0 ? body.is_default : false,
        body.display_order || 0
      ]
    );
    const created = await query(
      "SELECT * FROM bank_accounts WHERE payment_method_id = ? AND account_number = ? ORDER BY id DESC LIMIT 1",
      [paymentMethodId, body.account_number]
    );
    return {
      success: true,
      data: created[0],
      message: "Bank account created successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error creating bank account:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to create bank account"
    });
  }
});

const bankAccounts_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: bankAccounts_post
}, Symbol.toStringTag, { value: 'Module' }));

const _accountId__delete = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const paymentMethodId = parseInt(getRouterParam(event, "id") || "0");
  const accountId = parseInt(getRouterParam(event, "accountId") || "0");
  if (!paymentMethodId || !accountId) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID and account ID are required"
    });
  }
  try {
    const accounts = await query(
      "SELECT id, is_default FROM bank_accounts WHERE id = ? AND payment_method_id = ?",
      [accountId, paymentMethodId]
    );
    if (accounts.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Bank account not found"
      });
    }
    const account = accounts[0];
    if (account.is_default) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot delete default bank account"
      });
    }
    await execute(
      "DELETE FROM bank_accounts WHERE id = ?",
      [accountId]
    );
    return {
      success: true,
      message: "Bank account deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error deleting bank account:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to delete bank account"
    });
  }
});

const _accountId__delete$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _accountId__delete
}, Symbol.toStringTag, { value: 'Module' }));

const _accountId__put = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const paymentMethodId = parseInt(getRouterParam(event, "id") || "0");
  const accountId = parseInt(getRouterParam(event, "accountId") || "0");
  if (!paymentMethodId || !accountId) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID and account ID are required"
    });
  }
  const body = await readBody();
  try {
    const accounts = await query(
      "SELECT id, payment_method_id FROM bank_accounts WHERE id = ? AND payment_method_id = ?",
      [accountId, paymentMethodId]
    );
    if (accounts.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Bank account not found"
      });
    }
    if (body.is_default) {
      await execute(
        "UPDATE bank_accounts SET is_default = FALSE WHERE payment_method_id = ? AND is_default = TRUE AND id != ?",
        [paymentMethodId, accountId]
      );
    }
    const updates = [];
    const values = [];
    if (body.bank_name !== void 0) {
      updates.push("bank_name = ?");
      values.push(body.bank_name);
    }
    if (body.account_name !== void 0) {
      updates.push("account_name = ?");
      values.push(body.account_name);
    }
    if (body.account_number !== void 0) {
      updates.push("account_number = ?");
      values.push(body.account_number);
    }
    if (body.account_type !== void 0) {
      updates.push("account_type = ?");
      values.push(body.account_type);
    }
    if (body.branch_name !== void 0) {
      updates.push("branch_name = ?");
      values.push(body.branch_name || null);
    }
    if (body.qr_code_url !== void 0) {
      updates.push("qr_code_url = ?");
      values.push(body.qr_code_url || null);
    }
    if (body.is_active !== void 0) {
      updates.push("is_active = ?");
      values.push(body.is_active);
    }
    if (body.is_default !== void 0) {
      updates.push("is_default = ?");
      values.push(body.is_default);
    }
    if (body.display_order !== void 0) {
      updates.push("display_order = ?");
      values.push(body.display_order);
    }
    if (updates.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updates.push("updated_at = NOW()");
    values.push(accountId);
    await execute(
      `UPDATE bank_accounts SET ${updates.join(", ")} WHERE id = ?`,
      values
    );
    const updated = await query(
      "SELECT * FROM bank_accounts WHERE id = ?",
      [accountId]
    );
    return {
      success: true,
      data: updated[0],
      message: "Bank account updated successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error updating bank account:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to update bank account"
    });
  }
});

const _accountId__put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _accountId__put
}, Symbol.toStringTag, { value: 'Module' }));

const gateway_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const paymentMethodId = parseInt(getRouterParam(event, "id") || "0");
  if (!paymentMethodId) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID is required"
    });
  }
  try {
    const methods = await query(
      "SELECT id, type, code FROM payment_methods WHERE id = ?",
      [paymentMethodId]
    );
    if (methods.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Payment method not found"
      });
    }
    if (methods[0].type !== "payment_gateway") {
      throw createError$2({
        statusCode: 400,
        message: "Gateway configuration is only available for payment_gateway payment methods"
      });
    }
    const gateways = await query(
      `SELECT 
        id,
        payment_method_id,
        gateway_code,
        gateway_name,
        api_key,
        api_secret,
        merchant_id,
        webhook_secret,
        endpoint_url,
        is_test_mode,
        is_active,
        config,
        created_at,
        updated_at
      FROM payment_gateways
      WHERE payment_method_id = ?`,
      [paymentMethodId]
    );
    if (gateways.length > 0) {
      const gateway = gateways[0];
      if (gateway.api_secret) {
        gateway.api_secret = gateway.api_secret.substring(0, 4) + "****";
      }
      if (gateway.webhook_secret) {
        gateway.webhook_secret = gateway.webhook_secret.substring(0, 4) + "****";
      }
    }
    return {
      success: true,
      data: gateways.length > 0 ? gateways[0] : null
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error fetching payment gateway:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch payment gateway"
    });
  }
});

const gateway_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: gateway_get
}, Symbol.toStringTag, { value: 'Module' }));

const gateway_put = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const paymentMethodId = parseInt(getRouterParam(event, "id") || "0");
  if (!paymentMethodId) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID is required"
    });
  }
  const body = await readBody();
  if (!body.gateway_code || !body.gateway_name) {
    throw createError$2({
      statusCode: 400,
      message: "Gateway code and name are required"
    });
  }
  try {
    const methods = await query(
      "SELECT id, type, code FROM payment_methods WHERE id = ?",
      [paymentMethodId]
    );
    if (methods.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Payment method not found"
      });
    }
    if (methods[0].type !== "payment_gateway") {
      throw createError$2({
        statusCode: 400,
        message: "Gateway configuration is only available for payment_gateway payment methods"
      });
    }
    const existing = await query(
      "SELECT id, api_secret, webhook_secret FROM payment_gateways WHERE payment_method_id = ?",
      [paymentMethodId]
    );
    const configJson = body.config ? JSON.stringify(body.config) : null;
    if (existing.length > 0) {
      const updates = ["gateway_code = ?", "gateway_name = ?", "updated_at = NOW()"];
      const values = [body.gateway_code, body.gateway_name];
      if (body.api_key !== void 0) {
        updates.push("api_key = ?");
        values.push(body.api_key || null);
      }
      if (body.api_secret !== void 0 && !body.api_secret.includes("****")) {
        updates.push("api_secret = ?");
        values.push(body.api_secret || null);
      }
      if (body.merchant_id !== void 0) {
        updates.push("merchant_id = ?");
        values.push(body.merchant_id || null);
      }
      if (body.webhook_secret !== void 0 && !body.webhook_secret.includes("****")) {
        updates.push("webhook_secret = ?");
        values.push(body.webhook_secret || null);
      }
      if (body.endpoint_url !== void 0) {
        updates.push("endpoint_url = ?");
        values.push(body.endpoint_url || null);
      }
      if (body.is_test_mode !== void 0) {
        updates.push("is_test_mode = ?");
        values.push(body.is_test_mode);
      }
      if (body.is_active !== void 0) {
        updates.push("is_active = ?");
        values.push(body.is_active);
      }
      if (body.config !== void 0) {
        updates.push("config = ?");
        values.push(configJson);
      }
      values.push(existing[0].id);
      await execute(
        `UPDATE payment_gateways SET ${updates.join(", ")} WHERE id = ?`,
        values
      );
    } else {
      await execute(
        `INSERT INTO payment_gateways (
          payment_method_id, gateway_code, gateway_name,
          api_key, api_secret, merchant_id, webhook_secret,
          endpoint_url, is_test_mode, is_active, config
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          paymentMethodId,
          body.gateway_code,
          body.gateway_name,
          body.api_key || null,
          body.api_secret || null,
          body.merchant_id || null,
          body.webhook_secret || null,
          body.endpoint_url || null,
          body.is_test_mode !== void 0 ? body.is_test_mode : true,
          body.is_active !== void 0 ? body.is_active : true,
          configJson
        ]
      );
    }
    const gateways = await query(
      "SELECT * FROM payment_gateways WHERE payment_method_id = ?",
      [paymentMethodId]
    );
    if (gateways.length > 0) {
      const gateway = { ...gateways[0] };
      if (gateway.api_secret) {
        gateway.api_secret = gateway.api_secret.substring(0, 4) + "****";
      }
      if (gateway.webhook_secret) {
        gateway.webhook_secret = gateway.webhook_secret.substring(0, 4) + "****";
      }
      if (gateway.config) {
        try {
          gateway.config = JSON.parse(gateway.config);
        } catch (e) {
        }
      }
      return {
        success: true,
        data: gateway,
        message: "Payment gateway configuration updated successfully"
      };
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to save gateway configuration"
    });
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error updating payment gateway:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to update payment gateway"
    });
  }
});

const gateway_put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: gateway_put
}, Symbol.toStringTag, { value: 'Module' }));

const status_patch$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const id = parseInt(getRouterParam(event, "id") || "0");
  if (!id) {
    throw createError$2({
      statusCode: 400,
      message: "Payment method ID is required"
    });
  }
  const body = await readBody();
  if (body.is_active === void 0) {
    throw createError$2({
      statusCode: 400,
      message: "is_active is required"
    });
  }
  try {
    const existing = await query(
      "SELECT id, is_default FROM payment_methods WHERE id = ?",
      [id]
    );
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Payment method not found"
      });
    }
    if (existing[0].is_default && !body.is_active) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot deactivate default payment method"
      });
    }
    await execute(
      "UPDATE payment_methods SET is_active = ?, updated_at = NOW() WHERE id = ?",
      [body.is_active, id]
    );
    const updated = await query(
      "SELECT * FROM payment_methods WHERE id = ?",
      [id]
    );
    return {
      success: true,
      data: updated[0],
      message: `Payment method ${body.is_active ? "activated" : "deactivated"} successfully`
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error updating payment method status:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to update payment method status"
    });
  }
});

const status_patch$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: status_patch$2
}, Symbol.toStringTag, { value: 'Module' }));

const roles_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  let whereConditions = [];
  const queryValues = [];
  if (search) {
    whereConditions.push(`(name LIKE ? OR description LIKE ?)`);
    const searchPattern = `%${search}%`;
    queryValues.push(searchPattern, searchPattern);
  }
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
  try {
    const roles2 = await query(
      `SELECT 
        id,
        name,
        description,
        created_at
      FROM roles
      ${whereClause}
      ORDER BY name ASC`,
      queryValues
    );
    return {
      success: true,
      data: roles2
    };
  } catch (error) {
    console.error("Error fetching roles:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch roles"
    });
  }
});

const roles_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: roles_get
}, Symbol.toStringTag, { value: 'Module' }));

const roles_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody();
  if (!body.name) {
    throw createError$2({
      statusCode: 400,
      message: "Name is required"
    });
  }
  try {
    const existing = await query(
      "SELECT id FROM roles WHERE name = ?",
      [body.name]
    );
    if (existing.length > 0) {
      throw createError$2({
        statusCode: 409,
        message: "Role name already exists"
      });
    }
    const result = await execute(
      `INSERT INTO roles (name, description)
       VALUES (?, ?)`,
      [
        body.name,
        body.description || null
      ]
    );
    const roles2 = await query(
      "SELECT * FROM roles WHERE id = ?",
      [result.insertId]
    );
    return {
      success: true,
      data: roles2[0],
      message: "Role created successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    throw createError$2({
      statusCode: 500,
      message: "Failed to create role"
    });
  }
});

const roles_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: roles_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$c = defineEventHandler(async (event) => {
  var _a;
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const roleId = parseInt(getRouterParam(event, "id") || "0");
  if (!roleId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid role ID"
    });
  }
  try {
    const existing = await query("SELECT id, name FROM roles WHERE id = ?", [roleId]);
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Role not found"
      });
    }
    const roleName = existing[0].name;
    const systemRoles = ["system_admin", "owner", "admin", "branch_admin", "tutor", "parent", "student"];
    if (systemRoles.includes(roleName)) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot delete system role"
      });
    }
    const usage = await query(
      "SELECT COUNT(*) as count FROM user_roles WHERE role_id = ?",
      [roleId]
    );
    if (((_a = usage[0]) == null ? void 0 : _a.count) > 0) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot delete role. It is being used by users."
      });
    }
    await execute("DELETE FROM roles WHERE id = ?", [roleId]);
    return {
      success: true,
      message: "Role deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete role"
    });
  }
});

const _id__delete$d = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$c
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$c = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const roleId = parseInt(getRouterParam(event, "id") || "0");
  if (!roleId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid role ID"
    });
  }
  const body = await readBody();
  try {
    const existing = await query("SELECT id FROM roles WHERE id = ?", [roleId]);
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Role not found"
      });
    }
    if (body.name) {
      const nameCheck = await query(
        "SELECT id FROM roles WHERE name = ? AND id != ?",
        [body.name, roleId]
      );
      if (nameCheck.length > 0) {
        throw createError$2({
          statusCode: 409,
          message: "Role name already exists"
        });
      }
    }
    const updateFields = [];
    const updateValues = [];
    if (body.name !== void 0) {
      updateFields.push("name = ?");
      updateValues.push(body.name);
    }
    if (body.description !== void 0) {
      updateFields.push("description = ?");
      updateValues.push(body.description);
    }
    if (updateFields.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updateValues.push(roleId);
    await execute(
      `UPDATE roles SET ${updateFields.join(", ")} WHERE id = ?`,
      updateValues
    );
    const roles2 = await query("SELECT * FROM roles WHERE id = ?", [roleId]);
    return {
      success: true,
      data: roles2[0],
      message: "Role updated successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    throw createError$2({
      statusCode: 500,
      message: "Failed to update role"
    });
  }
});

const _id__put$d = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$c
}, Symbol.toStringTag, { value: 'Module' }));

const subjects_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  let whereConditions = [];
  const queryValues = [];
  if (search) {
    whereConditions.push(`(name LIKE ? OR code LIKE ? OR short_name LIKE ?)`);
    const searchPattern = `%${search}%`;
    queryValues.push(searchPattern, searchPattern, searchPattern);
  }
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
  try {
    const subjects = await query(
      `SELECT 
        id,
        code,
        name,
        short_name,
        description,
        icon,
        created_at
      FROM subjects
      ${whereClause}
      ORDER BY name ASC`,
      queryValues
    );
    return {
      success: true,
      data: subjects
    };
  } catch (error) {
    console.error("Error fetching subjects:", error);
    if (error.code === "ER_NO_SUCH_TABLE") {
      return {
        success: true,
        data: []
      };
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch subjects"
    });
  }
});

const subjects_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: subjects_get
}, Symbol.toStringTag, { value: 'Module' }));

const subjects_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody();
  if (!body.code || !body.name) {
    throw createError$2({
      statusCode: 400,
      message: "Code and name are required"
    });
  }
  try {
    const existing = await query(
      "SELECT id FROM subjects WHERE code = ?",
      [body.code]
    );
    if (existing.length > 0) {
      throw createError$2({
        statusCode: 409,
        message: "Subject code already exists"
      });
    }
    const result = await execute(
      `INSERT INTO subjects (code, name, short_name, description, icon)
       VALUES (?, ?, ?, ?, ?)`,
      [
        body.code,
        body.name,
        body.short_name || null,
        body.description || null,
        body.icon || null
      ]
    );
    const subjects = await query(
      "SELECT * FROM subjects WHERE id = ?",
      [result.insertId]
    );
    return {
      success: true,
      data: subjects[0],
      message: "Subject created successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Subjects table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to create subject"
    });
  }
});

const subjects_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: subjects_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$a = defineEventHandler(async (event) => {
  var _a;
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const subjectId = parseInt(getRouterParam(event, "id") || "0");
  if (!subjectId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid subject ID"
    });
  }
  try {
    const existing = await query("SELECT id FROM subjects WHERE id = ?", [subjectId]);
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Subject not found"
      });
    }
    const usage = await query(
      "SELECT COUNT(*) as count FROM course_subjects WHERE subject_id = ?",
      [subjectId]
    );
    if (((_a = usage[0]) == null ? void 0 : _a.count) > 0) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot delete subject. It is being used in courses."
      });
    }
    await execute("DELETE FROM subjects WHERE id = ?", [subjectId]);
    return {
      success: true,
      message: "Subject deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Subjects table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete subject"
    });
  }
});

const _id__delete$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$a
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$a = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const subjectId = parseInt(getRouterParam(event, "id") || "0");
  if (!subjectId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid subject ID"
    });
  }
  const body = await readBody();
  try {
    const existing = await query("SELECT id FROM subjects WHERE id = ?", [subjectId]);
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Subject not found"
      });
    }
    if (body.code) {
      const codeCheck = await query(
        "SELECT id FROM subjects WHERE code = ? AND id != ?",
        [body.code, subjectId]
      );
      if (codeCheck.length > 0) {
        throw createError$2({
          statusCode: 409,
          message: "Subject code already exists"
        });
      }
    }
    const updateFields = [];
    const updateValues = [];
    if (body.code !== void 0) {
      updateFields.push("code = ?");
      updateValues.push(body.code);
    }
    if (body.name !== void 0) {
      updateFields.push("name = ?");
      updateValues.push(body.name);
    }
    if (body.short_name !== void 0) {
      updateFields.push("short_name = ?");
      updateValues.push(body.short_name);
    }
    if (body.description !== void 0) {
      updateFields.push("description = ?");
      updateValues.push(body.description);
    }
    if (body.icon !== void 0) {
      updateFields.push("icon = ?");
      updateValues.push(body.icon);
    }
    if (updateFields.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updateValues.push(subjectId);
    await execute(
      `UPDATE subjects SET ${updateFields.join(", ")} WHERE id = ?`,
      updateValues
    );
    const subjects = await query("SELECT * FROM subjects WHERE id = ?", [subjectId]);
    return {
      success: true,
      data: subjects[0],
      message: "Subject updated successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "Subjects table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to update subject"
    });
  }
});

const _id__put$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$a
}, Symbol.toStringTag, { value: 'Module' }));

const system_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const queryParams = getQuery(event);
  const category = queryParams.category;
  const publicOnly = queryParams.public === "true";
  try {
    let sql = "SELECT id, `key`, value, type, category, description, is_public, created_at, updated_at FROM system_settings WHERE 1=1";
    const params = [];
    if (category) {
      sql += " AND category = ?";
      params.push(category);
    }
    if (publicOnly) {
      sql += " AND is_public = TRUE";
    }
    sql += " ORDER BY category, `key`";
    const settings = await query(sql, params);
    const formattedSettings = settings.map((setting) => {
      let parsedValue = setting.value;
      if (setting.type === "number") {
        parsedValue = setting.value ? parseFloat(setting.value) : null;
      } else if (setting.type === "boolean") {
        parsedValue = setting.value === "true" || setting.value === "1";
      } else if (setting.type === "json") {
        try {
          parsedValue = setting.value ? JSON.parse(setting.value) : null;
        } catch (e) {
          parsedValue = setting.value;
        }
      }
      return {
        ...setting,
        value: parsedValue
      };
    });
    if (!category) {
      const grouped = {};
      formattedSettings.forEach((setting) => {
        if (!grouped[setting.category]) {
          grouped[setting.category] = [];
        }
        grouped[setting.category].push(setting);
      });
      return {
        success: true,
        data: grouped
      };
    }
    return {
      success: true,
      data: formattedSettings
    };
  } catch (error) {
    console.error("Error fetching system settings:", error);
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "System settings table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch system settings"
    });
  }
});

const system_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: system_get
}, Symbol.toStringTag, { value: 'Module' }));

const system_put = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody();
  if (!body.settings || !Array.isArray(body.settings) || body.settings.length === 0) {
    throw createError$2({
      statusCode: 400,
      message: "Settings array is required"
    });
  }
  try {
    const updatedSettings = [];
    for (const setting of body.settings) {
      const existing = await query(
        "SELECT id, type FROM system_settings WHERE `key` = ?",
        [setting.key]
      );
      if (existing.length === 0) {
        throw createError$2({
          statusCode: 404,
          message: `Setting with key "${setting.key}" not found`
        });
      }
      const settingType = existing[0].type;
      let valueToStore = setting.value;
      if (settingType === "boolean") {
        valueToStore = setting.value ? "true" : "false";
      } else if (settingType === "number") {
        valueToStore = String(setting.value);
      } else if (settingType === "json") {
        valueToStore = typeof setting.value === "string" ? setting.value : JSON.stringify(setting.value);
      } else {
        valueToStore = String(setting.value);
      }
      await execute(
        "UPDATE system_settings SET value = ?, updated_at = NOW() WHERE `key` = ?",
        [valueToStore, setting.key]
      );
      const updated = await query(
        "SELECT id, `key`, value, type, category, description, is_public FROM system_settings WHERE `key` = ?",
        [setting.key]
      );
      if (updated.length > 0) {
        let parsedValue = updated[0].value;
        if (settingType === "number") {
          parsedValue = updated[0].value ? parseFloat(updated[0].value) : null;
        } else if (settingType === "boolean") {
          parsedValue = updated[0].value === "true" || updated[0].value === "1";
        } else if (settingType === "json") {
          try {
            parsedValue = updated[0].value ? JSON.parse(updated[0].value) : null;
          } catch (e) {
            parsedValue = updated[0].value;
          }
        }
        updatedSettings.push({
          ...updated[0],
          value: parsedValue
        });
      }
    }
    return {
      success: true,
      data: updatedSettings,
      message: "System settings updated successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error updating system settings:", error);
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "System settings table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to update system settings"
    });
  }
});

const system_put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: system_put
}, Symbol.toStringTag, { value: 'Module' }));

const _key__get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const settingKey = getRouterParam(event, "key");
  if (!settingKey) {
    throw createError$2({
      statusCode: 400,
      message: "Setting key is required"
    });
  }
  try {
    const settings = await query(
      "SELECT id, `key`, value, type, category, description, is_public FROM system_settings WHERE `key` = ?",
      [settingKey]
    );
    if (settings.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Setting not found"
      });
    }
    const setting = settings[0];
    let parsedValue = setting.value;
    if (setting.type === "number") {
      parsedValue = setting.value ? parseFloat(setting.value) : null;
    } else if (setting.type === "boolean") {
      parsedValue = setting.value === "true" || setting.value === "1";
    } else if (setting.type === "json") {
      try {
        parsedValue = setting.value ? JSON.parse(setting.value) : null;
      } catch (e) {
        parsedValue = setting.value;
      }
    }
    return {
      success: true,
      data: {
        ...setting,
        value: parsedValue
      }
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error fetching system setting:", error);
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "System settings table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch system setting"
    });
  }
});

const _key__get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _key__get
}, Symbol.toStringTag, { value: 'Module' }));

const _key__put = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const settingKey = getRouterParam(event, "key");
  if (!settingKey) {
    throw createError$2({
      statusCode: 400,
      message: "Setting key is required"
    });
  }
  const body = await readBody();
  if (body.value === void 0) {
    throw createError$2({
      statusCode: 400,
      message: "Value is required"
    });
  }
  try {
    const existing = await query(
      "SELECT id, type FROM system_settings WHERE `key` = ?",
      [settingKey]
    );
    if (existing.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Setting not found"
      });
    }
    const settingType = existing[0].type;
    let valueToStore;
    if (settingType === "boolean") {
      valueToStore = body.value ? "true" : "false";
    } else if (settingType === "number") {
      valueToStore = String(body.value);
    } else if (settingType === "json") {
      valueToStore = typeof body.value === "string" ? body.value : JSON.stringify(body.value);
    } else {
      valueToStore = String(body.value);
    }
    await execute(
      "UPDATE system_settings SET value = ?, updated_at = NOW() WHERE `key` = ?",
      [valueToStore, settingKey]
    );
    const updated = await query(
      "SELECT id, `key`, value, type, category, description, is_public FROM system_settings WHERE `key` = ?",
      [settingKey]
    );
    let parsedValue = updated[0].value;
    if (settingType === "number") {
      parsedValue = updated[0].value ? parseFloat(updated[0].value) : null;
    } else if (settingType === "boolean") {
      parsedValue = updated[0].value === "true" || updated[0].value === "1";
    } else if (settingType === "json") {
      try {
        parsedValue = updated[0].value ? JSON.parse(updated[0].value) : null;
      } catch (e) {
        parsedValue = updated[0].value;
      }
    }
    return {
      success: true,
      data: {
        ...updated[0],
        value: parsedValue
      },
      message: "System setting updated successfully"
    };
  } catch (error) {
    if (error.statusCode) throw error;
    console.error("Error updating system setting:", error);
    if (error.code === "ER_NO_SUCH_TABLE") {
      throw createError$2({
        statusCode: 400,
        message: "System settings table does not exist. Please run migration first."
      });
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to update system setting"
    });
  }
});

const _key__put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _key__put
}, Symbol.toStringTag, { value: 'Module' }));

const students_get = defineEventHandler(async (event) => {
  var _a;
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin", "branch_admin", "tutor"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin or Tutor role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  const page = parseInt(queryParams.page) || 1;
  const limit = parseInt(queryParams.limit) || 20;
  const offset = (page - 1) * limit;
  const isSystemAdmin = roles.includes("system_admin") || roles.includes("owner");
  const isAdmin = roles.includes("admin");
  const isBranchAdmin = roles.includes("branch_admin");
  const isTutor = roles.includes("tutor");
  let branchIds = [];
  if (isBranchAdmin && !isSystemAdmin && !isAdmin) {
    const branchAdmins = await query(
      "SELECT branch_id FROM branch_admins WHERE user_id = ?",
      [auth.userId]
    );
    branchIds = branchAdmins.map((ba) => ba.branch_id);
    if (branchIds.length === 0) {
      return {
        success: true,
        data: [],
        pagination: {
          page,
          limit,
          total: 0,
          totalPages: 0
        }
      };
    }
  }
  let tutorId = null;
  let courseIds = [];
  if (isTutor && !isSystemAdmin && !isBranchAdmin) {
    const tutors = await query(
      "SELECT id FROM tutors WHERE user_id = ?",
      [auth.userId]
    );
    if (tutors.length === 0) {
      return {
        success: true,
        data: [],
        pagination: {
          page,
          limit,
          total: 0,
          totalPages: 0
        }
      };
    }
    tutorId = tutors[0].id;
    const tutorCourses = await query(
      "SELECT DISTINCT course_id FROM tutor_courses WHERE tutor_id = ?",
      [tutorId]
    );
    courseIds = tutorCourses.map((tc) => tc.course_id);
    if (courseIds.length === 0) {
      return {
        success: true,
        data: [],
        pagination: {
          page,
          limit,
          total: 0,
          totalPages: 0
        }
      };
    }
  }
  let whereConditions = [];
  const queryValues = [];
  const status = queryParams.status;
  if (status) {
    whereConditions.push(`u.status = ?`);
    queryValues.push(status);
  }
  if (search) {
    whereConditions.push(`(
      u.username LIKE ? OR 
      u.email LIKE ? OR 
      u.first_name LIKE ? OR 
      u.last_name LIKE ?
    )`);
    const searchPattern = `%${search}%`;
    queryValues.push(searchPattern, searchPattern, searchPattern, searchPattern);
  }
  whereConditions.push(`r.name = 'student'`);
  if (isBranchAdmin && !isSystemAdmin && branchIds.length > 0) {
    whereConditions.push(`e.branch_id IN (${branchIds.map(() => "?").join(",")})`);
    queryValues.push(...branchIds);
  }
  if (isTutor && !isSystemAdmin && !isBranchAdmin && courseIds.length > 0) {
    whereConditions.push(`e.course_id IN (${courseIds.map(() => "?").join(",")})`);
    queryValues.push(...courseIds);
  }
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
  let fromClause = `FROM users u
     INNER JOIN user_roles ur ON u.id = ur.user_id
     INNER JOIN roles r ON ur.role_id = r.id`;
  if (isBranchAdmin && !isSystemAdmin && branchIds.length > 0) {
    fromClause += ` INNER JOIN enrollments e ON u.id = e.student_id`;
  } else if (isTutor && !isSystemAdmin && !isBranchAdmin && courseIds.length > 0) {
    fromClause += ` INNER JOIN enrollments e ON u.id = e.student_id`;
  }
  const countResult = await query(
    `SELECT COUNT(DISTINCT u.id) as count
     ${fromClause}
     ${whereClause}`,
    queryValues
  );
  const total = ((_a = countResult[0]) == null ? void 0 : _a.count) || 0;
  const students = await query(
    `SELECT 
       u.id,
       u.username,
       u.email,
       u.first_name,
       u.last_name,
       u.phone,
       u.status,
       u.created_at,
       u.updated_at,
       GROUP_CONCAT(DISTINCT CONCAT(
         IFNULL(p.id, ''), ':', 
         IFNULL(CONCAT(p.first_name, ' ', p.last_name), ''), ':', 
         IFNULL(ps.relationship, '')
       ) SEPARATOR '||') as parent_info
     ${fromClause}
     LEFT JOIN parent_students ps ON u.id = ps.student_id
     LEFT JOIN users p ON ps.parent_id = p.id
     ${whereClause}
     GROUP BY u.id
     ORDER BY u.created_at DESC
     LIMIT ? OFFSET ?`,
    [...queryValues, limit, offset]
  );
  const formattedStudents = students.map((student) => {
    const parents = [];
    if (student.parent_info) {
      const parentInfos = student.parent_info.split("||").filter((info) => info.trim() !== "");
      for (const info of parentInfos) {
        const [parentId, parentName, relationship] = info.split(":");
        if (parentId && parentName && parentId !== "" && parentName !== "") {
          parents.push({
            id: parseInt(parentId),
            name: parentName,
            relationship: relationship || "guardian"
          });
        }
      }
    }
    return {
      id: student.id,
      username: student.username,
      email: student.email,
      first_name: student.first_name,
      last_name: student.last_name,
      phone: student.phone,
      status: student.status,
      parents,
      created_at: student.created_at,
      updated_at: student.updated_at
    };
  });
  return {
    success: true,
    data: formattedStudents,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  };
});

const students_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: students_get
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get$4 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin", "branch_admin", "tutor"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin or Tutor role required."
    });
  }
  const studentId = parseInt(getRouterParam(event, "id") || "0");
  if (!studentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid student ID"
    });
  }
  const isSystemAdmin = roles.includes("system_admin") || roles.includes("owner");
  const isAdmin = roles.includes("admin");
  const isBranchAdmin = roles.includes("branch_admin");
  const isTutor = roles.includes("tutor");
  if (isBranchAdmin && !isSystemAdmin && !isAdmin) {
    const { query: query2 } = await Promise.resolve().then(function () { return db; });
    const branchAdmins = await query2(
      "SELECT branch_id FROM branch_admins WHERE user_id = ?",
      [auth.userId]
    );
    if (branchAdmins.length > 0) {
      const branchIds = branchAdmins.map((ba) => ba.branch_id);
      const enrollments2 = await query2(
        `SELECT id FROM enrollments 
           WHERE student_id = ? AND branch_id IN (${branchIds.map(() => "?").join(",")})`,
        [studentId, ...branchIds]
      );
      if (enrollments2.length === 0) {
        throw createError$2({
          statusCode: 403,
          message: "Access denied. Student is not enrolled in your branch."
        });
      }
    }
  }
  if (isTutor && !isSystemAdmin && !isBranchAdmin) {
    const { query: query2 } = await Promise.resolve().then(function () { return db; });
    const tutors = await query2(
      "SELECT id FROM tutors WHERE user_id = ?",
      [auth.userId]
    );
    if (tutors.length > 0) {
      const tutorId = tutors[0].id;
      const tutorCourses = await query2(
        "SELECT DISTINCT course_id FROM tutor_courses WHERE tutor_id = ?",
        [tutorId]
      );
      if (tutorCourses.length > 0) {
        const courseIds = tutorCourses.map((tc) => tc.course_id);
        const enrollments2 = await query2(
          `SELECT id FROM enrollments 
           WHERE student_id = ? AND course_id IN (${courseIds.map(() => "?").join(",")})`,
          [studentId, ...courseIds]
        );
        if (enrollments2.length === 0) {
          throw createError$2({
            statusCode: 403,
            message: "Access denied. Student is not enrolled in your courses."
          });
        }
      } else {
        throw createError$2({
          statusCode: 403,
          message: "Access denied. You have no assigned courses."
        });
      }
    } else {
      throw createError$2({
        statusCode: 403,
        message: "Access denied. Tutor profile not found."
      });
    }
  }
  const student = await findUserById(studentId);
  if (!student) {
    throw createError$2({
      statusCode: 404,
      message: "Student not found"
    });
  }
  const studentRoles = await query(
    `SELECT r.name 
     FROM user_roles ur
     JOIN roles r ON ur.role_id = r.id
     WHERE ur.user_id = ? AND r.name = 'student'`,
    [studentId]
  );
  if (studentRoles.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "User is not a student"
    });
  }
  const parents = await query(
    `SELECT 
       p.id,
       p.username,
       p.email,
       p.first_name,
       p.last_name,
       p.phone,
       p.status,
       ps.relationship
     FROM parent_students ps
     INNER JOIN users p ON ps.parent_id = p.id
     WHERE ps.student_id = ?`,
    [studentId]
  );
  const enrollments = await query(
    `SELECT 
       e.id,
       e.status as enrollment_status,
       e.created_at as enrolled_at,
       c.id as course_id,
       c.title as course_title,
       c.code as course_code,
       b.id as branch_id,
       b.name as branch_name,
       b.code as branch_code
     FROM enrollments e
     INNER JOIN courses c ON e.course_id = c.id
     INNER JOIN branches b ON e.branch_id = b.id
     WHERE e.student_id = ?
     ORDER BY e.created_at DESC`,
    [studentId]
  );
  const { password_hash, ...publicStudent } = student;
  return {
    success: true,
    data: {
      student: publicStudent,
      parents: parents.map((p) => ({
        id: p.id,
        username: p.username,
        email: p.email,
        first_name: p.first_name,
        last_name: p.last_name,
        phone: p.phone,
        status: p.status,
        relationship: p.relationship
      })),
      enrollments: enrollments.map((e) => ({
        id: e.id,
        course: {
          id: e.course_id,
          title: e.course_title,
          code: e.course_code
        },
        branch: {
          id: e.branch_id,
          name: e.branch_name,
          code: e.branch_code
        },
        status: e.enrollment_status,
        enrolled_at: e.enrolled_at
      }))
    }
  };
});

const _id__get$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get$4
}, Symbol.toStringTag, { value: 'Module' }));

const parents_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const studentId = parseInt(getRouterParam(event, "id") || "0");
  if (!studentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid student ID"
    });
  }
  const body = await readBody(event);
  if (!body.parent_id || !body.relationship) {
    throw createError$2({
      statusCode: 400,
      message: "parent_id and relationship are required"
    });
  }
  const student = await findUserById(studentId);
  if (!student) {
    throw createError$2({
      statusCode: 404,
      message: "Student not found"
    });
  }
  const studentRoles = await query(
    `SELECT r.name 
     FROM user_roles ur
     JOIN roles r ON ur.role_id = r.id
     WHERE ur.user_id = ? AND r.name = 'student'`,
    [studentId]
  );
  if (studentRoles.length === 0) {
    throw createError$2({
      statusCode: 400,
      message: "User is not a student"
    });
  }
  const parent = await findUserById(body.parent_id);
  if (!parent) {
    throw createError$2({
      statusCode: 404,
      message: "Parent not found"
    });
  }
  const parentRoles = await query(
    `SELECT r.name 
     FROM user_roles ur
     JOIN roles r ON ur.role_id = r.id
     WHERE ur.user_id = ? AND r.name = 'parent'`,
    [body.parent_id]
  );
  if (parentRoles.length === 0) {
    throw createError$2({
      statusCode: 400,
      message: "User is not a parent"
    });
  }
  const existing = await query(
    "SELECT id FROM parent_students WHERE parent_id = ? AND student_id = ?",
    [body.parent_id, studentId]
  );
  if (existing.length > 0) {
    throw createError$2({
      statusCode: 409,
      message: "Parent-student relationship already exists"
    });
  }
  const validRelationships = ["father", "mother", "guardian", "other"];
  if (!validRelationships.includes(body.relationship)) {
    throw createError$2({
      statusCode: 400,
      message: `Invalid relationship. Must be one of: ${validRelationships.join(", ")}`
    });
  }
  await execute(
    "INSERT INTO parent_students (parent_id, student_id, relationship) VALUES (?, ?, ?)",
    [body.parent_id, studentId, body.relationship]
  );
  const newParent = await query(
    `SELECT 
       p.id,
       p.username,
       p.email,
       p.first_name,
       p.last_name,
       p.phone,
       p.status,
       ps.relationship
     FROM parent_students ps
     INNER JOIN users p ON ps.parent_id = p.id
     WHERE ps.parent_id = ? AND ps.student_id = ?`,
    [body.parent_id, studentId]
  );
  if (newParent.length === 0) {
    throw createError$2({
      statusCode: 500,
      message: "Failed to retrieve parent information"
    });
  }
  return {
    success: true,
    data: {
      id: newParent[0].id,
      username: newParent[0].username,
      email: newParent[0].email,
      first_name: newParent[0].first_name,
      last_name: newParent[0].last_name,
      phone: newParent[0].phone,
      status: newParent[0].status,
      relationship: newParent[0].relationship
    },
    message: "Parent added successfully"
  };
});

const parents_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: parents_post
}, Symbol.toStringTag, { value: 'Module' }));

const _parentId__delete = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const routeParams = event.context.params;
  const studentId = parseInt((routeParams == null ? void 0 : routeParams.id) || "0");
  const parentId = parseInt((routeParams == null ? void 0 : routeParams.parentId) || "0");
  if (!studentId || !parentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid student ID or parent ID"
    });
  }
  const student = await findUserById(studentId);
  if (!student) {
    throw createError$2({
      statusCode: 404,
      message: "Student not found"
    });
  }
  const relationship = await query(
    "SELECT id FROM parent_students WHERE parent_id = ? AND student_id = ?",
    [parentId, studentId]
  );
  if (relationship.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Parent-student relationship not found"
    });
  }
  await execute(
    "DELETE FROM parent_students WHERE parent_id = ? AND student_id = ?",
    [parentId, studentId]
  );
  return {
    success: true,
    message: "Parent removed successfully"
  };
});

const _parentId__delete$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _parentId__delete
}, Symbol.toStringTag, { value: 'Module' }));

const _parentId__patch = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const routeParams = event.context.params;
  const studentId = parseInt((routeParams == null ? void 0 : routeParams.id) || "0");
  const parentId = parseInt((routeParams == null ? void 0 : routeParams.parentId) || "0");
  if (!studentId || !parentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid student ID or parent ID"
    });
  }
  const body = await readBody(event);
  const { relationship } = body;
  if (!relationship || !["father", "mother", "guardian", "other"].includes(relationship)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid relationship. Must be one of: father, mother, guardian, other"
    });
  }
  const student = await findUserById(studentId);
  if (!student) {
    throw createError$2({
      statusCode: 404,
      message: "Student not found"
    });
  }
  const existingRelationship = await query(
    "SELECT id, relationship FROM parent_students WHERE parent_id = ? AND student_id = ?",
    [parentId, studentId]
  );
  if (existingRelationship.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Parent-student relationship not found"
    });
  }
  await execute(
    "UPDATE parent_students SET relationship = ? WHERE parent_id = ? AND student_id = ?",
    [relationship, parentId, studentId]
  );
  return {
    success: true,
    message: "Parent relationship updated successfully",
    data: {
      parent_id: parentId,
      student_id: studentId,
      relationship
    }
  };
});

const _parentId__patch$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _parentId__patch
}, Symbol.toStringTag, { value: 'Module' }));

const payments_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required to view payment history."
    });
  }
  const studentId = parseInt(getRouterParam(event, "id") || "0");
  if (!studentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid student ID"
    });
  }
  const isSystemAdmin = roles.includes("system_admin") || roles.includes("owner");
  const isAdmin = roles.includes("admin");
  const isBranchAdmin = roles.includes("branch_admin");
  if (isBranchAdmin && !isSystemAdmin && !isAdmin) {
    const branchAdmins = await query(
      "SELECT branch_id FROM branch_admins WHERE user_id = ?",
      [auth.userId]
    );
    if (branchAdmins.length > 0) {
      const branchIds = branchAdmins.map((ba) => ba.branch_id);
      const enrollments = await query(
        `SELECT id FROM enrollments 
         WHERE student_id = ? AND branch_id IN (${branchIds.map(() => "?").join(",")})`,
        [studentId, ...branchIds]
      );
      if (enrollments.length === 0) {
        throw createError$2({
          statusCode: 403,
          message: "Access denied. Student is not enrolled in your branch."
        });
      }
    }
  }
  const student = await findUserById(studentId);
  if (!student) {
    throw createError$2({
      statusCode: 404,
      message: "Student not found"
    });
  }
  const payments = await query(
    `SELECT 
       p.id,
       p.amount,
       p.final_amount,
       p.status,
       p.payment_method,
       p.paid_at,
       p.created_at,
       p.updated_at,
       p.invoice_number,
       p.transaction_id,
       e.id as enrollment_id,
       c.title as course_title,
       c.code as course_code,
       b.name as branch_name
     FROM payments p
     LEFT JOIN enrollments e ON p.enrollment_id = e.id
     LEFT JOIN courses c ON e.course_id = c.id
     LEFT JOIN branches b ON e.branch_id = b.id
     WHERE p.user_id = ?
     ORDER BY p.created_at DESC`,
    [studentId]
  );
  return {
    success: true,
    data: payments.map((p) => ({
      id: p.id,
      amount: parseFloat(p.final_amount || p.amount),
      status: p.status,
      payment_method: p.payment_method,
      payment_method_name: p.payment_method === "bank_transfer" ? "\u0E42\u0E2D\u0E19\u0E40\u0E07\u0E34\u0E19" : p.payment_method === "online" ? "\u0E0A\u0E33\u0E23\u0E30\u0E2D\u0E2D\u0E19\u0E44\u0E25\u0E19\u0E4C" : p.payment_method || "\u0E44\u0E21\u0E48\u0E23\u0E30\u0E1A\u0E38",
      payment_date: p.paid_at || p.created_at,
      invoice_number: p.invoice_number,
      transaction_id: p.transaction_id,
      enrollment: p.enrollment_id ? {
        id: p.enrollment_id,
        course: {
          title: p.course_title,
          code: p.course_code
        },
        branch: {
          name: p.branch_name
        }
      } : null,
      created_at: p.created_at,
      updated_at: p.updated_at
    }))
  };
});

const payments_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: payments_get
}, Symbol.toStringTag, { value: 'Module' }));

const testimonials_get$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const queryParams = getQuery(event);
  const search = queryParams.search;
  const status = queryParams.status;
  let sql = `
    SELECT 
      id,
      name,
      role,
      comment,
      rating,
      avatar_url,
      status,
      display_order,
      created_at,
      updated_at
    FROM testimonials
    WHERE 1=1
  `;
  const params = [];
  if (search) {
    sql += ` AND (name LIKE ? OR role LIKE ? OR comment LIKE ?)`;
    const searchPattern = `%${search}%`;
    params.push(searchPattern, searchPattern, searchPattern);
  }
  if (status) {
    sql += ` AND status = ?`;
    params.push(status);
  }
  sql += ` ORDER BY display_order ASC, created_at DESC`;
  try {
    const testimonials = await query(sql, params);
    return {
      success: true,
      data: testimonials
    };
  } catch (error) {
    console.error("Error fetching testimonials:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch testimonials"
    });
  }
});

const testimonials_get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: testimonials_get$2
}, Symbol.toStringTag, { value: 'Module' }));

const testimonials_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const body = await readBody();
  if (!body.name || !body.role || !body.comment || !body.rating) {
    throw createError$2({
      statusCode: 400,
      message: "Name, role, comment, and rating are required"
    });
  }
  if (body.rating < 1 || body.rating > 5) {
    throw createError$2({
      statusCode: 400,
      message: "Rating must be between 1 and 5"
    });
  }
  const validStatuses = ["pending", "approved", "rejected"];
  const status = body.status && validStatuses.includes(body.status) ? body.status : "pending";
  try {
    const result = await execute(
      `INSERT INTO testimonials (name, role, comment, rating, avatar_url, status, display_order)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        body.name,
        body.role,
        body.comment,
        body.rating,
        body.avatar_url || null,
        status,
        body.display_order || 0
      ]
    );
    return {
      success: true,
      data: {
        id: result.insertId
      }
    };
  } catch (error) {
    console.error("Error creating testimonial:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to create testimonial"
    });
  }
});

const testimonials_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: testimonials_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$8 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const testimonialId = parseInt(getRouterParam(event, "id") || "0");
  if (!testimonialId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid testimonial ID"
    });
  }
  const existing = await query(
    "SELECT id FROM testimonials WHERE id = ?",
    [testimonialId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Testimonial not found"
    });
  }
  try {
    await execute("DELETE FROM testimonials WHERE id = ?", [testimonialId]);
    return {
      success: true,
      message: "Testimonial deleted successfully"
    };
  } catch (error) {
    console.error("Error deleting testimonial:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete testimonial"
    });
  }
});

const _id__delete$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$8
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$8 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["system_admin", "owner", "admin"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const testimonialId = parseInt(getRouterParam(event, "id") || "0");
  if (!testimonialId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid testimonial ID"
    });
  }
  const body = await readBody();
  const existing = await query(
    "SELECT id FROM testimonials WHERE id = ?",
    [testimonialId]
  );
  if (existing.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Testimonial not found"
    });
  }
  if (body.rating !== void 0 && (body.rating < 1 || body.rating > 5)) {
    throw createError$2({
      statusCode: 400,
      message: "Rating must be between 1 and 5"
    });
  }
  if (body.status) {
    const validStatuses = ["pending", "approved", "rejected"];
    if (!validStatuses.includes(body.status)) {
      throw createError$2({
        statusCode: 400,
        message: "Invalid status"
      });
    }
  }
  const updates = [];
  const values = [];
  if (body.name !== void 0) {
    updates.push("name = ?");
    values.push(body.name);
  }
  if (body.role !== void 0) {
    updates.push("role = ?");
    values.push(body.role);
  }
  if (body.comment !== void 0) {
    updates.push("comment = ?");
    values.push(body.comment);
  }
  if (body.rating !== void 0) {
    updates.push("rating = ?");
    values.push(body.rating);
  }
  if (body.avatar_url !== void 0) {
    updates.push("avatar_url = ?");
    values.push(body.avatar_url);
  }
  if (body.status !== void 0) {
    updates.push("status = ?");
    values.push(body.status);
  }
  if (body.display_order !== void 0) {
    updates.push("display_order = ?");
    values.push(body.display_order);
  }
  if (updates.length === 0) {
    throw createError$2({
      statusCode: 400,
      message: "No fields to update"
    });
  }
  values.push(testimonialId);
  try {
    await execute(
      `UPDATE testimonials SET ${updates.join(", ")} WHERE id = ?`,
      values
    );
    return {
      success: true,
      message: "Testimonial updated successfully"
    };
  } catch (error) {
    console.error("Error updating testimonial:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update testimonial"
    });
  }
});

const _id__put$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$8
}, Symbol.toStringTag, { value: 'Module' }));

const schedules_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const isTutor = roles.includes(UserRole.TUTOR);
  const isSystemAdmin = roles.includes(UserRole.SYSTEM_ADMIN) || roles.includes(UserRole.OWNER);
  const isAdmin = roles.includes(UserRole.ADMIN);
  const isBranchAdmin = roles.includes(UserRole.BRANCH_ADMIN);
  if (!isTutor && !isSystemAdmin && !isAdmin && !isBranchAdmin) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Tutor or Admin role required."
    });
  }
  const queryParams = getQuery(event);
  const startDate = queryParams.start_date;
  const endDate = queryParams.end_date;
  const status = queryParams.status;
  const courseId = queryParams.course_id;
  const tutorId = queryParams.tutor_id;
  let filterTutorId = null;
  let branchIds = [];
  if (isTutor && !isSystemAdmin && !isAdmin && !isBranchAdmin) {
    const tutors = await query(
      "SELECT id FROM tutors WHERE user_id = ?",
      [auth.userId]
    );
    if (tutors.length === 0 || !tutors[0]) {
      return {
        success: true,
        data: []
      };
    }
    filterTutorId = tutors[0].id;
  } else if (isBranchAdmin && !isSystemAdmin && !isAdmin) {
    const branchAdmins = await query(
      "SELECT branch_id FROM branch_admins WHERE user_id = ?",
      [auth.userId]
    );
    branchIds = branchAdmins.map((ba) => ba.branch_id);
    if (branchIds.length === 0) {
      return {
        success: true,
        data: []
      };
    }
  } else if (tutorId) {
    filterTutorId = parseInt(tutorId);
  }
  let sql = `
    SELECT 
      cs.id,
      cs.course_id,
      cs.branch_id,
      cs.tutor_id,
      cs.start_datetime,
      cs.end_datetime,
      cs.session_type,
      cs.meeting_link,
      cs.video_url,
      cs.status,
      c.title as course_title,
      c.code as course_code,
      c.type as course_type,
      b.name as branch_name,
      b.code as branch_code,
      t.id as tutor_profile_id
    FROM course_schedules cs
    INNER JOIN courses c ON cs.course_id = c.id
    INNER JOIN branches b ON cs.branch_id = b.id
    INNER JOIN tutors t ON cs.tutor_id = t.id
    WHERE 1=1
  `;
  const params = [];
  if (filterTutorId) {
    sql += ` AND cs.tutor_id = ?`;
    params.push(filterTutorId);
  }
  if (branchIds.length > 0) {
    sql += ` AND cs.branch_id IN (${branchIds.map(() => "?").join(",")})`;
    params.push(...branchIds);
  }
  if (startDate) {
    sql += ` AND DATE(cs.start_datetime) >= ?`;
    params.push(startDate);
  }
  if (endDate) {
    sql += ` AND DATE(cs.start_datetime) <= ?`;
    params.push(endDate);
  }
  if (status) {
    sql += ` AND cs.status = ?`;
    params.push(status);
  }
  if (courseId) {
    sql += ` AND cs.course_id = ?`;
    params.push(parseInt(courseId));
  }
  sql += ` ORDER BY cs.start_datetime ASC`;
  try {
    const schedules = await query(sql, params);
    return {
      success: true,
      data: schedules.map((s) => ({
        id: s.id,
        course_id: s.course_id,
        branch_id: s.branch_id,
        tutor_id: s.tutor_id,
        start_datetime: s.start_datetime,
        end_datetime: s.end_datetime,
        session_type: s.session_type,
        meeting_link: s.meeting_link,
        video_url: s.video_url,
        status: s.status,
        course: {
          id: s.course_id,
          title: s.course_title,
          code: s.course_code,
          type: s.course_type
        },
        branch: {
          id: s.branch_id,
          name: s.branch_name,
          code: s.branch_code
        }
      }))
    };
  } catch (error) {
    console.error("Error fetching schedules:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch schedules"
    });
  }
});

const schedules_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: schedules_get
}, Symbol.toStringTag, { value: 'Module' }));

const upload_post$2 = defineEventHandler(async (event) => {
  await requireAuth(event);
  try {
    const query = getQuery(event);
    const entityType = query.entityType;
    const entityId = query.entityId ? parseInt(query.entityId) : null;
    const fileType = query.fileType || "content";
    const allowedEntityTypes = ["courses", "articles", "testimonials", "users"];
    if (!entityType || !allowedEntityTypes.includes(entityType)) {
      throw createError$2({
        statusCode: 400,
        message: `entityType is required and must be one of: ${allowedEntityTypes.join(", ")}`
      });
    }
    if (!entityId && ["thumbnail", "featured", "avatar"].includes(fileType)) {
      throw createError$2({
        statusCode: 400,
        message: "entityId is required for thumbnail, featured, and avatar file types"
      });
    }
    const formData = await readMultipartFormData(event);
    if (!formData || formData.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No file uploaded"
      });
    }
    const file = formData[0];
    if (!file.filename || !file.data) {
      throw createError$2({
        statusCode: 400,
        message: "Invalid file"
      });
    }
    const allowedTypes = ["image/jpeg", "image/jpg", "image/png", "image/gif", "image/webp"];
    if (!file.type || !allowedTypes.includes(file.type)) {
      throw createError$2({
        statusCode: 400,
        message: "Only image files are allowed (JPEG, PNG, GIF, WebP)"
      });
    }
    let maxSize = 2 * 1024 * 1024;
    if (fileType === "avatar") {
      maxSize = 1 * 1024 * 1024;
    } else if (fileType === "thumbnail" || fileType === "featured") {
      maxSize = 2 * 1024 * 1024;
    } else if (fileType === "content") {
      maxSize = 2 * 1024 * 1024;
    }
    if (file.data.length > maxSize) {
      const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(0);
      throw createError$2({
        statusCode: 400,
        message: `File size exceeds ${maxSizeMB}MB limit`
      });
    }
    let uploadsDir;
    let publicUrl;
    let filename;
    if (entityId) {
      const entityDir = join$1(process.cwd(), "public", "uploads", entityType, entityId.toString());
      if (!existsSync$1(entityDir)) {
        await mkdir(entityDir, { recursive: true });
      }
      const extension = file.filename.split(".").pop();
      if (fileType === "thumbnail" || fileType === "featured" || fileType === "avatar") {
        filename = `${fileType}.${extension}`;
      } else {
        const timestamp = Date.now();
        filename = `content-${timestamp}.${extension}`;
      }
      uploadsDir = entityDir;
      publicUrl = `/uploads/${entityType}/${entityId}/${filename}`;
    } else {
      uploadsDir = join$1(process.cwd(), "public", "uploads", entityType);
      if (!existsSync$1(uploadsDir)) {
        await mkdir(uploadsDir, { recursive: true });
      }
      const timestamp = Date.now();
      const randomString = Math.random().toString(36).substring(2, 15);
      const extension = file.filename.split(".").pop();
      filename = `${timestamp}-${randomString}.${extension}`;
      publicUrl = `/uploads/${entityType}/${filename}`;
    }
    const filePath = join$1(uploadsDir, filename);
    await writeFile$1(filePath, file.data);
    return {
      success: true,
      data: {
        url: publicUrl,
        filename,
        originalName: file.filename,
        size: file.data.length,
        type: file.type,
        entityType,
        entityId,
        fileType
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error uploading file:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to upload file"
    });
  }
});

const upload_post$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: upload_post$2
}, Symbol.toStringTag, { value: 'Module' }));

const users_get = defineEventHandler(async (event) => {
  var _a;
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const adminRoles = ["system_admin", "owner", "admin", "branch_admin"];
  if (!roles.some((role2) => adminRoles.includes(role2))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const queryParams = getQuery(event);
  const role = queryParams.role;
  const search = queryParams.search;
  const page = parseInt(queryParams.page) || 1;
  const limit = parseInt(queryParams.limit) || 20;
  const offset = (page - 1) * limit;
  let whereConditions = [];
  const queryValues = [];
  if (role) {
    whereConditions.push(`r.name = ?`);
    queryValues.push(role);
  }
  const status = queryParams.status;
  if (status) {
    whereConditions.push(`u.status = ?`);
    queryValues.push(status);
  }
  if (search) {
    whereConditions.push(`(
      u.username LIKE ? OR 
      u.email LIKE ? OR 
      u.first_name LIKE ? OR 
      u.last_name LIKE ?
    )`);
    const searchPattern = `%${search}%`;
    queryValues.push(searchPattern, searchPattern, searchPattern, searchPattern);
  }
  whereConditions.push(`u.id IN (
    SELECT DISTINCT ur_inner.user_id
    FROM user_roles ur_inner
    JOIN roles r_inner ON ur_inner.role_id = r_inner.id
    WHERE r_inner.name IN ('system_admin', 'owner', 'admin', 'branch_admin', 'tutor')
  )`);
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
  const countResult = await query(
    `SELECT COUNT(DISTINCT u.id) as count
     FROM users u
     LEFT JOIN user_roles ur ON u.id = ur.user_id
     LEFT JOIN roles r ON ur.role_id = r.id
     ${whereClause}`,
    queryValues
  );
  const total = ((_a = countResult[0]) == null ? void 0 : _a.count) || 0;
  const users = await query(
    `SELECT 
       u.id,
       u.username,
       u.email,
       u.first_name,
       u.last_name,
       u.phone,
       u.status,
       u.created_at,
       u.updated_at,
       GROUP_CONCAT(DISTINCT r.name) as roles
     FROM users u
     LEFT JOIN user_roles ur ON u.id = ur.user_id
     LEFT JOIN roles r ON ur.role_id = r.id
     ${whereClause}
     GROUP BY u.id
     ORDER BY u.created_at DESC
     LIMIT ? OFFSET ?`,
    [...queryValues, limit, offset]
  );
  const formattedUsers = users.map((user) => {
    const allRoles = user.roles ? user.roles.split(",").filter((r) => r && r.trim()) : [];
    const validRoles = ["system_admin", "owner", "admin", "branch_admin", "tutor"];
    const displayRoles = allRoles.filter((role2) => validRoles.includes(role2));
    return {
      id: user.id,
      username: user.username,
      email: user.email,
      first_name: user.first_name,
      last_name: user.last_name,
      phone: user.phone,
      status: user.status,
      roles: displayRoles,
      // Only show valid roles
      created_at: user.created_at,
      updated_at: user.updated_at
    };
  });
  return {
    success: true,
    data: formattedUsers,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  };
});

const users_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: users_get
}, Symbol.toStringTag, { value: 'Module' }));

const users_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const adminRoles = ["system_admin", "owner"];
  if (!roles.some((role) => adminRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const body = await readBody(event);
  if (!body.username || !body.password || !body.first_name || !body.last_name) {
    throw createError$2({
      statusCode: 400,
      message: "Username, password, first name, and last name are required"
    });
  }
  if (!body.roles || body.roles.length === 0) {
    throw createError$2({
      statusCode: 400,
      message: "At least one role is required"
    });
  }
  const existingUser = await findUserByIdentifier(body.username);
  if (existingUser) {
    throw createError$2({
      statusCode: 409,
      message: "Username already exists"
    });
  }
  if (body.email) {
    const existingEmailUser = await findUserByEmail(body.email);
    if (existingEmailUser) {
      throw createError$2({
        statusCode: 409,
        message: "Email already exists"
      });
    }
  }
  const validRoles = await query(
    "SELECT id, name FROM roles WHERE name IN (?)",
    [body.roles]
  );
  if (validRoles.length !== body.roles.length) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid role(s) provided"
    });
  }
  const passwordHash = await bcrypt.hash(body.password, 12);
  const result = await execute(
    `INSERT INTO users (username, email, password_hash, first_name, last_name, phone, status)
     VALUES (?, ?, ?, ?, ?, ?, 'active')`,
    [
      body.username,
      body.email || null,
      passwordHash,
      body.first_name,
      body.last_name,
      body.phone || null
    ]
  );
  const userId = result.insertId;
  for (const role of validRoles) {
    await execute(
      "INSERT INTO user_roles (user_id, role_id) VALUES (?, ?)",
      [userId, role.id]
    );
  }
  const { getUserWithRoles } = await Promise.resolve().then(function () { return auth_service; });
  const user = await getUserWithRoles(userId);
  if (!user) {
    throw createError$2({
      statusCode: 500,
      message: "Failed to create user"
    });
  }
  return {
    success: true,
    data: user,
    message: "User created successfully"
  };
});

const users_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: users_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$6 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const adminRoles = ["system_admin", "owner"];
  if (!roles.some((role) => adminRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const userId = parseInt(getRouterParam(event, "id") || "0");
  if (!userId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid user ID"
    });
  }
  if (userId === auth.userId) {
    throw createError$2({
      statusCode: 400,
      message: "Cannot delete your own account"
    });
  }
  const existingUser = await findUserById(userId);
  if (!existingUser) {
    throw createError$2({
      statusCode: 404,
      message: "User not found"
    });
  }
  await execute(
    "UPDATE users SET status = ?, updated_at = NOW() WHERE id = ?",
    ["inactive", userId]
  );
  return {
    success: true,
    message: "User deleted successfully"
  };
});

const _id__delete$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$6
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$6 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const adminRoles = ["system_admin", "owner", "admin", "branch_admin"];
  if (!roles.some((role) => adminRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
  const userId = parseInt(getRouterParam(event, "id") || "0");
  if (!userId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid user ID"
    });
  }
  const body = await readBody(event);
  const { findUserById } = await Promise.resolve().then(function () { return auth_service; });
  const existingUser = await findUserById(userId);
  if (!existingUser) {
    throw createError$2({
      statusCode: 404,
      message: "User not found"
    });
  }
  if (body.username && body.username !== existingUser.username) {
    const usernameUser = await findUserByIdentifier(body.username);
    if (usernameUser && usernameUser.id !== userId) {
      throw createError$2({
        statusCode: 409,
        message: "Username already exists"
      });
    }
  }
  if (body.email !== void 0 && body.email !== existingUser.email) {
    if (body.email) {
      const emailUser = await findUserByEmail(body.email);
      if (emailUser && emailUser.id !== userId) {
        throw createError$2({
          statusCode: 409,
          message: "Email already exists"
        });
      }
    }
  }
  const updateFields = [];
  const updateValues = [];
  if (body.username !== void 0) {
    updateFields.push("username = ?");
    updateValues.push(body.username);
  }
  if (body.email !== void 0) {
    updateFields.push("email = ?");
    updateValues.push(body.email);
  }
  if (body.password) {
    const passwordHash = await bcrypt.hash(body.password, 12);
    updateFields.push("password_hash = ?");
    updateValues.push(passwordHash);
  }
  if (body.first_name !== void 0) {
    updateFields.push("first_name = ?");
    updateValues.push(body.first_name);
  }
  if (body.last_name !== void 0) {
    updateFields.push("last_name = ?");
    updateValues.push(body.last_name);
  }
  if (body.phone !== void 0) {
    updateFields.push("phone = ?");
    updateValues.push(body.phone);
  }
  if (updateFields.length > 0) {
    updateValues.push(userId);
    await execute(
      `UPDATE users SET ${updateFields.join(", ")}, updated_at = NOW() WHERE id = ?`,
      updateValues
    );
  }
  if (body.roles !== void 0) {
    const validRoles = await query(
      "SELECT id, name FROM roles WHERE name IN (?)",
      [body.roles]
    );
    if (validRoles.length !== body.roles.length) {
      throw createError$2({
        statusCode: 400,
        message: "Invalid role(s) provided"
      });
    }
    await execute("DELETE FROM user_roles WHERE user_id = ?", [userId]);
    for (const role of validRoles) {
      await execute(
        "INSERT INTO user_roles (user_id, role_id) VALUES (?, ?)",
        [userId, role.id]
      );
    }
  }
  const user = await getUserWithRoles(userId);
  if (!user) {
    throw createError$2({
      statusCode: 500,
      message: "Failed to get updated user"
    });
  }
  return {
    success: true,
    data: user,
    message: "User updated successfully"
  };
});

const _id__put$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$6
}, Symbol.toStringTag, { value: 'Module' }));

const status_patch = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const adminRoles = ["system_admin", "owner"];
  if (!roles.some((role) => adminRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. System Admin or Owner role required."
    });
  }
  const userId = parseInt(getRouterParam(event, "id") || "0");
  if (!userId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid user ID"
    });
  }
  if (userId === auth.userId) {
    throw createError$2({
      statusCode: 400,
      message: "Cannot change your own account status"
    });
  }
  const body = await readBody(event);
  if (!body.status || !Object.values(UserStatus).includes(body.status)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid status. Must be one of: active, inactive, suspended"
    });
  }
  const existingUser = await findUserById(userId);
  if (!existingUser) {
    throw createError$2({
      statusCode: 404,
      message: "User not found"
    });
  }
  await execute(
    "UPDATE users SET status = ?, updated_at = NOW() WHERE id = ?",
    [body.status, userId]
  );
  const user = await getUserWithRoles(userId);
  if (!user) {
    throw createError$2({
      statusCode: 500,
      message: "Failed to get updated user"
    });
  }
  return {
    success: true,
    data: user,
    message: `User status updated to ${body.status}`
  };
});

const status_patch$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: status_patch
}, Symbol.toStringTag, { value: 'Module' }));

const addresses_get = defineEventHandler(async (event) => {
  await requireAuth(event);
  const userId = parseInt(getRouterParam(event, "userId") || "0");
  if (!userId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid user ID"
    });
  }
  try {
    const addresses = await query(
      `SELECT 
        id,
        user_id,
        address_type,
        recipient_name,
        phone,
        address_line1,
        address_line2,
        subdistrict,
        district,
        province,
        postal_code,
        country,
        is_default,
        created_at,
        updated_at
      FROM user_addresses
      WHERE user_id = ?
      ORDER BY is_default DESC, created_at ASC`,
      [userId]
    );
    return {
      success: true,
      data: addresses
    };
  } catch (error) {
    console.error("Error fetching user addresses:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch user addresses"
    });
  }
});

const addresses_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: addresses_get
}, Symbol.toStringTag, { value: 'Module' }));

const addresses_post = defineEventHandler(async (event) => {
  await requireAuth(event);
  const userId = parseInt(getRouterParam(event, "userId") || "0");
  if (!userId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid user ID"
    });
  }
  const body = await readBody(event);
  if (!body.recipient_name || !body.phone || !body.address_line1 || !body.province || !body.postal_code) {
    throw createError$2({
      statusCode: 400,
      message: "Recipient name, phone, address line 1, province, and postal code are required"
    });
  }
  const validAddressTypes = ["home", "work", "other"];
  if (body.address_type && !validAddressTypes.includes(body.address_type)) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid address type"
    });
  }
  try {
    const users = await query(
      "SELECT id FROM users WHERE id = ?",
      [userId]
    );
    if (users.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "User not found"
      });
    }
    if (body.is_default) {
      await execute(
        "UPDATE user_addresses SET is_default = FALSE WHERE user_id = ?",
        [userId]
      );
    }
    const result = await execute(
      `INSERT INTO user_addresses (
        user_id, address_type, recipient_name, phone,
        address_line1, address_line2, subdistrict, district,
        province, postal_code, country, is_default
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        userId,
        body.address_type || "home",
        body.recipient_name,
        body.phone,
        body.address_line1,
        body.address_line2 || null,
        body.subdistrict || null,
        body.district || null,
        body.province,
        body.postal_code,
        body.country || "Thailand",
        body.is_default || false
      ]
    );
    const addresses = await query(
      `SELECT 
        id,
        user_id,
        address_type,
        recipient_name,
        phone,
        address_line1,
        address_line2,
        subdistrict,
        district,
        province,
        postal_code,
        country,
        is_default,
        created_at,
        updated_at
      FROM user_addresses
      WHERE id = ?`,
      [result.insertId]
    );
    return {
      success: true,
      data: addresses[0]
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error creating user address:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to create user address"
    });
  }
});

const addresses_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: addresses_post
}, Symbol.toStringTag, { value: 'Module' }));

const _addressId__delete = defineEventHandler(async (event) => {
  await requireAuth(event);
  const userId = parseInt(getRouterParam(event, "userId") || "0");
  const addressId = parseInt(getRouterParam(event, "addressId") || "0");
  if (!userId || !addressId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid user ID or address ID"
    });
  }
  try {
    const addresses = await query(
      "SELECT id FROM user_addresses WHERE id = ? AND user_id = ?",
      [addressId, userId]
    );
    if (addresses.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Address not found"
      });
    }
    const enrollments = await query(
      "SELECT id FROM enrollments WHERE shipping_address_id = ? LIMIT 1",
      [addressId]
    );
    if (enrollments.length > 0) {
      throw createError$2({
        statusCode: 400,
        message: "Cannot delete address that is used in enrollments"
      });
    }
    await execute(
      "DELETE FROM user_addresses WHERE id = ? AND user_id = ?",
      [addressId, userId]
    );
    return {
      success: true,
      message: "Address deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error deleting user address:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete user address"
    });
  }
});

const _addressId__delete$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _addressId__delete
}, Symbol.toStringTag, { value: 'Module' }));

const _addressId__put = defineEventHandler(async (event) => {
  await requireAuth(event);
  const userId = parseInt(getRouterParam(event, "userId") || "0");
  const addressId = parseInt(getRouterParam(event, "addressId") || "0");
  if (!userId || !addressId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid user ID or address ID"
    });
  }
  const body = await readBody(event);
  const addresses = await query(
    "SELECT id FROM user_addresses WHERE id = ? AND user_id = ?",
    [addressId, userId]
  );
  if (addresses.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Address not found"
    });
  }
  if (body.address_type) {
    const validAddressTypes = ["home", "work", "other"];
    if (!validAddressTypes.includes(body.address_type)) {
      throw createError$2({
        statusCode: 400,
        message: "Invalid address type"
      });
    }
  }
  try {
    if (body.is_default) {
      await execute(
        "UPDATE user_addresses SET is_default = FALSE WHERE user_id = ? AND id != ?",
        [userId, addressId]
      );
    }
    const updates = [];
    const params = [];
    if (body.address_type !== void 0) {
      updates.push("address_type = ?");
      params.push(body.address_type);
    }
    if (body.recipient_name !== void 0) {
      updates.push("recipient_name = ?");
      params.push(body.recipient_name);
    }
    if (body.phone !== void 0) {
      updates.push("phone = ?");
      params.push(body.phone);
    }
    if (body.address_line1 !== void 0) {
      updates.push("address_line1 = ?");
      params.push(body.address_line1);
    }
    if (body.address_line2 !== void 0) {
      updates.push("address_line2 = ?");
      params.push(body.address_line2 || null);
    }
    if (body.subdistrict !== void 0) {
      updates.push("subdistrict = ?");
      params.push(body.subdistrict || null);
    }
    if (body.district !== void 0) {
      updates.push("district = ?");
      params.push(body.district || null);
    }
    if (body.province !== void 0) {
      updates.push("province = ?");
      params.push(body.province);
    }
    if (body.postal_code !== void 0) {
      updates.push("postal_code = ?");
      params.push(body.postal_code);
    }
    if (body.country !== void 0) {
      updates.push("country = ?");
      params.push(body.country);
    }
    if (body.is_default !== void 0) {
      updates.push("is_default = ?");
      params.push(body.is_default);
    }
    if (updates.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updates.push("updated_at = CURRENT_TIMESTAMP");
    params.push(addressId, userId);
    await execute(
      `UPDATE user_addresses SET ${updates.join(", ")} WHERE id = ? AND user_id = ?`,
      params
    );
    const updated = await query(
      `SELECT 
        id,
        user_id,
        address_type,
        recipient_name,
        phone,
        address_line1,
        address_line2,
        subdistrict,
        district,
        province,
        postal_code,
        country,
        is_default,
        created_at,
        updated_at
      FROM user_addresses
      WHERE id = ? AND user_id = ?`,
      [addressId, userId]
    );
    return {
      success: true,
      data: updated[0]
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error updating user address:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update user address"
    });
  }
});

const _addressId__put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _addressId__put
}, Symbol.toStringTag, { value: 'Module' }));

const setDefault_patch = defineEventHandler(async (event) => {
  await requireAuth(event);
  const userId = parseInt(getRouterParam(event, "userId") || "0");
  const addressId = parseInt(getRouterParam(event, "addressId") || "0");
  if (!userId || !addressId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid user ID or address ID"
    });
  }
  try {
    const addresses = await query(
      "SELECT id FROM user_addresses WHERE id = ? AND user_id = ?",
      [addressId, userId]
    );
    if (addresses.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Address not found"
      });
    }
    await execute(
      "UPDATE user_addresses SET is_default = FALSE WHERE user_id = ?",
      [userId]
    );
    await execute(
      "UPDATE user_addresses SET is_default = TRUE, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND user_id = ?",
      [addressId, userId]
    );
    const updated = await query(
      `SELECT 
        id,
        user_id,
        address_type,
        recipient_name,
        phone,
        address_line1,
        address_line2,
        subdistrict,
        district,
        province,
        postal_code,
        country,
        is_default,
        created_at,
        updated_at
      FROM user_addresses
      WHERE id = ? AND user_id = ?`,
      [addressId, userId]
    );
    return {
      success: true,
      data: updated[0]
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error setting default address:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to set default address"
    });
  }
});

const setDefault_patch$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: setDefault_patch
}, Symbol.toStringTag, { value: 'Module' }));

const articles_get = defineEventHandler(async (event) => {
  const queryParams = getQuery(event);
  const limit = parseInt(queryParams.limit) || 10;
  const category = queryParams.category;
  const featured = queryParams.featured === "true";
  let sql = `
    SELECT 
      id,
      title,
      slug,
      excerpt,
      category,
      icon,
      featured_image_url,
      is_featured,
      view_count,
      published_at,
      created_at
    FROM articles
    WHERE status = 'published'
  `;
  const params = [];
  if (category) {
    sql += ` AND category = ?`;
    params.push(category);
  }
  if (featured) {
    sql += ` AND is_featured = TRUE`;
  }
  sql += ` ORDER BY display_order ASC, published_at DESC LIMIT ?`;
  params.push(limit);
  try {
    const articles = await query(sql, params);
    return {
      success: true,
      data: articles
    };
  } catch (error) {
    console.error("Error fetching articles:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch articles"
    });
  }
});

const articles_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: articles_get
}, Symbol.toStringTag, { value: 'Module' }));

const _slug__get$2 = defineEventHandler(async (event) => {
  const slug = getRouterParam(event, "slug");
  if (!slug) {
    throw createError$2({
      statusCode: 400,
      message: "Article slug is required"
    });
  }
  try {
    const articles = await query(
      `SELECT 
        a.id,
        a.title,
        a.slug,
        a.excerpt,
        a.content,
        a.category,
        a.icon,
        a.featured_image_url,
        a.is_featured,
        a.view_count,
        a.published_at,
        a.created_at,
        a.updated_at,
        u.first_name as author_first_name,
        u.last_name as author_last_name
      FROM articles a
      LEFT JOIN users u ON a.author_id = u.id
      WHERE a.slug = ? AND a.status = 'published'`,
      [slug]
    );
    if (articles.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Article not found"
      });
    }
    const article = articles[0];
    try {
      await query(
        "UPDATE articles SET view_count = view_count + 1 WHERE id = ?",
        [article.id]
      );
    } catch (error) {
      console.error("Failed to increment view count:", error);
    }
    return {
      success: true,
      data: {
        ...article,
        author_name: article.author_first_name && article.author_last_name ? `${article.author_first_name} ${article.author_last_name}` : null
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error fetching article:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch article"
    });
  }
});

const _slug__get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _slug__get$2
}, Symbol.toStringTag, { value: 'Module' }));

const forgotPassword_post = defineEventHandler(async (event) => {
  const body = await readBody(event);
  const { identifier } = body;
  if (!identifier) {
    throw createError$2({
      statusCode: 400,
      message: "\u0E0A\u0E37\u0E48\u0E2D\u0E1C\u0E39\u0E49\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19\u0E2B\u0E23\u0E37\u0E2D\u0E2D\u0E35\u0E40\u0E21\u0E25\u0E4C\u0E08\u0E33\u0E40\u0E1B\u0E47\u0E19\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E23\u0E2D\u0E01"
    });
  }
  return {
    success: true,
    message: "\u0E2B\u0E32\u0E01\u0E2D\u0E35\u0E40\u0E21\u0E25\u0E4C\u0E19\u0E35\u0E49\u0E21\u0E35\u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E23\u0E30\u0E1A\u0E1A \u0E40\u0E23\u0E32\u0E08\u0E30\u0E2A\u0E48\u0E07\u0E25\u0E34\u0E07\u0E01\u0E4C\u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E43\u0E2B\u0E49\u0E04\u0E38\u0E13"
  };
});

const forgotPassword_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: forgotPassword_post
}, Symbol.toStringTag, { value: 'Module' }));

const login_post = defineEventHandler(async (event) => {
  try {
    const body = await readBody(event);
    console.log("[Login API] Received login request for username:", body.username);
    if (!body.username || !body.password) {
      console.log("[Login API] Validation failed: missing username or password");
      throw createError$2({
        statusCode: 400,
        message: "Username and password are required"
      });
    }
    console.log("[Login API] Calling login service...");
    const result = await login(body);
    console.log("[Login API] Login successful for user ID:", result.user.id);
    setCookie(event, "access_token", result.accessToken, {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
      maxAge: 15 * 60
      // 15 minutes
    });
    setCookie(event, "refresh_token", result.refreshToken, {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
      maxAge: 7 * 24 * 60 * 60
      // 7 days
    });
    return {
      success: true,
      data: {
        user: result.user,
        accessToken: result.accessToken
      }
    };
  } catch (error) {
    console.error("[Login API] Error:", error);
    console.error("[Login API] Error message:", error.message);
    console.error("[Login API] Error statusCode:", error.statusCode);
    throw error;
  }
});

const login_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: login_post
}, Symbol.toStringTag, { value: 'Module' }));

const me_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const user = await getUserWithRoles(auth.userId);
  if (!user) {
    throw createError$2({
      statusCode: 404,
      message: "User not found"
    });
  }
  return {
    success: true,
    data: user
  };
});

const me_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: me_get
}, Symbol.toStringTag, { value: 'Module' }));

const callback_post = defineEventHandler(async (event) => {
  var _a, _b, _c, _d;
  const provider = getRouterParam(event, "provider");
  const body = await readBody(event);
  const { code, redirect_uri } = body;
  if (!["google", "facebook", "line"].includes(provider || "")) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid OAuth provider"
    });
  }
  const config = useRuntimeConfig$1();
  const clientId = process.env[`OAUTH_${provider.toUpperCase()}_CLIENT_ID`];
  const clientSecret = process.env[`OAUTH_${provider.toUpperCase()}_CLIENT_SECRET`];
  if (!clientId || !clientSecret) {
    throw createError$2({
      statusCode: 500,
      message: `${provider} OAuth is not configured`
    });
  }
  try {
    let userInfo = {};
    if (provider === "google") {
      const tokenResponse = await $fetch("https://oauth2.googleapis.com/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          code,
          client_id: clientId,
          client_secret: clientSecret,
          redirect_uri: redirect_uri || `${config.public.apiBase}/auth/callback/google`,
          grant_type: "authorization_code"
        }).toString()
      });
      const userResponse = await $fetch("https://www.googleapis.com/oauth2/v2/userinfo", {
        headers: {
          Authorization: `Bearer ${tokenResponse.access_token}`
        }
      });
      userInfo = {
        email: userResponse.email,
        firstName: userResponse.given_name,
        lastName: userResponse.family_name,
        picture: userResponse.picture
      };
    } else if (provider === "facebook") {
      const tokenResponse = await $fetch("https://graph.facebook.com/v18.0/oauth/access_token", {
        method: "GET",
        params: {
          client_id: clientId,
          client_secret: clientSecret,
          redirect_uri: redirect_uri || `${config.public.apiBase}/auth/callback/facebook`,
          code
        }
      });
      const userResponse = await $fetch("https://graph.facebook.com/v18.0/me", {
        params: {
          fields: "id,name,email,first_name,last_name,picture",
          access_token: tokenResponse.access_token
        }
      });
      userInfo = {
        email: userResponse.email,
        firstName: userResponse.first_name,
        lastName: userResponse.last_name,
        picture: (_b = (_a = userResponse.picture) == null ? void 0 : _a.data) == null ? void 0 : _b.url
      };
    } else if (provider === "line") {
      const tokenResponse = await $fetch("https://api.line.me/oauth2/v2.1/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          grant_type: "authorization_code",
          code,
          redirect_uri: redirect_uri || `${config.public.apiBase}/auth/callback/line`,
          client_id: clientId,
          client_secret: clientSecret
        }).toString()
      });
      const userResponse = await $fetch("https://api.line.me/v2/profile", {
        headers: {
          Authorization: `Bearer ${tokenResponse.access_token}`
        }
      });
      let email = "";
      if (tokenResponse.id_token) {
        const payload = JSON.parse(Buffer.from(tokenResponse.id_token.split(".")[1], "base64").toString());
        email = payload.email;
      }
      userInfo = {
        email: email || `${userResponse.userId}@line.me`,
        firstName: ((_c = userResponse.displayName) == null ? void 0 : _c.split(" ")[0]) || "",
        lastName: ((_d = userResponse.displayName) == null ? void 0 : _d.split(" ").slice(1).join(" ")) || "",
        picture: userResponse.pictureUrl
      };
    }
    if (!userInfo.email) {
      throw createError$2({
        statusCode: 400,
        message: "Unable to get email from OAuth provider"
      });
    }
    let user = await findUserByEmail(userInfo.email);
    if (!user) {
      const username = userInfo.email.split("@")[0] + "_" + provider;
      const randomPassword = Math.random().toString(36).slice(-12) + Math.random().toString(36).slice(-12);
      const createdUser = await createUser({
        username,
        email: userInfo.email,
        password: randomPassword,
        // Will be hashed, user can't login with password
        first_name: userInfo.firstName || "",
        last_name: userInfo.lastName || "",
        phone: void 0
      }, UserRole.PARENT);
      user = createdUser;
      if (userInfo.picture) {
        await execute(
          "UPDATE users SET avatar_url = ? WHERE id = ?",
          [userInfo.picture, user.id]
        );
      }
    } else {
      if (userInfo.picture && !user.avatar_url) {
        await execute(
          "UPDATE users SET avatar_url = ? WHERE id = ?",
          [userInfo.picture, user.id]
        );
      }
    }
    const userWithRoles = await getUserWithRoles(user.id);
    if (!userWithRoles) {
      throw createError$2({
        statusCode: 500,
        message: "Failed to get user roles"
      });
    }
    const accessToken = generateAccessToken(userWithRoles);
    const refreshToken = generateRefreshToken(user.id);
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);
    await execute(
      `INSERT INTO refresh_tokens (user_id, token, expires_at)
       VALUES (?, ?, ?)
       ON DUPLICATE KEY UPDATE token = ?, expires_at = ?`,
      [user.id, refreshToken, expiresAt, refreshToken, expiresAt]
    );
    setCookie(event, "access_token", accessToken, {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
      maxAge: 2 * 60 * 60
      // 2 hours
    });
    setCookie(event, "refresh_token", refreshToken, {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
      maxAge: 7 * 24 * 60 * 60
      // 7 days
    });
    return {
      success: true,
      data: {
        user: userWithRoles,
        accessToken
      }
    };
  } catch (err) {
    console.error(`OAuth ${provider} callback error:`, err);
    throw createError$2({
      statusCode: 500,
      message: err.message || `Failed to authenticate with ${provider}`
    });
  }
});

const callback_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: callback_post
}, Symbol.toStringTag, { value: 'Module' }));

const url_post = defineEventHandler(async (event) => {
  const provider = getRouterParam(event, "provider");
  const body = await readBody(event);
  const { redirect_uri, state } = body;
  if (!["google", "facebook", "line"].includes(provider || "")) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid OAuth provider"
    });
  }
  const config = useRuntimeConfig$1();
  const clientId = process.env[`OAUTH_${provider.toUpperCase()}_CLIENT_ID`];
  process.env[`OAUTH_${provider.toUpperCase()}_CLIENT_SECRET`];
  process.env[`OAUTH_${provider.toUpperCase()}_BASE_URL`];
  if (!clientId) {
    throw createError$2({
      statusCode: 500,
      message: `${provider} OAuth is not configured`
    });
  }
  const callbackUrl = `${config.public.apiBase}/auth/callback/${provider}?state=${encodeURIComponent(state || "")}`;
  let authUrl = "";
  if (provider === "google") {
    const scopes = "openid email profile";
    authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirect_uri || callbackUrl)}&response_type=code&scope=${encodeURIComponent(scopes)}&state=${encodeURIComponent(state || "")}`;
  } else if (provider === "facebook") {
    const scopes = "email,public_profile";
    authUrl = `https://www.facebook.com/v18.0/dialog/oauth?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirect_uri || callbackUrl)}&scope=${encodeURIComponent(scopes)}&state=${encodeURIComponent(state || "")}`;
  } else if (provider === "line") {
    const scopes = "profile openid email";
    authUrl = `https://access.line.me/oauth2/v2.1/authorize?response_type=code&client_id=${clientId}&redirect_uri=${encodeURIComponent(redirect_uri || callbackUrl)}&state=${encodeURIComponent(state || "")}&scope=${encodeURIComponent(scopes)}`;
  }
  return authUrl;
});

const url_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: url_post
}, Symbol.toStringTag, { value: 'Module' }));

const register_post = defineEventHandler(async (event) => {
  const body = await readBody(event);
  if (!body.username || !body.password || !body.first_name || !body.last_name) {
    throw createError$2({
      statusCode: 400,
      message: "Username, password, first name, and last name are required"
    });
  }
  const { findUserByIdentifier } = await Promise.resolve().then(function () { return auth_service; });
  const existingUser = await findUserByIdentifier(body.username);
  if (existingUser) {
    throw createError$2({
      statusCode: 409,
      message: "Username already registered"
    });
  }
  if (body.email) {
    const { findUserByEmail } = await Promise.resolve().then(function () { return auth_service; });
    const existingEmailUser = await findUserByEmail(body.email);
    if (existingEmailUser) {
      throw createError$2({
        statusCode: 409,
        message: "Email already registered"
      });
    }
  }
  const user = await createUser(body);
  if (body.role) {
    const { queryOne, execute: execute2 } = await Promise.resolve().then(function () { return db; });
    const roleRecord = await queryOne(
      "SELECT id FROM roles WHERE name = ?",
      [body.role]
    );
    if (roleRecord) {
      await execute2(
        "DELETE FROM user_roles WHERE user_id = ?",
        [user.id]
      );
      await execute2(
        "INSERT INTO user_roles (user_id, role_id) VALUES (?, ?)",
        [user.id, roleRecord.id]
      );
    }
  }
  const userWithRoles = await getUserWithRoles(user.id);
  if (!userWithRoles) {
    throw createError$2({
      statusCode: 500,
      message: "Failed to create user"
    });
  }
  const accessToken = generateAccessToken(userWithRoles);
  const refreshToken = generateRefreshToken(user.id);
  const { execute } = await Promise.resolve().then(function () { return db; });
  const expiresAt = /* @__PURE__ */ new Date();
  expiresAt.setDate(expiresAt.getDate() + 7);
  await execute(
    `INSERT INTO refresh_tokens (user_id, token, expires_at)
     VALUES (?, ?, ?)`,
    [user.id, refreshToken, expiresAt]
  );
  setCookie(event, "access_token", accessToken, {
    httpOnly: true,
    secure: true,
    sameSite: "strict",
    maxAge: 15 * 60
  });
  setCookie(event, "refresh_token", refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60
  });
  return {
    success: true,
    data: {
      user: userWithRoles,
      accessToken
    }
  };
});

const register_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: register_post
}, Symbol.toStringTag, { value: 'Module' }));

const branches_get = defineEventHandler(async (event) => {
  try {
    const branches = await query(
      `SELECT 
        id,
        name,
        code,
        address,
        phone,
        email,
        status,
        created_at,
        updated_at
      FROM branches
      WHERE status = 'active'
      ORDER BY name ASC`
    );
    return {
      success: true,
      data: branches
    };
  } catch (error) {
    console.error("Error fetching branches:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch branches"
    });
  }
});

const branches_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: branches_get
}, Symbol.toStringTag, { value: 'Module' }));

const appointments_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const queryParams = getQuery(event);
  const startDate = queryParams.start_date;
  const endDate = queryParams.end_date;
  const status = queryParams.status;
  const appointmentType = queryParams.appointment_type;
  try {
    let sql = `
      SELECT DISTINCT
        ca.id,
        ca.user_id,
        ca.title,
        ca.description,
        ca.start_datetime,
        ca.end_datetime,
        ca.appointment_type,
        ca.location,
        ca.meeting_link,
        ca.status,
        ca.color,
        ca.reminder_minutes,
        ca.created_at,
        ca.updated_at,
        u.first_name,
        u.last_name,
        CASE WHEN ca.user_id = ? THEN TRUE ELSE FALSE END as is_mine
      FROM calendar_appointments ca
      INNER JOIN users u ON ca.user_id = u.id
      WHERE (
        ca.user_id = ?
        OR EXISTS (
          SELECT 1 FROM calendar_appointment_participants cap
          WHERE cap.appointment_id = ca.id AND cap.user_id = ?
        )
      )
    `;
    const params = [auth.userId, auth.userId, auth.userId];
    const filterConditions = [];
    if (startDate) {
      filterConditions.push(`DATE(ca.start_datetime) >= ?`);
      params.push(startDate);
    }
    if (endDate) {
      filterConditions.push(`DATE(ca.start_datetime) <= ?`);
      params.push(endDate);
    }
    if (status) {
      filterConditions.push(`ca.status = ?`);
      params.push(status);
    }
    if (appointmentType) {
      filterConditions.push(`ca.appointment_type = ?`);
      params.push(appointmentType);
    }
    if (filterConditions.length > 0) {
      sql += ` AND ${filterConditions.join(" AND ")}`;
    }
    sql += ` ORDER BY ca.start_datetime ASC`;
    const appointments = await query(sql, params);
    const appointmentIds = appointments.map((a) => a.id);
    let participants = [];
    if (appointmentIds.length > 0) {
      participants = await query(
        `SELECT 
          cap.appointment_id,
          cap.user_id,
          cap.participant_type,
          cap.status as participant_status,
          u.first_name,
          u.last_name,
          u.email
        FROM calendar_appointment_participants cap
        INNER JOIN users u ON cap.user_id = u.id
        WHERE cap.appointment_id IN (${appointmentIds.map(() => "?").join(",")})`,
        appointmentIds
      );
    }
    const participantsByAppointment = /* @__PURE__ */ new Map();
    participants.forEach((p) => {
      if (!participantsByAppointment.has(p.appointment_id)) {
        participantsByAppointment.set(p.appointment_id, []);
      }
      participantsByAppointment.get(p.appointment_id).push({
        user_id: p.user_id,
        participant_type: p.participant_type,
        status: p.participant_status,
        user: {
          id: p.user_id,
          first_name: p.first_name,
          last_name: p.last_name,
          email: p.email
        }
      });
    });
    return {
      success: true,
      data: appointments.map((a) => ({
        id: a.id,
        user_id: a.user_id,
        title: a.title,
        description: a.description,
        start_datetime: a.start_datetime,
        end_datetime: a.end_datetime,
        appointment_type: a.appointment_type,
        location: a.location,
        meeting_link: a.meeting_link,
        status: a.status,
        color: a.color,
        reminder_minutes: a.reminder_minutes,
        created_at: a.created_at,
        updated_at: a.updated_at,
        is_mine: a.is_mine === 1 || a.is_mine === true,
        created_by: {
          id: a.user_id,
          first_name: a.first_name,
          last_name: a.last_name
        },
        participants: participantsByAppointment.get(a.id) || []
      }))
    };
  } catch (error) {
    console.error("Error fetching calendar appointments:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch calendar appointments"
    });
  }
});

const appointments_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: appointments_get
}, Symbol.toStringTag, { value: 'Module' }));

const appointments_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const body = await readBody(event);
  if (!body.title || !body.start_datetime || !body.end_datetime) {
    throw createError$2({
      statusCode: 400,
      message: "Title, start_datetime, and end_datetime are required"
    });
  }
  const startDate = new Date(body.start_datetime);
  const endDate = new Date(body.end_datetime);
  if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid datetime format"
    });
  }
  if (endDate < startDate) {
    throw createError$2({
      statusCode: 400,
      message: "end_datetime must be after start_datetime"
    });
  }
  const appointmentType = body.appointment_type || "student";
  const status = body.status || "scheduled";
  const color = body.color || "#3B82F6";
  try {
    const result = await execute(
      `INSERT INTO calendar_appointments (
        user_id, title, description, start_datetime, end_datetime,
        appointment_type, location, meeting_link, status, color, reminder_minutes
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        auth.userId,
        body.title,
        body.description || null,
        body.start_datetime,
        body.end_datetime,
        appointmentType,
        body.location || null,
        body.meeting_link || null,
        status,
        color,
        body.reminder_minutes || null
      ]
    );
    const appointmentId = result.insertId;
    if (body.participant_user_ids && body.participant_user_ids.length > 0) {
      for (const userId of body.participant_user_ids) {
        if (userId === auth.userId) continue;
        const userRoles = await query(
          `SELECT r.name 
           FROM user_roles ur
           JOIN roles r ON ur.role_id = r.id
           WHERE ur.user_id = ?`,
          [userId]
        );
        let participantType = "other";
        if (userRoles.length > 0) {
          const roleName = userRoles[0].name;
          if (roleName === "student") participantType = "student";
          else if (roleName === "parent") participantType = "parent";
          else if (roleName === "tutor") participantType = "tutor";
          else if (["system_admin", "owner", "admin", "branch_admin"].includes(roleName)) participantType = "admin";
        }
        await execute(
          "INSERT INTO calendar_appointment_participants (appointment_id, user_id, participant_type) VALUES (?, ?, ?)",
          [appointmentId, userId, participantType]
        );
      }
    }
    const appointments = await query(
      `SELECT 
        ca.id,
        ca.user_id,
        ca.title,
        ca.description,
        ca.start_datetime,
        ca.end_datetime,
        ca.appointment_type,
        ca.location,
        ca.meeting_link,
        ca.status,
        ca.color,
        ca.reminder_minutes,
        ca.created_at,
        ca.updated_at,
        u.first_name,
        u.last_name
      FROM calendar_appointments ca
      INNER JOIN users u ON ca.user_id = u.id
      WHERE ca.id = ?`,
      [appointmentId]
    );
    if (appointments.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Appointment not found after creation"
      });
    }
    const createdAppointment = appointments[0];
    const participants = await query(
      `SELECT 
        cap.user_id,
        cap.participant_type,
        cap.status as participant_status,
        u.first_name,
        u.last_name,
        u.email
      FROM calendar_appointment_participants cap
      INNER JOIN users u ON cap.user_id = u.id
      WHERE cap.appointment_id = ?`,
      [appointmentId]
    );
    return {
      success: true,
      data: {
        id: createdAppointment.id,
        user_id: createdAppointment.user_id,
        title: createdAppointment.title,
        description: createdAppointment.description,
        start_datetime: createdAppointment.start_datetime,
        end_datetime: createdAppointment.end_datetime,
        appointment_type: createdAppointment.appointment_type,
        location: createdAppointment.location,
        meeting_link: createdAppointment.meeting_link,
        status: createdAppointment.status,
        color: createdAppointment.color,
        reminder_minutes: createdAppointment.reminder_minutes,
        created_at: createdAppointment.created_at,
        updated_at: createdAppointment.updated_at,
        created_by: {
          id: createdAppointment.user_id,
          first_name: createdAppointment.first_name,
          last_name: createdAppointment.last_name
        },
        participants: participants.map((p) => ({
          user_id: p.user_id,
          participant_type: p.participant_type,
          status: p.participant_status,
          user: {
            id: p.user_id,
            first_name: p.first_name,
            last_name: p.last_name,
            email: p.email
          }
        }))
      }
    };
  } catch (error) {
    console.error("Error creating calendar appointment:", error);
    if (error.statusCode) {
      throw error;
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to create calendar appointment"
    });
  }
});

const appointments_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: appointments_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$4 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const appointmentId = parseInt(getRouterParam(event, "id") || "0");
  if (!appointmentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid appointment ID"
    });
  }
  try {
    const appointments = await query(
      "SELECT user_id FROM calendar_appointments WHERE id = ?",
      [appointmentId]
    );
    if (appointments.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Appointment not found"
      });
    }
    const appointmentData = appointments[0];
    if (appointmentData.user_id !== auth.userId) {
      throw createError$2({
        statusCode: 403,
        message: "You can only delete appointments you created"
      });
    }
    await execute(
      "DELETE FROM calendar_appointments WHERE id = ?",
      [appointmentId]
    );
    return {
      success: true,
      message: "Appointment deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error deleting calendar appointment:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete calendar appointment"
    });
  }
});

const _id__delete$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$4
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$4 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const appointmentId = parseInt(getRouterParam(event, "id") || "0");
  const body = await readBody(event);
  if (!appointmentId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid appointment ID"
    });
  }
  try {
    const appointments = await query(
      `SELECT user_id FROM calendar_appointments WHERE id = ?`,
      [appointmentId]
    );
    if (appointments.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Appointment not found"
      });
    }
    const appointmentData = appointments[0];
    if (appointmentData.user_id !== auth.userId) {
      throw createError$2({
        statusCode: 403,
        message: "You can only edit appointments you created"
      });
    }
    if (body.start_datetime || body.end_datetime) {
      const currentAppointment = await query(
        "SELECT start_datetime, end_datetime FROM calendar_appointments WHERE id = ?",
        [appointmentId]
      );
      const startDate = body.start_datetime ? new Date(body.start_datetime) : new Date(currentAppointment[0].start_datetime);
      const endDate = body.end_datetime ? new Date(body.end_datetime) : new Date(currentAppointment[0].end_datetime);
      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
        throw createError$2({
          statusCode: 400,
          message: "Invalid datetime format"
        });
      }
      if (endDate < startDate) {
        throw createError$2({
          statusCode: 400,
          message: "end_datetime must be after start_datetime"
        });
      }
    }
    const updateFields = [];
    const updateValues = [];
    if (body.title !== void 0) {
      updateFields.push("title = ?");
      updateValues.push(body.title);
    }
    if (body.description !== void 0) {
      updateFields.push("description = ?");
      updateValues.push(body.description || null);
    }
    if (body.start_datetime !== void 0) {
      updateFields.push("start_datetime = ?");
      updateValues.push(body.start_datetime);
    }
    if (body.end_datetime !== void 0) {
      updateFields.push("end_datetime = ?");
      updateValues.push(body.end_datetime);
    }
    if (body.appointment_type !== void 0) {
      updateFields.push("appointment_type = ?");
      updateValues.push(body.appointment_type);
    }
    if (body.location !== void 0) {
      updateFields.push("location = ?");
      updateValues.push(body.location || null);
    }
    if (body.meeting_link !== void 0) {
      updateFields.push("meeting_link = ?");
      updateValues.push(body.meeting_link || null);
    }
    if (body.status !== void 0) {
      updateFields.push("status = ?");
      updateValues.push(body.status);
    }
    if (body.color !== void 0) {
      updateFields.push("color = ?");
      updateValues.push(body.color);
    }
    if (body.reminder_minutes !== void 0) {
      updateFields.push("reminder_minutes = ?");
      updateValues.push(body.reminder_minutes || null);
    }
    if (updateFields.length === 0 && body.participant_user_ids === void 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    if (updateFields.length > 0) {
      updateValues.push(appointmentId);
      await execute(
        `UPDATE calendar_appointments SET ${updateFields.join(", ")} WHERE id = ?`,
        updateValues
      );
    }
    if (body.participant_user_ids !== void 0) {
      await execute(
        "DELETE FROM calendar_appointment_participants WHERE appointment_id = ?",
        [appointmentId]
      );
      if (body.participant_user_ids.length > 0) {
        for (const userId of body.participant_user_ids) {
          if (userId === auth.userId) continue;
          const userRoles = await query(
            `SELECT r.name 
             FROM user_roles ur
             JOIN roles r ON ur.role_id = r.id
             WHERE ur.user_id = ?`,
            [userId]
          );
          let participantType = "other";
          if (userRoles.length > 0) {
            const roleName = userRoles[0].name;
            if (roleName === "student") participantType = "student";
            else if (roleName === "parent") participantType = "parent";
            else if (roleName === "tutor") participantType = "tutor";
            else if (["system_admin", "owner", "admin", "branch_admin"].includes(roleName)) participantType = "admin";
          }
          await execute(
            "INSERT INTO calendar_appointment_participants (appointment_id, user_id, participant_type) VALUES (?, ?, ?)",
            [appointmentId, userId, participantType]
          );
        }
      }
    }
    const updatedAppointments = await query(
      `SELECT 
        ca.id,
        ca.user_id,
        ca.title,
        ca.description,
        ca.start_datetime,
        ca.end_datetime,
        ca.appointment_type,
        ca.location,
        ca.meeting_link,
        ca.status,
        ca.color,
        ca.reminder_minutes,
        ca.created_at,
        ca.updated_at,
        u.first_name,
        u.last_name
      FROM calendar_appointments ca
      INNER JOIN users u ON ca.user_id = u.id
      WHERE ca.id = ?`,
      [appointmentId]
    );
    const updatedAppointment = updatedAppointments[0];
    const participants = await query(
      `SELECT 
        cap.user_id,
        cap.participant_type,
        cap.status as participant_status,
        u.first_name,
        u.last_name,
        u.email
      FROM calendar_appointment_participants cap
      INNER JOIN users u ON cap.user_id = u.id
      WHERE cap.appointment_id = ?`,
      [appointmentId]
    );
    return {
      success: true,
      data: {
        id: updatedAppointment.id,
        user_id: updatedAppointment.user_id,
        title: updatedAppointment.title,
        description: updatedAppointment.description,
        start_datetime: updatedAppointment.start_datetime,
        end_datetime: updatedAppointment.end_datetime,
        appointment_type: updatedAppointment.appointment_type,
        location: updatedAppointment.location,
        meeting_link: updatedAppointment.meeting_link,
        status: updatedAppointment.status,
        color: updatedAppointment.color,
        reminder_minutes: updatedAppointment.reminder_minutes,
        created_at: updatedAppointment.created_at,
        updated_at: updatedAppointment.updated_at,
        created_by: {
          id: updatedAppointment.user_id,
          first_name: updatedAppointment.first_name,
          last_name: updatedAppointment.last_name
        },
        participants: participants.map((p) => ({
          user_id: p.user_id,
          participant_type: p.participant_type,
          status: p.participant_status,
          user: {
            id: p.user_id,
            first_name: p.first_name,
            last_name: p.last_name,
            email: p.email
          }
        }))
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error updating calendar appointment:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update calendar appointment"
    });
  }
});

const _id__put$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$4
}, Symbol.toStringTag, { value: 'Module' }));

const events_get$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const queryParams = getQuery(event);
  const startDate = queryParams.start_date;
  const endDate = queryParams.end_date;
  const eventType = queryParams.event_type;
  const includeShared = queryParams.include_shared !== "false";
  const branchId = queryParams.branch_id;
  const roles = await getUserRoles(auth.userId);
  const isSystemAdmin = roles.includes(UserRole.SYSTEM_ADMIN) || roles.includes(UserRole.OWNER);
  const isAdmin = roles.includes(UserRole.ADMIN);
  const isBranchAdmin = roles.includes(UserRole.BRANCH_ADMIN);
  const isTutor = roles.includes(UserRole.TUTOR);
  const isStudent = roles.includes(UserRole.STUDENT);
  const isParent = roles.includes(UserRole.PARENT);
  let userBranchIds = [];
  if (isBranchAdmin && !isSystemAdmin && !isAdmin) {
    const branchAdmins = await query(
      "SELECT branch_id FROM branch_admins WHERE user_id = ?",
      [auth.userId]
    );
    userBranchIds = branchAdmins.map((ba) => ba.branch_id);
  } else if (isTutor && !isSystemAdmin && !isAdmin && !isBranchAdmin) {
    const tutors = await query(
      "SELECT id FROM tutors WHERE user_id = ?",
      [auth.userId]
    );
    if (tutors.length > 0 && tutors[0]) {
      const tutorBranches = await query(
        "SELECT branch_id FROM tutor_branches WHERE tutor_id = ?",
        [tutors[0].id]
      );
      userBranchIds = tutorBranches.map((tb) => tb.branch_id);
    }
  } else if (isStudent && !isSystemAdmin && !isAdmin && !isBranchAdmin) {
    const enrollments = await query(
      'SELECT DISTINCT branch_id FROM enrollments WHERE student_id = ? AND status = "active"',
      [auth.userId]
    );
    userBranchIds = enrollments.map((e) => e.branch_id);
  } else if (isParent && !isSystemAdmin && !isAdmin && !isBranchAdmin) {
    const parentStudents = await query(
      `SELECT DISTINCT ps.student_id 
       FROM parent_students ps
       INNER JOIN enrollments e ON ps.student_id = e.student_id
       WHERE ps.parent_id = ? AND e.status = "active"`,
      [auth.userId]
    );
    if (parentStudents.length > 0) {
      const studentIds = parentStudents.map((ps) => ps.student_id);
      const enrollments = await query(
        `SELECT DISTINCT branch_id FROM enrollments 
         WHERE student_id IN (${studentIds.map(() => "?").join(",")}) AND status = "active"`,
        studentIds
      );
      userBranchIds = enrollments.map((e) => e.branch_id);
    }
  }
  const sharedScopeConditions = [];
  const sharedScopeParams = [];
  if (includeShared) {
    sharedScopeConditions.push(`ce.shared_scope = 'public'`);
    if (isSystemAdmin || isAdmin) {
      sharedScopeConditions.push(`ce.shared_scope = 'admins'`);
    }
    if (isBranchAdmin || isSystemAdmin || isAdmin) {
      if (userBranchIds.length > 0) {
        sharedScopeConditions.push(
          `(ce.shared_scope = 'branch_admins' AND (ce.shared_branch_id IS NULL OR ce.shared_branch_id IN (${userBranchIds.map(() => "?").join(",")})))`
        );
        sharedScopeParams.push(...userBranchIds);
      } else {
        sharedScopeConditions.push(`ce.shared_scope = 'branch_admins'`);
      }
    }
    if (isTutor || isSystemAdmin || isAdmin) {
      if (userBranchIds.length > 0) {
        sharedScopeConditions.push(
          `(ce.shared_scope = 'tutors' AND (ce.shared_branch_id IS NULL OR ce.shared_branch_id IN (${userBranchIds.map(() => "?").join(",")})))`
        );
        sharedScopeParams.push(...userBranchIds);
      } else {
        sharedScopeConditions.push(`ce.shared_scope = 'tutors'`);
      }
    }
    if (isStudent || isSystemAdmin || isAdmin) {
      sharedScopeConditions.push(`ce.shared_scope = 'students'`);
      if (userBranchIds.length > 0) {
        sharedScopeConditions.push(
          `(ce.shared_scope = 'branch_students' AND ce.shared_branch_id IN (${userBranchIds.map(() => "?").join(",")}))`
        );
        sharedScopeParams.push(...userBranchIds);
      }
    }
    if (isParent || isSystemAdmin || isAdmin) {
      sharedScopeConditions.push(`ce.shared_scope = 'parents'`);
      if (userBranchIds.length > 0) {
        sharedScopeConditions.push(
          `(ce.shared_scope = 'branch_parents' AND ce.shared_branch_id IN (${userBranchIds.map(() => "?").join(",")}))`
        );
        sharedScopeParams.push(...userBranchIds);
      }
    }
    sharedScopeConditions.push(
      `EXISTS (
        SELECT 1 FROM calendar_event_shared_with cesw
        WHERE cesw.event_id = ce.id AND cesw.shared_with_user_id = ?
      )`
    );
    sharedScopeParams.push(auth.userId);
  }
  let sql = `
    SELECT DISTINCT
      ce.id,
      ce.user_id,
      ce.title,
      ce.description,
      ce.start_datetime,
      ce.end_datetime,
      ce.location,
      ce.color,
      ce.is_all_day,
      ce.reminder_minutes,
      ce.is_shared,
      ce.shared_scope,
      ce.shared_branch_id,
      ce.event_type,
      ce.created_at,
      ce.updated_at,
      u.first_name,
      u.last_name,
      CASE WHEN ce.user_id = ? THEN TRUE ELSE FALSE END as is_mine
    FROM calendar_events ce
    INNER JOIN users u ON ce.user_id = u.id
    WHERE (
      ce.user_id = ?
      ${includeShared && sharedScopeConditions.length > 0 ? `OR (ce.is_shared = TRUE AND (${sharedScopeConditions.join(" OR ")}))` : ""}
    )
  `;
  const params = [auth.userId, auth.userId, ...sharedScopeParams];
  const filterConditions = [];
  if (startDate) {
    filterConditions.push(`DATE(ce.start_datetime) >= ?`);
    params.push(startDate);
  }
  if (endDate) {
    filterConditions.push(`DATE(ce.start_datetime) <= ?`);
    params.push(endDate);
  }
  if (eventType) {
    filterConditions.push(`ce.event_type = ?`);
    params.push(eventType);
  }
  if (branchId) {
    filterConditions.push(`(ce.shared_branch_id = ? OR ce.shared_branch_id IS NULL)`);
    params.push(parseInt(branchId));
  }
  if (filterConditions.length > 0) {
    sql += ` AND ${filterConditions.join(" AND ")}`;
  }
  sql += ` ORDER BY ce.start_datetime ASC`;
  try {
    const events = await query(sql, params);
    return {
      success: true,
      data: events.map((e) => ({
        id: e.id,
        user_id: e.user_id,
        title: e.title,
        description: e.description,
        start_datetime: e.start_datetime,
        end_datetime: e.end_datetime,
        location: e.location,
        color: e.color,
        is_all_day: e.is_all_day,
        reminder_minutes: e.reminder_minutes,
        is_shared: e.is_shared,
        shared_scope: e.shared_scope,
        shared_branch_id: e.shared_branch_id,
        event_type: e.event_type,
        created_at: e.created_at,
        updated_at: e.updated_at,
        is_mine: e.is_mine === 1 || e.is_mine === true,
        created_by: {
          id: e.user_id,
          first_name: e.first_name,
          last_name: e.last_name
        }
      }))
    };
  } catch (error) {
    console.error("Error fetching calendar events:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch calendar events"
    });
  }
});

const events_get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: events_get$2
}, Symbol.toStringTag, { value: 'Module' }));

const events_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const body = await readBody(event);
  if (!body.title || !body.start_datetime || !body.end_datetime) {
    throw createError$2({
      statusCode: 400,
      message: "Title, start_datetime, and end_datetime are required"
    });
  }
  const startDate = new Date(body.start_datetime);
  const endDate = new Date(body.end_datetime);
  if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid datetime format"
    });
  }
  if (endDate < startDate) {
    throw createError$2({
      statusCode: 400,
      message: "end_datetime must be after start_datetime"
    });
  }
  const isShared = body.is_shared || false;
  const sharedScope = isShared ? body.shared_scope || "public" : "private";
  const eventType = body.event_type || "personal";
  const color = body.color || "#3B82F6";
  const isAllDay = body.is_all_day || false;
  try {
    const result = await execute(
      `INSERT INTO calendar_events (
        user_id, title, description, start_datetime, end_datetime,
        location, color, is_all_day, reminder_minutes,
        is_shared, shared_scope, shared_branch_id, event_type
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        auth.userId,
        body.title,
        body.description || null,
        body.start_datetime,
        body.end_datetime,
        body.location || null,
        color,
        isAllDay,
        body.reminder_minutes || null,
        isShared,
        sharedScope,
        body.shared_branch_id || null,
        eventType
      ]
    );
    const eventId = result.insertId;
    if (isShared && body.shared_with_user_ids && body.shared_with_user_ids.length > 0) {
      for (const userId of body.shared_with_user_ids) {
        await execute(
          "INSERT INTO calendar_event_shared_with (event_id, shared_with_user_id) VALUES (?, ?)",
          [eventId, userId]
        );
      }
    }
    const events = await query(
      `SELECT 
        ce.id,
        ce.user_id,
        ce.title,
        ce.description,
        ce.start_datetime,
        ce.end_datetime,
        ce.location,
        ce.color,
        ce.is_all_day,
        ce.reminder_minutes,
        ce.is_shared,
        ce.shared_scope,
        ce.shared_branch_id,
        ce.event_type,
        ce.created_at,
        ce.updated_at,
        u.first_name,
        u.last_name
      FROM calendar_events ce
      INNER JOIN users u ON ce.user_id = u.id
      WHERE ce.id = ?`,
      [eventId]
    );
    if (events.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Event not found after creation"
      });
    }
    const createdEvent = events[0];
    return {
      success: true,
      data: {
        id: createdEvent.id,
        user_id: createdEvent.user_id,
        title: createdEvent.title,
        description: createdEvent.description,
        start_datetime: createdEvent.start_datetime,
        end_datetime: createdEvent.end_datetime,
        location: createdEvent.location,
        color: createdEvent.color,
        is_all_day: createdEvent.is_all_day,
        reminder_minutes: createdEvent.reminder_minutes,
        is_shared: createdEvent.is_shared,
        shared_scope: createdEvent.shared_scope,
        shared_branch_id: createdEvent.shared_branch_id,
        event_type: createdEvent.event_type,
        created_at: createdEvent.created_at,
        updated_at: createdEvent.updated_at,
        created_by: {
          id: createdEvent.user_id,
          first_name: createdEvent.first_name,
          last_name: createdEvent.last_name
        }
      }
    };
  } catch (error) {
    console.error("Error creating calendar event:", error);
    if (error.statusCode) {
      throw error;
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to create calendar event"
    });
  }
});

const events_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: events_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const eventId = parseInt(getRouterParam(event, "id") || "0");
  if (!eventId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid event ID"
    });
  }
  try {
    const events = await query(
      "SELECT user_id FROM calendar_events WHERE id = ?",
      [eventId]
    );
    if (events.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Event not found"
      });
    }
    const eventData = events[0];
    if (eventData.user_id !== auth.userId) {
      throw createError$2({
        statusCode: 403,
        message: "You can only delete your own events"
      });
    }
    await execute(
      "DELETE FROM calendar_events WHERE id = ?",
      [eventId]
    );
    return {
      success: true,
      message: "Event deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error deleting calendar event:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete calendar event"
    });
  }
});

const _id__delete$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$2
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const eventId = parseInt(getRouterParam(event, "id") || "0");
  if (!eventId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid event ID"
    });
  }
  try {
    const events = await query(
      `SELECT 
        ce.id,
        ce.user_id,
        ce.title,
        ce.description,
        ce.start_datetime,
        ce.end_datetime,
        ce.location,
        ce.color,
        ce.is_all_day,
        ce.reminder_minutes,
        ce.is_shared,
        ce.shared_scope,
        ce.shared_branch_id,
        ce.event_type,
        ce.created_at,
        ce.updated_at,
        u.first_name,
        u.last_name
      FROM calendar_events ce
      INNER JOIN users u ON ce.user_id = u.id
      WHERE ce.id = ?`,
      [eventId]
    );
    if (events.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Event not found"
      });
    }
    const eventData = events[0];
    const isMine = eventData.user_id === auth.userId;
    if (!isMine && !eventData.is_shared) {
      throw createError$2({
        statusCode: 403,
        message: "Access denied"
      });
    }
    if (!isMine && eventData.is_shared) {
      const roles = await getUserRoles(auth.userId);
      const hasAccess = await checkSharedEventAccess(
        eventId,
        eventData.shared_scope,
        eventData.shared_branch_id,
        auth.userId,
        roles
      );
      if (!hasAccess) {
        throw createError$2({
          statusCode: 403,
          message: "Access denied"
        });
      }
    }
    const individualShares = await query(
      "SELECT shared_with_user_id FROM calendar_event_shared_with WHERE event_id = ?",
      [eventId]
    );
    return {
      success: true,
      data: {
        id: eventData.id,
        user_id: eventData.user_id,
        title: eventData.title,
        description: eventData.description,
        start_datetime: eventData.start_datetime,
        end_datetime: eventData.end_datetime,
        location: eventData.location,
        color: eventData.color,
        is_all_day: eventData.is_all_day,
        reminder_minutes: eventData.reminder_minutes,
        is_shared: eventData.is_shared,
        shared_scope: eventData.shared_scope,
        shared_branch_id: eventData.shared_branch_id,
        event_type: eventData.event_type,
        created_at: eventData.created_at,
        updated_at: eventData.updated_at,
        is_mine: isMine,
        created_by: {
          id: eventData.user_id,
          first_name: eventData.first_name,
          last_name: eventData.last_name
        },
        shared_with_user_ids: individualShares.map((s) => s.shared_with_user_id)
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error fetching calendar event:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch calendar event"
    });
  }
});
async function checkSharedEventAccess(eventId, sharedScope, sharedBranchId, userId, roles) {
  const isSystemAdmin = roles.includes(UserRole.SYSTEM_ADMIN) || roles.includes(UserRole.OWNER);
  const isAdmin = roles.includes(UserRole.ADMIN);
  const isBranchAdmin = roles.includes(UserRole.BRANCH_ADMIN);
  const isTutor = roles.includes(UserRole.TUTOR);
  const isStudent = roles.includes(UserRole.STUDENT);
  const isParent = roles.includes(UserRole.PARENT);
  if (sharedScope === "public") return true;
  if (sharedScope === "admins" && (isSystemAdmin || isAdmin)) return true;
  if (sharedScope === "branch_admins") {
    if (isSystemAdmin || isAdmin) return true;
    if (isBranchAdmin) {
      if (sharedBranchId === null) return true;
      const branchAdmins = await query(
        "SELECT branch_id FROM branch_admins WHERE user_id = ?",
        [userId]
      );
      return branchAdmins.some((ba) => ba.branch_id === sharedBranchId);
    }
  }
  if (sharedScope === "tutors") {
    if (isSystemAdmin || isAdmin) return true;
    if (isTutor) {
      if (sharedBranchId === null) return true;
      const tutors = await query(
        "SELECT id FROM tutors WHERE user_id = ?",
        [userId]
      );
      if (tutors.length > 0 && tutors[0]) {
        const tutorBranches = await query(
          "SELECT branch_id FROM tutor_branches WHERE tutor_id = ?",
          [tutors[0].id]
        );
        return tutorBranches.some((tb) => tb.branch_id === sharedBranchId);
      }
    }
  }
  if (sharedScope === "students" || sharedScope === "branch_students") {
    if (isSystemAdmin || isAdmin) return true;
    if (isStudent) {
      if (sharedScope === "students") return true;
      if (sharedBranchId) {
        const enrollments = await query(
          'SELECT DISTINCT branch_id FROM enrollments WHERE student_id = ? AND status = "active"',
          [userId]
        );
        return enrollments.some((e) => e.branch_id === sharedBranchId);
      }
    }
  }
  if (sharedScope === "parents" || sharedScope === "branch_parents") {
    if (isSystemAdmin || isAdmin) return true;
    if (isParent) {
      if (sharedScope === "parents") return true;
      if (sharedBranchId) {
        const parentStudents = await query(
          `SELECT DISTINCT ps.student_id 
           FROM parent_students ps
           INNER JOIN enrollments e ON ps.student_id = e.student_id
           WHERE ps.parent_id = ? AND e.status = "active" AND e.branch_id = ?`,
          [userId, sharedBranchId]
        );
        return parentStudents.length > 0;
      }
    }
  }
  const individualShares = await query(
    "SELECT shared_with_user_id FROM calendar_event_shared_with WHERE event_id = ? AND shared_with_user_id = ?",
    [eventId, userId]
  );
  if (individualShares.length > 0) return true;
  return false;
}

const _id__get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get$2
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put$2 = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const eventId = parseInt(getRouterParam(event, "id") || "0");
  const body = await readBody(event);
  if (!eventId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid event ID"
    });
  }
  try {
    const events = await query(
      "SELECT user_id FROM calendar_events WHERE id = ?",
      [eventId]
    );
    if (events.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Event not found"
      });
    }
    const eventData = events[0];
    if (eventData.user_id !== auth.userId) {
      throw createError$2({
        statusCode: 403,
        message: "You can only edit your own events"
      });
    }
    if (body.start_datetime || body.end_datetime) {
      const currentEvent = await query(
        "SELECT start_datetime, end_datetime FROM calendar_events WHERE id = ?",
        [eventId]
      );
      const startDate = body.start_datetime ? new Date(body.start_datetime) : new Date(currentEvent[0].start_datetime);
      const endDate = body.end_datetime ? new Date(body.end_datetime) : new Date(currentEvent[0].end_datetime);
      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
        throw createError$2({
          statusCode: 400,
          message: "Invalid datetime format"
        });
      }
      if (endDate < startDate) {
        throw createError$2({
          statusCode: 400,
          message: "end_datetime must be after start_datetime"
        });
      }
    }
    const updateFields = [];
    const updateValues = [];
    if (body.title !== void 0) {
      updateFields.push("title = ?");
      updateValues.push(body.title);
    }
    if (body.description !== void 0) {
      updateFields.push("description = ?");
      updateValues.push(body.description || null);
    }
    if (body.start_datetime !== void 0) {
      updateFields.push("start_datetime = ?");
      updateValues.push(body.start_datetime);
    }
    if (body.end_datetime !== void 0) {
      updateFields.push("end_datetime = ?");
      updateValues.push(body.end_datetime);
    }
    if (body.location !== void 0) {
      updateFields.push("location = ?");
      updateValues.push(body.location || null);
    }
    if (body.color !== void 0) {
      updateFields.push("color = ?");
      updateValues.push(body.color);
    }
    if (body.is_all_day !== void 0) {
      updateFields.push("is_all_day = ?");
      updateValues.push(body.is_all_day);
    }
    if (body.reminder_minutes !== void 0) {
      updateFields.push("reminder_minutes = ?");
      updateValues.push(body.reminder_minutes || null);
    }
    if (body.is_shared !== void 0) {
      updateFields.push("is_shared = ?");
      updateValues.push(body.is_shared);
    }
    if (body.shared_scope !== void 0) {
      updateFields.push("shared_scope = ?");
      updateValues.push(body.is_shared ? body.shared_scope : "private");
    }
    if (body.shared_branch_id !== void 0) {
      updateFields.push("shared_branch_id = ?");
      updateValues.push(body.shared_branch_id || null);
    }
    if (body.event_type !== void 0) {
      updateFields.push("event_type = ?");
      updateValues.push(body.event_type);
    }
    if (updateFields.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updateValues.push(eventId);
    await execute(
      `UPDATE calendar_events SET ${updateFields.join(", ")} WHERE id = ?`,
      updateValues
    );
    if (body.shared_with_user_ids !== void 0) {
      await execute(
        "DELETE FROM calendar_event_shared_with WHERE event_id = ?",
        [eventId]
      );
      if (body.shared_with_user_ids.length > 0) {
        for (const userId of body.shared_with_user_ids) {
          await execute(
            "INSERT INTO calendar_event_shared_with (event_id, shared_with_user_id) VALUES (?, ?)",
            [eventId, userId]
          );
        }
      }
    }
    const updatedEvents = await query(
      `SELECT 
        ce.id,
        ce.user_id,
        ce.title,
        ce.description,
        ce.start_datetime,
        ce.end_datetime,
        ce.location,
        ce.color,
        ce.is_all_day,
        ce.reminder_minutes,
        ce.is_shared,
        ce.shared_scope,
        ce.shared_branch_id,
        ce.event_type,
        ce.created_at,
        ce.updated_at,
        u.first_name,
        u.last_name
      FROM calendar_events ce
      INNER JOIN users u ON ce.user_id = u.id
      WHERE ce.id = ?`,
      [eventId]
    );
    const updatedEvent = updatedEvents[0];
    const individualShares = await query(
      "SELECT shared_with_user_id FROM calendar_event_shared_with WHERE event_id = ?",
      [eventId]
    );
    return {
      success: true,
      data: {
        id: updatedEvent.id,
        user_id: updatedEvent.user_id,
        title: updatedEvent.title,
        description: updatedEvent.description,
        start_datetime: updatedEvent.start_datetime,
        end_datetime: updatedEvent.end_datetime,
        location: updatedEvent.location,
        color: updatedEvent.color,
        is_all_day: updatedEvent.is_all_day,
        reminder_minutes: updatedEvent.reminder_minutes,
        is_shared: updatedEvent.is_shared,
        shared_scope: updatedEvent.shared_scope,
        shared_branch_id: updatedEvent.shared_branch_id,
        event_type: updatedEvent.event_type,
        created_at: updatedEvent.created_at,
        updated_at: updatedEvent.updated_at,
        created_by: {
          id: updatedEvent.user_id,
          first_name: updatedEvent.first_name,
          last_name: updatedEvent.last_name
        },
        shared_with_user_ids: individualShares.map((s) => s.shared_with_user_id)
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error updating calendar event:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update calendar event"
    });
  }
});

const _id__put$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put$2
}, Symbol.toStringTag, { value: 'Module' }));

const tasks_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const queryParams = getQuery(event);
  const startDate = queryParams.start_date;
  const endDate = queryParams.end_date;
  const status = queryParams.status;
  const priority = queryParams.priority;
  const includeShared = queryParams.include_shared !== "false";
  const roles = await getUserRoles(auth.userId);
  const isSystemAdmin = roles.includes(UserRole.SYSTEM_ADMIN) || roles.includes(UserRole.OWNER);
  const isAdmin = roles.includes(UserRole.ADMIN);
  const isBranchAdmin = roles.includes(UserRole.BRANCH_ADMIN);
  const isTutor = roles.includes(UserRole.TUTOR);
  let userBranchIds = [];
  if (isBranchAdmin && !isSystemAdmin && !isAdmin) {
    const branchAdmins = await query(
      "SELECT branch_id FROM branch_admins WHERE user_id = ?",
      [auth.userId]
    );
    userBranchIds = branchAdmins.map((ba) => ba.branch_id);
  }
  const sharedScopeConditions = [];
  const sharedScopeParams = [];
  if (includeShared) {
    sharedScopeConditions.push(`ct.shared_scope = 'public'`);
    if (isSystemAdmin || isAdmin) {
      sharedScopeConditions.push(`ct.shared_scope = 'admins'`);
    }
    if (isBranchAdmin || isSystemAdmin || isAdmin) {
      if (userBranchIds.length > 0) {
        sharedScopeConditions.push(
          `(ct.shared_scope = 'branch_admins' AND (ct.shared_branch_id IS NULL OR ct.shared_branch_id IN (${userBranchIds.map(() => "?").join(",")})))`
        );
        sharedScopeParams.push(...userBranchIds);
      } else {
        sharedScopeConditions.push(`ct.shared_scope = 'branch_admins'`);
      }
    }
    if (isTutor || isSystemAdmin || isAdmin) {
      if (userBranchIds.length > 0) {
        sharedScopeConditions.push(
          `(ct.shared_scope = 'tutors' AND (ct.shared_branch_id IS NULL OR ct.shared_branch_id IN (${userBranchIds.map(() => "?").join(",")})))`
        );
        sharedScopeParams.push(...userBranchIds);
      } else {
        sharedScopeConditions.push(`ct.shared_scope = 'tutors'`);
      }
    }
    sharedScopeConditions.push(
      `EXISTS (
        SELECT 1 FROM calendar_task_shared_with ctsw
        WHERE ctsw.task_id = ct.id AND ctsw.shared_with_user_id = ?
      )`
    );
    sharedScopeParams.push(auth.userId);
  }
  let sql = `
    SELECT DISTINCT
      ct.id,
      ct.user_id,
      ct.title,
      ct.description,
      ct.due_date,
      ct.start_date,
      ct.priority,
      ct.status,
      ct.color,
      ct.is_shared,
      ct.shared_scope,
      ct.shared_branch_id,
      ct.category,
      ct.completed_at,
      ct.created_at,
      ct.updated_at,
      u.first_name,
      u.last_name,
      CASE WHEN ct.user_id = ? THEN TRUE ELSE FALSE END as is_mine
    FROM calendar_tasks ct
    INNER JOIN users u ON ct.user_id = u.id
    WHERE (
      ct.user_id = ?
      ${includeShared && sharedScopeConditions.length > 0 ? `OR (ct.is_shared = TRUE AND (${sharedScopeConditions.join(" OR ")}))` : ""}
    )
  `;
  const params = [auth.userId, auth.userId, ...sharedScopeParams];
  const filterConditions = [];
  if (startDate) {
    filterConditions.push(`(DATE(ct.due_date) >= ? OR DATE(ct.start_date) >= ?)`);
    params.push(startDate, startDate);
  }
  if (endDate) {
    filterConditions.push(`(DATE(ct.due_date) <= ? OR DATE(ct.start_date) <= ? OR ct.due_date IS NULL)`);
    params.push(endDate, endDate);
  }
  if (status) {
    filterConditions.push(`ct.status = ?`);
    params.push(status);
  }
  if (priority) {
    filterConditions.push(`ct.priority = ?`);
    params.push(priority);
  }
  if (filterConditions.length > 0) {
    sql += ` AND ${filterConditions.join(" AND ")}`;
  }
  sql += ` ORDER BY ct.due_date ASC NULLS LAST, ct.priority DESC, ct.created_at DESC`;
  try {
    const tasks = await query(sql, params);
    return {
      success: true,
      data: tasks.map((t) => ({
        id: t.id,
        user_id: t.user_id,
        title: t.title,
        description: t.description,
        due_date: t.due_date,
        start_date: t.start_date,
        priority: t.priority,
        status: t.status,
        color: t.color,
        is_shared: t.is_shared,
        shared_scope: t.shared_scope,
        shared_branch_id: t.shared_branch_id,
        category: t.category,
        completed_at: t.completed_at,
        created_at: t.created_at,
        updated_at: t.updated_at,
        is_mine: t.is_mine === 1 || t.is_mine === true,
        created_by: {
          id: t.user_id,
          first_name: t.first_name,
          last_name: t.last_name
        }
      }))
    };
  } catch (error) {
    console.error("Error fetching calendar tasks:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch calendar tasks"
    });
  }
});

const tasks_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: tasks_get
}, Symbol.toStringTag, { value: 'Module' }));

const tasks_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const body = await readBody(event);
  if (!body.title) {
    throw createError$2({
      statusCode: 400,
      message: "Title is required"
    });
  }
  const priority = body.priority || "medium";
  const status = body.status || "not_started";
  const color = body.color || "#10B981";
  const isShared = body.is_shared || false;
  const sharedScope = isShared ? body.shared_scope || "public" : "private";
  try {
    const result = await execute(
      `INSERT INTO calendar_tasks (
        user_id, title, description, due_date, start_date,
        priority, status, color, category,
        is_shared, shared_scope, shared_branch_id
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        auth.userId,
        body.title,
        body.description || null,
        body.due_date || null,
        body.start_date || null,
        priority,
        status,
        color,
        body.category || null,
        isShared,
        sharedScope,
        body.shared_branch_id || null
      ]
    );
    const taskId = result.insertId;
    if (isShared && body.shared_with_user_ids && body.shared_with_user_ids.length > 0) {
      for (const userId of body.shared_with_user_ids) {
        await execute(
          "INSERT INTO calendar_task_shared_with (task_id, shared_with_user_id) VALUES (?, ?)",
          [taskId, userId]
        );
      }
    }
    const tasks = await query(
      `SELECT 
        ct.id,
        ct.user_id,
        ct.title,
        ct.description,
        ct.due_date,
        ct.start_date,
        ct.priority,
        ct.status,
        ct.color,
        ct.category,
        ct.is_shared,
        ct.shared_scope,
        ct.shared_branch_id,
        ct.completed_at,
        ct.created_at,
        ct.updated_at,
        u.first_name,
        u.last_name
      FROM calendar_tasks ct
      INNER JOIN users u ON ct.user_id = u.id
      WHERE ct.id = ?`,
      [taskId]
    );
    if (tasks.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Task not found after creation"
      });
    }
    const createdTask = tasks[0];
    return {
      success: true,
      data: {
        id: createdTask.id,
        user_id: createdTask.user_id,
        title: createdTask.title,
        description: createdTask.description,
        due_date: createdTask.due_date,
        start_date: createdTask.start_date,
        priority: createdTask.priority,
        status: createdTask.status,
        color: createdTask.color,
        category: createdTask.category,
        is_shared: createdTask.is_shared,
        shared_scope: createdTask.shared_scope,
        shared_branch_id: createdTask.shared_branch_id,
        completed_at: createdTask.completed_at,
        created_at: createdTask.created_at,
        updated_at: createdTask.updated_at,
        created_by: {
          id: createdTask.user_id,
          first_name: createdTask.first_name,
          last_name: createdTask.last_name
        }
      }
    };
  } catch (error) {
    console.error("Error creating calendar task:", error);
    if (error.statusCode) {
      throw error;
    }
    throw createError$2({
      statusCode: 500,
      message: "Failed to create calendar task"
    });
  }
});

const tasks_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: tasks_post
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const taskId = parseInt(getRouterParam(event, "id") || "0");
  if (!taskId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid task ID"
    });
  }
  try {
    const tasks = await query(
      "SELECT user_id FROM calendar_tasks WHERE id = ?",
      [taskId]
    );
    if (tasks.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Task not found"
      });
    }
    const taskData = tasks[0];
    if (taskData.user_id !== auth.userId) {
      throw createError$2({
        statusCode: 403,
        message: "You can only delete your own tasks"
      });
    }
    await execute(
      "DELETE FROM calendar_tasks WHERE id = ?",
      [taskId]
    );
    return {
      success: true,
      message: "Task deleted successfully"
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error deleting calendar task:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to delete calendar task"
    });
  }
});

const _id__delete$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete
}, Symbol.toStringTag, { value: 'Module' }));

const _id__put = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const taskId = parseInt(getRouterParam(event, "id") || "0");
  const body = await readBody(event);
  if (!taskId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid task ID"
    });
  }
  try {
    const tasks = await query(
      "SELECT user_id FROM calendar_tasks WHERE id = ?",
      [taskId]
    );
    if (tasks.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Task not found"
      });
    }
    const taskData = tasks[0];
    if (taskData.user_id !== auth.userId) {
      throw createError$2({
        statusCode: 403,
        message: "You can only edit your own tasks"
      });
    }
    const updateFields = [];
    const updateValues = [];
    if (body.title !== void 0) {
      updateFields.push("title = ?");
      updateValues.push(body.title);
    }
    if (body.description !== void 0) {
      updateFields.push("description = ?");
      updateValues.push(body.description || null);
    }
    if (body.due_date !== void 0) {
      updateFields.push("due_date = ?");
      updateValues.push(body.due_date || null);
    }
    if (body.start_date !== void 0) {
      updateFields.push("start_date = ?");
      updateValues.push(body.start_date || null);
    }
    if (body.priority !== void 0) {
      updateFields.push("priority = ?");
      updateValues.push(body.priority);
    }
    if (body.status !== void 0) {
      updateFields.push("status = ?");
      updateValues.push(body.status);
      if (body.status === "completed") {
        updateFields.push("completed_at = NOW()");
      } else if (body.status !== "completed") {
        updateFields.push("completed_at = NULL");
      }
    }
    if (body.color !== void 0) {
      updateFields.push("color = ?");
      updateValues.push(body.color);
    }
    if (body.category !== void 0) {
      updateFields.push("category = ?");
      updateValues.push(body.category || null);
    }
    if (body.is_shared !== void 0) {
      updateFields.push("is_shared = ?");
      updateValues.push(body.is_shared);
    }
    if (body.shared_scope !== void 0) {
      updateFields.push("shared_scope = ?");
      updateValues.push(body.is_shared ? body.shared_scope : "private");
    }
    if (body.shared_branch_id !== void 0) {
      updateFields.push("shared_branch_id = ?");
      updateValues.push(body.shared_branch_id || null);
    }
    if (updateFields.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No fields to update"
      });
    }
    updateValues.push(taskId);
    await execute(
      `UPDATE calendar_tasks SET ${updateFields.join(", ")} WHERE id = ?`,
      updateValues
    );
    if (body.shared_with_user_ids !== void 0) {
      await execute(
        "DELETE FROM calendar_task_shared_with WHERE task_id = ?",
        [taskId]
      );
      if (body.shared_with_user_ids.length > 0) {
        for (const userId of body.shared_with_user_ids) {
          await execute(
            "INSERT INTO calendar_task_shared_with (task_id, shared_with_user_id) VALUES (?, ?)",
            [taskId, userId]
          );
        }
      }
    }
    const updatedTasks = await query(
      `SELECT 
        ct.id,
        ct.user_id,
        ct.title,
        ct.description,
        ct.due_date,
        ct.start_date,
        ct.priority,
        ct.status,
        ct.color,
        ct.category,
        ct.is_shared,
        ct.shared_scope,
        ct.shared_branch_id,
        ct.completed_at,
        ct.created_at,
        ct.updated_at,
        u.first_name,
        u.last_name
      FROM calendar_tasks ct
      INNER JOIN users u ON ct.user_id = u.id
      WHERE ct.id = ?`,
      [taskId]
    );
    const updatedTask = updatedTasks[0];
    return {
      success: true,
      data: {
        id: updatedTask.id,
        user_id: updatedTask.user_id,
        title: updatedTask.title,
        description: updatedTask.description,
        due_date: updatedTask.due_date,
        start_date: updatedTask.start_date,
        priority: updatedTask.priority,
        status: updatedTask.status,
        color: updatedTask.color,
        category: updatedTask.category,
        is_shared: updatedTask.is_shared,
        shared_scope: updatedTask.shared_scope,
        shared_branch_id: updatedTask.shared_branch_id,
        completed_at: updatedTask.completed_at,
        created_at: updatedTask.created_at,
        updated_at: updatedTask.updated_at,
        created_by: {
          id: updatedTask.user_id,
          first_name: updatedTask.first_name,
          last_name: updatedTask.last_name
        }
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error updating calendar task:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to update calendar task"
    });
  }
});

const _id__put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__put
}, Symbol.toStringTag, { value: 'Module' }));

const userConnections = /* @__PURE__ */ new Map();
const roomSubscriptions = /* @__PURE__ */ new Map();
async function sendSSE(event, eventName, data) {
  try {
    const message = `event: ${eventName}
data: ${JSON.stringify(data)}

`;
    await event.node.res.write(message);
  } catch (error) {
    console.error("[SSE] Error sending event:", error);
  }
}
function subscribeUser(userId, event) {
  if (!userConnections.has(userId)) {
    userConnections.set(userId, []);
  }
  userConnections.get(userId).push(event);
  console.log(`[SSE] User ${userId} subscribed, total connections: ${userConnections.get(userId).length}`);
}
function unsubscribeUser(userId, event) {
  const connections = userConnections.get(userId);
  if (connections) {
    const index = connections.indexOf(event);
    if (index > -1) {
      connections.splice(index, 1);
      console.log(`[SSE] User ${userId} unsubscribed, remaining connections: ${connections.length}`);
    }
    if (connections.length === 0) {
      userConnections.delete(userId);
    }
  }
}
function subscribeToRoom(roomId, userId) {
  if (!roomSubscriptions.has(roomId)) {
    roomSubscriptions.set(roomId, /* @__PURE__ */ new Set());
  }
  roomSubscriptions.get(roomId).add(userId);
  console.log(`[SSE] User ${userId} subscribed to room ${roomId}`);
}
function unsubscribeFromRoom(roomId, userId) {
  const subscribers = roomSubscriptions.get(roomId);
  if (subscribers) {
    subscribers.delete(userId);
    console.log(`[SSE] User ${userId} unsubscribed from room ${roomId}`);
    if (subscribers.size === 0) {
      roomSubscriptions.delete(roomId);
    }
  }
}

const events_get = defineEventHandler(async (event) => {
  const query = getQuery(event);
  let userId;
  if (query.token) {
    try {
      const { verifyAccessToken } = await Promise.resolve().then(function () { return jwt; });
      const { getUserWithRoles } = await Promise.resolve().then(function () { return auth_service; });
      const payload = verifyAccessToken(query.token);
      const user = await getUserWithRoles(payload.userId);
      if (!user) {
        throw createError$2({
          statusCode: 401,
          message: "User not found"
        });
      }
      userId = user.id;
    } catch (error) {
      throw createError$2({
        statusCode: 401,
        message: "Invalid token"
      });
    }
  } else {
    const auth = await requireAuth(event);
    userId = auth.userId;
  }
  setHeader(event, "Content-Type", "text/event-stream");
  setHeader(event, "Cache-Control", "no-cache");
  setHeader(event, "Connection", "keep-alive");
  setHeader(event, "X-Accel-Buffering", "no");
  setHeader(event, "Access-Control-Allow-Origin", "*");
  setHeader(event, "Access-Control-Allow-Credentials", "true");
  console.log(`[SSE] User ${userId} connecting to chat events stream`);
  subscribeUser(userId, event);
  try {
    const rooms = await getUserChatRooms(userId);
    console.log(`[SSE] User ${userId} has ${rooms.length} rooms:`, rooms.map((r) => ({ id: r.id, course_id: r.course_id, student_id: r.student_id, tutor_id: r.tutor_id })));
    for (const room of rooms) {
      subscribeToRoom(room.id, userId);
    }
    console.log(`[SSE] \u2705 User ${userId} subscribed to ${rooms.length} rooms`);
  } catch (error) {
    console.error(`[SSE] \u274C Error loading rooms for user ${userId}:`, error);
  }
  await sendSSE(event, "connected", {
    userId,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
  const heartbeatInterval = setInterval(async () => {
    try {
      await sendSSE(event, "heartbeat", {
        timestamp: Date.now()
      });
    } catch (error) {
      clearInterval(heartbeatInterval);
    }
  }, 3e4);
  if (query.roomId) {
    const roomId = parseInt(query.roomId);
    if (roomId) {
      try {
        const hasAccess = await verifyRoomAccess(userId, roomId);
        if (hasAccess) {
          subscribeToRoom(roomId, userId);
          await sendSSE(event, "room_subscribed", {
            roomId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      } catch (error) {
        console.error(`[SSE] Error subscribing to room ${roomId}:`, error);
      }
    }
  }
  event.node.req.on("close", () => {
    console.log(`[SSE] User ${userId} disconnected`);
    clearInterval(heartbeatInterval);
    unsubscribeUser(userId, event);
    try {
      const rooms = getUserChatRooms(userId);
      rooms.then((roomList) => {
        for (const room of roomList) {
          unsubscribeFromRoom(room.id, userId);
        }
      }).catch(console.error);
    } catch (error) {
      console.error(`[SSE] Error unsubscribing from rooms:`, error);
    }
  });
  event.node.req.on("error", (error) => {
    console.error(`[SSE] Connection error for user ${userId}:`, error);
    clearInterval(heartbeatInterval);
    unsubscribeUser(userId, event);
  });
  return new Promise(() => {
  });
});

const events_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: events_get
}, Symbol.toStringTag, { value: 'Module' }));

const subscribe_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const body = await readBody(event);
  const roomId = parseInt(body.roomId || "0");
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  subscribeToRoom(roomId, auth.userId);
  console.log(`[SSE] \u2705 User ${auth.userId} subscribed to room ${roomId} via API`);
  const connections = userConnections.get(auth.userId);
  if (connections) {
    for (const conn of connections) {
      try {
        await sendSSE(conn, "room_subscribed", {
          roomId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      } catch (error) {
        console.error(`[SSE] Error sending room_subscribed to user ${auth.userId}:`, error);
      }
    }
  }
  return {
    success: true,
    roomId
  };
});

const subscribe_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: subscribe_post
}, Symbol.toStringTag, { value: 'Module' }));

const rooms_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  try {
    const rooms = await getUserChatRooms(auth.userId);
    return {
      success: true,
      data: rooms
    };
  } catch (error) {
    console.error("[API] Error fetching chat rooms:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch chat rooms"
    });
  }
});

const rooms_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: rooms_get
}, Symbol.toStringTag, { value: 'Module' }));

const rooms_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const body = await readBody(event);
  const user = await getUserWithRoles(auth.userId);
  if (!user || !user.roles.includes(UserRole.STUDENT)) {
    throw createError$2({
      statusCode: 403,
      message: "Only students can create chat rooms"
    });
  }
  if (!body.course_id || !body.tutor_id) {
    throw createError$2({
      statusCode: 400,
      message: "course_id and tutor_id are required"
    });
  }
  try {
    const room = await createChatRoom(auth.userId, body);
    return {
      success: true,
      data: room
    };
  } catch (error) {
    console.error("[API] Error creating chat room:", error);
    throw createError$2({
      statusCode: 400,
      message: error.message || "Failed to create chat room"
    });
  }
});

const rooms_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: rooms_post
}, Symbol.toStringTag, { value: 'Module' }));

const _roomId__get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    const room = await getChatRoom(roomId);
    if (!room) {
      throw createError$2({
        statusCode: 404,
        message: "Chat room not found"
      });
    }
    return {
      success: true,
      data: room
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("[API] Error fetching chat room:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch chat room"
    });
  }
});

const _roomId__get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _roomId__get
}, Symbol.toStringTag, { value: 'Module' }));

const messages_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  const query = getQuery(event);
  const limit = parseInt(query.limit) || 50;
  const offset = parseInt(query.offset) || 0;
  const since = query.since ? parseInt(query.since) : void 0;
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    let messages = await getChatMessages(roomId, limit, offset);
    if (since) {
      messages = messages.filter((msg) => {
        const msgId = msg.id;
        return typeof msgId === "number" && msgId > since;
      });
    }
    return {
      success: true,
      data: messages
    };
  } catch (error) {
    console.error("[API] Error fetching messages:", error);
    console.error("[API] Error details:", {
      message: error.message,
      code: error.code,
      sqlState: error.sqlState,
      stack: error.stack
    });
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to fetch messages",
      data: void 0
    });
  }
});

const messages_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: messages_get
}, Symbol.toStringTag, { value: 'Module' }));

const messages_post = defineEventHandler(async (event) => {
  var _a, _b;
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  const body = await readBody(event);
  console.log("[API] \u{1F4E8} POST /chat/rooms/[roomId]/messages called:", {
    roomId,
    userId: auth.userId,
    content: (_a = body.content) == null ? void 0 : _a.substring(0, 50),
    messageType: body.message_type,
    hasFile: !!body.file_url,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
  if (!roomId) {
    console.error("[API] \u274C Invalid room ID:", roomId);
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  if (!body.content && !body.file_url) {
    console.error("[API] \u274C Message content or file is required");
    throw createError$2({
      statusCode: 400,
      message: "Message content or file is required"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    console.log("[API] \u{1F4BE} Saving message to database...");
    const message = await saveMessage({
      room_id: roomId,
      sender_id: auth.userId,
      content: body.content || null,
      message_type: body.message_type || "text",
      file_url: body.file_url || null,
      file_name: body.file_name || null,
      file_size: body.file_size || null,
      file_type: body.file_type || null,
      reply_to_id: body.reply_to_id || null
    });
    console.log("[API] \u2705 Message saved to database:", {
      messageId: message.id,
      roomId: message.room_id,
      senderId: message.sender_id,
      content: (_b = message.content) == null ? void 0 : _b.substring(0, 50),
      createdAt: message.created_at
    });
    try {
      const nitroApp = useNitroApp();
      const io = nitroApp.io;
      if (io) {
        console.log(`[API] \u{1F4E4} Sending message ${message.id} via Socket.IO to room ${roomId}, sender: ${auth.userId}`);
        const room = await getChatRoom(roomId);
        const recipientId = room ? room.student_id === auth.userId ? room.tutor_id : room.student_id : null;
        const courseId = room == null ? void 0 : room.course_id;
        try {
          const DEBUG_MODE = process.env.DEBUG_SOCKET_ROOMS === "true";
          if (DEBUG_MODE) {
            const roomSockets = await io.in(`room:${roomId}`).fetchSockets();
            console.log(`[API] \u{1F50D} Room ${roomId} has ${roomSockets.length} connected socket(s)`);
            const userIdsInRoom = roomSockets.map((s) => {
              var _a2, _b2, _c;
              const userId = ((_a2 = s.data) == null ? void 0 : _a2.userId) || ((_c = (_b2 = s.data) == null ? void 0 : _b2.user) == null ? void 0 : _c.id);
              return {
                socketId: s.id,
                userId,
                rooms: Array.from(s.rooms || [])
              };
            });
            console.log(`[API] \u{1F465} Users in room ${roomId}:`, JSON.stringify(userIdsInRoom, null, 2));
            if (room && recipientId) {
              const recipientInRoom = userIdsInRoom.some((u) => u.userId === recipientId);
              console.log(`[API] \u{1F3AF} Recipient ${recipientId} in room ${roomId}:`, recipientInRoom);
            }
          }
          try {
            io.to(`room:${roomId}`).emit("new_message", message);
            if (DEBUG_MODE) {
              console.log(`[API] \u2705 Emitted 'new_message' to room ${roomId} (excluded sender ${auth.userId})`);
            }
          } catch (emitError) {
            if (emitError.code !== "ECONNRESET" && emitError.message !== "read ECONNRESET") {
              console.error(`[API] \u274C Error emitting to room ${roomId}:`, emitError);
            }
          }
          if (courseId) {
            try {
              io.to(`course:${courseId}`).emit("course_message_notification", {
                roomId,
                message,
                recipientId
              });
              if (DEBUG_MODE) {
                console.log(`[API] \u{1F4E2} Sent course notification to course:${courseId}`);
              }
            } catch (courseError) {
              if (courseError.code !== "ECONNRESET" && courseError.message !== "read ECONNRESET") {
                console.error(`[API] \u274C Error emitting to course ${courseId}:`, courseError);
              }
            }
          }
          if (room && recipientId) {
            try {
              io.to(`user:${recipientId}`).emit("new_message_notification", {
                roomId,
                message
              });
              if (DEBUG_MODE) {
                console.log(`[API] \u2705 Sent notification to recipient ${recipientId}`);
              }
            } catch (notifyError) {
              if (notifyError.code !== "ECONNRESET" && notifyError.message !== "read ECONNRESET") {
                console.error(`[API] \u274C Error sending notification to recipient ${recipientId}:`, notifyError);
              }
            }
          }
        } catch (socketError) {
          if (socketError.code !== "ECONNRESET" && socketError.message !== "read ECONNRESET") {
            console.error("[API] \u274C Socket.IO error:", socketError);
          }
        }
      } else {
        console.warn("[API] \u26A0\uFE0F  Socket.IO not available");
      }
    } catch (socketError) {
      console.error("[API] \u274C Socket.IO error for real-time update:", socketError);
    }
    return {
      success: true,
      data: message
    };
  } catch (error) {
    console.error("[API] Error sending message:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to send message"
    });
  }
});

const messages_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: messages_post
}, Symbol.toStringTag, { value: 'Module' }));

const read_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  const body = await readBody(event);
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    await markMessagesAsRead(roomId, auth.userId, body.messageId);
    const nitroApp = useNitroApp();
    const io = nitroApp.io;
    if (io) {
      try {
        io.to(`room:${roomId}`).emit("messages_read", {
          roomId,
          userId: auth.userId,
          messageId: body.messageId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      } catch (emitError) {
        if (emitError.code !== "ECONNRESET" && emitError.message !== "read ECONNRESET") {
          console.error("[API] Error emitting messages_read event:", emitError);
        }
      }
    }
    return {
      success: true
    };
  } catch (error) {
    console.error("[API] Error marking messages as read:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to mark messages as read"
    });
  }
});

const read_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: read_post
}, Symbol.toStringTag, { value: 'Module' }));

const notes_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    const notes = await query(`
      SELECT 
        crn.*,
        creator.first_name as creator_first_name,
        creator.last_name as creator_last_name,
        updater.first_name as updater_first_name,
        updater.last_name as updater_last_name
      FROM chat_room_notes crn
      LEFT JOIN users creator ON crn.created_by = creator.id
      LEFT JOIN users updater ON crn.updated_by = updater.id
      WHERE crn.room_id = ?
      ORDER BY crn.updated_at DESC, crn.created_at DESC
    `, [roomId]);
    const formattedNotes = notes.map((note) => ({
      id: note.id,
      room_id: note.room_id,
      content: note.content,
      created_by: note.created_by,
      updated_by: note.updated_by,
      created_at: note.created_at,
      updated_at: note.updated_at,
      creator: {
        id: note.created_by,
        first_name: note.creator_first_name,
        last_name: note.creator_last_name
      },
      updater: note.updated_by ? {
        id: note.updated_by,
        first_name: note.updater_first_name,
        last_name: note.updater_last_name
      } : null
    }));
    return {
      success: true,
      data: formattedNotes
    };
  } catch (error) {
    console.error("[API] Error fetching notes:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch notes"
    });
  }
});

const notes_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: notes_get
}, Symbol.toStringTag, { value: 'Module' }));

const notes_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  const body = await readBody(event);
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  if (!body.content || !body.content.trim()) {
    throw createError$2({
      statusCode: 400,
      message: "Note content is required"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    const result = await execute(
      "INSERT INTO chat_room_notes (room_id, content, created_by) VALUES (?, ?, ?)",
      [roomId, body.content.trim(), auth.userId]
    );
    const notes = await query(`
      SELECT 
        crn.*,
        creator.first_name as creator_first_name,
        creator.last_name as creator_last_name
      FROM chat_room_notes crn
      LEFT JOIN users creator ON crn.created_by = creator.id
      WHERE crn.id = ?
    `, [result.insertId]);
    if (!notes || notes.length === 0) {
      throw createError$2({
        statusCode: 500,
        message: "Failed to retrieve created note"
      });
    }
    const note = notes[0];
    const formattedNote = {
      id: note.id,
      room_id: note.room_id,
      content: note.content,
      created_by: note.created_by,
      updated_by: note.updated_by,
      created_at: note.created_at,
      updated_at: note.updated_at,
      creator: {
        id: note.created_by,
        first_name: note.creator_first_name,
        last_name: note.creator_last_name
      },
      updater: null
    };
    return {
      success: true,
      data: formattedNote
    };
  } catch (error) {
    console.error("[API] Error creating note:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to create note"
    });
  }
});

const notes_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: notes_post
}, Symbol.toStringTag, { value: 'Module' }));

const _noteId__put = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  const noteId = parseInt(getRouterParam(event, "noteId") || "0");
  const body = await readBody(event);
  if (!roomId || !noteId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID or note ID"
    });
  }
  if (!body.content || !body.content.trim()) {
    throw createError$2({
      statusCode: 400,
      message: "Note content is required"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  const existingNotes = await query(
    "SELECT id, room_id FROM chat_room_notes WHERE id = ?",
    [noteId]
  );
  if (!existingNotes || existingNotes.length === 0) {
    throw createError$2({
      statusCode: 404,
      message: "Note not found"
    });
  }
  if (existingNotes[0].room_id !== roomId) {
    throw createError$2({
      statusCode: 403,
      message: "Note does not belong to this room"
    });
  }
  try {
    await execute(
      "UPDATE chat_room_notes SET content = ?, updated_by = ? WHERE id = ?",
      [body.content.trim(), auth.userId, noteId]
    );
    const notes = await query(`
      SELECT 
        crn.*,
        creator.first_name as creator_first_name,
        creator.last_name as creator_last_name,
        updater.first_name as updater_first_name,
        updater.last_name as updater_last_name
      FROM chat_room_notes crn
      LEFT JOIN users creator ON crn.created_by = creator.id
      LEFT JOIN users updater ON crn.updated_by = updater.id
      WHERE crn.id = ?
    `, [noteId]);
    if (!notes || notes.length === 0) {
      throw createError$2({
        statusCode: 500,
        message: "Failed to retrieve updated note"
      });
    }
    const note = notes[0];
    const formattedNote = {
      id: note.id,
      room_id: note.room_id,
      content: note.content,
      created_by: note.created_by,
      updated_by: note.updated_by,
      created_at: note.created_at,
      updated_at: note.updated_at,
      creator: {
        id: note.created_by,
        first_name: note.creator_first_name,
        last_name: note.creator_last_name
      },
      updater: note.updated_by ? {
        id: note.updated_by,
        first_name: note.updater_first_name,
        last_name: note.updater_last_name
      } : null
    };
    return {
      success: true,
      data: formattedNote
    };
  } catch (error) {
    console.error("[API] Error updating note:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to update note"
    });
  }
});

const _noteId__put$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _noteId__put
}, Symbol.toStringTag, { value: 'Module' }));

const tags_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    const tags = await query(`
      SELECT 
        crt.*,
        u.first_name as creator_first_name,
        u.last_name as creator_last_name
      FROM chat_room_tags crt
      LEFT JOIN users u ON crt.created_by = u.id
      WHERE crt.room_id = ?
      ORDER BY crt.created_at DESC
    `, [roomId]);
    const formattedTags = tags.map((tag) => ({
      id: tag.id,
      room_id: tag.room_id,
      tag_name: tag.tag_name,
      color: tag.color,
      created_by: tag.created_by,
      created_at: tag.created_at,
      creator: {
        id: tag.created_by,
        first_name: tag.creator_first_name,
        last_name: tag.creator_last_name
      }
    }));
    return {
      success: true,
      data: formattedTags
    };
  } catch (error) {
    console.error("[API] Error fetching tags:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch tags"
    });
  }
});

const tags_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: tags_get
}, Symbol.toStringTag, { value: 'Module' }));

const tags_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  const body = await readBody(event);
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  if (!body.tag_name || !body.tag_name.trim()) {
    throw createError$2({
      statusCode: 400,
      message: "Tag name is required"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    const result = await execute(
      "INSERT INTO chat_room_tags (room_id, tag_name, color, created_by) VALUES (?, ?, ?, ?)",
      [roomId, body.tag_name.trim(), body.color || "#3B82F6", auth.userId]
    );
    const tags = await query(`
      SELECT 
        crt.*,
        u.first_name as creator_first_name,
        u.last_name as creator_last_name
      FROM chat_room_tags crt
      LEFT JOIN users u ON crt.created_by = u.id
      WHERE crt.id = ?
    `, [result.insertId]);
    if (!tags || tags.length === 0) {
      throw createError$2({
        statusCode: 500,
        message: "Failed to retrieve created tag"
      });
    }
    const tag = tags[0];
    const formattedTag = {
      id: tag.id,
      room_id: tag.room_id,
      tag_name: tag.tag_name,
      color: tag.color,
      created_by: tag.created_by,
      created_at: tag.created_at,
      creator: {
        id: tag.created_by,
        first_name: tag.creator_first_name,
        last_name: tag.creator_last_name
      }
    };
    return {
      success: true,
      data: formattedTag
    };
  } catch (error) {
    console.error("[API] Error creating tag:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to create tag"
    });
  }
});

const tags_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: tags_post
}, Symbol.toStringTag, { value: 'Module' }));

const typing_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    const nitroApp = useNitroApp();
    const io = nitroApp.io;
    if (io) {
      try {
        io.to(`room:${roomId}`).emit("user_typing", {
          userId: auth.userId,
          roomId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      } catch (emitError) {
        if (emitError.code !== "ECONNRESET" && emitError.message !== "read ECONNRESET") {
          console.error("[API] Error emitting typing event:", emitError);
        }
      }
    }
    return {
      success: true
    };
  } catch (error) {
    if (error.code !== "ECONNRESET" && error.message !== "read ECONNRESET") {
      console.error("[API] Error emitting typing event:", error);
      throw createError$2({
        statusCode: 500,
        message: error.message || "Failed to emit typing event"
      });
    }
    return { success: true };
  }
});

const typing_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: typing_post
}, Symbol.toStringTag, { value: 'Module' }));

const stop_post = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roomId = parseInt(getRouterParam(event, "roomId") || "0");
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid room ID"
    });
  }
  const hasAccess = await verifyRoomAccess(auth.userId, roomId);
  if (!hasAccess) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied to this room"
    });
  }
  try {
    const nitroApp = useNitroApp();
    const io = nitroApp.io;
    if (io) {
      try {
        io.to(`room:${roomId}`).emit("stop_typing", {
          userId: auth.userId,
          roomId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      } catch (emitError) {
        if (emitError.code !== "ECONNRESET" && emitError.message !== "read ECONNRESET") {
          console.error("[API] Error emitting stop typing event:", emitError);
        }
      }
    }
    return {
      success: true
    };
  } catch (error) {
    if (error.code !== "ECONNRESET" && error.message !== "read ECONNRESET") {
      console.error("[API] Error emitting stop typing event:", error);
      throw createError$2({
        statusCode: 500,
        message: error.message || "Failed to emit stop typing event"
      });
    }
    return { success: true };
  }
});

const stop_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: stop_post
}, Symbol.toStringTag, { value: 'Module' }));

const upload_post = defineEventHandler(async (event) => {
  await requireAuth(event);
  const query = getQuery(event);
  const roomId = query.roomId ? parseInt(query.roomId) : null;
  const fileType = query.fileType || "image";
  if (!roomId) {
    throw createError$2({
      statusCode: 400,
      message: "roomId is required"
    });
  }
  try {
    const formData = await readMultipartFormData(event);
    if (!formData || formData.length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "No file uploaded"
      });
    }
    const file = formData[0];
    if (!file.filename || !file.data) {
      throw createError$2({
        statusCode: 400,
        message: "Invalid file"
      });
    }
    const isImage = fileType === "image";
    const allowedImageTypes = ["image/jpeg", "image/jpg", "image/png", "image/gif", "image/webp"];
    const allowedFileTypes = [
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.ms-excel",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "text/plain"
    ];
    if (isImage) {
      if (!file.type || !allowedImageTypes.includes(file.type)) {
        throw createError$2({
          statusCode: 400,
          message: "Only image files are allowed (JPEG, PNG, GIF, WebP)"
        });
      }
    } else {
      if (!file.type || !allowedImageTypes.includes(file.type) && !allowedFileTypes.includes(file.type)) {
        throw createError$2({
          statusCode: 400,
          message: "File type not allowed"
        });
      }
    }
    const maxImageSize = 5 * 1024 * 1024;
    const maxFileSize = 10 * 1024 * 1024;
    const maxSize = isImage ? maxImageSize : maxFileSize;
    if (file.data.length > maxSize) {
      const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(0);
      throw createError$2({
        statusCode: 400,
        message: `File size exceeds ${maxSizeMB}MB limit`
      });
    }
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(2, 15);
    const extension = file.filename.split(".").pop();
    const filename = `${timestamp}-${randomString}.${extension}`;
    const subdir = isImage ? "images" : "files";
    const uploadsDir = join$1(process.cwd(), "public", "uploads", "chat", roomId.toString(), subdir);
    if (!existsSync$1(uploadsDir)) {
      await mkdir(uploadsDir, { recursive: true });
    }
    const filePath = join$1(uploadsDir, filename);
    await writeFile$1(filePath, file.data);
    const publicUrl = `/uploads/chat/${roomId}/${subdir}/${filename}`;
    return {
      success: true,
      data: {
        url: publicUrl,
        filename,
        originalName: file.filename,
        size: file.data.length,
        type: file.type
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error uploading file:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to upload file"
    });
  }
});

const upload_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: upload_post
}, Symbol.toStringTag, { value: 'Module' }));

const _slug__get = defineEventHandler(async (event) => {
  const slug = getRouterParam(event, "slug");
  if (!slug) {
    throw createError$2({
      statusCode: 400,
      message: "Slug parameter is required"
    });
  }
  try {
    const pages = await query(
      "SELECT id, slug, title, content, meta_title, meta_description, meta_keywords, is_active, created_at, updated_at FROM content_pages WHERE slug = ? AND is_active = TRUE LIMIT 1",
      [slug]
    );
    if (pages.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Page not found"
      });
    }
    return {
      success: true,
      data: pages[0]
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error fetching content page:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch content page"
    });
  }
});

const _slug__get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _slug__get
}, Symbol.toStringTag, { value: 'Module' }));

const courses_get = defineEventHandler(async (event) => {
  var _a;
  const queryParams = getQuery(event);
  const search = queryParams.search;
  const type = queryParams.type;
  const level = queryParams.level;
  const branchId = queryParams.branch_id;
  const page = parseInt(queryParams.page) || 1;
  const limit = parseInt(queryParams.limit) || 15;
  const offset = (page - 1) * limit;
  let sql = `
    SELECT 
      c.id,
      c.title,
      c.description,
      c.type,
      c.price,
      c.onsite_price,
      c.online_price,
      c.duration_hours,
      c.level,
      c.status,
      c.code,
      c.thumbnail_url,
      c.created_at,
      c.updated_at,
      COUNT(DISTINCT e.id) as enrollment_count
    FROM courses c
    LEFT JOIN enrollments e ON c.id = e.course_id AND e.status = 'active'
    WHERE c.status = 'published'
  `;
  const params = [];
  if (search) {
    sql += ` AND (c.title LIKE ? OR c.code LIKE ? OR c.description LIKE ?)`;
    const searchPattern = `%${search}%`;
    params.push(searchPattern, searchPattern, searchPattern);
  }
  if (type) {
    sql += ` AND c.type = ?`;
    params.push(type);
  }
  if (level) {
    sql += ` AND c.level = ?`;
    params.push(level);
  }
  if (branchId) {
    sql += ` AND EXISTS (
      SELECT 1 FROM course_branches cb
      INNER JOIN branches b ON cb.branch_id = b.id
      WHERE cb.course_id = c.id 
      AND cb.branch_id = ?
      AND cb.is_available = 1
      AND b.status = 'active'
    )`;
    params.push(parseInt(branchId));
  }
  sql += ` GROUP BY c.id, c.title, c.description, c.type, c.price, c.onsite_price, c.online_price, 
    c.duration_hours, c.level, c.status, c.code, c.thumbnail_url, c.created_at, c.updated_at`;
  const sortBy = queryParams.sort_by || "newest";
  if (sortBy === "price_asc") {
    sql += ` ORDER BY c.price ASC`;
  } else if (sortBy === "price_desc") {
    sql += ` ORDER BY c.price DESC`;
  } else if (sortBy === "popular") {
    sql += ` ORDER BY enrollment_count DESC`;
  } else {
    sql += ` ORDER BY c.created_at DESC`;
  }
  try {
    const countParams = [];
    let countSql = `
      SELECT COUNT(DISTINCT c.id) as total
      FROM courses c
      WHERE c.status = 'published'
    `;
    if (search) {
      countSql += ` AND (c.title LIKE ? OR c.code LIKE ? OR c.description LIKE ?)`;
      const searchPattern = `%${search}%`;
      countParams.push(searchPattern, searchPattern, searchPattern);
    }
    if (type) {
      countSql += ` AND c.type = ?`;
      countParams.push(type);
    }
    if (level) {
      countSql += ` AND c.level = ?`;
      countParams.push(level);
    }
    if (branchId) {
      countSql += ` AND EXISTS (
        SELECT 1 FROM course_branches cb
        INNER JOIN branches b ON cb.branch_id = b.id
        WHERE cb.course_id = c.id 
        AND cb.branch_id = ?
        AND cb.is_available = 1
        AND b.status = 'active'
      )`;
      countParams.push(parseInt(branchId));
    }
    const countResult = await query(countSql, countParams);
    const total = ((_a = countResult == null ? void 0 : countResult[0]) == null ? void 0 : _a.total) || 0;
    const totalPages = Math.ceil(total / limit);
    sql += ` LIMIT ? OFFSET ?`;
    params.push(limit, offset);
    const courses = await query(sql, params);
    const formattedCourses = courses.map((course) => ({
      id: course.id,
      title: course.title,
      description: course.description,
      type: course.type,
      price: parseFloat(course.price || "0"),
      onsite_price: course.onsite_price ? parseFloat(course.onsite_price) : null,
      online_price: course.online_price ? parseFloat(course.online_price) : null,
      duration_hours: course.duration_hours,
      level: course.level,
      code: course.code,
      thumbnail_url: course.thumbnail_url,
      enrollment_count: parseInt(course.enrollment_count || "0"),
      created_at: course.created_at,
      updated_at: course.updated_at
    }));
    return {
      success: true,
      data: formattedCourses,
      pagination: {
        page,
        limit,
        total,
        totalPages
      }
    };
  } catch (error) {
    console.error("Error fetching courses:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch courses"
    });
  }
});

const courses_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: courses_get
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get = defineEventHandler(async (event) => {
  var _a;
  const courseId = parseInt(getRouterParam(event, "id") || "0");
  if (!courseId) {
    throw createError$2({
      statusCode: 400,
      message: "Invalid course ID"
    });
  }
  try {
    let courses;
    let thumbnailUrl = null;
    try {
      courses = await query(
        `SELECT 
          c.id,
          c.title,
          c.description,
          c.type,
          c.price,
          c.onsite_price,
          c.online_price,
          c.duration_hours,
          c.level,
          c.status,
          c.code,
          c.created_at,
          c.updated_at,
          c.thumbnail_url
        FROM courses c
        WHERE c.id = ? AND c.status = 'published'`,
        [courseId]
      );
      thumbnailUrl = ((_a = courses[0]) == null ? void 0 : _a.thumbnail_url) || null;
    } catch (err) {
      if (err.code === "ER_BAD_FIELD_ERROR" && err.message.includes("thumbnail_url")) {
        courses = await query(
          `SELECT 
            c.id,
            c.title,
            c.description,
            c.type,
            c.price,
            c.duration_hours,
            c.level,
            c.status,
            c.code,
            c.created_at,
            c.updated_at
          FROM courses c
          WHERE c.id = ? AND c.status = 'published'`,
          [courseId]
        );
        thumbnailUrl = null;
      } else {
        throw err;
      }
    }
    if (courses.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Course not found"
      });
    }
    const course = courses[0];
    const courseBranches = await query(
      `SELECT 
        cb.id,
        cb.course_id,
        cb.branch_id,
        cb.seat_limit,
        cb.current_enrollments,
        cb.is_available,
        b.name as branch_name,
        b.code as branch_code,
        b.status as branch_status
      FROM course_branches cb
      INNER JOIN branches b ON cb.branch_id = b.id
      WHERE cb.course_id = ? AND cb.is_available = 1 AND b.status = 'active'`,
      [courseId]
    );
    return {
      success: true,
      data: {
        course: {
          id: course.id,
          title: course.title,
          description: course.description,
          type: course.type,
          price: course.price,
          onsite_price: course.onsite_price || course.price,
          online_price: course.online_price || course.price,
          duration_hours: course.duration_hours,
          level: course.level,
          status: course.status,
          code: course.code,
          thumbnail_url: thumbnailUrl,
          created_at: course.created_at,
          updated_at: course.updated_at
        },
        branches: courseBranches.map((cb) => ({
          branch_id: cb.branch_id,
          branch_name: cb.branch_name,
          branch_code: cb.branch_code,
          seat_limit: cb.seat_limit,
          current_enrollments: cb.current_enrollments || 0,
          is_available: cb.is_available,
          available_seats: cb.seat_limit ? cb.seat_limit - (cb.current_enrollments || 0) : null
        }))
      }
    };
  } catch (error) {
    if (error.statusCode) {
      throw error;
    }
    console.error("Error fetching course detail:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch course detail"
    });
  }
});

const _id__get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get
}, Symbol.toStringTag, { value: 'Module' }));

const health_get = defineEventHandler(async (event) => {
  return {
    status: "ok",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    timezone: "Asia/Bangkok"
  };
});

const health_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: health_get
}, Symbol.toStringTag, { value: 'Module' }));

const availableChats_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["student", "parent"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Student or Parent role required."
    });
  }
  let studentIds = [auth.userId];
  if (roles.includes("parent")) {
    const linkedStudents = await query(
      `SELECT DISTINCT student_id 
       FROM parent_students 
       WHERE parent_id = ? AND is_active = 1`,
      [auth.userId]
    );
    studentIds = [auth.userId, ...linkedStudents.map((s) => s.student_id)];
  }
  const placeholders = studentIds.map(() => "?").join(",");
  const sql = `
    SELECT DISTINCT
      e.id as enrollment_id,
      e.course_id,
      e.student_id,
      c.title as course_title,
      c.code as course_code,
      c.thumbnail_url as course_thumbnail,
      tutor_user.id as tutor_user_id,
      tutor_user.first_name as tutor_first_name,
      tutor_user.last_name as tutor_last_name,
      tutor_user.username as tutor_username,
      tutor_user.email as tutor_email,
      tutor_user.avatar_url as tutor_avatar,
      cr.id as chat_room_id
    FROM enrollments e
    INNER JOIN courses c ON e.course_id = c.id
    INNER JOIN tutor_courses tc ON c.id = tc.course_id
    INNER JOIN tutors tutor_table ON tc.tutor_id = tutor_table.id
    INNER JOIN users tutor_user ON tutor_table.user_id = tutor_user.id
    LEFT JOIN chat_rooms cr ON (
      cr.course_id = c.id 
      AND cr.student_id = e.student_id 
      AND cr.tutor_id = tutor_user.id
      AND cr.status = 'active'
    )
    WHERE e.student_id IN (${placeholders})
      AND e.status IN ('active', 'completed')
      AND tutor_user.status = 'active'
      AND tutor_table.status = 'active'
    ORDER BY c.title, tutor_user.first_name, tutor_user.last_name
  `;
  try {
    const results = await query(sql, studentIds);
    const chatOptions = [];
    const seen = /* @__PURE__ */ new Set();
    for (const row of results) {
      const key = `${row.course_id}-${row.tutor_user_id}-${row.student_id}`;
      if (!seen.has(key)) {
        seen.add(key);
        chatOptions.push({
          course: {
            id: row.course_id,
            title: row.course_title,
            code: row.course_code,
            thumbnail: row.course_thumbnail
          },
          tutor: {
            id: row.tutor_user_id,
            firstName: row.tutor_first_name,
            lastName: row.tutor_last_name,
            username: row.tutor_username,
            email: row.tutor_email,
            avatar: row.tutor_avatar
          },
          enrollmentId: row.enrollment_id,
          studentId: row.student_id,
          chatRoomId: row.chat_room_id
        });
      }
    }
    return {
      success: true,
      data: chatOptions
    };
  } catch (error) {
    console.error("[Available Chats API] Error:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to fetch available chats"
    });
  }
});

const availableChats_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: availableChats_get
}, Symbol.toStringTag, { value: 'Module' }));

const myCourses_get = defineEventHandler(async (event) => {
  const auth = await requireAuth(event);
  const roles = await getUserRoles(auth.userId);
  const allowedRoles = ["student", "parent"];
  if (!roles.some((role) => allowedRoles.includes(role))) {
    throw createError$2({
      statusCode: 403,
      message: "Access denied. Student or Parent role required."
    });
  }
  let studentIds = [auth.userId];
  if (roles.includes("parent")) {
    const linkedStudents = await query(
      `SELECT DISTINCT student_id 
       FROM parent_students 
       WHERE parent_id = ? AND is_active = 1`,
      [auth.userId]
    );
    studentIds = [auth.userId, ...linkedStudents.map((s) => s.student_id)];
  }
  let hasEnrollmentType = false;
  try {
    const columnCheck = await query(
      `SELECT COLUMN_NAME 
       FROM INFORMATION_SCHEMA.COLUMNS 
       WHERE TABLE_SCHEMA = DATABASE() 
       AND TABLE_NAME = 'enrollments' 
       AND COLUMN_NAME = 'enrollment_type'`
    );
    hasEnrollmentType = columnCheck.length > 0;
  } catch (error) {
    console.log("[My Courses API] Could not check column existence, assuming column doesn't exist");
  }
  const enrollmentTypeSelect = hasEnrollmentType ? `COALESCE(e.enrollment_type, 'onsite') as enrollment_type` : `'onsite' as enrollment_type`;
  const placeholders = studentIds.map(() => "?").join(",");
  let sql = `
    SELECT 
      e.id,
      e.student_id,
      e.course_id,
      e.branch_id,
      ${enrollmentTypeSelect},
      e.enrollment_date,
      e.status,
      e.created_at,
      e.updated_at,
      c.id as course_id,
      c.title as course_title,
      c.code as course_code,
      c.description as course_description,
      c.thumbnail_url as course_thumbnail_url,
      c.type as course_type,
      c.level as course_level,
      c.price as course_price,
      c.onsite_price,
      c.online_price,
      b.name as branch_name,
      b.code as branch_code,
      s.first_name as student_first_name,
      s.last_name as student_last_name,
      s.username as student_username
    FROM enrollments e
    INNER JOIN courses c ON e.course_id = c.id
    LEFT JOIN branches b ON e.branch_id = b.id
    INNER JOIN users s ON e.student_id = s.id
    WHERE e.student_id IN (${placeholders})
      AND e.status IN ('active', 'completed')
    ORDER BY e.enrollment_date DESC
  `;
  try {
    const enrollments = await query(sql, studentIds);
    const formattedEnrollments = enrollments.map((enrollment) => ({
      id: enrollment.id,
      enrollmentDate: enrollment.enrollment_date,
      status: enrollment.status,
      enrollmentType: enrollment.enrollment_type || "onsite",
      course: {
        id: enrollment.course_id,
        title: enrollment.course_title,
        code: enrollment.course_code,
        description: enrollment.course_description,
        thumbnail: enrollment.course_thumbnail_url,
        thumbnail_url: enrollment.course_thumbnail_url,
        type: enrollment.course_type,
        level: enrollment.course_level,
        price: enrollment.course_price,
        onsite_price: enrollment.onsite_price,
        online_price: enrollment.online_price
      },
      branch: enrollment.branch_id ? {
        id: enrollment.branch_id,
        name: enrollment.branch_name,
        code: enrollment.branch_code
      } : null,
      student: {
        id: enrollment.student_id,
        firstName: enrollment.student_first_name,
        lastName: enrollment.student_last_name,
        username: enrollment.student_username
      },
      // TODO: Calculate progress from learning progress table if exists
      progress: 0,
      createdAt: enrollment.created_at,
      updatedAt: enrollment.updated_at
    }));
    return {
      success: true,
      data: formattedEnrollments
    };
  } catch (error) {
    console.error("[My Courses API] Error fetching enrollments:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Failed to fetch enrollments"
    });
  }
});

const myCourses_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: myCourses_get
}, Symbol.toStringTag, { value: 'Module' }));

const testimonials_get = defineEventHandler(async (event) => {
  const queryParams = getQuery(event);
  const limit = parseInt(queryParams.limit) || 10;
  const sql = `
    SELECT 
      id,
      name,
      role,
      comment,
      rating,
      avatar_url,
      display_order
    FROM testimonials
    WHERE status = 'approved'
    ORDER BY display_order ASC, created_at DESC
    LIMIT ?
  `;
  try {
    const testimonials = await query(sql, [limit]);
    return {
      success: true,
      data: testimonials
    };
  } catch (error) {
    console.error("Error fetching testimonials:", error);
    throw createError$2({
      statusCode: 500,
      message: "Failed to fetch testimonials"
    });
  }
});

const testimonials_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: testimonials_get
}, Symbol.toStringTag, { value: 'Module' }));

const VueResolver = (_, value) => {
  return isRef(value) ? toValue(value) : value;
};

const headSymbol = "usehead";
// @__NO_SIDE_EFFECTS__
function vueInstall(head) {
  const plugin = {
    install(app) {
      app.config.globalProperties.$unhead = head;
      app.config.globalProperties.$head = head;
      app.provide(headSymbol, head);
    }
  };
  return plugin.install;
}

// @__NO_SIDE_EFFECTS__
function injectHead$1() {
  if (hasInjectionContext()) {
    const instance = inject(headSymbol);
    if (!instance) {
      throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
    }
    return instance;
  }
  throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
}
function useHead$1(input, options = {}) {
  const head = options.head || /* @__PURE__ */ injectHead$1();
  return head.ssr ? head.push(input || {}, options) : clientUseHead(head, input, options);
}
function clientUseHead(head, input, options = {}) {
  const deactivated = ref(false);
  let entry;
  watchEffect(() => {
    const i = deactivated.value ? {} : walkResolver(input, VueResolver);
    if (entry) {
      entry.patch(i);
    } else {
      entry = head.push(i, options);
    }
  });
  const vm = getCurrentInstance();
  if (vm) {
    onBeforeUnmount(() => {
      entry.dispose();
    });
    onDeactivated(() => {
      deactivated.value = true;
    });
    onActivated(() => {
      deactivated.value = false;
    });
  }
  return entry;
}

// @__NO_SIDE_EFFECTS__
function createHead(options = {}) {
  const head = createHead$1({
    ...options,
    propResolvers: [VueResolver]
  });
  head.install = vueInstall(head);
  return head;
}

const appHead = {"meta":[{"name":"viewport","content":"width=device-width, initial-scale=1"},{"charset":"utf-8"}],"link":[],"style":[],"script":[],"noscript":[]};

const appRootTag = "div";

const appRootAttrs = {"id":"__nuxt"};

const appTeleportTag = "div";

const appTeleportAttrs = {"id":"teleports"};

const appSpaLoaderTag = "div";

const appSpaLoaderAttrs = {"id":"__nuxt-loader"};

const appId$1 = "nuxt-app";

function baseURL() {
  return useRuntimeConfig$1().app.baseURL;
}
function buildAssetsDir() {
  return useRuntimeConfig$1().app.buildAssetsDir;
}
function buildAssetsURL(...path) {
  return joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...path);
}
function publicAssetsURL(...path) {
  const app = useRuntimeConfig$1().app;
  const publicBase = app.cdnURL || app.baseURL;
  return path.length ? joinRelativeURL(publicBase, ...path) : publicBase;
}

const APP_ROOT_OPEN_TAG = `<${appRootTag}${propsToString(appRootAttrs)}>`;
const APP_ROOT_CLOSE_TAG = `</${appRootTag}>`;
const getServerEntry = () => Promise.resolve().then(function () { return server; }).then((r) => r.default || r);
const getPrecomputedDependencies = () => Promise.resolve().then(function () { return client_precomputed$1; }).then((r) => r.default || r).then((r) => typeof r === "function" ? r() : r);
const getSSRRenderer = lazyCachedFunction(async () => {
  const createSSRApp = await getServerEntry();
  if (!createSSRApp) {
    throw new Error("Server bundle is not available");
  }
  const precomputed = await getPrecomputedDependencies();
  const renderer = createRenderer(createSSRApp, {
    precomputed,
    manifest: void 0,
    renderToString: renderToString$1,
    buildAssetsURL
  });
  async function renderToString$1(input, context) {
    const html = await renderToString(input, context);
    return APP_ROOT_OPEN_TAG + html + APP_ROOT_CLOSE_TAG;
  }
  return renderer;
});
const getSPARenderer = lazyCachedFunction(async () => {
  const precomputed = await getPrecomputedDependencies();
  const spaTemplate = await Promise.resolve().then(function () { return _virtual__spaTemplate; }).then((r) => r.template).catch(() => "").then((r) => {
    {
      const APP_SPA_LOADER_OPEN_TAG = `<${appSpaLoaderTag}${propsToString(appSpaLoaderAttrs)}>`;
      const APP_SPA_LOADER_CLOSE_TAG = `</${appSpaLoaderTag}>`;
      const appTemplate = APP_ROOT_OPEN_TAG + APP_ROOT_CLOSE_TAG;
      const loaderTemplate = r ? APP_SPA_LOADER_OPEN_TAG + r + APP_SPA_LOADER_CLOSE_TAG : "";
      return appTemplate + loaderTemplate;
    }
  });
  const renderer = createRenderer(() => () => {
  }, {
    precomputed,
    manifest: void 0,
    renderToString: () => spaTemplate,
    buildAssetsURL
  });
  const result = await renderer.renderToString({});
  const renderToString = (ssrContext) => {
    const config = useRuntimeConfig$1(ssrContext.event);
    ssrContext.modules ||= /* @__PURE__ */ new Set();
    ssrContext.payload.serverRendered = false;
    ssrContext.config = {
      public: config.public,
      app: config.app
    };
    return Promise.resolve(result);
  };
  return {
    rendererContext: renderer.rendererContext,
    renderToString
  };
});
function lazyCachedFunction(fn) {
  let res = null;
  return () => {
    if (res === null) {
      res = fn().catch((err) => {
        res = null;
        throw err;
      });
    }
    return res;
  };
}
function getRenderer(ssrContext) {
  return ssrContext.noSSR ? getSPARenderer() : getSSRRenderer();
}
const getSSRStyles = lazyCachedFunction(() => Promise.resolve().then(function () { return styles$1; }).then((r) => r.default || r));

function renderPayloadResponse(ssrContext) {
  return {
    body: stringify$1(splitPayload(ssrContext).payload, ssrContext._payloadReducers) ,
    statusCode: getResponseStatus(ssrContext.event),
    statusMessage: getResponseStatusText(ssrContext.event),
    headers: {
      "content-type": "application/json;charset=utf-8" ,
      "x-powered-by": "Nuxt"
    }
  };
}
function renderPayloadJsonScript(opts) {
  const contents = opts.data ? stringify$1(opts.data, opts.ssrContext._payloadReducers) : "";
  const payload = {
    "type": "application/json",
    "innerHTML": contents,
    "data-nuxt-data": appId$1,
    "data-ssr": !(opts.ssrContext.noSSR)
  };
  {
    payload.id = "__NUXT_DATA__";
  }
  if (opts.src) {
    payload["data-src"] = opts.src;
  }
  const config = uneval(opts.ssrContext.config);
  return [
    payload,
    {
      innerHTML: `window.__NUXT__={};window.__NUXT__.config=${config}`
    }
  ];
}
function splitPayload(ssrContext) {
  const { data, prerenderedAt, ...initial } = ssrContext.payload;
  return {
    initial: { ...initial, prerenderedAt },
    payload: { data, prerenderedAt }
  };
}

const unheadOptions = {
  disableDefaults: true,
};

function createSSRContext(event) {
  const ssrContext = {
    url: event.path,
    event,
    runtimeConfig: useRuntimeConfig$1(event),
    noSSR: event.context.nuxt?.noSSR || (false),
    head: createHead(unheadOptions),
    error: false,
    nuxt: void 0,
    /* NuxtApp */
    payload: {},
    _payloadReducers: /* @__PURE__ */ Object.create(null),
    modules: /* @__PURE__ */ new Set()
  };
  return ssrContext;
}
function setSSRError(ssrContext, error) {
  ssrContext.error = true;
  ssrContext.payload = { error };
  ssrContext.url = error.url;
}

async function renderInlineStyles(usedModules) {
  const styleMap = await getSSRStyles();
  const inlinedStyles = /* @__PURE__ */ new Set();
  for (const mod of usedModules) {
    if (mod in styleMap && styleMap[mod]) {
      for (const style of await styleMap[mod]()) {
        inlinedStyles.add(style);
      }
    }
  }
  return Array.from(inlinedStyles).map((style) => ({ innerHTML: style }));
}

const renderSSRHeadOptions = {"omitLineBreaks":true};

const entryIds = [];

globalThis.__buildAssetsURL = buildAssetsURL;
globalThis.__publicAssetsURL = publicAssetsURL;
const HAS_APP_TELEPORTS = !!(appTeleportAttrs.id);
const APP_TELEPORT_OPEN_TAG = HAS_APP_TELEPORTS ? `<${appTeleportTag}${propsToString(appTeleportAttrs)}>` : "";
const APP_TELEPORT_CLOSE_TAG = HAS_APP_TELEPORTS ? `</${appTeleportTag}>` : "";
const PAYLOAD_URL_RE = /^[^?]*\/_payload.json(?:\?.*)?$/ ;
const renderer = defineRenderHandler(async (event) => {
  const nitroApp = useNitroApp();
  const ssrError = event.path.startsWith("/__nuxt_error") ? getQuery(event) : null;
  if (ssrError && !("__unenv__" in event.node.req)) {
    throw createError$2({
      statusCode: 404,
      statusMessage: "Page Not Found: /__nuxt_error"
    });
  }
  const ssrContext = createSSRContext(event);
  const headEntryOptions = { mode: "server" };
  ssrContext.head.push(appHead, headEntryOptions);
  if (ssrError) {
    ssrError.statusCode &&= Number.parseInt(ssrError.statusCode);
    if (typeof ssrError.data === "string") {
      try {
        ssrError.data = destr(ssrError.data);
      } catch {
      }
    }
    setSSRError(ssrContext, ssrError);
  }
  const isRenderingPayload = PAYLOAD_URL_RE.test(ssrContext.url);
  if (isRenderingPayload) {
    const url = ssrContext.url.substring(0, ssrContext.url.lastIndexOf("/")) || "/";
    ssrContext.url = url;
    event._path = event.node.req.url = url;
  }
  const routeOptions = getRouteRules$1(event);
  if (routeOptions.ssr === false) {
    ssrContext.noSSR = true;
  }
  const renderer = await getRenderer(ssrContext);
  {
    for (const id of entryIds) {
      ssrContext.modules.add(id);
    }
  }
  const _rendered = await renderer.renderToString(ssrContext).catch(async (error) => {
    if (ssrContext._renderResponse && error.message === "skipping render") {
      return {};
    }
    const _err = !ssrError && ssrContext.payload?.error || error;
    await ssrContext.nuxt?.hooks.callHook("app:error", _err);
    throw _err;
  });
  const inlinedStyles = !ssrContext._renderResponse && !isRenderingPayload ? await renderInlineStyles(ssrContext.modules ?? []) : [];
  await ssrContext.nuxt?.hooks.callHook("app:rendered", { ssrContext, renderResult: _rendered });
  if (ssrContext._renderResponse) {
    return ssrContext._renderResponse;
  }
  if (ssrContext.payload?.error && !ssrError) {
    throw ssrContext.payload.error;
  }
  if (isRenderingPayload) {
    const response = renderPayloadResponse(ssrContext);
    return response;
  }
  const NO_SCRIPTS = routeOptions.noScripts;
  const { styles, scripts } = getRequestDependencies(ssrContext, renderer.rendererContext);
  if (ssrContext._preloadManifest && !NO_SCRIPTS) {
    ssrContext.head.push({
      link: [
        { rel: "preload", as: "fetch", fetchpriority: "low", crossorigin: "anonymous", href: buildAssetsURL(`builds/meta/${ssrContext.runtimeConfig.app.buildId}.json`) }
      ]
    }, { ...headEntryOptions, tagPriority: "low" });
  }
  if (inlinedStyles.length) {
    ssrContext.head.push({ style: inlinedStyles });
  }
  const link = [];
  for (const resource of Object.values(styles)) {
    link.push({ rel: "stylesheet", href: renderer.rendererContext.buildAssetsURL(resource.file), crossorigin: "" });
  }
  if (link.length) {
    ssrContext.head.push({ link }, headEntryOptions);
  }
  if (!NO_SCRIPTS) {
    ssrContext.head.push({
      link: getPreloadLinks(ssrContext, renderer.rendererContext)
    }, headEntryOptions);
    ssrContext.head.push({
      link: getPrefetchLinks(ssrContext, renderer.rendererContext)
    }, headEntryOptions);
    ssrContext.head.push({
      script: renderPayloadJsonScript({ ssrContext, data: ssrContext.payload }) 
    }, {
      ...headEntryOptions,
      // this should come before another end of body scripts
      tagPosition: "bodyClose",
      tagPriority: "high"
    });
  }
  if (!routeOptions.noScripts) {
    const tagPosition = "head";
    ssrContext.head.push({
      script: Object.values(scripts).map((resource) => ({
        type: resource.module ? "module" : null,
        src: renderer.rendererContext.buildAssetsURL(resource.file),
        defer: resource.module ? null : true,
        // if we are rendering script tag payloads that import an async payload
        // we need to ensure this resolves before executing the Nuxt entry
        tagPosition,
        crossorigin: ""
      }))
    }, headEntryOptions);
  }
  const { headTags, bodyTags, bodyTagsOpen, htmlAttrs, bodyAttrs } = await renderSSRHead(ssrContext.head, renderSSRHeadOptions);
  const htmlContext = {
    htmlAttrs: htmlAttrs ? [htmlAttrs] : [],
    head: normalizeChunks([headTags]),
    bodyAttrs: bodyAttrs ? [bodyAttrs] : [],
    bodyPrepend: normalizeChunks([bodyTagsOpen, ssrContext.teleports?.body]),
    body: [
      _rendered.html,
      APP_TELEPORT_OPEN_TAG + (HAS_APP_TELEPORTS ? joinTags([ssrContext.teleports?.[`#${appTeleportAttrs.id}`]]) : "") + APP_TELEPORT_CLOSE_TAG
    ],
    bodyAppend: [bodyTags]
  };
  await nitroApp.hooks.callHook("render:html", htmlContext, { event });
  return {
    body: renderHTMLDocument(htmlContext),
    statusCode: getResponseStatus(event),
    statusMessage: getResponseStatusText(event),
    headers: {
      "content-type": "text/html;charset=utf-8",
      "x-powered-by": "Nuxt"
    }
  };
});
function normalizeChunks(chunks) {
  const result = [];
  for (const _chunk of chunks) {
    const chunk = _chunk?.trim();
    if (chunk) {
      result.push(chunk);
    }
  }
  return result;
}
function joinTags(tags) {
  return tags.join("");
}
function joinAttrs(chunks) {
  if (chunks.length === 0) {
    return "";
  }
  return " " + chunks.join(" ");
}
function renderHTMLDocument(html) {
  return `<!DOCTYPE html><html${joinAttrs(html.htmlAttrs)}><head>${joinTags(html.head)}</head><body${joinAttrs(html.bodyAttrs)}>${joinTags(html.bodyPrepend)}${joinTags(html.body)}${joinTags(html.bodyAppend)}</body></html>`;
}

const renderer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: renderer
}, Symbol.toStringTag, { value: 'Module' }));

if (!globalThis.$fetch) {
  globalThis.$fetch = $fetch$1.create({
    baseURL: baseURL()
  });
}
if (!("global" in globalThis)) {
  globalThis.global = globalThis;
}
const appLayoutTransition = false;
const nuxtLinkDefaults = { "componentName": "NuxtLink" };
const appId = "nuxt-app";
function getNuxtAppCtx(id = appId) {
  return getContext(id, {
    asyncContext: false
  });
}
const NuxtPluginIndicator = "__nuxt_plugin";
function createNuxtApp(options) {
  let hydratingCount = 0;
  const nuxtApp = {
    _id: options.id || appId || "nuxt-app",
    _scope: effectScope(),
    provide: void 0,
    versions: {
      get nuxt() {
        return "4.2.2";
      },
      get vue() {
        return nuxtApp.vueApp.version;
      }
    },
    payload: shallowReactive({
      ...options.ssrContext?.payload || {},
      data: shallowReactive({}),
      state: reactive({}),
      once: /* @__PURE__ */ new Set(),
      _errors: shallowReactive({})
    }),
    static: {
      data: {}
    },
    runWithContext(fn) {
      if (nuxtApp._scope.active && !getCurrentScope()) {
        return nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn));
      }
      return callWithNuxt(nuxtApp, fn);
    },
    isHydrating: false,
    deferHydration() {
      if (!nuxtApp.isHydrating) {
        return () => {
        };
      }
      hydratingCount++;
      let called = false;
      return () => {
        if (called) {
          return;
        }
        called = true;
        hydratingCount--;
        if (hydratingCount === 0) {
          nuxtApp.isHydrating = false;
          return nuxtApp.callHook("app:suspense:resolve");
        }
      };
    },
    _asyncDataPromises: {},
    _asyncData: shallowReactive({}),
    _payloadRevivers: {},
    ...options
  };
  {
    nuxtApp.payload.serverRendered = true;
  }
  if (nuxtApp.ssrContext) {
    nuxtApp.payload.path = nuxtApp.ssrContext.url;
    nuxtApp.ssrContext.nuxt = nuxtApp;
    nuxtApp.ssrContext.payload = nuxtApp.payload;
    nuxtApp.ssrContext.config = {
      public: nuxtApp.ssrContext.runtimeConfig.public,
      app: nuxtApp.ssrContext.runtimeConfig.app
    };
  }
  nuxtApp.hooks = createHooks();
  nuxtApp.hook = nuxtApp.hooks.hook;
  {
    const contextCaller = async function(hooks, args) {
      for (const hook of hooks) {
        await nuxtApp.runWithContext(() => hook(...args));
      }
    };
    nuxtApp.hooks.callHook = (name, ...args) => nuxtApp.hooks.callHookWith(contextCaller, name, ...args);
  }
  nuxtApp.callHook = nuxtApp.hooks.callHook;
  nuxtApp.provide = (name, value) => {
    const $name = "$" + name;
    defineGetter(nuxtApp, $name, value);
    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);
  };
  defineGetter(nuxtApp.vueApp, "$nuxt", nuxtApp);
  defineGetter(nuxtApp.vueApp.config.globalProperties, "$nuxt", nuxtApp);
  const runtimeConfig = options.ssrContext.runtimeConfig;
  nuxtApp.provide("config", runtimeConfig);
  return nuxtApp;
}
function registerPluginHooks(nuxtApp, plugin2) {
  if (plugin2.hooks) {
    nuxtApp.hooks.addHooks(plugin2.hooks);
  }
}
async function applyPlugin(nuxtApp, plugin2) {
  if (typeof plugin2 === "function") {
    const { provide: provide2 } = await nuxtApp.runWithContext(() => plugin2(nuxtApp)) || {};
    if (provide2 && typeof provide2 === "object") {
      for (const key in provide2) {
        nuxtApp.provide(key, provide2[key]);
      }
    }
  }
}
async function applyPlugins(nuxtApp, plugins2) {
  const resolvedPlugins = /* @__PURE__ */ new Set();
  const unresolvedPlugins = [];
  const parallels = [];
  let error = void 0;
  let promiseDepth = 0;
  async function executePlugin(plugin2) {
    const unresolvedPluginsForThisPlugin = plugin2.dependsOn?.filter((name) => plugins2.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];
    if (unresolvedPluginsForThisPlugin.length > 0) {
      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin2]);
    } else {
      const promise = applyPlugin(nuxtApp, plugin2).then(async () => {
        if (plugin2._name) {
          resolvedPlugins.add(plugin2._name);
          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {
            if (dependsOn.has(plugin2._name)) {
              dependsOn.delete(plugin2._name);
              if (dependsOn.size === 0) {
                promiseDepth++;
                await executePlugin(unexecutedPlugin);
              }
            }
          }));
        }
      }).catch((e) => {
        if (!plugin2.parallel && !nuxtApp.payload.error) {
          throw e;
        }
        error ||= e;
      });
      if (plugin2.parallel) {
        parallels.push(promise);
      } else {
        await promise;
      }
    }
  }
  for (const plugin2 of plugins2) {
    if (nuxtApp.ssrContext?.islandContext && plugin2.env?.islands === false) {
      continue;
    }
    registerPluginHooks(nuxtApp, plugin2);
  }
  for (const plugin2 of plugins2) {
    if (nuxtApp.ssrContext?.islandContext && plugin2.env?.islands === false) {
      continue;
    }
    await executePlugin(plugin2);
  }
  await Promise.all(parallels);
  if (promiseDepth) {
    for (let i = 0; i < promiseDepth; i++) {
      await Promise.all(parallels);
    }
  }
  if (error) {
    throw nuxtApp.payload.error || error;
  }
}
// @__NO_SIDE_EFFECTS__
function defineNuxtPlugin(plugin2) {
  if (typeof plugin2 === "function") {
    return plugin2;
  }
  const _name = plugin2._name || plugin2.name;
  delete plugin2.name;
  return Object.assign(plugin2.setup || (() => {
  }), plugin2, { [NuxtPluginIndicator]: true, _name });
}
function callWithNuxt(nuxt, setup, args) {
  const fn = () => setup();
  const nuxtAppCtx = getNuxtAppCtx(nuxt._id);
  {
    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt, fn));
  }
}
function tryUseNuxtApp(id) {
  let nuxtAppInstance;
  if (hasInjectionContext()) {
    nuxtAppInstance = getCurrentInstance()?.appContext.app.$nuxt;
  }
  nuxtAppInstance ||= getNuxtAppCtx(id).tryUse();
  return nuxtAppInstance || null;
}
function useNuxtApp(id) {
  const nuxtAppInstance = tryUseNuxtApp(id);
  if (!nuxtAppInstance) {
    {
      throw new Error("[nuxt] instance unavailable");
    }
  }
  return nuxtAppInstance;
}
// @__NO_SIDE_EFFECTS__
function useRuntimeConfig(_event) {
  return useNuxtApp().$config;
}
function defineGetter(obj, key, val) {
  Object.defineProperty(obj, key, { get: () => val });
}
const LayoutMetaSymbol = /* @__PURE__ */ Symbol("layout-meta");
const PageRouteSymbol = /* @__PURE__ */ Symbol("route");
globalThis._importMeta_.url.replace(/\/app\/.*$/, "/");
const useRouter = () => {
  return useNuxtApp()?.$router;
};
const useRoute = () => {
  if (hasInjectionContext()) {
    return inject(PageRouteSymbol, useNuxtApp()._route);
  }
  return useNuxtApp()._route;
};
// @__NO_SIDE_EFFECTS__
function defineNuxtRouteMiddleware(middleware) {
  return middleware;
}
const isProcessingMiddleware = () => {
  try {
    if (useNuxtApp()._processingMiddleware) {
      return true;
    }
  } catch {
    return false;
  }
  return false;
};
const URL_QUOTE_RE = /"/g;
const navigateTo = (to, options) => {
  to ||= "/";
  const toPath = typeof to === "string" ? to : "path" in to ? resolveRouteObject(to) : useRouter().resolve(to).href;
  const isExternalHost = hasProtocol(toPath, { acceptRelative: true });
  const isExternal = options?.external || isExternalHost;
  if (isExternal) {
    if (!options?.external) {
      throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
    }
    const { protocol } = new URL(toPath, "http://localhost");
    if (protocol && isScriptProtocol(protocol)) {
      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`);
    }
  }
  const inMiddleware = isProcessingMiddleware();
  const router = useRouter();
  const nuxtApp = useNuxtApp();
  {
    if (nuxtApp.ssrContext) {
      const fullPath = typeof to === "string" || isExternal ? toPath : router.resolve(to).fullPath || "/";
      const location2 = isExternal ? toPath : joinURL((/* @__PURE__ */ useRuntimeConfig()).app.baseURL, fullPath);
      const redirect = async function(response) {
        await nuxtApp.callHook("app:redirected");
        const encodedLoc = location2.replace(URL_QUOTE_RE, "%22");
        const encodedHeader = encodeURL(location2, isExternalHost);
        nuxtApp.ssrContext._renderResponse = {
          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),
          body: `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`,
          headers: { location: encodedHeader }
        };
        return response;
      };
      if (!isExternal && inMiddleware) {
        router.afterEach((final) => final.fullPath === fullPath ? redirect(false) : void 0);
        return to;
      }
      return redirect(!inMiddleware ? void 0 : (
        /* abort route navigation */
        false
      ));
    }
  }
  if (isExternal) {
    nuxtApp._scope.stop();
    if (options?.replace) {
      (void 0).replace(toPath);
    } else {
      (void 0).href = toPath;
    }
    if (inMiddleware) {
      if (!nuxtApp.isHydrating) {
        return false;
      }
      return new Promise(() => {
      });
    }
    return Promise.resolve();
  }
  return options?.replace ? router.replace(to) : router.push(to);
};
function resolveRouteObject(to) {
  return withQuery(to.path || "", to.query || {}) + (to.hash || "");
}
function encodeURL(location2, isExternalHost = false) {
  const url = new URL(location2, "http://localhost");
  if (!isExternalHost) {
    return url.pathname + url.search + url.hash;
  }
  if (location2.startsWith("//")) {
    return url.toString().replace(url.protocol, "");
  }
  return url.toString();
}
const NUXT_ERROR_SIGNATURE = "__nuxt_error";
const useError = /* @__NO_SIDE_EFFECTS__ */ () => toRef(useNuxtApp().payload, "error");
const showError = (error) => {
  const nuxtError = createError(error);
  try {
    const error2 = /* @__PURE__ */ useError();
    if (false) ;
    error2.value ||= nuxtError;
  } catch {
    throw nuxtError;
  }
  return nuxtError;
};
const isNuxtError = (error) => !!error && typeof error === "object" && NUXT_ERROR_SIGNATURE in error;
const createError = (error) => {
  const nuxtError = createError$2(error);
  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {
    value: true,
    configurable: false,
    writable: false
  });
  return nuxtError;
};
const unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:head",
  enforce: "pre",
  setup(nuxtApp) {
    const head = nuxtApp.ssrContext.head;
    nuxtApp.vueApp.use(head);
  }
});
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
async function getRouteRules(arg) {
  const path = typeof arg === "string" ? arg : arg.path;
  {
    useNuxtApp().ssrContext._preloadManifest = true;
    const _routeRulesMatcher = toRouteMatcher(
      createRouter$1({ routes: (/* @__PURE__ */ useRuntimeConfig()).nitro.routeRules })
    );
    return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());
  }
}
const __nuxt_page_meta$G = {
  layout: "homepage"
};
const __nuxt_page_meta$F = {
  layout: "homepage"
};
const __nuxt_page_meta$E = {
  layout: "chat"
};
const __nuxt_page_meta$D = {
  layout: "student"
};
const __nuxt_page_meta$C = {
  layout: "admin"
};
const __nuxt_page_meta$B = {
  layout: "homepage"
};
const __nuxt_page_meta$A = {
  layout: "homepage"
};
const __nuxt_page_meta$z = {
  layout: "homepage"
};
const __nuxt_page_meta$y = {
  layout: "homepage"
};
const __nuxt_page_meta$x = {
  layout: "homepage"
};
const __nuxt_page_meta$w = {
  layout: "student"
};
const __nuxt_page_meta$v = {
  layout: "admin"
};
const __nuxt_page_meta$u = {
  layout: "admin"
};
const __nuxt_page_meta$t = {
  layout: "admin"
};
const __nuxt_page_meta$s = {
  layout: "admin"
};
const __nuxt_page_meta$r = {
  layout: "admin"
};
const __nuxt_page_meta$q = {
  layout: "default"
};
const __nuxt_page_meta$p = {
  layout: "admin"
};
const __nuxt_page_meta$o = {
  layout: "admin"
};
const __nuxt_page_meta$n = {
  layout: "admin"
};
const __nuxt_page_meta$m = {
  layout: "admin"
};
const __nuxt_page_meta$l = {
  layout: "admin"
};
const __nuxt_page_meta$k = {
  layout: "homepage"
};
const __nuxt_page_meta$j = {
  layout: "admin"
};
const __nuxt_page_meta$i = {
  layout: "admin"
};
const __nuxt_page_meta$h = {
  layout: "admin"
};
const __nuxt_page_meta$g = {
  layout: "admin"
};
const __nuxt_page_meta$f = {
  layout: "admin"
};
const __nuxt_page_meta$e = {
  layout: "admin"
};
const __nuxt_page_meta$d = {
  layout: "admin"
};
const __nuxt_page_meta$c = {
  layout: "admin"
};
const __nuxt_page_meta$b = {
  layout: "admin"
};
const __nuxt_page_meta$a = {
  layout: "admin"
};
const __nuxt_page_meta$9 = {
  layout: "admin"
};
const __nuxt_page_meta$8 = {
  layout: "admin"
};
const __nuxt_page_meta$7 = {
  layout: "admin"
};
const __nuxt_page_meta$6 = {
  layout: "admin"
};
const __nuxt_page_meta$5 = {
  layout: "admin"
};
const __nuxt_page_meta$4 = {
  layout: "admin"
};
const __nuxt_page_meta$3 = {
  layout: "admin"
};
const __nuxt_page_meta$2 = {
  layout: "admin"
};
const __nuxt_page_meta$1 = {
  layout: "admin"
};
const __nuxt_page_meta = {
  layout: "admin"
};
const _routes = [
  {
    name: "help",
    path: "/help",
    component: () => Promise.resolve().then(function () { return helpKYo9vp6y; })
  },
  {
    name: "about",
    path: "/about",
    component: () => Promise.resolve().then(function () { return about6n5z4B2O; })
  },
  {
    name: "index",
    path: "/",
    meta: __nuxt_page_meta$G || {},
    component: () => Promise.resolve().then(function () { return indexCyzpvD2m; })
  },
  {
    name: "careers",
    path: "/careers",
    component: () => Promise.resolve().then(function () { return careersD6l1aock; })
  },
  {
    name: "contact",
    path: "/contact",
    component: () => Promise.resolve().then(function () { return contact57Wsn9cM; })
  },
  {
    name: "support",
    path: "/support",
    component: () => Promise.resolve().then(function () { return supportApQFj3ne; })
  },
  {
    name: "auth-login",
    path: "/auth/login",
    meta: { ...__nuxt_page_meta$F || {}, ...{ "middleware": "guest" } },
    component: () => Promise.resolve().then(function () { return loginDEr0jyvp; })
  },
  {
    name: "chat",
    path: "/chat",
    meta: { ...__nuxt_page_meta$E || {}, ...{ "middleware": "auth" } },
    component: () => Promise.resolve().then(function () { return indexCTYKMr9P; })
  },
  {
    name: "my-courses",
    path: "/my-courses",
    meta: { ...__nuxt_page_meta$D || {}, ...{ "middleware": "auth" } },
    component: () => Promise.resolve().then(function () { return myCoursesB847wEG; })
  },
  {
    name: "admin",
    path: "/admin",
    meta: { ...__nuxt_page_meta$C || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexCb9_knGu; })
  },
  {
    name: "admin-login",
    path: "/admin/login",
    meta: { "middleware": "guest" },
    component: () => Promise.resolve().then(function () { return loginDqqBgQn6; })
  },
  {
    name: "courses-id",
    path: "/courses/:id()",
    meta: __nuxt_page_meta$B || {},
    component: () => Promise.resolve().then(function () { return _id_D2Wpd0Y; })
  },
  {
    name: "auth-register",
    path: "/auth/register",
    meta: { ...__nuxt_page_meta$A || {}, ...{ "middleware": "guest" } },
    component: () => Promise.resolve().then(function () { return registerCdyLrvRz; })
  },
  {
    name: "courses",
    path: "/courses",
    meta: __nuxt_page_meta$z || {},
    component: () => Promise.resolve().then(function () { return indexBjLz_g6_; })
  },
  {
    name: "articles",
    path: "/articles",
    meta: __nuxt_page_meta$y || {},
    component: () => Promise.resolve().then(function () { return indexCLWrykF8; })
  },
  {
    name: "articles-slug",
    path: "/articles/:slug()",
    meta: __nuxt_page_meta$x || {},
    component: () => Promise.resolve().then(function () { return _slug_CfMQhSJZ; })
  },
  {
    name: "payment-history",
    path: "/payment-history",
    meta: { ...__nuxt_page_meta$w || {}, ...{ "middleware": "auth" } },
    component: () => Promise.resolve().then(function () { return paymentHistoryBDqgnPfV; })
  },
  {
    name: "admin-chat",
    path: "/admin/chat",
    meta: { ...__nuxt_page_meta$v || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return index9b65BEUu; })
  },
  {
    name: "admin-users",
    path: "/admin/users",
    meta: { ...__nuxt_page_meta$u || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexDZHCqHn_; })
  },
  {
    name: "admin-chat-roomId",
    path: "/admin/chat/:roomId()",
    meta: { ...__nuxt_page_meta$t || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return _roomId_Qi9MxOXe; })
  },
  {
    name: "admin-courses",
    path: "/admin/courses",
    meta: { ...__nuxt_page_meta$s || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexDjC_26Kt; })
  },
  {
    name: "admin-students",
    path: "/admin/students",
    meta: { ...__nuxt_page_meta$r || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexBqsX72xU; })
  },
  {
    name: "auth-forgot-password",
    path: "/auth/forgot-password",
    meta: __nuxt_page_meta$q || {},
    component: () => Promise.resolve().then(function () { return forgotPasswordD78DQuHr; })
  },
  {
    name: "admin-content-pages-new",
    path: "/admin/content/pages/new",
    meta: { ...__nuxt_page_meta$p || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return newFSBUYZ_J; })
  },
  {
    name: "admin-courses-id-edit",
    path: "/admin/courses/:id()/edit",
    meta: { ...__nuxt_page_meta$o || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return editKCC45fLa; })
  },
  {
    name: "admin-enrollments",
    path: "/admin/enrollments",
    meta: { ...__nuxt_page_meta$n || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexD7Kkgqct; })
  },
  {
    name: "admin-courses-id",
    path: "/admin/courses/:id()",
    meta: { ...__nuxt_page_meta$m || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexFJv__duR; })
  },
  {
    name: "admin-students-id-edit",
    path: "/admin/students/:id()/edit",
    meta: { ...__nuxt_page_meta$l || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return editC6V17F6j; })
  },
  {
    name: "auth-callback-provider",
    path: "/auth/callback/:provider()",
    meta: __nuxt_page_meta$k || {},
    component: () => Promise.resolve().then(function () { return _provider_KjhVxuSc; })
  },
  {
    name: "admin-content-pages",
    path: "/admin/content/pages",
    meta: { ...__nuxt_page_meta$j || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexCSgfzyoj; })
  },
  {
    name: "admin-students-id",
    path: "/admin/students/:id()",
    meta: { ...__nuxt_page_meta$i || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexCScfA6Bq; })
  },
  {
    name: "admin-tutor-courses",
    path: "/admin/tutor/courses",
    meta: { ...__nuxt_page_meta$h || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexD0CwM0km; })
  },
  {
    name: "admin-tutor-students-id",
    path: "/admin/tutor/students/:id()",
    meta: { ...__nuxt_page_meta$g || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return _id_BkoAM4Py; })
  },
  {
    name: "admin-settings-email",
    path: "/admin/settings/email",
    meta: { ...__nuxt_page_meta$f || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexBfoDd_bx; })
  },
  {
    name: "admin-settings-roles",
    path: "/admin/settings/roles",
    meta: { ...__nuxt_page_meta$e || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexCvk7ldB7; })
  },
  {
    name: "admin-settings-users",
    path: "/admin/settings/users",
    meta: { ...__nuxt_page_meta$d || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexC6_laMk5; })
  },
  {
    name: "admin-tutor-schedule",
    path: "/admin/tutor/schedule",
    meta: { ...__nuxt_page_meta$c || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexXfjEsN76; })
  },
  {
    name: "admin-tutor-students",
    path: "/admin/tutor/students",
    meta: { ...__nuxt_page_meta$b || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexCfAkTeA8; })
  },
  {
    name: "admin-enrollments-id-edit",
    path: "/admin/enrollments/:id()/edit",
    meta: { ...__nuxt_page_meta$a || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return editT7KjozcG; })
  },
  {
    name: "admin-settings-system",
    path: "/admin/settings/system",
    meta: { ...__nuxt_page_meta$9 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexDgxVJ48; })
  },
  {
    name: "admin-content-articles",
    path: "/admin/content/articles",
    meta: { ...__nuxt_page_meta$8 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexIrFooeij; })
  },
  {
    name: "admin-enrollments-id",
    path: "/admin/enrollments/:id()",
    meta: { ...__nuxt_page_meta$7 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexDkMwtOCR; })
  },
  {
    name: "admin-content-pages-id-edit",
    path: "/admin/content/pages/:id()/edit",
    meta: { ...__nuxt_page_meta$6 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return editDnflIVDD; })
  },
  {
    name: "admin-settings-branches",
    path: "/admin/settings/branches",
    meta: { ...__nuxt_page_meta$5 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexCvVx2A2E; })
  },
  {
    name: "admin-settings-subjects",
    path: "/admin/settings/subjects",
    meta: { ...__nuxt_page_meta$4 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexDVcRUuY6; })
  },
  {
    name: "admin-settings-inclusions",
    path: "/admin/settings/inclusions",
    meta: { ...__nuxt_page_meta$3 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexDh96TKdI; })
  },
  {
    name: "admin-content-testimonials",
    path: "/admin/content/testimonials",
    meta: { ...__nuxt_page_meta$2 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexFkEPeqsA; })
  },
  {
    name: "admin-settings-grade-levels",
    path: "/admin/settings/grade-levels",
    meta: { ...__nuxt_page_meta$1 || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return indexDXtBDEsv; })
  },
  {
    name: "admin-settings-payment-methods",
    path: "/admin/settings/payment-methods",
    meta: { ...__nuxt_page_meta || {}, ...{ "middleware": "admin" } },
    component: () => Promise.resolve().then(function () { return index6MOfGLUy; })
  },
  {
    name: "admin-settings-email-components-SMTPTab",
    path: "/admin/settings/email/components/SMTPTab",
    component: () => Promise.resolve().then(function () { return SMTPTabBmssJ9_; })
  },
  {
    name: "admin-settings-system-components-DisplayTab",
    path: "/admin/settings/system/components/DisplayTab",
    component: () => Promise.resolve().then(function () { return DisplayTabCsMJSnCo; })
  },
  {
    name: "admin-settings-system-components-GeneralTab",
    path: "/admin/settings/system/components/GeneralTab",
    component: () => Promise.resolve().then(function () { return GeneralTabCHRudM28; })
  },
  {
    name: "admin-settings-email-components-TemplatesTab",
    path: "/admin/settings/email/components/TemplatesTab",
    component: () => Promise.resolve().then(function () { return TemplatesTabBpOw2Zp; })
  },
  {
    name: "admin-settings-system-components-LanguageTab",
    path: "/admin/settings/system/components/LanguageTab",
    component: () => Promise.resolve().then(function () { return LanguageTabDbPMqoWD; })
  },
  {
    name: "admin-settings-system-components-SecurityTab",
    path: "/admin/settings/system/components/SecurityTab",
    component: () => Promise.resolve().then(function () { return SecurityTabDDNotXn0; })
  },
  {
    name: "admin-settings-system-components-TimezoneTab",
    path: "/admin/settings/system/components/TimezoneTab",
    component: () => Promise.resolve().then(function () { return TimezoneTabDw893pUd; })
  },
  {
    name: "admin-settings-email-components-TemplateModal",
    path: "/admin/settings/email/components/TemplateModal",
    component: () => Promise.resolve().then(function () { return TemplateModalGRTNwPnN; })
  },
  {
    name: "admin-settings-system-components-FileUploadTab",
    path: "/admin/settings/system/components/FileUploadTab",
    component: () => Promise.resolve().then(function () { return FileUploadTabCW3cNCWa; })
  },
  {
    name: "admin-settings-system-components-MaintenanceTab",
    path: "/admin/settings/system/components/MaintenanceTab",
    component: () => Promise.resolve().then(function () { return MaintenanceTabDm9kgHWA; })
  },
  {
    name: "admin-settings-system-components-NotificationTab",
    path: "/admin/settings/system/components/NotificationTab",
    component: () => Promise.resolve().then(function () { return NotificationTabCXea2PWy; })
  },
  {
    name: "admin-settings-payment-methods-components-BankAccountModal",
    path: "/admin/settings/payment-methods/components/BankAccountModal",
    component: () => Promise.resolve().then(function () { return BankAccountModalTDo4EpJK; })
  },
  {
    name: "admin-settings-payment-methods-components-PaymentMethodModal",
    path: "/admin/settings/payment-methods/components/PaymentMethodModal",
    component: () => Promise.resolve().then(function () { return PaymentMethodModalBnfeOhC_; })
  },
  {
    name: "admin-settings-payment-methods-components-BankAccountsSection",
    path: "/admin/settings/payment-methods/components/BankAccountsSection",
    component: () => Promise.resolve().then(function () { return BankAccountsSectionDvbJydEj; })
  },
  {
    name: "admin-settings-payment-methods-components-gateway-KsherConfig",
    path: "/admin/settings/payment-methods/components/gateway/KsherConfig",
    component: () => Promise.resolve().then(function () { return KsherConfigCzUwN_np; })
  },
  {
    name: "admin-settings-payment-methods-components-gateway-StripeConfig",
    path: "/admin/settings/payment-methods/components/gateway/StripeConfig",
    component: () => Promise.resolve().then(function () { return StripeConfig8Ff2Qb4D; })
  },
  {
    name: "admin-settings-payment-methods-components-GatewayConfigSection",
    path: "/admin/settings/payment-methods/components/GatewayConfigSection",
    component: () => Promise.resolve().then(function () { return GatewayConfigSectionDQwVCOTd; })
  },
  {
    name: "admin-settings-payment-methods-components-PaymentMethodBasicInfo",
    path: "/admin/settings/payment-methods/components/PaymentMethodBasicInfo",
    component: () => Promise.resolve().then(function () { return PaymentMethodBasicInfoDluNVwrX; })
  },
  {
    name: "admin-settings-payment-methods-components-PaymentMethodDetailModal",
    path: "/admin/settings/payment-methods/components/PaymentMethodDetailModal",
    component: () => Promise.resolve().then(function () { return PaymentMethodDetailModalBI2Ymto6; })
  },
  {
    name: "admin-settings-payment-methods-components-gateway-GenericGatewayConfig",
    path: "/admin/settings/payment-methods/components/gateway/GenericGatewayConfig",
    component: () => Promise.resolve().then(function () { return GenericGatewayConfigCywwJcQF; })
  }
];
const _wrapInTransition = (props, children) => {
  return { default: () => children.default?.() };
};
const ROUTE_KEY_PARENTHESES_RE = /(:\w+)\([^)]+\)/g;
const ROUTE_KEY_SYMBOLS_RE = /(:\w+)[?+*]/g;
const ROUTE_KEY_NORMAL_RE = /:\w+/g;
function generateRouteKey(route) {
  const source = route?.meta.key ?? route.path.replace(ROUTE_KEY_PARENTHESES_RE, "$1").replace(ROUTE_KEY_SYMBOLS_RE, "$1").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || "");
  return typeof source === "function" ? source(route) : source;
}
function isChangingPage(to, from) {
  if (to === from || from === START_LOCATION) {
    return false;
  }
  if (generateRouteKey(to) !== generateRouteKey(from)) {
    return true;
  }
  const areComponentsSame = to.matched.every(
    (comp, index) => comp.components && comp.components.default === from.matched[index]?.components?.default
  );
  if (areComponentsSame) {
    return false;
  }
  return true;
}
const routerOptions0 = {
  scrollBehavior(to, from, savedPosition) {
    const nuxtApp = useNuxtApp();
    const hashScrollBehaviour = useRouter().options?.scrollBehaviorType ?? "auto";
    if (to.path.replace(/\/$/, "") === from.path.replace(/\/$/, "")) {
      if (from.hash && !to.hash) {
        return { left: 0, top: 0 };
      }
      if (to.hash) {
        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior: hashScrollBehaviour };
      }
      return false;
    }
    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === "function" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;
    if (routeAllowsScrollToTop === false) {
      return false;
    }
    const hookToWait = nuxtApp._runningTransition ? "page:transition:finish" : "page:loading:end";
    return new Promise((resolve) => {
      if (from === START_LOCATION) {
        resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour));
        return;
      }
      nuxtApp.hooks.hookOnce(hookToWait, () => {
        requestAnimationFrame(() => resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour)));
      });
    });
  }
};
function _getHashElementScrollMarginTop(selector) {
  try {
    const elem = (void 0).querySelector(selector);
    if (elem) {
      return (Number.parseFloat(getComputedStyle(elem).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle((void 0).documentElement).scrollPaddingTop) || 0);
    }
  } catch {
  }
  return 0;
}
function _calculatePosition(to, from, savedPosition, defaultHashScrollBehaviour) {
  if (savedPosition) {
    return savedPosition;
  }
  const isPageNavigation = isChangingPage(to, from);
  if (to.hash) {
    return {
      el: to.hash,
      top: _getHashElementScrollMarginTop(to.hash),
      behavior: isPageNavigation ? defaultHashScrollBehaviour : "instant"
    };
  }
  return {
    left: 0,
    top: 0
  };
}
const configRouterOptions = {
  hashMode: false,
  scrollBehaviorType: "auto"
};
const routerOptions = {
  ...configRouterOptions,
  ...routerOptions0
};
const validate = /* @__PURE__ */ defineNuxtRouteMiddleware(async (to, from) => {
  let __temp, __restore;
  if (!to.meta?.validate) {
    return;
  }
  const result = ([__temp, __restore] = executeAsync(() => Promise.resolve(to.meta.validate(to))), __temp = await __temp, __restore(), __temp);
  if (result === true) {
    return;
  }
  const error = createError({
    fatal: false,
    statusCode: result && result.statusCode || 404,
    statusMessage: result && result.statusMessage || `Page Not Found: ${to.fullPath}`,
    data: {
      path: to.fullPath
    }
  });
  return error;
});
const manifest_45route_45rule = /* @__PURE__ */ defineNuxtRouteMiddleware(async (to) => {
  {
    return;
  }
});
const globalMiddleware = [
  validate,
  manifest_45route_45rule
];
const namedMiddleware = {
  admin: () => Promise.resolve().then(function () { return adminCTEb7jtN; }),
  auth: () => Promise.resolve().then(function () { return authDbjuH_U_; }),
  guest: () => Promise.resolve().then(function () { return guestCZSH4cDN; })
};
const plugin$1 = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:router",
  enforce: "pre",
  async setup(nuxtApp) {
    let __temp, __restore;
    let routerBase = (/* @__PURE__ */ useRuntimeConfig()).app.baseURL;
    const history = routerOptions.history?.(routerBase) ?? createMemoryHistory(routerBase);
    const routes = routerOptions.routes ? ([__temp, __restore] = executeAsync(() => routerOptions.routes(_routes)), __temp = await __temp, __restore(), __temp) ?? _routes : _routes;
    let startPosition;
    const router = createRouter$2({
      ...routerOptions,
      scrollBehavior: (to, from, savedPosition) => {
        if (from === START_LOCATION) {
          startPosition = savedPosition;
          return;
        }
        if (routerOptions.scrollBehavior) {
          router.options.scrollBehavior = routerOptions.scrollBehavior;
          if ("scrollRestoration" in (void 0).history) {
            const unsub = router.beforeEach(() => {
              unsub();
              (void 0).history.scrollRestoration = "manual";
            });
          }
          return routerOptions.scrollBehavior(to, START_LOCATION, startPosition || savedPosition);
        }
      },
      history,
      routes
    });
    nuxtApp.vueApp.use(router);
    const previousRoute = shallowRef(router.currentRoute.value);
    router.afterEach((_to, from) => {
      previousRoute.value = from;
    });
    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, "previousRoute", {
      get: () => previousRoute.value
    });
    const initialURL = nuxtApp.ssrContext.url;
    const _route = shallowRef(router.currentRoute.value);
    const syncCurrentRoute = () => {
      _route.value = router.currentRoute.value;
    };
    router.afterEach((to, from) => {
      if (to.matched.at(-1)?.components?.default === from.matched.at(-1)?.components?.default) {
        syncCurrentRoute();
      }
    });
    const route = { sync: syncCurrentRoute };
    for (const key in _route.value) {
      Object.defineProperty(route, key, {
        get: () => _route.value[key],
        enumerable: true
      });
    }
    nuxtApp._route = shallowReactive(route);
    nuxtApp._middleware ||= {
      global: [],
      named: {}
    };
    if (!nuxtApp.ssrContext?.islandContext) {
      router.afterEach(async (to, _from, failure) => {
        delete nuxtApp._processingMiddleware;
        if (failure) {
          await nuxtApp.callHook("page:loading:end");
        }
        if (failure?.type === 4) {
          return;
        }
        if (to.redirectedFrom && to.fullPath !== initialURL) {
          await nuxtApp.runWithContext(() => navigateTo(to.fullPath || "/"));
        }
      });
    }
    try {
      if (true) {
        ;
        [__temp, __restore] = executeAsync(() => router.push(initialURL)), await __temp, __restore();
        ;
      }
      ;
      [__temp, __restore] = executeAsync(() => router.isReady()), await __temp, __restore();
      ;
    } catch (error2) {
      [__temp, __restore] = executeAsync(() => nuxtApp.runWithContext(() => showError(error2))), await __temp, __restore();
    }
    const resolvedInitialRoute = router.currentRoute.value;
    syncCurrentRoute();
    if (nuxtApp.ssrContext?.islandContext) {
      return { provide: { router } };
    }
    const initialLayout = nuxtApp.payload.state._layout;
    router.beforeEach(async (to, from) => {
      await nuxtApp.callHook("page:loading:start");
      to.meta = reactive(to.meta);
      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {
        to.meta.layout = initialLayout;
      }
      nuxtApp._processingMiddleware = true;
      if (!nuxtApp.ssrContext?.islandContext) {
        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);
        for (const component of to.matched) {
          const componentMiddleware = component.meta.middleware;
          if (!componentMiddleware) {
            continue;
          }
          for (const entry2 of toArray(componentMiddleware)) {
            middlewareEntries.add(entry2);
          }
        }
        {
          const routeRules = await nuxtApp.runWithContext(() => getRouteRules({ path: to.path }));
          if (routeRules.appMiddleware) {
            for (const key in routeRules.appMiddleware) {
              if (routeRules.appMiddleware[key]) {
                middlewareEntries.add(key);
              } else {
                middlewareEntries.delete(key);
              }
            }
          }
        }
        for (const entry2 of middlewareEntries) {
          const middleware = typeof entry2 === "string" ? nuxtApp._middleware.named[entry2] || await namedMiddleware[entry2]?.().then((r) => r.default || r) : entry2;
          if (!middleware) {
            throw new Error(`Unknown route middleware: '${entry2}'.`);
          }
          try {
            if (false) ;
            const result = await nuxtApp.runWithContext(() => middleware(to, from));
            if (true) {
              if (result === false || result instanceof Error) {
                const error2 = result || createError({
                  statusCode: 404,
                  statusMessage: `Page Not Found: ${initialURL}`
                });
                await nuxtApp.runWithContext(() => showError(error2));
                return false;
              }
            }
            if (result === true) {
              continue;
            }
            if (result === false) {
              return result;
            }
            if (result) {
              if (isNuxtError(result) && result.fatal) {
                await nuxtApp.runWithContext(() => showError(result));
              }
              return result;
            }
          } catch (err) {
            const error2 = createError(err);
            if (error2.fatal) {
              await nuxtApp.runWithContext(() => showError(error2));
            }
            return error2;
          }
        }
      }
    });
    router.onError(async () => {
      delete nuxtApp._processingMiddleware;
      await nuxtApp.callHook("page:loading:end");
    });
    router.afterEach((to) => {
      if (to.matched.length === 0) {
        return nuxtApp.runWithContext(() => showError(createError({
          statusCode: 404,
          fatal: false,
          statusMessage: `Page not found: ${to.fullPath}`,
          data: {
            path: to.fullPath
          }
        })));
      }
    });
    nuxtApp.hooks.hookOnce("app:created", async () => {
      try {
        if ("name" in resolvedInitialRoute) {
          resolvedInitialRoute.name = void 0;
        }
        await router.replace({
          ...resolvedInitialRoute,
          force: true
        });
        router.options.scrollBehavior = routerOptions.scrollBehavior;
      } catch (error2) {
        await nuxtApp.runWithContext(() => showError(error2));
      }
    });
    return { provide: { router } };
  }
});
function definePayloadReducer(name, reduce) {
  {
    useNuxtApp().ssrContext._payloadReducers[name] = reduce;
  }
}
const reducers = [
  ["NuxtError", (data) => isNuxtError(data) && data.toJSON()],
  ["EmptyShallowRef", (data) => isRef(data) && isShallow(data) && !data.value && (typeof data.value === "bigint" ? "0n" : JSON.stringify(data.value) || "_")],
  ["EmptyRef", (data) => isRef(data) && !data.value && (typeof data.value === "bigint" ? "0n" : JSON.stringify(data.value) || "_")],
  ["ShallowRef", (data) => isRef(data) && isShallow(data) && data.value],
  ["ShallowReactive", (data) => isReactive(data) && isShallow(data) && toRaw(data)],
  ["Ref", (data) => isRef(data) && data.value],
  ["Reactive", (data) => isReactive(data) && toRaw(data)]
];
const revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:revive-payload:server",
  setup() {
    for (const [reducer, fn] of reducers) {
      definePayloadReducer(reducer, fn);
    }
  }
});
const piniaSymbol = (
  /* istanbul ignore next */
  /* @__PURE__ */ Symbol()
);
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      {
        pinia._a = app;
        app.provide(piniaSymbol, pinia);
        app.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin2) => _p.push(plugin2));
        toBeInstalled = [];
      }
    },
    use(plugin2) {
      if (!this._a && true) {
        toBeInstalled.push(plugin2);
      } else {
        _p.push(plugin2);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia;
}
defineComponent({
  name: "ServerPlaceholder",
  render() {
    return createElementBlock("div");
  }
});
const clientOnlySymbol = /* @__PURE__ */ Symbol.for("nuxt:client-only");
defineComponent({
  name: "ClientOnly",
  inheritAttrs: false,
  props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
  ...false,
  setup(props, { slots, attrs }) {
    const mounted = shallowRef(false);
    const vm = getCurrentInstance();
    if (vm) {
      vm._nuxtClientOnly = true;
    }
    provide(clientOnlySymbol, true);
    return () => {
      if (mounted.value) {
        const vnodes = slots.default?.();
        if (vnodes && vnodes.length === 1) {
          return [cloneVNode(vnodes[0], attrs)];
        }
        return vnodes;
      }
      const slot = slots.fallback || slots.placeholder;
      if (slot) {
        return h$1(slot);
      }
      const fallbackStr = props.fallback || props.placeholder || "";
      const fallbackTag = props.fallbackTag || props.placeholderTag || "span";
      return createElementBlock(fallbackTag, attrs, fallbackStr);
    };
  }
});
const useStateKeyPrefix = "$s";
function useState(...args) {
  const autoKey = typeof args[args.length - 1] === "string" ? args.pop() : void 0;
  if (typeof args[0] !== "string") {
    args.unshift(autoKey);
  }
  const [_key, init] = args;
  if (!_key || typeof _key !== "string") {
    throw new TypeError("[nuxt] [useState] key must be a string: " + _key);
  }
  if (init !== void 0 && typeof init !== "function") {
    throw new Error("[nuxt] [useState] init must be a function: " + init);
  }
  const key = useStateKeyPrefix + _key;
  const nuxtApp = useNuxtApp();
  const state = toRef(nuxtApp.payload.state, key);
  if (state.value === void 0 && init) {
    const initialValue = init();
    if (isRef(initialValue)) {
      nuxtApp.payload.state[key] = initialValue;
      return initialValue;
    }
    state.value = initialValue;
  }
  return state;
}
function useRequestEvent(nuxtApp) {
  nuxtApp ||= useNuxtApp();
  return nuxtApp.ssrContext?.event;
}
const CookieDefaults = {
  path: "/",
  watch: true,
  decode: (val) => destr(decodeURIComponent(val)),
  encode: (val) => encodeURIComponent(typeof val === "string" ? val : JSON.stringify(val))
};
function useCookie(name, _opts) {
  const opts = { ...CookieDefaults, ..._opts };
  opts.filter ??= (key) => key === name;
  const cookies = readRawCookies(opts) || {};
  let delay;
  if (opts.maxAge !== void 0) {
    delay = opts.maxAge * 1e3;
  } else if (opts.expires) {
    delay = opts.expires.getTime() - Date.now();
  }
  const hasExpired = delay !== void 0 && delay <= 0;
  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());
  const cookie = ref(cookieValue);
  {
    const nuxtApp = useNuxtApp();
    const writeFinalCookieValue = () => {
      if (opts.readonly || isEqual(cookie.value, cookies[name])) {
        return;
      }
      nuxtApp._cookies ||= {};
      if (name in nuxtApp._cookies) {
        if (isEqual(cookie.value, nuxtApp._cookies[name])) {
          return;
        }
      }
      nuxtApp._cookies[name] = cookie.value;
      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);
    };
    const unhook = nuxtApp.hooks.hookOnce("app:rendered", writeFinalCookieValue);
    nuxtApp.hooks.hookOnce("app:error", () => {
      unhook();
      return writeFinalCookieValue();
    });
  }
  return cookie;
}
function readRawCookies(opts = {}) {
  {
    return parse(getRequestHeader(useRequestEvent(), "cookie") || "", opts);
  }
}
function writeServerCookie(event, name, value, opts = {}) {
  if (event) {
    if (value !== null && value !== void 0) {
      return setCookie(event, name, value, opts);
    }
    if (getCookie(event, name) !== void 0) {
      return deleteCookie(event, name, opts);
    }
  }
}
const plugin = /* @__PURE__ */ defineNuxtPlugin({
  name: "pinia",
  setup(nuxtApp) {
    const pinia = createPinia();
    nuxtApp.vueApp.use(pinia);
    {
      nuxtApp.payload.pinia = pinia.state.value;
    }
    return {
      provide: {
        pinia
      }
    };
  }
});
const components_plugin_4kY4pyzJIYX99vmMAAIorFf3CnAaptHitJgf7JxiED8 = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:global-components"
});
const plugins = [
  unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU,
  plugin$1,
  revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms,
  plugin,
  components_plugin_4kY4pyzJIYX99vmMAAIorFf3CnAaptHitJgf7JxiED8
];
const layouts = {
  admin: defineAsyncComponent(() => Promise.resolve().then(function () { return adminC7VZ2CY_; }).then((m) => m.default || m)),
  chat: defineAsyncComponent(() => Promise.resolve().then(function () { return chatDEZCJvs0; }).then((m) => m.default || m)),
  default: defineAsyncComponent(() => Promise.resolve().then(function () { return defaultDK77MwgI; }).then((m) => m.default || m)),
  homepage: defineAsyncComponent(() => Promise.resolve().then(function () { return homepageBUzDIIY1; }).then((m) => m.default || m)),
  student: defineAsyncComponent(() => Promise.resolve().then(function () { return studentCM_re3zP; }).then((m) => m.default || m))
};
const LayoutLoader = defineComponent({
  name: "LayoutLoader",
  inheritAttrs: false,
  props: {
    name: String,
    layoutProps: Object
  },
  setup(props, context) {
    return () => h$1(layouts[props.name], props.layoutProps, context.slots);
  }
});
const nuxtLayoutProps = {
  name: {
    type: [String, Boolean, Object],
    default: null
  },
  fallback: {
    type: [String, Object],
    default: null
  }
};
const __nuxt_component_0$c = defineComponent({
  name: "NuxtLayout",
  inheritAttrs: false,
  props: nuxtLayoutProps,
  setup(props, context) {
    const nuxtApp = useNuxtApp();
    const injectedRoute = inject(PageRouteSymbol);
    const shouldUseEagerRoute = !injectedRoute || injectedRoute === useRoute();
    const route = shouldUseEagerRoute ? useRoute$1() : injectedRoute;
    const layout = computed(() => {
      let layout2 = unref(props.name) ?? route?.meta.layout ?? "default";
      if (layout2 && !(layout2 in layouts)) {
        if (props.fallback) {
          layout2 = unref(props.fallback);
        }
      }
      return layout2;
    });
    const layoutRef = shallowRef();
    context.expose({ layoutRef });
    const done = nuxtApp.deferHydration();
    let lastLayout;
    return () => {
      const hasLayout = layout.value && layout.value in layouts;
      const transitionProps = route?.meta.layoutTransition ?? appLayoutTransition;
      const previouslyRenderedLayout = lastLayout;
      lastLayout = layout.value;
      return _wrapInTransition(hasLayout && transitionProps, {
        default: () => h$1(Suspense, { suspensible: true, onResolve: () => {
          nextTick(done);
        } }, {
          default: () => h$1(
            LayoutProvider,
            {
              layoutProps: mergeProps(context.attrs, { ref: layoutRef }),
              key: layout.value || void 0,
              name: layout.value,
              shouldProvide: !props.name,
              isRenderingNewLayout: (name) => {
                return name !== previouslyRenderedLayout && name === layout.value;
              },
              hasTransition: !!transitionProps
            },
            context.slots
          )
        })
      }).default();
    };
  }
});
const LayoutProvider = defineComponent({
  name: "NuxtLayoutProvider",
  inheritAttrs: false,
  props: {
    name: {
      type: [String, Boolean]
    },
    layoutProps: {
      type: Object
    },
    hasTransition: {
      type: Boolean
    },
    shouldProvide: {
      type: Boolean
    },
    isRenderingNewLayout: {
      type: Function,
      required: true
    }
  },
  setup(props, context) {
    const name = props.name;
    if (props.shouldProvide) {
      provide(LayoutMetaSymbol, {
        isCurrent: (route) => name === (route.meta.layout ?? "default")
      });
    }
    const injectedRoute = inject(PageRouteSymbol);
    const isNotWithinNuxtPage = injectedRoute && injectedRoute === useRoute();
    if (isNotWithinNuxtPage) {
      const vueRouterRoute = useRoute$1();
      const reactiveChildRoute = {};
      for (const _key in vueRouterRoute) {
        const key = _key;
        Object.defineProperty(reactiveChildRoute, key, {
          enumerable: true,
          get: () => {
            return props.isRenderingNewLayout(props.name) ? vueRouterRoute[key] : injectedRoute[key];
          }
        });
      }
      provide(PageRouteSymbol, shallowReactive(reactiveChildRoute));
    }
    return () => {
      if (!name || typeof name === "string" && !(name in layouts)) {
        return context.slots.default?.();
      }
      return h$1(
        LayoutLoader,
        { key: name, layoutProps: props.layoutProps, name },
        context.slots
      );
    };
  }
});
const defineRouteProvider = (name = "RouteProvider") => defineComponent({
  name,
  props: {
    route: {
      type: Object,
      required: true
    },
    vnode: Object,
    vnodeRef: Object,
    renderKey: String,
    trackRootNodes: Boolean
  },
  setup(props) {
    const previousKey = props.renderKey;
    const previousRoute = props.route;
    const route = {};
    for (const key in props.route) {
      Object.defineProperty(route, key, {
        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key],
        enumerable: true
      });
    }
    provide(PageRouteSymbol, shallowReactive(route));
    return () => {
      if (!props.vnode) {
        return props.vnode;
      }
      return h$1(props.vnode, { ref: props.vnodeRef });
    };
  }
});
const RouteProvider = defineRouteProvider();
const __nuxt_component_1$3 = defineComponent({
  name: "NuxtPage",
  inheritAttrs: false,
  props: {
    name: {
      type: String
    },
    transition: {
      type: [Boolean, Object],
      default: void 0
    },
    keepalive: {
      type: [Boolean, Object],
      default: void 0
    },
    route: {
      type: Object
    },
    pageKey: {
      type: [Function, String],
      default: null
    }
  },
  setup(props, { attrs, slots, expose }) {
    const nuxtApp = useNuxtApp();
    const pageRef = ref();
    inject(PageRouteSymbol, null);
    expose({ pageRef });
    inject(LayoutMetaSymbol, null);
    nuxtApp.deferHydration();
    return () => {
      return h$1(RouterView, { name: props.name, route: props.route, ...attrs }, {
        default: (routeProps) => {
          return h$1(Suspense, { suspensible: true }, {
            default() {
              return h$1(RouteProvider, {
                vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,
                route: routeProps.route,
                vnodeRef: pageRef
              });
            }
          });
        }
      });
    };
  }
});
function normalizeSlot(slot, data) {
  const slotContent = slot(data);
  return slotContent.length === 1 ? h$1(slotContent[0]) : h$1(Fragment, void 0, slotContent);
}
const _sfc_main$4$2 = /* @__PURE__ */ defineComponent({
  __name: "ConfirmModal",
  __ssrInlineRender: true,
  props: {
    isOpen: { type: Boolean },
    title: { default: "" },
    message: {},
    confirmText: { default: "" },
    cancelText: { default: "" },
    type: { default: "info" },
    showInput: { type: Boolean, default: false },
    inputLabel: { default: "" },
    inputPlaceholder: { default: "" }
  },
  emits: ["confirm", "cancel"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const inputValue = ref("");
    const iconComponent = computed(() => {
      const icons = {
        danger: ExclamationCircleIcon,
        warning: ExclamationTriangleIcon,
        info: InformationCircleIcon
      };
      return icons[props.type];
    });
    const iconBgClass = computed(() => {
      const classes = {
        danger: "bg-red-100",
        warning: "bg-yellow-100",
        info: "bg-blue-100"
      };
      return classes[props.type];
    });
    const iconClass = computed(() => {
      const classes = {
        danger: "text-red-600",
        warning: "text-yellow-600",
        info: "text-blue-600"
      };
      return classes[props.type];
    });
    const confirmButtonClass = computed(() => {
      const classes = {
        danger: "bg-red-600 hover:bg-red-700",
        warning: "bg-yellow-600 hover:bg-yellow-700",
        info: "bg-blue-600 hover:bg-blue-700"
      };
      return classes[props.type];
    });
    watch$1(() => props.isOpen, (newVal) => {
      if (newVal && props.showInput) {
        inputValue.value = "";
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderTeleport(_push, (_push2) => {
        if (__props.isOpen) {
          _push2(`<div class="fixed inset-0 z-[10000] flex items-center justify-center p-4" data-v-701507a9><div class="absolute inset-0 bg-black/50 backdrop-blur-sm" data-v-701507a9></div><div class="relative bg-white rounded-lg shadow-xl max-w-md w-full p-6 z-10" data-v-701507a9><div class="${ssrRenderClass([unref(iconBgClass), "flex items-center justify-center w-12 h-12 mx-auto mb-4 rounded-full"])}" data-v-701507a9>`);
          ssrRenderVNode(_push2, createVNode(resolveDynamicComponent(unref(iconComponent)), {
            class: ["w-6 h-6", unref(iconClass)]
          }, null), _parent);
          _push2(`</div><h3 class="text-lg font-semibold text-gray-900 text-center mb-2" data-v-701507a9>${ssrInterpolate(__props.title)}</h3><p class="text-sm text-gray-600 text-center mb-6 whitespace-pre-line" data-v-701507a9>${ssrInterpolate(__props.message)}</p>`);
          if (__props.showInput) {
            _push2(`<div class="mb-6" data-v-701507a9><label class="block text-sm font-medium text-gray-700 mb-2" data-v-701507a9>${ssrInterpolate(__props.inputLabel)}</label><input${ssrRenderAttr("value", unref(inputValue))} type="text" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"${ssrRenderAttr("placeholder", __props.inputPlaceholder)} data-v-701507a9></div>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`<div class="flex gap-3" data-v-701507a9><button class="flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" data-v-701507a9>${ssrInterpolate(__props.cancelText)}</button><button class="${ssrRenderClass([unref(confirmButtonClass), "flex-1 px-4 py-2 text-sm font-medium text-white rounded-lg transition-colors"])}" data-v-701507a9>${ssrInterpolate(__props.confirmText)}</button></div></div></div>`);
        } else {
          _push2(`<!---->`);
        }
      }, "body", false, _parent);
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_setup$4$2 = _sfc_main$4$2.setup;
_sfc_main$4$2.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ConfirmModal.vue");
  return _sfc_setup$4$2 ? _sfc_setup$4$2(props, ctx) : void 0;
};
const __nuxt_component_2$1 = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$4$2, [["__scopeId", "data-v-701507a9"]]), { __name: "ConfirmModal" });
const _sfc_main$3$3 = /* @__PURE__ */ defineComponent({
  __name: "TokenExpirationDialog",
  __ssrInlineRender: true,
  props: {
    isOpen: { type: Boolean },
    message: {}
  },
  emits: ["close", "login"],
  setup(__props, { emit: __emit }) {
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderTeleport(_push, (_push2) => {
        if (__props.isOpen) {
          _push2(`<div class="fixed inset-0 z-[10001] flex items-center justify-center p-4" data-v-99d8e1cf><div class="absolute inset-0 bg-black/50 backdrop-blur-sm" data-v-99d8e1cf></div><div class="relative bg-white rounded-lg shadow-xl max-w-md w-full p-6 z-10" data-v-99d8e1cf><div class="flex items-center justify-center w-12 h-12 mx-auto mb-4 rounded-full bg-yellow-100" data-v-99d8e1cf>`);
          _push2(ssrRenderComponent(unref(ExclamationTriangleIcon), { class: "w-6 h-6 text-yellow-600" }, null, _parent));
          _push2(`</div><h3 class="text-lg font-semibold text-gray-900 text-center mb-2" data-v-99d8e1cf>  </h3><p class="text-sm text-gray-600 text-center mb-6 whitespace-pre-line" data-v-99d8e1cf>${ssrInterpolate(__props.message)}</p><div class="flex gap-3" data-v-99d8e1cf><button class="flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" data-v-99d8e1cf>  </button><button class="flex-1 px-4 py-2 text-sm font-medium text-white bg-green-600 hover:bg-green-700 rounded-lg transition-colors" data-v-99d8e1cf>  </button></div></div></div>`);
        } else {
          _push2(`<!---->`);
        }
      }, "body", false, _parent);
    };
  }
});
const _sfc_setup$3$3 = _sfc_main$3$3.setup;
_sfc_main$3$3.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/TokenExpirationDialog.vue");
  return _sfc_setup$3$3 ? _sfc_setup$3$3(props, ctx) : void 0;
};
const __nuxt_component_3 = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$3$3, [["__scopeId", "data-v-99d8e1cf"]]), { __name: "TokenExpirationDialog" });
const useConfirm = () => {
  const isOpen = useState("confirmModal:isOpen", () => false);
  const options = useState("confirmModal:options", () => null);
  const resolveRef = useState("confirmModal:resolve", () => null);
  const confirm = (opts) => {
    return new Promise((resolve) => {
      const confirmOptions = typeof opts === "string" ? { message: opts } : opts;
      options.value = confirmOptions;
      isOpen.value = true;
      resolveRef.value = resolve;
    });
  };
  const handleConfirm = async (value) => {
    if (resolveRef.value) {
      if (options.value?.showInput) {
        resolveRef.value(value || "");
      } else {
        resolveRef.value(true);
      }
    }
    isOpen.value = false;
    await new Promise((resolve) => setTimeout(resolve, 300));
    options.value = null;
    resolveRef.value = null;
  };
  const handleCancel = async () => {
    if (resolveRef.value) {
      if (options.value?.showInput) {
        resolveRef.value(false);
      } else {
        resolveRef.value(false);
      }
    }
    isOpen.value = false;
    await new Promise((resolve) => setTimeout(resolve, 300));
    options.value = null;
    resolveRef.value = null;
  };
  return {
    isOpen: readonly(isOpen),
    options: readonly(options),
    confirm,
    handleConfirm,
    handleCancel
  };
};
const useAuth = () => {
  const user = useState("auth.user", () => null);
  const accessToken = useState("auth.token", () => null);
  const isAuthenticated = computed(() => !!user.value && !!accessToken.value);
  const login = async (username, password) => {
    const config = /* @__PURE__ */ useRuntimeConfig();
    const response = await $fetch(`${config.public.apiBase}/auth/login`, {
      method: "POST",
      body: { username, password }
    });
    if (response.success) {
      user.value = response.data.user;
      accessToken.value = response.data.accessToken;
      const tokenCookie = useCookie("access_token", {
        httpOnly: true,
        secure: "production" === "production",
        sameSite: "strict",
        maxAge: 2 * 60 * 60
        // 2 hours
      });
      tokenCookie.value = response.data.accessToken;
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    return response;
  };
  const logout = async () => {
    const config = /* @__PURE__ */ useRuntimeConfig();
    try {
      await $fetch(`${config.public.apiBase}/auth/logout`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken.value}`
        }
      });
    } catch (error) {
    }
    user.value = null;
    accessToken.value = null;
    const tokenCookie = useCookie("access_token");
    tokenCookie.value = null;
    await navigateTo("/");
  };
  const fetchUser = async () => {
    const config = /* @__PURE__ */ useRuntimeConfig();
    const tokenCookie = useCookie("access_token");
    if (!tokenCookie.value) {
      return null;
    }
    try {
      const response = await $fetch(`${config.public.apiBase}/auth/me`, {
        headers: {
          Authorization: `Bearer ${tokenCookie.value}`
        }
      });
      if (response.success) {
        user.value = response.data;
        accessToken.value = tokenCookie.value;
        return response.data;
      }
    } catch (error) {
      user.value = null;
      accessToken.value = null;
      tokenCookie.value = null;
    }
    return null;
  };
  const hasRole = (role) => {
    return user.value?.roles.includes(role) ?? false;
  };
  const hasAnyRole = (roles) => {
    return roles.some((role) => hasRole(role));
  };
  return {
    user: readonly(user),
    accessToken: readonly(accessToken),
    isAuthenticated,
    login,
    logout,
    fetchUser,
    hasRole,
    hasAnyRole
  };
};
const useTokenExpiration = () => {
  const showExpirationDialog = useState("tokenExpiration:showDialog", () => false);
  const expirationMessage = useState("tokenExpiration:message", () => "");
  const handleTokenExpiration = (message) => {
    expirationMessage.value = message || " \n";
    showExpirationDialog.value = true;
  };
  const closeExpirationDialog = () => {
    showExpirationDialog.value = false;
    expirationMessage.value = "";
  };
  const redirectToLogin = async () => {
    const { logout } = useAuth();
    closeExpirationDialog();
    await logout();
    await navigateTo("/auth/login");
  };
  return {
    showExpirationDialog: readonly(showExpirationDialog),
    expirationMessage: readonly(expirationMessage),
    handleTokenExpiration,
    closeExpirationDialog,
    redirectToLogin
  };
};
const _sfc_main$2$3 = /* @__PURE__ */ defineComponent({
  __name: "app",
  __ssrInlineRender: true,
  setup(__props) {
    const { isOpen: confirmIsOpen, options: confirmOptions, handleConfirm, handleCancel } = useConfirm();
    const {
      showExpirationDialog: tokenExpirationDialogOpen,
      expirationMessage: tokenExpirationMessage,
      closeExpirationDialog: closeTokenExpirationDialog,
      redirectToLogin: handleTokenExpirationLogin
    } = useTokenExpiration();
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLayout = __nuxt_component_0$c;
      const _component_NuxtPage = __nuxt_component_1$3;
      const _component_ConfirmModal = __nuxt_component_2$1;
      const _component_TokenExpirationDialog = __nuxt_component_3;
      _push(`<!--[-->`);
      _push(ssrRenderComponent(_component_NuxtLayout, null, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent(_component_NuxtPage, null, null, _parent2, _scopeId));
          } else {
            return [
              createVNode(_component_NuxtPage)
            ];
          }
        }),
        _: 1
      }, _parent));
      if (unref(confirmIsOpen) || unref(confirmOptions)) {
        _push(ssrRenderComponent(_component_ConfirmModal, {
          "is-open": unref(confirmIsOpen),
          title: unref(confirmOptions)?.title,
          message: unref(confirmOptions)?.message || "",
          "confirm-text": unref(confirmOptions)?.confirmText,
          "cancel-text": unref(confirmOptions)?.cancelText,
          type: unref(confirmOptions)?.type,
          "show-input": unref(confirmOptions)?.showInput,
          "input-label": unref(confirmOptions)?.inputLabel,
          "input-placeholder": unref(confirmOptions)?.inputPlaceholder,
          onConfirm: unref(handleConfirm),
          onCancel: unref(handleCancel)
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (unref(tokenExpirationDialogOpen) || unref(tokenExpirationMessage)) {
        _push(ssrRenderComponent(_component_TokenExpirationDialog, {
          "is-open": unref(tokenExpirationDialogOpen),
          message: unref(tokenExpirationMessage),
          onClose: unref(closeTokenExpirationDialog),
          onLogin: unref(handleTokenExpirationLogin)
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`<!--]-->`);
    };
  }
});
const _sfc_setup$2$3 = _sfc_main$2$3.setup;
_sfc_main$2$3.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("app.vue");
  return _sfc_setup$2$3 ? _sfc_setup$2$3(props, ctx) : void 0;
};
const _sfc_main$1$d = /* @__PURE__ */ defineComponent({
  __name: "error",
  __ssrInlineRender: true,
  props: {
    error: {}
  },
  setup(__props) {
    const props = __props;
    useRoute();
    useRouter();
    const getErrorTitle = () => {
      const titles = {
        404: "",
        403: "",
        401: "",
        500: ""
      };
      return titles[props.error.statusCode] || "";
    };
    const getErrorMessage = () => {
      const message = props.error.message || props.error.statusMessage || props.error.data?.message || "";
      return message.replace(/\/admin\/cour\s+e/g, "/admin/courses");
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "flex items-center justify-center min-h-screen bg-gray-50" }, _attrs))}><div class="text-center max-w-md mx-4"><h1 class="text-6xl font-bold mb-4 text-gray-800">${ssrInterpolate(__props.error.statusCode)}</h1><h2 class="text-2xl font-semibold mb-2 text-gray-700">${ssrInterpolate(getErrorTitle())}</h2><p class="text-gray-600 mb-8">${ssrInterpolate(getErrorMessage())}</p><div class="flex gap-3 justify-center"><button class="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium">  </button><button class="px-6 py-3 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors font-medium">  </button></div></div></div>`);
    };
  }
});
const _sfc_setup$1$d = _sfc_main$1$d.setup;
_sfc_main$1$d.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("error.vue");
  return _sfc_setup$1$d ? _sfc_setup$1$d(props, ctx) : void 0;
};
const _sfc_main$1g = {
  __name: "nuxt-root",
  __ssrInlineRender: true,
  setup(__props) {
    const IslandRenderer = () => null;
    const nuxtApp = useNuxtApp();
    nuxtApp.deferHydration();
    nuxtApp.ssrContext.url;
    const SingleRenderer = false;
    provide(PageRouteSymbol, useRoute());
    nuxtApp.hooks.callHookWith((hooks) => hooks.map((hook) => hook()), "vue:setup");
    const error = /* @__PURE__ */ useError();
    const abortRender = error.value && !nuxtApp.ssrContext.error;
    onErrorCaptured((err, target, info) => {
      nuxtApp.hooks.callHook("vue:error", err, target, info).catch((hookError) => console.error("[nuxt] Error in `vue:error` hook", hookError));
      {
        const p = nuxtApp.runWithContext(() => showError(err));
        onServerPrefetch(() => p);
        return false;
      }
    });
    const islandContext = nuxtApp.ssrContext.islandContext;
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderSuspense(_push, {
        default: () => {
          if (unref(abortRender)) {
            _push(`<div></div>`);
          } else if (unref(error)) {
            _push(ssrRenderComponent(unref(_sfc_main$1$d), { error: unref(error) }, null, _parent));
          } else if (unref(islandContext)) {
            _push(ssrRenderComponent(unref(IslandRenderer), { context: unref(islandContext) }, null, _parent));
          } else if (unref(SingleRenderer)) {
            ssrRenderVNode(_push, createVNode(resolveDynamicComponent(unref(SingleRenderer)), null, null), _parent);
          } else {
            _push(ssrRenderComponent(unref(_sfc_main$2$3), null, null, _parent));
          }
        },
        _: 1
      });
    };
  }
};
const _sfc_setup$1g = _sfc_main$1g.setup;
_sfc_main$1g.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/nuxt/dist/app/components/nuxt-root.vue");
  return _sfc_setup$1g ? _sfc_setup$1g(props, ctx) : void 0;
};
let entry;
{
  entry = async function createNuxtAppServer(ssrContext) {
    const vueApp = createApp$1(_sfc_main$1g);
    const nuxt = createNuxtApp({ vueApp, ssrContext });
    try {
      await applyPlugins(nuxt, plugins);
      await nuxt.hooks.callHook("app:created", vueApp);
    } catch (error) {
      await nuxt.hooks.callHook("app:error", error);
      nuxt.payload.error ||= createError(error);
    }
    if (ssrContext?._renderResponse) {
      throw new Error("skipping render");
    }
    return vueApp;
  };
}
const entry_default = (ssrContext) => entry(ssrContext);

const server = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  _: _export_sfc,
  a: useRoute,
  b: useRouter,
  c: useRuntimeConfig,
  d: useNuxtApp,
  default: entry_default,
  e: nuxtLinkDefaults,
  f: useConfirm,
  g: defineNuxtRouteMiddleware,
  h: createError,
  i: useState,
  n: navigateTo,
  r: resolveRouteObject,
  u: useAuth
}, Symbol.toStringTag, { value: 'Module' }));

const client_precomputed = ((h,j,k,m,o,q,u,x,z,A,B,C,D,E,F,G,H,I,J,K,L,N,P,Q,R,T,U,V,W,X,Y,Z,$,_,hb,jb,kb,mb,ob)=>({dependencies:{"../node_modules/nuxt/dist/app/entry.js":{scripts:{"../node_modules/nuxt/dist/app/entry.js":h={resourceType:"script",module:true,prefetch:true,preload:true,file:"CX4WDIMJ.js",name:"entry",src:"../node_modules/nuxt/dist/app/entry.js",isEntry:true,dynamicImports:["middleware/admin.ts","middleware/auth.ts","middleware/guest.ts","layouts/admin.vue","layouts/chat.vue","layouts/default.vue","layouts/homepage.vue","layouts/student.vue"],css:["entry.DLS_FDRg.css"]}},styles:{"entry.DLS_FDRg.css":j={file:"entry.DLS_FDRg.css",resourceType:"style",prefetch:true,preload:true}},preload:{"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"entry.DLS_FDRg.css":{scripts:{},styles:{},preload:{"entry.DLS_FDRg.css":j},prefetch:{}},"../shared/types/user.types.ts":{scripts:{},styles:{},preload:{"../shared/types/user.types.ts":k={resourceType:"script",module:true,prefetch:true,preload:true,file:"LiZfZJ8V.js",name:"user.types",src:"../shared/types/user.types.ts",isDynamicEntry:true}},prefetch:{}},"_0JwXLbdW.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_0JwXLbdW.js":m={resourceType:"script",module:true,prefetch:true,preload:true,file:"0JwXLbdW.js",name:"nuxt-link",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_rQp7WoB7.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_rQp7WoB7.js":o={resourceType:"script",module:true,prefetch:true,preload:true,file:"rQp7WoB7.js",name:"StripeConfig.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_Bw0amrgs.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_Bw0amrgs.js":q={resourceType:"script",module:true,prefetch:true,preload:true,file:"Bw0amrgs.js",name:"KsherConfig.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_DE9j9Y27.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_DE9j9Y27.js":u={resourceType:"script",module:true,prefetch:true,preload:true,file:"DE9j9Y27.js",name:"GenericGatewayConfig.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_8aee2ZTh.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_8aee2ZTh.js":x={resourceType:"script",module:true,prefetch:true,preload:true,file:"8aee2ZTh.js",name:"GatewayConfigSection.vue",imports:["_rQp7WoB7.js","_Bw0amrgs.js","_DE9j9Y27.js","../node_modules/nuxt/dist/app/entry.js"]},"_rQp7WoB7.js":o,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_Bw0amrgs.js":q,"_DE9j9Y27.js":u},prefetch:{"entry.DLS_FDRg.css":j}},"_CaK-Jlu2.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_CaK-Jlu2.js":z={resourceType:"script",module:true,prefetch:true,preload:true,file:"CaK-Jlu2.js",name:"PaymentMethodBasicInfo.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_BeJ1R-XH.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_BeJ1R-XH.js":A={resourceType:"script",module:true,prefetch:true,preload:true,file:"BeJ1R-XH.js",name:"BankAccountModal.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_BmYQ950h.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_BmYQ950h.js":B={resourceType:"script",module:true,prefetch:true,preload:true,file:"BmYQ950h.js",name:"BankAccountsSection.vue",imports:["_BeJ1R-XH.js","../node_modules/nuxt/dist/app/entry.js"]},"_BeJ1R-XH.js":A,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_B2mp1wD8.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_B2mp1wD8.js":C={resourceType:"script",module:true,prefetch:true,preload:true,file:"B2mp1wD8.js",name:"PaymentMethodDetailModal.vue",imports:["../node_modules/nuxt/dist/app/entry.js","_CaK-Jlu2.js","_BmYQ950h.js","_8aee2ZTh.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_CaK-Jlu2.js":z,"_BmYQ950h.js":B,"_BeJ1R-XH.js":A,"_8aee2ZTh.js":x,"_rQp7WoB7.js":o,"_Bw0amrgs.js":q,"_DE9j9Y27.js":u},prefetch:{"entry.DLS_FDRg.css":j}},"_CiM0_A9B.js":{scripts:{},styles:{},preload:{"_CiM0_A9B.js":D={resourceType:"script",module:true,prefetch:true,preload:true,file:"CiM0_A9B.js",name:"th"}},prefetch:{}},"_BALXvQ8s.js":{scripts:{},styles:{},preload:{"_BALXvQ8s.js":E={resourceType:"script",module:true,prefetch:true,preload:true,file:"BALXvQ8s.js",name:"format",imports:["_CiM0_A9B.js"]},"_CiM0_A9B.js":D},prefetch:{}},"_BFsmL2mK.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_BFsmL2mK.js":F={resourceType:"script",module:true,prefetch:true,preload:true,file:"BFsmL2mK.js",name:"SecurityTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_BdJkXebB.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_BdJkXebB.js":G={resourceType:"script",module:true,prefetch:true,preload:true,file:"BdJkXebB.js",name:"AddressSelect",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_DbIPe0gX.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_DbIPe0gX.js":H={resourceType:"script",module:true,prefetch:true,preload:true,file:"DbIPe0gX.js",name:"TemplateModal.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_C-BNIxyI.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_C-BNIxyI.js":I={resourceType:"script",module:true,prefetch:true,preload:true,file:"C-BNIxyI.js",name:"TemplatesTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js","_DbIPe0gX.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_DbIPe0gX.js":H},prefetch:{"entry.DLS_FDRg.css":j}},"_C2YKbQDp.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_C2YKbQDp.js":J={resourceType:"script",module:true,prefetch:true,preload:true,file:"C2YKbQDp.js",name:"UserModal",imports:["../node_modules/nuxt/dist/app/entry.js","../shared/types/user.types.ts"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"../shared/types/user.types.ts":k},prefetch:{"entry.DLS_FDRg.css":j}},"_CPO0it5h.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_CPO0it5h.js":K={resourceType:"script",module:true,prefetch:true,preload:true,file:"CPO0it5h.js",name:"NotificationTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_CasXnXPt.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_CasXnXPt.js":L={resourceType:"script",module:true,prefetch:true,preload:true,file:"CasXnXPt.js",name:"TimezoneTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_CfAzB1GA.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_CfAzB1GA.js":N={resourceType:"script",module:true,prefetch:true,preload:true,file:"CfAzB1GA.js",name:"LanguageTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_D4wADBKf.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_D4wADBKf.js":P={resourceType:"script",module:true,prefetch:true,preload:true,file:"D4wADBKf.js",name:"CourseCard",imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_DDbQURS5.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_DDbQURS5.js":Q={resourceType:"script",module:true,prefetch:true,preload:true,file:"DDbQURS5.js",name:"SMTPTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_DDxt_u6O.js":{scripts:{},styles:{},preload:{"_DDxt_u6O.js":R={resourceType:"script",module:true,prefetch:true,preload:true,file:"DDxt_u6O.js",name:"endOfMonth",imports:["_CiM0_A9B.js"]},"_CiM0_A9B.js":D},prefetch:{}},"_DVLQ4A6n.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_DVLQ4A6n.js":T={resourceType:"script",module:true,prefetch:true,preload:true,file:"DVLQ4A6n.js",name:"GeneralTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_Dac6oD3c.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_Dac6oD3c.js":U={resourceType:"script",module:true,prefetch:true,preload:true,file:"Dac6oD3c.js",name:"MaintenanceTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_Dfn2J_7j.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_Dfn2J_7j.js":V={resourceType:"script",module:true,prefetch:true,preload:true,file:"Dfn2J_7j.js",name:"DisplayTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_DjKcNith.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_DjKcNith.js":W={resourceType:"script",module:true,prefetch:true,preload:true,file:"DjKcNith.js",name:"PaymentMethodModal.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_Dm9QA4UA.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_Dm9QA4UA.js":X={resourceType:"script",module:true,prefetch:true,preload:true,file:"Dm9QA4UA.js",name:"FileUploadTab.vue",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_H1WKJ1ey.js":{scripts:{},styles:{},preload:{"_H1WKJ1ey.js":Y={resourceType:"script",module:true,prefetch:true,preload:true,file:"H1WKJ1ey.js",name:"parseISO",imports:["_BALXvQ8s.js","_CiM0_A9B.js"]},"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{}},"_PJD1JfRC.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_PJD1JfRC.js":Z={resourceType:"script",module:true,prefetch:true,preload:true,file:"PJD1JfRC.js",name:"StudentModal",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_RichTextEditor.9N-AczwR.css":{scripts:{},styles:{},preload:{"_RichTextEditor.9N-AczwR.css":{resourceType:"style",prefetch:true,preload:true,file:"RichTextEditor.9N-AczwR.css",src:"_RichTextEditor.9N-AczwR.css"}},prefetch:{}},"_cL3ZD5Hb.js":{scripts:{},styles:{},preload:{"_cL3ZD5Hb.js":$={resourceType:"script",module:true,prefetch:true,preload:true,file:"cL3ZD5Hb.js",name:"formatDistanceToNow",imports:["_DDxt_u6O.js","_CiM0_A9B.js"]},"_DDxt_u6O.js":R,"_CiM0_A9B.js":D},prefetch:{}},"_m998VyF-.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_m998VyF-.js":_={resourceType:"script",module:true,prefetch:true,preload:true,file:"m998VyF-.js",name:"EnrollmentModal",imports:["../node_modules/nuxt/dist/app/entry.js","_BdJkXebB.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BdJkXebB.js":G},prefetch:{"entry.DLS_FDRg.css":j}},"_v-KwyajG.js":{scripts:{},styles:{"RichTextEditor.9N-AczwR.css":hb={file:"RichTextEditor.9N-AczwR.css",resourceType:"style",prefetch:true,preload:true},"entry.DLS_FDRg.css":j},preload:{"_v-KwyajG.js":jb={resourceType:"script",module:true,prefetch:true,preload:true,file:"v-KwyajG.js",name:"RichTextEditor",imports:["../node_modules/nuxt/dist/app/entry.js"],css:["RichTextEditor.9N-AczwR.css"]},"RichTextEditor.9N-AczwR.css":hb,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"RichTextEditor.9N-AczwR.css":hb,"entry.DLS_FDRg.css":j}},"RichTextEditor.9N-AczwR.css":{scripts:{},styles:{},preload:{"RichTextEditor.9N-AczwR.css":hb},prefetch:{}},"_xJo2gTVb.js":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"_xJo2gTVb.js":kb={resourceType:"script",module:true,prefetch:true,preload:true,file:"xJo2gTVb.js",name:"interval",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"layouts/admin.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"layouts/admin.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CIjPKTSB.js",name:"admin",src:"layouts/admin.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_xJo2gTVb.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_xJo2gTVb.js":kb},prefetch:{"entry.DLS_FDRg.css":j}},"layouts/chat.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"layouts/chat.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CYB17nq9.js",name:"chat",src:"layouts/chat.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"layouts/default.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"layouts/default.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CllNs7J-.js",name:"default",src:"layouts/default.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"layouts/homepage.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"layouts/homepage.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CPokQ-Z0.js",name:"homepage",src:"layouts/homepage.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"layouts/student.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"layouts/student.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"B1BO9a0J.js",name:"student",src:"layouts/student.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_xJo2gTVb.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_xJo2gTVb.js":kb},prefetch:{"entry.DLS_FDRg.css":j}},"middleware/admin.ts":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"middleware/admin.ts":{resourceType:"script",module:true,prefetch:true,preload:true,file:"8smeP2F2.js",name:"admin",src:"middleware/admin.ts",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"],dynamicImports:["../shared/types/user.types.ts"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"middleware/auth.ts":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"middleware/auth.ts":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BJCjXCMr.js",name:"auth",src:"middleware/auth.ts",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"utils/auth.ts":{scripts:{},styles:{},preload:{"utils/auth.ts":mb={resourceType:"script",module:true,prefetch:true,preload:true,file:"BZUAIYhA.js",name:"auth",src:"utils/auth.ts",isDynamicEntry:true,imports:["../shared/types/user.types.ts"]},"../shared/types/user.types.ts":k},prefetch:{}},"middleware/guest.ts":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"middleware/guest.ts":{resourceType:"script",module:true,prefetch:true,preload:true,file:"C51Wn5Mq.js",name:"guest",src:"middleware/guest.ts",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","utils/auth.ts","../shared/types/user.types.ts"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"utils/auth.ts":mb,"../shared/types/user.types.ts":k},prefetch:{"entry.DLS_FDRg.css":j}},"pages/about.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/about.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CPo-A71o.js",name:"about",src:"pages/about.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"],css:[]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"about.CscaCdTE.css":{scripts:{},styles:{},preload:{"about.CscaCdTE.css":{file:"about.CscaCdTE.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"pages/admin/chat/[roomId].vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/chat/[roomId].vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"C8uZPu3n.js",name:"_roomId_",src:"pages/admin/chat/[roomId].vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/chat/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/chat/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CtteXIPZ.js",name:"index",src:"pages/admin/chat/index.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_cL3ZD5Hb.js","_CiM0_A9B.js","_DDxt_u6O.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_cL3ZD5Hb.js":$,"_DDxt_u6O.js":R,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/content/articles/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb},preload:{"pages/admin/content/articles/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CyzirTAB.js",name:"index",src:"pages/admin/content/articles/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_v-KwyajG.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_v-KwyajG.js":jb,"RichTextEditor.9N-AczwR.css":hb},prefetch:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb}},"pages/admin/content/pages/[id]/edit.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb},preload:{"pages/admin/content/pages/[id]/edit.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"C-arVmPL.js",name:"edit",src:"pages/admin/content/pages/[id]/edit.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_v-KwyajG.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_v-KwyajG.js":jb,"RichTextEditor.9N-AczwR.css":hb},prefetch:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb}},"pages/admin/content/pages/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/content/pages/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"9LjQvTqj.js",name:"index",src:"pages/admin/content/pages/index.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/content/pages/new.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb},preload:{"pages/admin/content/pages/new.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"PItv745k.js",name:"new",src:"pages/admin/content/pages/new.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_v-KwyajG.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_v-KwyajG.js":jb,"RichTextEditor.9N-AczwR.css":hb},prefetch:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb}},"pages/admin/content/testimonials/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/content/testimonials/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"B3Z3RBrt.js",name:"index",src:"pages/admin/content/testimonials/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/courses/[id]/edit.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb},preload:{"pages/admin/courses/[id]/edit.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CWJWjr3c.js",name:"edit",src:"pages/admin/courses/[id]/edit.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_v-KwyajG.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_v-KwyajG.js":jb,"RichTextEditor.9N-AczwR.css":hb},prefetch:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb}},"pages/admin/courses/[id]/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/courses/[id]/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CfuytIrk.js",name:"index",src:"pages/admin/courses/[id]/index.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/courses/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb},preload:{"pages/admin/courses/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"B49HIcoT.js",name:"index",src:"pages/admin/courses/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_v-KwyajG.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_v-KwyajG.js":jb,"RichTextEditor.9N-AczwR.css":hb,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j,"RichTextEditor.9N-AczwR.css":hb}},"pages/admin/enrollments/[id]/edit.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/enrollments/[id]/edit.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"C4BNzpKP.js",name:"edit",src:"pages/admin/enrollments/[id]/edit.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_BdJkXebB.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BdJkXebB.js":G},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/enrollments/[id]/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/enrollments/[id]/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Bc4y1aXM.js",name:"index",src:"pages/admin/enrollments/[id]/index.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/enrollments/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/enrollments/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DaQcxvqW.js",name:"index",src:"pages/admin/enrollments/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_m998VyF-.js","_BALXvQ8s.js","_CiM0_A9B.js","_BdJkXebB.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_m998VyF-.js":_,"_BdJkXebB.js":G,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CjwhNx0b.js",name:"index",src:"pages/admin/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/login.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/login.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"MEG3hhrh.js",name:"login",src:"pages/admin/login.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/branches/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/branches/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Qwhilmll.js",name:"index",src:"pages/admin/settings/branches/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/email/components/SMTPTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/email/components/SMTPTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BcKj8Aeq.js",name:"SMTPTab",src:"pages/admin/settings/email/components/SMTPTab.vue",isDynamicEntry:true,imports:["_DDbQURS5.js","../node_modules/nuxt/dist/app/entry.js"]},"_DDbQURS5.js":Q,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/email/components/TemplateModal.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/email/components/TemplateModal.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BKpWv-2O.js",name:"TemplateModal",src:"pages/admin/settings/email/components/TemplateModal.vue",isDynamicEntry:true,imports:["_DbIPe0gX.js","../node_modules/nuxt/dist/app/entry.js"]},"_DbIPe0gX.js":H,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/email/components/TemplatesTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/email/components/TemplatesTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DfgEv0ug.js",name:"TemplatesTab",src:"pages/admin/settings/email/components/TemplatesTab.vue",isDynamicEntry:true,imports:["_C-BNIxyI.js","../node_modules/nuxt/dist/app/entry.js","_DbIPe0gX.js"]},"_C-BNIxyI.js":I,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_DbIPe0gX.js":H},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/email/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/email/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DjwPAIHw.js",name:"index",src:"pages/admin/settings/email/index.vue",isDynamicEntry:true,imports:["_DDbQURS5.js","_C-BNIxyI.js","../node_modules/nuxt/dist/app/entry.js","_DbIPe0gX.js"]},"_DDbQURS5.js":Q,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_C-BNIxyI.js":I,"_DbIPe0gX.js":H},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/grade-levels/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/grade-levels/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BEBU9Hil.js",name:"index",src:"pages/admin/settings/grade-levels/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/inclusions/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/inclusions/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Dz_cw2Mu.js",name:"index",src:"pages/admin/settings/inclusions/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/BankAccountModal.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/BankAccountModal.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CRIXk28M.js",name:"BankAccountModal",src:"pages/admin/settings/payment-methods/components/BankAccountModal.vue",isDynamicEntry:true,imports:["_BeJ1R-XH.js","../node_modules/nuxt/dist/app/entry.js"]},"_BeJ1R-XH.js":A,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/BankAccountsSection.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/BankAccountsSection.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Cb3Vbygw.js",name:"BankAccountsSection",src:"pages/admin/settings/payment-methods/components/BankAccountsSection.vue",isDynamicEntry:true,imports:["_BmYQ950h.js","_BeJ1R-XH.js","../node_modules/nuxt/dist/app/entry.js"]},"_BmYQ950h.js":B,"_BeJ1R-XH.js":A,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/GatewayConfigSection.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/GatewayConfigSection.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BTopoM6U.js",name:"GatewayConfigSection",src:"pages/admin/settings/payment-methods/components/GatewayConfigSection.vue",isDynamicEntry:true,imports:["_8aee2ZTh.js","_rQp7WoB7.js","../node_modules/nuxt/dist/app/entry.js","_Bw0amrgs.js","_DE9j9Y27.js"]},"_8aee2ZTh.js":x,"_rQp7WoB7.js":o,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_Bw0amrgs.js":q,"_DE9j9Y27.js":u},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/PaymentMethodBasicInfo.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/PaymentMethodBasicInfo.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CTEk1XwB.js",name:"PaymentMethodBasicInfo",src:"pages/admin/settings/payment-methods/components/PaymentMethodBasicInfo.vue",isDynamicEntry:true,imports:["_CaK-Jlu2.js","../node_modules/nuxt/dist/app/entry.js"]},"_CaK-Jlu2.js":z,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/PaymentMethodDetailModal.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/PaymentMethodDetailModal.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BgJoX-5C.js",name:"PaymentMethodDetailModal",src:"pages/admin/settings/payment-methods/components/PaymentMethodDetailModal.vue",isDynamicEntry:true,imports:["_B2mp1wD8.js","../node_modules/nuxt/dist/app/entry.js","_CaK-Jlu2.js","_BmYQ950h.js","_BeJ1R-XH.js","_8aee2ZTh.js","_rQp7WoB7.js","_Bw0amrgs.js","_DE9j9Y27.js"]},"_B2mp1wD8.js":C,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_CaK-Jlu2.js":z,"_BmYQ950h.js":B,"_BeJ1R-XH.js":A,"_8aee2ZTh.js":x,"_rQp7WoB7.js":o,"_Bw0amrgs.js":q,"_DE9j9Y27.js":u},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/PaymentMethodModal.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/PaymentMethodModal.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BwweZmaY.js",name:"PaymentMethodModal",src:"pages/admin/settings/payment-methods/components/PaymentMethodModal.vue",isDynamicEntry:true,imports:["_DjKcNith.js","../node_modules/nuxt/dist/app/entry.js"]},"_DjKcNith.js":W,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/gateway/GenericGatewayConfig.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/gateway/GenericGatewayConfig.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DClwBoeE.js",name:"GenericGatewayConfig",src:"pages/admin/settings/payment-methods/components/gateway/GenericGatewayConfig.vue",isDynamicEntry:true,imports:["_DE9j9Y27.js","../node_modules/nuxt/dist/app/entry.js"]},"_DE9j9Y27.js":u,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/gateway/KsherConfig.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/gateway/KsherConfig.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DBq6vxy0.js",name:"KsherConfig",src:"pages/admin/settings/payment-methods/components/gateway/KsherConfig.vue",isDynamicEntry:true,imports:["_Bw0amrgs.js","../node_modules/nuxt/dist/app/entry.js"]},"_Bw0amrgs.js":q,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/components/gateway/StripeConfig.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/components/gateway/StripeConfig.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DWL7QY8Q.js",name:"StripeConfig",src:"pages/admin/settings/payment-methods/components/gateway/StripeConfig.vue",isDynamicEntry:true,imports:["_rQp7WoB7.js","../node_modules/nuxt/dist/app/entry.js"]},"_rQp7WoB7.js":o,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/payment-methods/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/payment-methods/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"B_w0QKyd.js",name:"index",src:"pages/admin/settings/payment-methods/index.vue",isDynamicEntry:true,imports:["_DjKcNith.js","_B2mp1wD8.js","../node_modules/nuxt/dist/app/entry.js","_CaK-Jlu2.js","_BmYQ950h.js","_BeJ1R-XH.js","_8aee2ZTh.js","_rQp7WoB7.js","_Bw0amrgs.js","_DE9j9Y27.js"]},"_DjKcNith.js":W,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_B2mp1wD8.js":C,"_CaK-Jlu2.js":z,"_BmYQ950h.js":B,"_BeJ1R-XH.js":A,"_8aee2ZTh.js":x,"_rQp7WoB7.js":o,"_Bw0amrgs.js":q,"_DE9j9Y27.js":u},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/roles/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/roles/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BdNG13rv.js",name:"index",src:"pages/admin/settings/roles/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/subjects/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/subjects/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"D8WKMr8o.js",name:"index",src:"pages/admin/settings/subjects/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/components/DisplayTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/components/DisplayTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Dd9IFq5w.js",name:"DisplayTab",src:"pages/admin/settings/system/components/DisplayTab.vue",isDynamicEntry:true,imports:["_Dfn2J_7j.js","../node_modules/nuxt/dist/app/entry.js"]},"_Dfn2J_7j.js":V,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/components/FileUploadTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/components/FileUploadTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DOCv56iD.js",name:"FileUploadTab",src:"pages/admin/settings/system/components/FileUploadTab.vue",isDynamicEntry:true,imports:["_Dm9QA4UA.js","../node_modules/nuxt/dist/app/entry.js"]},"_Dm9QA4UA.js":X,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/components/GeneralTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/components/GeneralTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BTqLQgnH.js",name:"GeneralTab",src:"pages/admin/settings/system/components/GeneralTab.vue",isDynamicEntry:true,imports:["_DVLQ4A6n.js","../node_modules/nuxt/dist/app/entry.js"]},"_DVLQ4A6n.js":T,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/components/LanguageTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/components/LanguageTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"B-X30aoF.js",name:"LanguageTab",src:"pages/admin/settings/system/components/LanguageTab.vue",isDynamicEntry:true,imports:["_CfAzB1GA.js","../node_modules/nuxt/dist/app/entry.js"]},"_CfAzB1GA.js":N,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/components/MaintenanceTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/components/MaintenanceTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DhtnrIcc.js",name:"MaintenanceTab",src:"pages/admin/settings/system/components/MaintenanceTab.vue",isDynamicEntry:true,imports:["_Dac6oD3c.js","../node_modules/nuxt/dist/app/entry.js"]},"_Dac6oD3c.js":U,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/components/NotificationTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/components/NotificationTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DJ1b1eKD.js",name:"NotificationTab",src:"pages/admin/settings/system/components/NotificationTab.vue",isDynamicEntry:true,imports:["_CPO0it5h.js","../node_modules/nuxt/dist/app/entry.js"]},"_CPO0it5h.js":K,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/components/SecurityTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/components/SecurityTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"NoIg-Coj.js",name:"SecurityTab",src:"pages/admin/settings/system/components/SecurityTab.vue",isDynamicEntry:true,imports:["_BFsmL2mK.js","../node_modules/nuxt/dist/app/entry.js"]},"_BFsmL2mK.js":F,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/components/TimezoneTab.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/components/TimezoneTab.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DOaAHroO.js",name:"TimezoneTab",src:"pages/admin/settings/system/components/TimezoneTab.vue",isDynamicEntry:true,imports:["_CasXnXPt.js","../node_modules/nuxt/dist/app/entry.js"]},"_CasXnXPt.js":L,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/system/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/system/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BHSDNIxN.js",name:"index",src:"pages/admin/settings/system/index.vue",isDynamicEntry:true,imports:["_DVLQ4A6n.js","_CasXnXPt.js","_Dac6oD3c.js","_BFsmL2mK.js","_Dm9QA4UA.js","_CPO0it5h.js","_CfAzB1GA.js","_Dfn2J_7j.js","../node_modules/nuxt/dist/app/entry.js"]},"_DVLQ4A6n.js":T,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_CasXnXPt.js":L,"_Dac6oD3c.js":U,"_BFsmL2mK.js":F,"_Dm9QA4UA.js":X,"_CPO0it5h.js":K,"_CfAzB1GA.js":N,"_Dfn2J_7j.js":V},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/settings/users/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/settings/users/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CDjH4OLA.js",name:"index",src:"pages/admin/settings/users/index.vue",isDynamicEntry:true,imports:["_C2YKbQDp.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js","../shared/types/user.types.ts"]},"_C2YKbQDp.js":J,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"../shared/types/user.types.ts":k,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/students/[id]/edit.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/students/[id]/edit.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"jfJEL8rP.js",name:"edit",src:"pages/admin/students/[id]/edit.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/students/[id]/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/students/[id]/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BiBmy0vu.js",name:"index",src:"pages/admin/students/[id]/index.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","_PJD1JfRC.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_PJD1JfRC.js":Z,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/students/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/students/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"C6b0ety_.js",name:"index",src:"pages/admin/students/index.vue",isDynamicEntry:true,imports:["_PJD1JfRC.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_PJD1JfRC.js":Z,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/tutor/courses/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/tutor/courses/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DzoPbhfs.js",name:"index",src:"pages/admin/tutor/courses/index.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/tutor/schedule/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/tutor/schedule/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"D7CgXfyH.js",name:"index",src:"pages/admin/tutor/schedule/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","../shared/types/user.types.ts","_BALXvQ8s.js","_CiM0_A9B.js","_DDxt_u6O.js","_H1WKJ1ey.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"../shared/types/user.types.ts":k,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D,"_DDxt_u6O.js":R,"_H1WKJ1ey.js":Y},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/tutor/students/[id].vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/tutor/students/[id].vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BOBs1G3d.js",name:"_id_",src:"pages/admin/tutor/students/[id].vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/tutor/students/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/tutor/students/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Be9nsAj3.js",name:"index",src:"pages/admin/tutor/students/index.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/admin/users/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/admin/users/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DCX2gqgQ.js",name:"index",src:"pages/admin/users/index.vue",isDynamicEntry:true,imports:["_C2YKbQDp.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js","../shared/types/user.types.ts"]},"_C2YKbQDp.js":J,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"../shared/types/user.types.ts":k,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/articles/[slug].vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/articles/[slug].vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DE0tsH7x.js",name:"_slug_",src:"pages/articles/[slug].vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"],css:[]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"_slug_.CGAP6FWb.css":{scripts:{},styles:{},preload:{"_slug_.CGAP6FWb.css":{file:"_slug_.CGAP6FWb.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"pages/articles/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/articles/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Bo53vrEk.js",name:"index",src:"pages/articles/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"],css:[]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"index.CA3aPy--.css":{scripts:{},styles:{},preload:{"index.CA3aPy--.css":{file:"index.CA3aPy--.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"pages/auth/callback/[provider].vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/auth/callback/[provider].vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"C5VP7iu_.js",name:"_provider_",src:"pages/auth/callback/[provider].vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_0JwXLbdW.js"],dynamicImports:["utils/auth.ts"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_0JwXLbdW.js":m},prefetch:{"entry.DLS_FDRg.css":j}},"pages/auth/forgot-password.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/auth/forgot-password.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"EIWeQM0D.js",name:"forgot-password",src:"pages/auth/forgot-password.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/auth/login.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/auth/login.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"rSZ_nZDf.js",name:"login",src:"pages/auth/login.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","utils/auth.ts","../shared/types/user.types.ts"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"utils/auth.ts":mb,"../shared/types/user.types.ts":k},prefetch:{"entry.DLS_FDRg.css":j}},"pages/auth/register.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/auth/register.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"C_uIs32I.js",name:"register",src:"pages/auth/register.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","utils/auth.ts","../shared/types/user.types.ts"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"utils/auth.ts":mb,"../shared/types/user.types.ts":k},prefetch:{"entry.DLS_FDRg.css":j}},"pages/careers.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/careers.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DxDEv_3r.js",name:"careers",src:"pages/careers.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"],css:[]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"careers.tQ6S07Om.css":{scripts:{},styles:{},preload:{"careers.tQ6S07Om.css":{file:"careers.tQ6S07Om.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"pages/chat/index.vue":{scripts:{},styles:{"index.C94WdXjb.css":ob={file:"index.C94WdXjb.css",resourceType:"style",prefetch:true,preload:true},"entry.DLS_FDRg.css":j},preload:{"pages/chat/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CeAJt_oh.js",name:"index",src:"pages/chat/index.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_cL3ZD5Hb.js","_CiM0_A9B.js","_BALXvQ8s.js","_xJo2gTVb.js","_H1WKJ1ey.js","_DDxt_u6O.js"],css:["index.C94WdXjb.css"]},"index.C94WdXjb.css":ob,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_cL3ZD5Hb.js":$,"_DDxt_u6O.js":R,"_CiM0_A9B.js":D,"_BALXvQ8s.js":E,"_xJo2gTVb.js":kb,"_H1WKJ1ey.js":Y},prefetch:{"index.C94WdXjb.css":ob,"entry.DLS_FDRg.css":j}},"index.C94WdXjb.css":{scripts:{},styles:{},preload:{"index.C94WdXjb.css":ob},prefetch:{}},"pages/contact.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/contact.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Cxo8nhUx.js",name:"contact",src:"pages/contact.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"],css:[]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"contact.BQWmQK7z.css":{scripts:{},styles:{},preload:{"contact.BQWmQK7z.css":{file:"contact.BQWmQK7z.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"pages/courses/[id].vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/courses/[id].vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CkyQOW3s.js",name:"_id_",src:"pages/courses/[id].vue",isDynamicEntry:true,imports:["_m998VyF-.js","../node_modules/nuxt/dist/app/entry.js","_BdJkXebB.js"]},"_m998VyF-.js":_,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BdJkXebB.js":G},prefetch:{"entry.DLS_FDRg.css":j}},"pages/courses/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/courses/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CqRDv-_f.js",name:"index",src:"pages/courses/index.vue",isDynamicEntry:true,imports:["_D4wADBKf.js","../node_modules/nuxt/dist/app/entry.js","_0JwXLbdW.js"]},"_D4wADBKf.js":P,"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/help.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/help.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BCw_uuzn.js",name:"help",src:"pages/help.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"],css:[]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"help.DlSzpRFm.css":{scripts:{},styles:{},preload:{"help.DlSzpRFm.css":{file:"help.DlSzpRFm.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"pages/index.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CmxfT9SS.js",name:"index",src:"pages/index.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","_D4wADBKf.js","../node_modules/nuxt/dist/app/entry.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_D4wADBKf.js":P},prefetch:{"entry.DLS_FDRg.css":j}},"pages/my-courses.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/my-courses.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BQPERQYg.js",name:"my-courses",src:"pages/my-courses.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js","_BALXvQ8s.js","_CiM0_A9B.js"]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j,"_BALXvQ8s.js":E,"_CiM0_A9B.js":D},prefetch:{"entry.DLS_FDRg.css":j}},"pages/payment-history.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/payment-history.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DwxO8qxn.js",name:"payment-history",src:"pages/payment-history.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"pages/support.vue":{scripts:{},styles:{"entry.DLS_FDRg.css":j},preload:{"pages/support.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"C7vjBmAo.js",name:"support",src:"pages/support.vue",isDynamicEntry:true,imports:["_0JwXLbdW.js","../node_modules/nuxt/dist/app/entry.js"],css:[]},"_0JwXLbdW.js":m,"../node_modules/nuxt/dist/app/entry.js":h,"entry.DLS_FDRg.css":j},prefetch:{"entry.DLS_FDRg.css":j}},"support.7nip7fuj.css":{scripts:{},styles:{},preload:{"support.7nip7fuj.css":{file:"support.7nip7fuj.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}}},entrypoints:["../node_modules/nuxt/dist/app/entry.js"],modules:{"../node_modules/nuxt/dist/app/entry.js":{file:"CX4WDIMJ.js",resourceType:"script",mimeType:void 0,module:true},"entry.DLS_FDRg.css":{file:"entry.DLS_FDRg.css",resourceType:"style",mimeType:void 0,module:void 0},"../shared/types/user.types.ts":{file:"LiZfZJ8V.js",resourceType:"script",mimeType:void 0,module:true},"_0JwXLbdW.js":{file:"0JwXLbdW.js",resourceType:"script",mimeType:void 0,module:true},"_8aee2ZTh.js":{file:"8aee2ZTh.js",resourceType:"script",mimeType:void 0,module:true},"_B2mp1wD8.js":{file:"B2mp1wD8.js",resourceType:"script",mimeType:void 0,module:true},"_BALXvQ8s.js":{file:"BALXvQ8s.js",resourceType:"script",mimeType:void 0,module:true},"_BFsmL2mK.js":{file:"BFsmL2mK.js",resourceType:"script",mimeType:void 0,module:true},"_BdJkXebB.js":{file:"BdJkXebB.js",resourceType:"script",mimeType:void 0,module:true},"_BeJ1R-XH.js":{file:"BeJ1R-XH.js",resourceType:"script",mimeType:void 0,module:true},"_BmYQ950h.js":{file:"BmYQ950h.js",resourceType:"script",mimeType:void 0,module:true},"_Bw0amrgs.js":{file:"Bw0amrgs.js",resourceType:"script",mimeType:void 0,module:true},"_C-BNIxyI.js":{file:"C-BNIxyI.js",resourceType:"script",mimeType:void 0,module:true},"_C2YKbQDp.js":{file:"C2YKbQDp.js",resourceType:"script",mimeType:void 0,module:true},"_CPO0it5h.js":{file:"CPO0it5h.js",resourceType:"script",mimeType:void 0,module:true},"_CaK-Jlu2.js":{file:"CaK-Jlu2.js",resourceType:"script",mimeType:void 0,module:true},"_CasXnXPt.js":{file:"CasXnXPt.js",resourceType:"script",mimeType:void 0,module:true},"_CfAzB1GA.js":{file:"CfAzB1GA.js",resourceType:"script",mimeType:void 0,module:true},"_CiM0_A9B.js":{file:"CiM0_A9B.js",resourceType:"script",mimeType:void 0,module:true},"_D4wADBKf.js":{file:"D4wADBKf.js",resourceType:"script",mimeType:void 0,module:true},"_DDbQURS5.js":{file:"DDbQURS5.js",resourceType:"script",mimeType:void 0,module:true},"_DDxt_u6O.js":{file:"DDxt_u6O.js",resourceType:"script",mimeType:void 0,module:true},"_DE9j9Y27.js":{file:"DE9j9Y27.js",resourceType:"script",mimeType:void 0,module:true},"_DVLQ4A6n.js":{file:"DVLQ4A6n.js",resourceType:"script",mimeType:void 0,module:true},"_Dac6oD3c.js":{file:"Dac6oD3c.js",resourceType:"script",mimeType:void 0,module:true},"_DbIPe0gX.js":{file:"DbIPe0gX.js",resourceType:"script",mimeType:void 0,module:true},"_Dfn2J_7j.js":{file:"Dfn2J_7j.js",resourceType:"script",mimeType:void 0,module:true},"_DjKcNith.js":{file:"DjKcNith.js",resourceType:"script",mimeType:void 0,module:true},"_Dm9QA4UA.js":{file:"Dm9QA4UA.js",resourceType:"script",mimeType:void 0,module:true},"_H1WKJ1ey.js":{file:"H1WKJ1ey.js",resourceType:"script",mimeType:void 0,module:true},"_PJD1JfRC.js":{file:"PJD1JfRC.js",resourceType:"script",mimeType:void 0,module:true},"_RichTextEditor.9N-AczwR.css":{file:"RichTextEditor.9N-AczwR.css",resourceType:"style",mimeType:void 0,module:void 0},"_cL3ZD5Hb.js":{file:"cL3ZD5Hb.js",resourceType:"script",mimeType:void 0,module:true},"_m998VyF-.js":{file:"m998VyF-.js",resourceType:"script",mimeType:void 0,module:true},"_rQp7WoB7.js":{file:"rQp7WoB7.js",resourceType:"script",mimeType:void 0,module:true},"_v-KwyajG.js":{file:"v-KwyajG.js",resourceType:"script",mimeType:void 0,module:true},"RichTextEditor.9N-AczwR.css":{file:"RichTextEditor.9N-AczwR.css",resourceType:"style",mimeType:void 0,module:void 0},"_xJo2gTVb.js":{file:"xJo2gTVb.js",resourceType:"script",mimeType:void 0,module:true},"layouts/admin.vue":{file:"CIjPKTSB.js",resourceType:"script",mimeType:void 0,module:true},"layouts/chat.vue":{file:"CYB17nq9.js",resourceType:"script",mimeType:void 0,module:true},"layouts/default.vue":{file:"CllNs7J-.js",resourceType:"script",mimeType:void 0,module:true},"layouts/homepage.vue":{file:"CPokQ-Z0.js",resourceType:"script",mimeType:void 0,module:true},"layouts/student.vue":{file:"B1BO9a0J.js",resourceType:"script",mimeType:void 0,module:true},"middleware/admin.ts":{file:"8smeP2F2.js",resourceType:"script",mimeType:void 0,module:true},"middleware/auth.ts":{file:"BJCjXCMr.js",resourceType:"script",mimeType:void 0,module:true},"middleware/guest.ts":{file:"C51Wn5Mq.js",resourceType:"script",mimeType:void 0,module:true},"pages/about.vue":{file:"CPo-A71o.js",resourceType:"script",mimeType:void 0,module:true},"about.CscaCdTE.css":{file:"about.CscaCdTE.css",resourceType:"style",mimeType:void 0,module:void 0},"pages/admin/chat/[roomId].vue":{file:"C8uZPu3n.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/chat/index.vue":{file:"CtteXIPZ.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/content/articles/index.vue":{file:"CyzirTAB.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/content/pages/[id]/edit.vue":{file:"C-arVmPL.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/content/pages/index.vue":{file:"9LjQvTqj.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/content/pages/new.vue":{file:"PItv745k.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/content/testimonials/index.vue":{file:"B3Z3RBrt.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/courses/[id]/edit.vue":{file:"CWJWjr3c.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/courses/[id]/index.vue":{file:"CfuytIrk.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/courses/index.vue":{file:"B49HIcoT.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/enrollments/[id]/edit.vue":{file:"C4BNzpKP.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/enrollments/[id]/index.vue":{file:"Bc4y1aXM.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/enrollments/index.vue":{file:"DaQcxvqW.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/index.vue":{file:"CjwhNx0b.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/login.vue":{file:"MEG3hhrh.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/branches/index.vue":{file:"Qwhilmll.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/email/components/SMTPTab.vue":{file:"BcKj8Aeq.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/email/components/TemplateModal.vue":{file:"BKpWv-2O.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/email/components/TemplatesTab.vue":{file:"DfgEv0ug.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/email/index.vue":{file:"DjwPAIHw.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/grade-levels/index.vue":{file:"BEBU9Hil.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/inclusions/index.vue":{file:"Dz_cw2Mu.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/BankAccountModal.vue":{file:"CRIXk28M.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/BankAccountsSection.vue":{file:"Cb3Vbygw.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/GatewayConfigSection.vue":{file:"BTopoM6U.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/PaymentMethodBasicInfo.vue":{file:"CTEk1XwB.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/PaymentMethodDetailModal.vue":{file:"BgJoX-5C.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/PaymentMethodModal.vue":{file:"BwweZmaY.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/gateway/GenericGatewayConfig.vue":{file:"DClwBoeE.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/gateway/KsherConfig.vue":{file:"DBq6vxy0.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/components/gateway/StripeConfig.vue":{file:"DWL7QY8Q.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/payment-methods/index.vue":{file:"B_w0QKyd.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/roles/index.vue":{file:"BdNG13rv.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/subjects/index.vue":{file:"D8WKMr8o.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/components/DisplayTab.vue":{file:"Dd9IFq5w.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/components/FileUploadTab.vue":{file:"DOCv56iD.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/components/GeneralTab.vue":{file:"BTqLQgnH.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/components/LanguageTab.vue":{file:"B-X30aoF.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/components/MaintenanceTab.vue":{file:"DhtnrIcc.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/components/NotificationTab.vue":{file:"DJ1b1eKD.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/components/SecurityTab.vue":{file:"NoIg-Coj.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/components/TimezoneTab.vue":{file:"DOaAHroO.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/system/index.vue":{file:"BHSDNIxN.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/settings/users/index.vue":{file:"CDjH4OLA.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/students/[id]/edit.vue":{file:"jfJEL8rP.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/students/[id]/index.vue":{file:"BiBmy0vu.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/students/index.vue":{file:"C6b0ety_.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/tutor/courses/index.vue":{file:"DzoPbhfs.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/tutor/schedule/index.vue":{file:"D7CgXfyH.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/tutor/students/[id].vue":{file:"BOBs1G3d.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/tutor/students/index.vue":{file:"Be9nsAj3.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/users/index.vue":{file:"DCX2gqgQ.js",resourceType:"script",mimeType:void 0,module:true},"pages/articles/[slug].vue":{file:"DE0tsH7x.js",resourceType:"script",mimeType:void 0,module:true},"_slug_.CGAP6FWb.css":{file:"_slug_.CGAP6FWb.css",resourceType:"style",mimeType:void 0,module:void 0},"pages/articles/index.vue":{file:"Bo53vrEk.js",resourceType:"script",mimeType:void 0,module:true},"index.CA3aPy--.css":{file:"index.CA3aPy--.css",resourceType:"style",mimeType:void 0,module:void 0},"pages/auth/callback/[provider].vue":{file:"C5VP7iu_.js",resourceType:"script",mimeType:void 0,module:true},"pages/auth/forgot-password.vue":{file:"EIWeQM0D.js",resourceType:"script",mimeType:void 0,module:true},"pages/auth/login.vue":{file:"rSZ_nZDf.js",resourceType:"script",mimeType:void 0,module:true},"pages/auth/register.vue":{file:"C_uIs32I.js",resourceType:"script",mimeType:void 0,module:true},"pages/careers.vue":{file:"DxDEv_3r.js",resourceType:"script",mimeType:void 0,module:true},"careers.tQ6S07Om.css":{file:"careers.tQ6S07Om.css",resourceType:"style",mimeType:void 0,module:void 0},"pages/chat/index.vue":{file:"CeAJt_oh.js",resourceType:"script",mimeType:void 0,module:true},"index.C94WdXjb.css":{file:"index.C94WdXjb.css",resourceType:"style",mimeType:void 0,module:void 0},"pages/contact.vue":{file:"Cxo8nhUx.js",resourceType:"script",mimeType:void 0,module:true},"contact.BQWmQK7z.css":{file:"contact.BQWmQK7z.css",resourceType:"style",mimeType:void 0,module:void 0},"pages/courses/[id].vue":{file:"CkyQOW3s.js",resourceType:"script",mimeType:void 0,module:true},"pages/courses/index.vue":{file:"CqRDv-_f.js",resourceType:"script",mimeType:void 0,module:true},"pages/help.vue":{file:"BCw_uuzn.js",resourceType:"script",mimeType:void 0,module:true},"help.DlSzpRFm.css":{file:"help.DlSzpRFm.css",resourceType:"style",mimeType:void 0,module:void 0},"pages/index.vue":{file:"CmxfT9SS.js",resourceType:"script",mimeType:void 0,module:true},"pages/my-courses.vue":{file:"BQPERQYg.js",resourceType:"script",mimeType:void 0,module:true},"pages/payment-history.vue":{file:"DwxO8qxn.js",resourceType:"script",mimeType:void 0,module:true},"pages/support.vue":{file:"C7vjBmAo.js",resourceType:"script",mimeType:void 0,module:true},"support.7nip7fuj.css":{file:"support.7nip7fuj.css",resourceType:"style",mimeType:void 0,module:void 0},"utils/auth.ts":{file:"BZUAIYhA.js",resourceType:"script",mimeType:void 0,module:true}}}))();

const client_precomputed$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: client_precomputed
}, Symbol.toStringTag, { value: 'Module' }));

const template = "";

const _virtual__spaTemplate = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  template: template
}, Symbol.toStringTag, { value: 'Module' }));

const interopDefault = r => r.default || r || [];
const styles = {
  "pages/help.vue": () => Promise.resolve().then(function () { return helpStyles_BcLrZ3bp$1; }).then(interopDefault),
  "pages/careers.vue": () => Promise.resolve().then(function () { return careersStyles_CgGOGSI$1; }).then(interopDefault),
  "pages/about.vue": () => Promise.resolve().then(function () { return aboutStyles_DL8U3_Ex$1; }).then(interopDefault),
  "pages/support.vue": () => Promise.resolve().then(function () { return supportStyles_CkYFZ4n$1; }).then(interopDefault),
  "pages/contact.vue": () => Promise.resolve().then(function () { return contactStyles_DlMtaC4v$1; }).then(interopDefault),
  "pages/articles/index.vue": () => Promise.resolve().then(function () { return indexStyles_DUruTEgV$1; }).then(interopDefault),
  "pages/articles/[slug].vue": () => Promise.resolve().then(function () { return _slug_Styles_BI_vgQG4$1; }).then(interopDefault),
  "pages/careers.vue?vue&type=style&index=0&scoped=c92df7ab&lang.css": () => Promise.resolve().then(function () { return careersStyles_CgGOGSI$1; }).then(interopDefault),
  "pages/help.vue?vue&type=style&index=0&scoped=bedacc18&lang.css": () => Promise.resolve().then(function () { return helpStyles_BcLrZ3bp$1; }).then(interopDefault),
  "pages/about.vue?vue&type=style&index=0&scoped=fd54481d&lang.css": () => Promise.resolve().then(function () { return aboutStyles_DL8U3_Ex$1; }).then(interopDefault),
  "pages/support.vue?vue&type=style&index=0&scoped=5dfe78b0&lang.css": () => Promise.resolve().then(function () { return supportStyles_CkYFZ4n$1; }).then(interopDefault),
  "pages/contact.vue?vue&type=style&index=0&scoped=db1b781d&lang.css": () => Promise.resolve().then(function () { return contactStyles_DlMtaC4v$1; }).then(interopDefault),
  "pages/articles/[slug].vue?vue&type=style&index=0&scoped=eb0d7bd9&lang.css": () => Promise.resolve().then(function () { return _slug_Styles_BI_vgQG4$1; }).then(interopDefault),
  "pages/articles/index.vue?vue&type=style&index=0&scoped=fe7937e4&lang.css": () => Promise.resolve().then(function () { return indexStyles_DUruTEgV$1; }).then(interopDefault),
  "components/RichTextEditor.vue": () => Promise.resolve().then(function () { return RichTextEditorStyles_CpqYpIg_$1; }).then(interopDefault),
  "components/RichTextEditor.vue?vue&type=style&index=0&lang.css": () => Promise.resolve().then(function () { return RichTextEditorStyles_CpqYpIg_$1; }).then(interopDefault),
  "components/TokenExpirationDialog.vue": () => Promise.resolve().then(function () { return TokenExpirationDialogStyles_BXl98F4N$1; }).then(interopDefault),
  "components/ConfirmModal.vue": () => Promise.resolve().then(function () { return ConfirmModalStyles_BGWJYiPN$1; }).then(interopDefault),
  "components/TokenExpirationDialog.vue?vue&type=style&index=0&scoped=99d8e1cf&lang.css": () => Promise.resolve().then(function () { return TokenExpirationDialogStyles_BXl98F4N$1; }).then(interopDefault),
  "components/ConfirmModal.vue?vue&type=style&index=0&scoped=701507a9&lang.css": () => Promise.resolve().then(function () { return ConfirmModalStyles_BGWJYiPN$1; }).then(interopDefault),
  "components/chat/ChatInput.vue": () => Promise.resolve().then(function () { return ChatInputStyles_CiuAWLX$1; }).then(interopDefault),
  "components/chat/ChatInput.vue?vue&type=style&index=0&scoped=c9b7ef97&lang.css": () => Promise.resolve().then(function () { return ChatInputStyles_CiuAWLX$1; }).then(interopDefault)
};

const styles$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: styles
}, Symbol.toStringTag, { value: 'Module' }));

const firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);
// @__NO_SIDE_EFFECTS__
function defineNuxtLink(options) {
  const componentName = options.componentName || "NuxtLink";
  function isHashLinkWithoutHashMode(link) {
    return typeof link === "string" && link.startsWith("#");
  }
  function resolveTrailingSlashBehavior(to, resolve, trailingSlash) {
    const effectiveTrailingSlash = trailingSlash ?? options.trailingSlash;
    if (!to || effectiveTrailingSlash !== "append" && effectiveTrailingSlash !== "remove") {
      return to;
    }
    if (typeof to === "string") {
      return applyTrailingSlashBehavior(to, effectiveTrailingSlash);
    }
    const path = "path" in to && to.path !== void 0 ? to.path : resolve(to).path;
    const resolvedPath = {
      ...to,
      name: void 0,
      // named routes would otherwise always override trailing slash behavior
      path: applyTrailingSlashBehavior(path, effectiveTrailingSlash)
    };
    return resolvedPath;
  }
  function useNuxtLink(props) {
    const router = useRouter();
    const config = useRuntimeConfig();
    const hasTarget = computed(() => !!props.target && props.target !== "_self");
    const isAbsoluteUrl = computed(() => {
      const path = props.to || props.href || "";
      return typeof path === "string" && hasProtocol(path, { acceptRelative: true });
    });
    const builtinRouterLink = resolveComponent("RouterLink");
    const useBuiltinLink = builtinRouterLink && typeof builtinRouterLink !== "string" ? builtinRouterLink.useLink : void 0;
    const isExternal = computed(() => {
      if (props.external) {
        return true;
      }
      const path = props.to || props.href || "";
      if (typeof path === "object") {
        return false;
      }
      return path === "" || isAbsoluteUrl.value;
    });
    const to = computed(() => {
      const path = props.to || props.href || "";
      if (isExternal.value) {
        return path;
      }
      return resolveTrailingSlashBehavior(path, router.resolve, props.trailingSlash);
    });
    const link = isExternal.value ? void 0 : useBuiltinLink?.({ ...props, to });
    const href = computed(() => {
      const effectiveTrailingSlash = props.trailingSlash ?? options.trailingSlash;
      if (!to.value || isAbsoluteUrl.value || isHashLinkWithoutHashMode(to.value)) {
        return to.value;
      }
      if (isExternal.value) {
        const path = typeof to.value === "object" && "path" in to.value ? resolveRouteObject(to.value) : to.value;
        const href2 = typeof path === "object" ? router.resolve(path).href : path;
        return applyTrailingSlashBehavior(href2, effectiveTrailingSlash);
      }
      if (typeof to.value === "object") {
        return router.resolve(to.value)?.href ?? null;
      }
      return applyTrailingSlashBehavior(joinURL(config.app.baseURL, to.value), effectiveTrailingSlash);
    });
    return {
      to,
      hasTarget,
      isAbsoluteUrl,
      isExternal,
      //
      href,
      isActive: link?.isActive ?? computed(() => to.value === router.currentRoute.value.path),
      isExactActive: link?.isExactActive ?? computed(() => to.value === router.currentRoute.value.path),
      route: link?.route ?? computed(() => router.resolve(to.value)),
      async navigate(_e) {
        await navigateTo(href.value, { replace: props.replace, external: isExternal.value || hasTarget.value });
      }
    };
  }
  return defineComponent({
    name: componentName,
    props: {
      // Routing
      to: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      href: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      // Attributes
      target: {
        type: String,
        default: void 0,
        required: false
      },
      rel: {
        type: String,
        default: void 0,
        required: false
      },
      noRel: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Prefetching
      prefetch: {
        type: Boolean,
        default: void 0,
        required: false
      },
      prefetchOn: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      noPrefetch: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Styling
      activeClass: {
        type: String,
        default: void 0,
        required: false
      },
      exactActiveClass: {
        type: String,
        default: void 0,
        required: false
      },
      prefetchedClass: {
        type: String,
        default: void 0,
        required: false
      },
      // Vue Router's `<RouterLink>` additional props
      replace: {
        type: Boolean,
        default: void 0,
        required: false
      },
      ariaCurrentValue: {
        type: String,
        default: void 0,
        required: false
      },
      // Edge cases handling
      external: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Slot API
      custom: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Behavior
      trailingSlash: {
        type: String,
        default: void 0,
        required: false
      }
    },
    useLink: useNuxtLink,
    setup(props, { slots }) {
      const router = useRouter();
      const { to, href, navigate, isExternal, hasTarget, isAbsoluteUrl } = useNuxtLink(props);
      shallowRef(false);
      const el = void 0;
      const elRef = void 0;
      async function prefetch(nuxtApp = useNuxtApp()) {
        {
          return;
        }
      }
      return () => {
        if (!isExternal.value && !hasTarget.value && !isHashLinkWithoutHashMode(to.value)) {
          const routerLinkProps = {
            ref: elRef,
            to: to.value,
            activeClass: props.activeClass || options.activeClass,
            exactActiveClass: props.exactActiveClass || options.exactActiveClass,
            replace: props.replace,
            ariaCurrentValue: props.ariaCurrentValue,
            custom: props.custom
          };
          if (!props.custom) {
            routerLinkProps.rel = props.rel || void 0;
          }
          return h$1(
            resolveComponent("RouterLink"),
            routerLinkProps,
            slots.default
          );
        }
        const target = props.target || null;
        const rel = firstNonUndefined(
          // converts `""` to `null` to prevent the attribute from being added as empty (`rel=""`)
          props.noRel ? "" : props.rel,
          options.externalRelAttribute,
          /*
          * A fallback rel of `noopener noreferrer` is applied for external links or links that open in a new tab.
          * This solves a reverse tabnapping security flaw in browsers pre-2021 as well as improving privacy.
          */
          isAbsoluteUrl.value || hasTarget.value ? "noopener noreferrer" : ""
        ) || null;
        if (props.custom) {
          if (!slots.default) {
            return null;
          }
          return slots.default({
            href: href.value,
            navigate,
            prefetch,
            get route() {
              if (!href.value) {
                return void 0;
              }
              const url = new URL(href.value, "http://localhost");
              return {
                path: url.pathname,
                fullPath: url.pathname,
                get query() {
                  return parseQuery(url.search);
                },
                hash: url.hash,
                params: {},
                name: void 0,
                matched: [],
                redirectedFrom: void 0,
                meta: {},
                href: href.value
              };
            },
            rel,
            target,
            isExternal: isExternal.value || hasTarget.value,
            isActive: false,
            isExactActive: false
          });
        }
        return h$1("a", {
          ref: el,
          href: href.value || null,
          // converts `""` to `null` to prevent the attribute from being added as empty (`href=""`)
          rel,
          target,
          onClick: (event) => {
            if (isExternal.value || hasTarget.value) {
              return;
            }
            event.preventDefault();
            return props.replace ? router.replace(href.value) : router.push(href.value);
          }
        }, slots.default?.());
      };
    }
  });
}
const __nuxt_component_0$b = /* @__PURE__ */ defineNuxtLink(nuxtLinkDefaults);
function applyTrailingSlashBehavior(to, trailingSlash) {
  const normalizeFn = trailingSlash === "append" ? withTrailingSlash : withoutTrailingSlash;
  const hasProtocolDifferentFromHttp = hasProtocol(to) && !to.startsWith("http");
  if (hasProtocolDifferentFromHttp) {
    return to;
  }
  return normalizeFn(to, true);
}

function injectHead(nuxtApp) {
  const nuxt = nuxtApp || useNuxtApp();
  return nuxt.ssrContext?.head || nuxt.runWithContext(() => {
    if (hasInjectionContext()) {
      const head = inject(headSymbol);
      if (!head) {
        throw new Error("[nuxt] [unhead] Missing Unhead instance.");
      }
      return head;
    }
  });
}
function useHead(input, options = {}) {
  const head = options.head || injectHead(options.nuxt);
  return useHead$1(input, { head, ...options });
}

const _sfc_main$1f = /* @__PURE__ */ defineComponent({
  __name: "help",
  __ssrInlineRender: true,
  setup(__props) {
    const page = ref(null);
    const loading = ref(true);
    const error = ref(null);
    useHead({
      title: () => page.value?.meta_title || page.value?.title || "",
      meta: [
        {
          name: "description",
          content: () => page.value?.meta_description || " - KDC Tutor School"
        },
        {
          name: "keywords",
          content: () => page.value?.meta_keywords || ""
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50 py-8" }, _attrs))} data-v-bedacc18><div class="container mx-auto px-4 py-12 max-w-4xl" data-v-bedacc18>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-20" data-v-bedacc18><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600" data-v-bedacc18></div><p class="mt-4 text-gray-600" data-v-bedacc18>...</p></div>`);
      } else if (unref(page)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8" data-v-bedacc18><h1 class="text-4xl font-bold text-gray-900 mb-6" data-v-bedacc18>${ssrInterpolate(unref(page).title)}</h1><div class="prose prose-lg max-w-none" data-v-bedacc18>${unref(page).content ?? ""}</div></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-bedacc18><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-bedacc18></h1><p class="text-gray-600 mb-6" data-v-bedacc18>${ssrInterpolate(unref(error))}</p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      } else {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-bedacc18><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-bedacc18></h1><p class="text-gray-600 mb-6" data-v-bedacc18> </p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$1f = _sfc_main$1f.setup;
_sfc_main$1f.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/help.vue");
  return _sfc_setup$1f ? _sfc_setup$1f(props, ctx) : void 0;
};
const help = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["__scopeId", "data-v-bedacc18"]]);

const helpKYo9vp6y = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: help
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1e = /* @__PURE__ */ defineComponent({
  __name: "about",
  __ssrInlineRender: true,
  setup(__props) {
    const page = ref(null);
    const loading = ref(true);
    const error = ref(null);
    useHead({
      title: () => page.value?.meta_title || page.value?.title || "",
      meta: [
        {
          name: "description",
          content: () => page.value?.meta_description || " - KDC Tutor School"
        },
        {
          name: "keywords",
          content: () => page.value?.meta_keywords || ""
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50 py-8" }, _attrs))} data-v-fd54481d><div class="container mx-auto px-4 py-12 max-w-4xl" data-v-fd54481d>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-20" data-v-fd54481d><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600" data-v-fd54481d></div><p class="mt-4 text-gray-600" data-v-fd54481d>...</p></div>`);
      } else if (unref(page)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8" data-v-fd54481d><h1 class="text-4xl font-bold text-gray-900 mb-6" data-v-fd54481d>${ssrInterpolate(unref(page).title)}</h1><div class="prose prose-lg max-w-none" data-v-fd54481d>${unref(page).content ?? ""}</div></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-fd54481d><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-fd54481d></h1><p class="text-gray-600 mb-6" data-v-fd54481d>${ssrInterpolate(unref(error))}</p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      } else {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-fd54481d><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-fd54481d></h1><p class="text-gray-600 mb-6" data-v-fd54481d> </p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$1e = _sfc_main$1e.setup;
_sfc_main$1e.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/about.vue");
  return _sfc_setup$1e ? _sfc_setup$1e(props, ctx) : void 0;
};
const about = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["__scopeId", "data-v-fd54481d"]]);

const about6n5z4B2O = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: about
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1d = /* @__PURE__ */ defineComponent({
  __name: "CourseCard",
  __ssrInlineRender: true,
  props: {
    course: {}
  },
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(ssrRenderComponent(_component_NuxtLink, mergeProps({
        to: `/courses/${__props.course.id}`,
        class: "block bg-white rounded-lg shadow hover:shadow-lg transition-shadow overflow-hidden"
      }, _attrs), {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="aspect-video bg-gray-200 relative"${_scopeId}>`);
            if (__props.course.thumbnail || __props.course.thumbnail_url) {
              _push2(`<img${ssrRenderAttr("src", __props.course.thumbnail || __props.course.thumbnail_url)}${ssrRenderAttr("alt", __props.course.title)} class="w-full h-full object-cover"${_scopeId}>`);
            } else {
              _push2(`<div class="w-full h-full flex items-center justify-center text-gray-400"${_scopeId}><svg class="w-16 h-16" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"${_scopeId}></path></svg></div>`);
            }
            if (__props.course.type) {
              _push2(`<div class="absolute top-2 left-2 bg-green-600 text-white px-2 py-1 rounded text-xs font-medium"${_scopeId}>${ssrInterpolate(__props.course.type)}</div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div><div class="p-4"${_scopeId}><div class="flex items-center gap-2 mb-2"${_scopeId}><span class="text-sm text-gray-500"${_scopeId}></span><span class="text-gray-300"${_scopeId}></span><span class="text-sm text-gray-500"${_scopeId}></span></div><h3 class="font-semibold text-lg mb-2 line-clamp-2"${_scopeId}>${ssrInterpolate(__props.course.title)}</h3>`);
            if (__props.course.description) {
              _push2(`<p class="text-gray-600 text-sm mb-4 line-clamp-2"${_scopeId}>${ssrInterpolate(__props.course.description)}</p>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`<div class="flex items-center justify-between"${_scopeId}><div class="flex items-center gap-4"${_scopeId}>`);
            if (__props.course.rating) {
              _push2(`<div class="flex items-center gap-1"${_scopeId}><svg class="w-4 h-4 text-yellow-400" fill="currentColor" viewBox="0 0 20 20"${_scopeId}><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"${_scopeId}></path></svg><span class="text-sm font-semibold"${_scopeId}>${ssrInterpolate(__props.course.rating)}</span></div>`);
            } else {
              _push2(`<!---->`);
            }
            if (__props.course.students) {
              _push2(`<div class="text-sm text-gray-500"${_scopeId}>${ssrInterpolate(__props.course.students.toLocaleString())}  </div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div><div class="text-right"${_scopeId}>`);
            if (__props.course.originalPrice) {
              _push2(`<div class="text-sm text-gray-400 line-through"${_scopeId}> ${ssrInterpolate(__props.course.originalPrice.toLocaleString())}</div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`<div class="text-lg font-bold text-green-600"${_scopeId}> ${ssrInterpolate(__props.course.price.toLocaleString())}</div></div></div></div>`);
          } else {
            return [
              createVNode("div", { class: "aspect-video bg-gray-200 relative" }, [
                __props.course.thumbnail || __props.course.thumbnail_url ? (openBlock(), createBlock("img", {
                  key: 0,
                  src: __props.course.thumbnail || __props.course.thumbnail_url,
                  alt: __props.course.title,
                  class: "w-full h-full object-cover"
                }, null, 8, ["src", "alt"])) : (openBlock(), createBlock("div", {
                  key: 1,
                  class: "w-full h-full flex items-center justify-center text-gray-400"
                }, [
                  (openBlock(), createBlock("svg", {
                    class: "w-16 h-16",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"
                    })
                  ]))
                ])),
                __props.course.type ? (openBlock(), createBlock("div", {
                  key: 2,
                  class: "absolute top-2 left-2 bg-green-600 text-white px-2 py-1 rounded text-xs font-medium"
                }, toDisplayString(__props.course.type), 1)) : createCommentVNode("", true)
              ]),
              createVNode("div", { class: "p-4" }, [
                createVNode("div", { class: "flex items-center gap-2 mb-2" }, [
                  createVNode("span", { class: "text-sm text-gray-500" }, ""),
                  createVNode("span", { class: "text-gray-300" }, ""),
                  createVNode("span", { class: "text-sm text-gray-500" }, "")
                ]),
                createVNode("h3", { class: "font-semibold text-lg mb-2 line-clamp-2" }, toDisplayString(__props.course.title), 1),
                __props.course.description ? (openBlock(), createBlock("p", {
                  key: 0,
                  class: "text-gray-600 text-sm mb-4 line-clamp-2"
                }, toDisplayString(__props.course.description), 1)) : createCommentVNode("", true),
                createVNode("div", { class: "flex items-center justify-between" }, [
                  createVNode("div", { class: "flex items-center gap-4" }, [
                    __props.course.rating ? (openBlock(), createBlock("div", {
                      key: 0,
                      class: "flex items-center gap-1"
                    }, [
                      (openBlock(), createBlock("svg", {
                        class: "w-4 h-4 text-yellow-400",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
                      ])),
                      createVNode("span", { class: "text-sm font-semibold" }, toDisplayString(__props.course.rating), 1)
                    ])) : createCommentVNode("", true),
                    __props.course.students ? (openBlock(), createBlock("div", {
                      key: 1,
                      class: "text-sm text-gray-500"
                    }, toDisplayString(__props.course.students.toLocaleString()) + "  ", 1)) : createCommentVNode("", true)
                  ]),
                  createVNode("div", { class: "text-right" }, [
                    __props.course.originalPrice ? (openBlock(), createBlock("div", {
                      key: 0,
                      class: "text-sm text-gray-400 line-through"
                    }, " " + toDisplayString(__props.course.originalPrice.toLocaleString()), 1)) : createCommentVNode("", true),
                    createVNode("div", { class: "text-lg font-bold text-green-600" }, " " + toDisplayString(__props.course.price.toLocaleString()), 1)
                  ])
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
});
const _sfc_setup$1d = _sfc_main$1d.setup;
_sfc_main$1d.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/CourseCard.vue");
  return _sfc_setup$1d ? _sfc_setup$1d(props, ctx) : void 0;
};
const __nuxt_component_0$a = Object.assign(_sfc_main$1d, { __name: "CourseCard" });

const _sfc_main$1c = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    useHead({
      title: "KDC School -  "
    });
    const categories = [
      { id: 1, name: "", icon: "", slug: "mathematics", count: 0 },
      { id: 2, name: "", icon: "", slug: "science", count: 0 },
      { id: 3, name: "", icon: "", slug: "thai", count: 0 },
      { id: 4, name: "", icon: "", slug: "english", count: 0 }
    ];
    const featuredCourses = ref([]);
    const loadingFeaturedCourses = ref(false);
    const stats = ref({
      yearsOfExperience: 10,
      totalStudents: 5e3,
      totalCourses: 50,
      successRate: 95
    });
    const testimonials = ref([]);
    const loadingTestimonials = ref(false);
    const featuredArticles = ref([]);
    const loadingArticles = ref(false);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      const _component_CourseCard = __nuxt_component_0$a;
      _push(`<!--[--><section class="bg-gradient-to-br from-green-500 to-green-700 text-white py-20"><div class="container mx-auto px-4"><div class="max-w-3xl mx-auto text-center"><h1 class="text-5xl font-bold mb-6">   </h1><p class="text-xl mb-8 text-green-100">   Live  VOD </p><div class="flex gap-4 justify-center">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/courses",
        class: "px-8 py-4 bg-white text-green-600 rounded-lg font-semibold hover:bg-gray-100 transition-colors shadow-lg"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/auth/register",
        class: "px-8 py-4 bg-transparent border-2 border-white text-white rounded-lg font-semibold hover:bg-white hover:text-green-600 transition-colors"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div></section><section class="py-16 bg-white"><div class="container mx-auto px-4"><h2 class="text-3xl font-bold text-center mb-12"> KDC School?</h2><div class="grid md:grid-cols-3 gap-8"><div class="text-center p-6 bg-gray-50 rounded-lg"><div class="text-5xl mb-4"></div><h3 class="text-xl font-semibold mb-2">Live Online Class</h3><p class="text-gray-600">  Real-time</p></div><div class="text-center p-6 bg-gray-50 rounded-lg"><div class="text-5xl mb-4"></div><h3 class="text-xl font-semibold mb-2">Video on Demand</h3><p class="text-gray-600"> </p></div><div class="text-center p-6 bg-gray-50 rounded-lg"><div class="text-5xl mb-4"></div><h3 class="text-xl font-semibold mb-2"></h3><p class="text-gray-600"> Kerry Express</p></div></div></div></section><section class="py-16"><div class="container mx-auto px-4"><div class="flex items-center justify-between mb-8"><h2 class="text-3xl font-bold"></h2>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/courses",
        class: "text-green-600 hover:text-green-700 font-semibold"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`   `);
          } else {
            return [
              createTextVNode("   ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div>`);
      if (unref(loadingFeaturedCourses)) {
        _push(`<div class="grid md:grid-cols-3 gap-6"><!--[-->`);
        ssrRenderList(3, (i) => {
          _push(`<div class="bg-white rounded-lg shadow animate-pulse"><div class="aspect-video bg-gray-200"></div><div class="p-4 space-y-3"><div class="h-4 bg-gray-200 rounded w-3/4"></div><div class="h-4 bg-gray-200 rounded w-full"></div><div class="h-4 bg-gray-200 rounded w-2/3"></div></div></div>`);
        });
        _push(`<!--]--></div>`);
      } else if (unref(featuredCourses).length > 0) {
        _push(`<div class="grid md:grid-cols-3 gap-6"><!--[-->`);
        ssrRenderList(unref(featuredCourses), (course) => {
          _push(ssrRenderComponent(_component_CourseCard, {
            key: course.id,
            course
          }, null, _parent));
        });
        _push(`<!--]--></div>`);
      } else {
        _push(`<div class="text-center py-8 text-gray-500"> ... </div>`);
      }
      _push(`</div></section><section class="py-16 bg-gradient-to-br from-green-600 to-green-700 text-white"><div class="container mx-auto px-4"><h2 class="text-3xl font-bold text-center mb-12"></h2><div class="grid grid-cols-2 md:grid-cols-4 gap-6 md:gap-8"><div class="text-center"><div class="text-4xl md:text-5xl font-bold mb-2">${ssrInterpolate(unref(stats).yearsOfExperience)}+</div><div class="text-green-100 text-sm md:text-base"></div></div><div class="text-center"><div class="text-4xl md:text-5xl font-bold mb-2">${ssrInterpolate(unref(stats).totalStudents.toLocaleString())}+</div><div class="text-green-100 text-sm md:text-base"></div></div><div class="text-center"><div class="text-4xl md:text-5xl font-bold mb-2">${ssrInterpolate(unref(stats).totalCourses)}+</div><div class="text-green-100 text-sm md:text-base"></div></div><div class="text-center"><div class="text-4xl md:text-5xl font-bold mb-2">${ssrInterpolate(unref(stats).successRate)}%</div><div class="text-green-100 text-sm md:text-base"></div></div></div></div></section><section class="py-16 bg-white"><div class="container mx-auto px-4"><h2 class="text-3xl font-bold text-center mb-12"></h2>`);
      if (unref(loadingTestimonials)) {
        _push(`<div class="grid md:grid-cols-3 gap-8"><!--[-->`);
        ssrRenderList(3, (i) => {
          _push(`<div class="bg-gray-50 rounded-lg p-6 shadow-sm animate-pulse"><div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div><div class="h-4 bg-gray-200 rounded w-full mb-2"></div><div class="h-4 bg-gray-200 rounded w-3/4"></div></div>`);
        });
        _push(`<!--]--></div>`);
      } else if (unref(testimonials).length > 0) {
        _push(`<div class="grid md:grid-cols-3 gap-8"><!--[-->`);
        ssrRenderList(unref(testimonials), (testimonial) => {
          _push(`<div class="bg-gray-50 rounded-lg p-6 shadow-sm"><div class="flex items-center gap-1 mb-4"><!--[-->`);
          ssrRenderList(5, (i) => {
            _push(`<svg class="${ssrRenderClass([i <= testimonial.rating ? "text-yellow-400" : "text-gray-300", "w-5 h-5"])}" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>`);
          });
          _push(`<!--]--></div><p class="text-gray-700 mb-4 italic">&quot;${ssrInterpolate(testimonial.comment)}&quot;</p><div><div class="font-semibold text-gray-900">${ssrInterpolate(testimonial.name)}</div><div class="text-sm text-gray-600">${ssrInterpolate(testimonial.role)}</div></div></div>`);
        });
        _push(`<!--]--></div>`);
      } else {
        _push(`<div class="text-center py-8 text-gray-500">  </div>`);
      }
      _push(`</div></section><section class="py-16 bg-gray-50"><div class="container mx-auto px-4"><h2 class="text-3xl font-bold text-center mb-8"></h2><p class="text-center text-gray-600 mb-8"></p><div class="grid md:grid-cols-4 gap-6"><!--[-->`);
      ssrRenderList(categories, (category) => {
        _push(ssrRenderComponent(_component_NuxtLink, {
          key: category.id,
          to: `/courses?category=${category.slug}`,
          class: "bg-white p-6 rounded-lg shadow hover:shadow-lg transition-shadow text-center group"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="text-4xl mb-4 group-hover:scale-110 transition-transform"${_scopeId}>${ssrInterpolate(category.icon)}</div><h3 class="font-semibold text-lg mb-2"${_scopeId}>${ssrInterpolate(category.name)}</h3><p class="text-gray-600 text-sm"${_scopeId}>${ssrInterpolate(category.count)} </p>`);
            } else {
              return [
                createVNode("div", { class: "text-4xl mb-4 group-hover:scale-110 transition-transform" }, toDisplayString(category.icon), 1),
                createVNode("h3", { class: "font-semibold text-lg mb-2" }, toDisplayString(category.name), 1),
                createVNode("p", { class: "text-gray-600 text-sm" }, toDisplayString(category.count) + " ", 1)
              ];
            }
          }),
          _: 2
        }, _parent));
      });
      _push(`<!--]--></div></div></section><section class="py-16 bg-white"><div class="container mx-auto px-4"><div class="flex items-center justify-between mb-8"><h2 class="text-3xl font-bold"> </h2>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/articles",
        class: "text-green-600 hover:text-green-700 font-semibold"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`   `);
          } else {
            return [
              createTextVNode("   ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div>`);
      if (unref(loadingArticles)) {
        _push(`<div class="grid md:grid-cols-3 gap-6"><!--[-->`);
        ssrRenderList(3, (i) => {
          _push(`<div class="bg-white rounded-lg shadow animate-pulse"><div class="aspect-video bg-gray-200"></div><div class="p-6 space-y-3"><div class="h-4 bg-gray-200 rounded w-1/4"></div><div class="h-4 bg-gray-200 rounded w-full"></div><div class="h-4 bg-gray-200 rounded w-2/3"></div></div></div>`);
        });
        _push(`<!--]--></div>`);
      } else if (unref(featuredArticles).length > 0) {
        _push(`<div class="grid md:grid-cols-3 gap-6"><!--[-->`);
        ssrRenderList(unref(featuredArticles), (article) => {
          _push(ssrRenderComponent(_component_NuxtLink, {
            key: article.id,
            to: `/articles/${article.slug}`,
            class: "bg-white rounded-lg shadow hover:shadow-lg transition-shadow overflow-hidden cursor-pointer block"
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`<div class="aspect-video bg-gradient-to-br from-green-400 to-green-600 flex items-center justify-center"${_scopeId}><div class="text-4xl"${_scopeId}>${ssrInterpolate(article.icon || "")}</div></div><div class="p-6"${_scopeId}><div class="text-sm text-gray-500 mb-2"${_scopeId}>${ssrInterpolate(article.category || "")}</div><h3 class="text-lg font-semibold mb-2 line-clamp-2"${_scopeId}>${ssrInterpolate(article.title)}</h3><p class="text-gray-600 text-sm mb-4 line-clamp-2"${_scopeId}>${ssrInterpolate(article.excerpt || "")}</p><div class="text-sm text-green-600 font-semibold"${_scopeId}> </div></div>`);
              } else {
                return [
                  createVNode("div", { class: "aspect-video bg-gradient-to-br from-green-400 to-green-600 flex items-center justify-center" }, [
                    createVNode("div", { class: "text-4xl" }, toDisplayString(article.icon || ""), 1)
                  ]),
                  createVNode("div", { class: "p-6" }, [
                    createVNode("div", { class: "text-sm text-gray-500 mb-2" }, toDisplayString(article.category || ""), 1),
                    createVNode("h3", { class: "text-lg font-semibold mb-2 line-clamp-2" }, toDisplayString(article.title), 1),
                    createVNode("p", { class: "text-gray-600 text-sm mb-4 line-clamp-2" }, toDisplayString(article.excerpt || ""), 1),
                    createVNode("div", { class: "text-sm text-green-600 font-semibold" }, " ")
                  ])
                ];
              }
            }),
            _: 2
          }, _parent));
        });
        _push(`<!--]--></div>`);
      } else {
        _push(`<div class="text-center py-8 text-gray-500">  </div>`);
      }
      _push(`</div></section><!--]-->`);
    };
  }
});
const _sfc_setup$1c = _sfc_main$1c.setup;
_sfc_main$1c.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/index.vue");
  return _sfc_setup$1c ? _sfc_setup$1c(props, ctx) : void 0;
};

const indexCyzpvD2m = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$1c
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1b = /* @__PURE__ */ defineComponent({
  __name: "careers",
  __ssrInlineRender: true,
  setup(__props) {
    const page = ref(null);
    const loading = ref(true);
    const error = ref(null);
    useHead({
      title: () => page.value?.meta_title || page.value?.title || "/",
      meta: [
        {
          name: "description",
          content: () => page.value?.meta_description || "/ - KDC Tutor School"
        },
        {
          name: "keywords",
          content: () => page.value?.meta_keywords || ""
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50 py-8" }, _attrs))} data-v-c92df7ab><div class="container mx-auto px-4 py-12 max-w-4xl" data-v-c92df7ab>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-20" data-v-c92df7ab><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600" data-v-c92df7ab></div><p class="mt-4 text-gray-600" data-v-c92df7ab>...</p></div>`);
      } else if (unref(page)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8" data-v-c92df7ab><h1 class="text-4xl font-bold text-gray-900 mb-6" data-v-c92df7ab>${ssrInterpolate(unref(page).title)}</h1><div class="prose prose-lg max-w-none" data-v-c92df7ab>${unref(page).content ?? ""}</div></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-c92df7ab><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-c92df7ab></h1><p class="text-gray-600 mb-6" data-v-c92df7ab>${ssrInterpolate(unref(error))}</p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      } else {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-c92df7ab><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-c92df7ab></h1><p class="text-gray-600 mb-6" data-v-c92df7ab> </p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$1b = _sfc_main$1b.setup;
_sfc_main$1b.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/careers.vue");
  return _sfc_setup$1b ? _sfc_setup$1b(props, ctx) : void 0;
};
const careers = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["__scopeId", "data-v-c92df7ab"]]);

const careersD6l1aock = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: careers
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1a = /* @__PURE__ */ defineComponent({
  __name: "contact",
  __ssrInlineRender: true,
  setup(__props) {
    const page = ref(null);
    const loading = ref(true);
    const error = ref(null);
    useHead({
      title: () => page.value?.meta_title || page.value?.title || "",
      meta: [
        {
          name: "description",
          content: () => page.value?.meta_description || " - KDC Tutor School"
        },
        {
          name: "keywords",
          content: () => page.value?.meta_keywords || ""
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50 py-8" }, _attrs))} data-v-db1b781d><div class="container mx-auto px-4 py-12 max-w-4xl" data-v-db1b781d>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-20" data-v-db1b781d><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600" data-v-db1b781d></div><p class="mt-4 text-gray-600" data-v-db1b781d>...</p></div>`);
      } else if (unref(page)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8" data-v-db1b781d><h1 class="text-4xl font-bold text-gray-900 mb-6" data-v-db1b781d>${ssrInterpolate(unref(page).title)}</h1><div class="prose prose-lg max-w-none" data-v-db1b781d>${unref(page).content ?? ""}</div></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-db1b781d><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-db1b781d></h1><p class="text-gray-600 mb-6" data-v-db1b781d>${ssrInterpolate(unref(error))}</p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      } else {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-db1b781d><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-db1b781d></h1><p class="text-gray-600 mb-6" data-v-db1b781d> </p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$1a = _sfc_main$1a.setup;
_sfc_main$1a.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/contact.vue");
  return _sfc_setup$1a ? _sfc_setup$1a(props, ctx) : void 0;
};
const contact = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["__scopeId", "data-v-db1b781d"]]);

const contact57Wsn9cM = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: contact
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$19 = /* @__PURE__ */ defineComponent({
  __name: "support",
  __ssrInlineRender: true,
  setup(__props) {
    const page = ref(null);
    const loading = ref(true);
    const error = ref(null);
    useHead({
      title: () => page.value?.meta_title || page.value?.title || "",
      meta: [
        {
          name: "description",
          content: () => page.value?.meta_description || " - KDC Tutor School"
        },
        {
          name: "keywords",
          content: () => page.value?.meta_keywords || ""
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50 py-8" }, _attrs))} data-v-5dfe78b0><div class="container mx-auto px-4 py-12 max-w-4xl" data-v-5dfe78b0>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-20" data-v-5dfe78b0><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600" data-v-5dfe78b0></div><p class="mt-4 text-gray-600" data-v-5dfe78b0>...</p></div>`);
      } else if (unref(page)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8" data-v-5dfe78b0><h1 class="text-4xl font-bold text-gray-900 mb-6" data-v-5dfe78b0>${ssrInterpolate(unref(page).title)}</h1><div class="prose prose-lg max-w-none" data-v-5dfe78b0>${unref(page).content ?? ""}</div></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-5dfe78b0><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-5dfe78b0></h1><p class="text-gray-600 mb-6" data-v-5dfe78b0>${ssrInterpolate(unref(error))}</p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      } else {
        _push(`<div class="bg-white rounded-lg shadow-sm p-8 text-center" data-v-5dfe78b0><h1 class="text-3xl font-bold text-gray-900 mb-4" data-v-5dfe78b0></h1><p class="text-gray-600 mb-6" data-v-5dfe78b0> </p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "inline-block px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$19 = _sfc_main$19.setup;
_sfc_main$19.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/support.vue");
  return _sfc_setup$19 ? _sfc_setup$19(props, ctx) : void 0;
};
const support = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["__scopeId", "data-v-5dfe78b0"]]);

const supportApQFj3ne = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: support
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$18 = /* @__PURE__ */ defineComponent({
  __name: "login",
  __ssrInlineRender: true,
  setup(__props) {
    useAuth();
    useRoute();
    useRouter();
    const form = reactive({
      username: "",
      password: ""
    });
    const loading = ref(false);
    const error = ref("");
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-[calc(100vh-200px)] flex items-center justify-center py-12" }, _attrs))}><div class="max-w-md w-full mx-4"><div class="bg-white rounded-lg shadow-lg p-8"><h1 class="text-3xl font-bold text-center mb-8"></h1><form class="space-y-6"><div><label for="username" class="block text-sm font-medium text-gray-700 mb-2">  </label><input id="username"${ssrRenderAttr("value", unref(form).username)} type="text" required class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder="username  email"></div><div><label for="password" class="block text-sm font-medium text-gray-700 mb-2">  </label><input id="password"${ssrRenderAttr("value", unref(form).password)} type="password" required class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder=""></div><div class="flex items-center justify-between"><label class="flex items-center cursor-pointer"><input type="checkbox" class="w-4 h-4 rounded border-gray-300 text-green-600 focus:ring-green-500 bg-white checked:bg-green-600 checked:border-green-600"><span class="ml-2 text-sm text-gray-600"></span></label>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/auth/forgot-password",
        class: "text-sm text-green-600 hover:text-green-700"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(` ? `);
          } else {
            return [
              createTextVNode(" ? ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div>`);
      if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="w-full py-3 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">`);
      if (unref(loading)) {
        _push(`<span>...</span>`);
      } else {
        _push(`<span></span>`);
      }
      _push(`</button></form><div class="mt-6 text-center"><p class="text-gray-600"> ? `);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/auth/register",
        class: "text-green-600 hover:text-green-700 font-semibold"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</p></div></div></div></div>`);
    };
  }
});
const _sfc_setup$18 = _sfc_main$18.setup;
_sfc_main$18.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/auth/login.vue");
  return _sfc_setup$18 ? _sfc_setup$18(props, ctx) : void 0;
};

const loginDEr0jyvp = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$18
}, Symbol.toStringTag, { value: 'Module' }));

const useUnreadMessages = () => {
  const config = useRuntimeConfig();
  const { accessToken, user } = useAuth();
  const unreadCount = ref(0);
  const loading = ref(false);
  const calculateUnreadCount = (rooms) => {
    return rooms.reduce((total, room) => {
      return total + (room.unread_count || 0);
    }, 0);
  };
  const fetchUnreadCount = async () => {
    if (!accessToken.value || !user.value) {
      unreadCount.value = 0;
      return;
    }
    loading.value = true;
    try {
      const response = await $fetch(
        `${config.public.apiBase}/chat/rooms`,
        {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        }
      );
      if (response.success) {
        unreadCount.value = calculateUnreadCount(response.data);
      }
    } catch (error) {
      console.error("[UnreadMessages] Error fetching unread count:", error);
      unreadCount.value = 0;
    } finally {
      loading.value = false;
    }
  };
  const updateUnreadCount = (rooms) => {
    unreadCount.value = calculateUnreadCount(rooms);
  };
  const resetUnreadCount = () => {
    unreadCount.value = 0;
  };
  watch$1([accessToken, user], ([token, currentUser]) => {
    if (token && currentUser) {
      fetchUnreadCount();
    } else {
      unreadCount.value = 0;
    }
  }, { immediate: true });
  return {
    unreadCount: readonly(unreadCount),
    loading: readonly(loading),
    fetchUnreadCount,
    updateUnreadCount,
    resetUnreadCount
  };
};

const _sfc_main$9$1 = /* @__PURE__ */ defineComponent({
  __name: "ChatRoomList",
  __ssrInlineRender: true,
  props: {
    rooms: {},
    activeRoom: {},
    loading: { type: Boolean, default: false }
  },
  emits: ["select-room", "create-room"],
  setup(__props, { emit: __emit }) {
    const { user, hasAnyRole } = useAuth();
    const canCreateRoom = computed(() => {
      return hasAnyRole(["student", "parent"]);
    });
    const getOtherUser = (room) => {
      if (!user.value) return null;
      return room.student_id === user.value.id ? room.tutor : room.student;
    };
    const formatDate = (dateString) => {
      if (!dateString) return "";
      try {
        return formatDistanceToNow(new Date(dateString), {
          addSuffix: true,
          locale: th
        });
      } catch {
        return dateString;
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "h-full flex flex-col" }, _attrs))}><div class="p-4 border-b"><div class="flex items-center justify-between mb-2"><h2 class="text-lg font-semibold"></h2></div>`);
      if (unref(canCreateRoom)) {
        _push(`<button class="w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-medium flex items-center justify-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div class="flex-1 overflow-y-auto">`);
      if (__props.loading) {
        _push(`<div class="p-4 text-center text-gray-500"> ... </div>`);
      } else if (__props.rooms.length === 0) {
        _push(`<div class="p-4 text-center text-gray-500">  </div>`);
      } else {
        _push(`<div class="divide-y"><!--[-->`);
        ssrRenderList(__props.rooms, (room) => {
          _push(`<button class="${ssrRenderClass([
            "w-full p-4 text-left hover:bg-gray-50 transition-colors",
            __props.activeRoom?.id === room.id ? "bg-green-50 border-l-4 border-l-green-600" : ""
          ])}"><div class="flex items-start space-x-3"><div class="flex-shrink-0"><div class="w-12 h-12 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden">`);
          if (getOtherUser(room)?.avatar_url) {
            _push(`<img${ssrRenderAttr("src", getOtherUser(room)?.avatar_url)}${ssrRenderAttr("alt", getOtherUser(room)?.first_name)} class="w-full h-full object-cover">`);
          } else {
            _push(`<span class="text-gray-500 text-lg font-semibold">${ssrInterpolate(getOtherUser(room)?.first_name?.charAt(0))}</span>`);
          }
          _push(`</div></div><div class="flex-1 min-w-0"><div class="flex items-center justify-between mb-1"><h3 class="font-semibold text-gray-900 truncate">${ssrInterpolate(getOtherUser(room)?.first_name)} ${ssrInterpolate(getOtherUser(room)?.last_name)}</h3>`);
          if (room.unread_count && room.unread_count > 0) {
            _push(`<span class="ml-2 flex-shrink-0 bg-green-600 text-white text-xs font-semibold rounded-full px-2 py-1 min-w-[20px] text-center">${ssrInterpolate(room.unread_count > 99 ? "99+" : room.unread_count)}</span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div><p class="text-sm text-gray-600 truncate">${ssrInterpolate(room.course?.title)}</p>`);
          if (room.last_message_at) {
            _push(`<p class="text-xs text-gray-400 mt-1">${ssrInterpolate(formatDate(room.last_message_at))}</p>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div></button>`);
        });
        _push(`<!--]--></div>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$9$1 = _sfc_main$9$1.setup;
_sfc_main$9$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/ChatRoomList.vue");
  return _sfc_setup$9$1 ? _sfc_setup$9$1(props, ctx) : void 0;
};
const ChatRoomList = Object.assign(_sfc_main$9$1, { __name: "ChatRoomList" });
const _sfc_main$8$1 = /* @__PURE__ */ defineComponent({
  __name: "ChatMessage",
  __ssrInlineRender: true,
  props: {
    message: {},
    currentUserId: {}
  },
  emits: ["image-click", "reply", "pin", "scroll-to-message"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const isOwnMessage = computed(() => props.message.sender_id === props.currentUserId);
    const showMenu = ref(false);
    const showContextMenu = ref(false);
    const formatTime = (dateString) => {
      try {
        return format$4(new Date(dateString), "HH:mm", { locale: th });
      } catch {
        return dateString;
      }
    };
    const formatFileSize = (bytes) => {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({
        class: [
          "flex mb-4",
          unref(isOwnMessage) ? "justify-end" : "justify-start"
        ]
      }, _attrs))}><div class="${ssrRenderClass(["flex space-x-2 max-w-[70%]", unref(isOwnMessage) ? "flex-row-reverse space-x-reverse" : ""])}">`);
      if (!unref(isOwnMessage)) {
        _push(`<div class="flex-shrink-0"><div class="w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden">`);
        if (__props.message.sender?.avatar_url) {
          _push(`<img${ssrRenderAttr("src", __props.message.sender.avatar_url)}${ssrRenderAttr("alt", __props.message.sender.first_name)} class="w-full h-full object-cover">`);
        } else {
          _push(`<span class="text-gray-500 text-sm font-semibold">${ssrInterpolate(__props.message.sender?.first_name?.charAt(0))}</span>`);
        }
        _push(`</div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="${ssrRenderClass(["flex flex-col group relative", unref(isOwnMessage) ? "items-end" : "items-start"])}">`);
      if (!unref(isOwnMessage)) {
        _push(`<span class="text-xs text-gray-500 mb-1 px-1">${ssrInterpolate(__props.message.sender?.first_name)} ${ssrInterpolate(__props.message.sender?.last_name)}</span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex items-center space-x-2"><div class="${ssrRenderClass([
        "rounded-lg px-4 py-2 relative",
        unref(isOwnMessage) ? "bg-green-600 text-white" : "bg-gray-100 text-gray-900"
      ])}">`);
      if (__props.message.reply_to) {
        _push(`<div class="${ssrRenderClass([
          "mb-2 pb-2 border-l-4 pl-2 cursor-pointer hover:opacity-90 transition-opacity",
          unref(isOwnMessage) ? "border-white text-white bg-white bg-opacity-20 rounded" : "border-gray-500 text-gray-700 bg-gray-50 rounded"
        ])}"><div class="${ssrRenderClass(["font-semibold mb-0.5", unref(isOwnMessage) ? "text-white" : "text-gray-800"])}">${ssrInterpolate(__props.message.reply_to.sender?.first_name)} ${ssrInterpolate(__props.message.reply_to.sender?.last_name)}</div><div class="${ssrRenderClass(["truncate", unref(isOwnMessage) ? "text-white" : "text-gray-700"])}">${ssrInterpolate(__props.message.reply_to.content || (__props.message.reply_to.file_name || ""))}</div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (__props.message.message_type === "text") {
        _push(`<p class="whitespace-pre-wrap break-words">${ssrInterpolate(__props.message.content)}</p>`);
      } else if (__props.message.message_type === "image") {
        _push(`<div class="max-w-sm">`);
        if (__props.message.file_url) {
          _push(`<img${ssrRenderAttr("src", __props.message.file_url)}${ssrRenderAttr("alt", __props.message.content || "Image")} class="rounded-lg max-w-full h-auto cursor-pointer">`);
        } else {
          _push(`<!---->`);
        }
        if (__props.message.content) {
          _push(`<p class="mt-2 text-sm opacity-90">${ssrInterpolate(__props.message.content)}</p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      } else if (__props.message.message_type === "file") {
        _push(`<div class="flex items-center space-x-2"><svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg><div class="flex-1 min-w-0"><a${ssrRenderAttr("href", __props.message.file_url)} target="_blank" rel="noopener noreferrer" class="text-sm font-medium hover:underline truncate block">${ssrInterpolate(__props.message.file_name || "")}</a>`);
        if (__props.message.file_size) {
          _push(`<p class="text-xs opacity-75">${ssrInterpolate(formatFileSize(__props.message.file_size))}</p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (unref(showMenu)) {
        _push(`<button class="p-1 text-gray-400 hover:text-gray-600 transition-colors flex-shrink-0" type="button"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg></button>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (unref(showContextMenu)) {
        _push(`<div class="${ssrRenderClass([
          "absolute z-50 bg-white border border-gray-200 rounded-lg shadow-lg py-1 min-w-[150px]",
          unref(isOwnMessage) ? "right-0" : "left-0"
        ])}" style="${ssrRenderStyle({ "top": "100%", "margin-top": "4px" })}"><button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 transition-colors">  </button><button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 transition-colors">  </button><button class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 transition-colors">${ssrInterpolate(__props.message.is_pinned ? "" : "")}</button></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<span class="text-xs text-gray-400 mt-1 px-1">${ssrInterpolate(formatTime(__props.message.created_at))}</span></div></div></div>`);
    };
  }
});
const _sfc_setup$8$1 = _sfc_main$8$1.setup;
_sfc_main$8$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/ChatMessage.vue");
  return _sfc_setup$8$1 ? _sfc_setup$8$1(props, ctx) : void 0;
};
const ChatMessage = Object.assign(_sfc_main$8$1, { __name: "ChatMessage" });
const useChatSocket = () => {
  useAuth();
  const socket = ref(null);
  const connected = ref(false);
  const connect = () => {
    {
      console.warn("[Chat Socket] Cannot connect in server-side");
      return;
    }
  };
  const disconnect = () => {
    if (socket.value) {
      socket.value.disconnect();
      socket.value = null;
      connected.value = false;
      console.log("[Chat Socket]   Disconnected");
    }
  };
  const joinRoom = (roomId) => {
    if (socket.value && connected.value) {
      console.log(`[Chat Socket]  Emitting join_room for room ${roomId}`, {
        socketId: socket.value.id,
        connected: connected.value
      });
      socket.value.emit("join_room", { roomId });
      socket.value.once("room_joined", (data) => {
        console.log(`[Chat Socket]  Successfully joined room ${data.roomId}`);
      });
      socket.value.once("error", (error) => {
        console.error(`[Chat Socket]  Error joining room ${roomId}:`, error.message);
      });
    } else {
      console.warn("[Chat Socket]   Cannot join room: not connected", {
        hasSocket: !!socket.value,
        connected: connected.value,
        roomId
      });
    }
  };
  const leaveRoom = (roomId) => {
    if (socket.value && connected.value) {
      socket.value.emit("leave_room", { roomId });
      console.log(`[Chat Socket]  Leaving room ${roomId}`);
    }
  };
  const on = (event, callback) => {
    if (socket.value) {
      const hasListener = socket.value.hasListeners(event);
      if (hasListener) {
        console.log(`[Chat Socket]  Event ${event} already has listeners, removing old ones first`);
        socket.value.off(event);
      }
      socket.value.on(event, callback);
      console.log(`[Chat Socket]  Listening to event: ${event}`, {
        socketId: socket.value.id,
        connected: socket.value.connected
      });
    } else {
      console.warn(`[Chat Socket]  Cannot listen to ${event}: socket not available`);
    }
  };
  const off = (event, callback) => {
    if (socket.value) {
      socket.value.off(event, callback);
    }
  };
  const emit = (event, data) => {
    if (socket.value && connected.value) {
      socket.value.emit(event, data);
    } else {
      console.warn(`[Chat Socket] Cannot emit ${event}: not connected`);
    }
  };
  return {
    socket: readonly(socket),
    connected: readonly(connected),
    connect,
    disconnect,
    joinRoom,
    leaveRoom,
    on,
    off,
    emit
  };
};
const useChat = () => {
  const config = useRuntimeConfig();
  const { accessToken, user } = useAuth();
  const rooms = ref([]);
  const activeRoom = ref(null);
  const messages = ref([]);
  const typingUsers = ref(/* @__PURE__ */ new Map());
  const {
    socket,
    connected,
    connect: connectSocket,
    disconnect: disconnectSocket,
    joinRoom: joinRoomSocket,
    leaveRoom: leaveRoomSocket,
    emit: socketEmit
  } = useChatSocket();
  const targetRoomId = ref(null);
  watch$1([connected, targetRoomId], ([isConnected, roomId]) => {
    if (isConnected && roomId) {
      console.log(`[Chat]  Both connected and roomId ready, joining room ${roomId}`);
      joinRoomSocket(roomId);
    }
  }, { immediate: true });
  const loadRooms = async () => {
    try {
      const response = await $fetch(
        `${config.public.apiBase}/chat/rooms`,
        {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        }
      );
      if (response.success) {
        rooms.value = response.data;
        if (connected.value) {
          response.data.forEach((room) => {
            joinRoomSocket(room.id);
          });
        } else {
          if (response.data.length > 0) {
            targetRoomId.value = response.data[0].id;
          }
        }
        if (false) ;
      }
    } catch (error) {
      console.error("[Chat] Error loading rooms:", error);
    }
  };
  const loadRoom = async (roomId) => {
    try {
      const response = await $fetch(
        `${config.public.apiBase}/chat/rooms/${roomId}`,
        {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        }
      );
      if (response.success) {
        activeRoom.value = response.data;
        console.log("[Chat]  Loaded room:", {
          roomId: response.data.id,
          studentId: response.data.student_id,
          tutorId: response.data.tutor_id
        });
        if (connected.value) {
          console.log(`[Chat]  Joining room ${roomId} via Socket.IO`);
          joinRoomSocket(roomId);
        } else {
          console.warn(`[Chat]   Socket.IO not connected, cannot join room ${roomId}`);
        }
        return response.data;
      }
    } catch (error) {
      console.error("[Chat] Error loading room:", error);
      throw error;
    }
  };
  const loadMessages = async (roomId, limit = 50, offset = 0) => {
    try {
      const response = await $fetch(
        `${config.public.apiBase}/chat/rooms/${roomId}/messages?limit=${limit}&offset=${offset}`,
        {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        }
      );
      if (response.success) {
        if (offset === 0) {
          const otherRoomMessages = messages.value.filter((m) => m.room_id !== roomId);
          messages.value = [...otherRoomMessages, ...response.data];
          console.log("[Chat]  First load messages for room:", {
            roomId,
            apiCount: response.data.length,
            otherRoomsCount: otherRoomMessages.length,
            totalCount: messages.value.length
          });
        } else {
          const existingIds = new Set(messages.value.map((m) => m.id));
          const newMessages = response.data.filter((msg) => !existingIds.has(msg.id));
          messages.value = [...newMessages, ...messages.value];
          console.log("[Chat]  Loaded more messages for room:", {
            roomId,
            apiCount: response.data.length,
            newCount: newMessages.length,
            totalCount: messages.value.length
          });
        }
        return response.data;
      }
    } catch (error) {
      console.error("[Chat] Error loading messages:", error);
      throw error;
    }
  };
  const joinRoom = (roomId) => {
    targetRoomId.value = roomId;
  };
  const leaveRoom = (roomId) => {
    if (connected.value) {
      leaveRoomSocket(roomId);
    }
    if (targetRoomId.value === roomId) {
      targetRoomId.value = null;
    }
  };
  const sendingMessages = ref(/* @__PURE__ */ new Set());
  const sendMessage = async (data) => {
    const messageContent = data.content || "";
    `${data.room_id}-${messageContent}-${Date.now()}`;
    console.log("[Chat]  sendMessage called:", {
      roomId: data.room_id,
      content: messageContent,
      messageType: data.message_type,
      userId: user.value?.id,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    const duplicateKey = `${data.room_id}-${messageContent}`;
    if (sendingMessages.value.has(duplicateKey)) {
      console.log("[Chat]  Message already being sent, skipping duplicate:", messageContent.substring(0, 50));
      return;
    }
    sendingMessages.value.add(duplicateKey);
    console.log("[Chat]  Message marked as sending, duplicateKey:", duplicateKey);
    try {
      const tempId = `temp-${Date.now()}-${Math.random()}`;
      const optimisticMessage = {
        id: tempId,
        room_id: data.room_id,
        sender_id: user.value?.id || 0,
        message_type: data.message_type || "text",
        content: messageContent,
        file_url: data.file_url || null,
        file_name: data.file_name || null,
        file_size: data.file_size || null,
        file_type: data.file_type || null,
        is_read: false,
        read_at: null,
        created_at: (/* @__PURE__ */ new Date()).toISOString(),
        sender: {
          id: user.value?.id || 0,
          first_name: user.value?.first_name || "",
          last_name: user.value?.last_name || "",
          avatar_url: user.value?.avatar_url || null
        }
      };
      const hasOptimistic = messages.value.some((m) => {
        const id = m.id;
        return typeof id === "string" && id.startsWith("temp-") && m.content === messageContent && m.room_id === data.room_id;
      });
      if (!hasOptimistic) {
        messages.value = [...messages.value, optimisticMessage];
      }
      console.log("[Chat]  Sending message via REST API:", {
        roomId: data.room_id,
        content: data.content?.substring(0, 50),
        messageType: data.message_type,
        apiUrl: `${config.public.apiBase}/chat/rooms/${data.room_id}/messages`,
        hasToken: !!accessToken.value
      });
      const response = await $fetch(
        `${config.public.apiBase}/chat/rooms/${data.room_id}/messages`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          },
          body: {
            content: data.content,
            message_type: data.message_type || "text",
            file_url: data.file_url,
            file_name: data.file_name,
            file_size: data.file_size,
            file_type: data.file_type,
            reply_to_id: data.reply_to_id || null
          }
        }
      );
      console.log("[Chat]  REST API response received:", {
        success: response.success,
        messageId: response.data?.id,
        content: response.data?.content?.substring(0, 50),
        roomId: response.data?.room_id
      });
      if (response.success) {
        console.log("[Chat]  REST API response received:", {
          messageId: response.data.id,
          content: response.data.content?.substring(0, 50)
        });
        const tempIndex = messages.value.findIndex((m) => {
          const id = m.id;
          return typeof id === "string" && id.startsWith("temp-") && m.content === messageContent && m.sender_id === user.value?.id && m.room_id === data.room_id;
        });
        if (tempIndex !== -1) {
          const newMessages = [...messages.value];
          newMessages[tempIndex] = response.data;
          messages.value = newMessages;
          console.log("[Chat]  Replaced optimistic message with real message");
        } else {
          const exists = messages.value.some((m) => m.id === response.data.id);
          if (!exists) {
            messages.value = [...messages.value, response.data];
            console.log("[Chat]  Added real message from REST API");
          }
        }
      }
    } catch (error) {
      console.error("[Chat]  Error sending message via REST API:", error);
      const tempIndex = messages.value.findIndex((m) => {
        const id = m.id;
        return typeof id === "string" && id.startsWith("temp-") && m.content === messageContent && m.sender_id === user.value?.id && m.room_id === data.room_id;
      });
      if (tempIndex !== -1) {
        const newMessages = [...messages.value];
        newMessages.splice(tempIndex, 1);
        messages.value = newMessages;
      }
      throw error;
    } finally {
      setTimeout(() => {
        sendingMessages.value.delete(duplicateKey);
      }, 2e3);
    }
  };
  const markAsRead = async (roomId, messageId) => {
    if (connected.value) {
      socketEmit("mark_read", { roomId, messageId });
    } else {
      try {
        await $fetch(`${config.public.apiBase}/chat/rooms/${roomId}/messages/read`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          },
          body: {
            messageId
          }
        });
      } catch (error) {
        console.error("[Chat] Error marking messages as read:", error);
      }
    }
    const room = rooms.value.find((r) => r.id === roomId);
    if (room) {
      room.unread_count = 0;
    }
  };
  const startTyping = async (roomId) => {
    if (connected.value) {
      socketEmit("typing", { roomId });
    } else {
      try {
        await $fetch(`${config.public.apiBase}/chat/rooms/${roomId}/typing`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
      } catch (error) {
        console.error("[Chat] Error starting typing:", error);
      }
    }
  };
  const stopTyping = async (roomId) => {
    if (connected.value) {
      socketEmit("stop_typing", { roomId });
    } else {
      try {
        await $fetch(`${config.public.apiBase}/chat/rooms/${roomId}/typing/stop`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
      } catch (error) {
        console.error("[Chat] Error stopping typing:", error);
      }
    }
  };
  const uploadFile = async (roomId, file, fileType = "image") => {
    const formData = new FormData();
    formData.append("file", file);
    const response = await $fetch(`${config.public.apiBase}/chat/upload?roomId=${roomId}&fileType=${fileType}`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${accessToken.value}`
      },
      body: formData
    });
    if (response.success) {
      return response.data;
    } else {
      throw new Error("Failed to upload file");
    }
  };
  const getRoomMessages = (roomId) => {
    return messages.value.filter((m) => m.room_id === roomId);
  };
  const sortedMessages = computed(() => {
    if (!activeRoom.value?.id) {
      return [];
    }
    const roomMessages = messages.value.filter((m) => m.room_id === activeRoom.value.id);
    const sorted = [...roomMessages].sort((a, b) => {
      const timeA = new Date(a.created_at).getTime();
      const timeB = new Date(b.created_at).getTime();
      return timeA - timeB;
    });
    console.log("[Chat]  sortedMessages computed:", {
      roomId: activeRoom.value.id,
      count: sorted.length,
      messageIds: sorted.map((m) => m.id).slice(-5)
    });
    return sorted;
  });
  const getTypingUsers = (roomId) => {
    const users = typingUsers.value.get(roomId);
    return users ? Array.from(users) : [];
  };
  const clearMessages = (roomId) => {
    messages.value = messages.value.filter((m) => m.room_id !== roomId);
  };
  const setActiveRoom = (room) => {
    console.log("[Chat]  setActiveRoom called:", {
      roomId: room?.id || "null",
      previousRoomId: activeRoom.value?.id,
      connected: connected.value
    });
    if (activeRoom.value && connected.value) {
      console.log(`[Chat]  Leaving previous room ${activeRoom.value.id}`);
      leaveRoomSocket(activeRoom.value.id);
    }
    activeRoom.value = room;
    if (activeRoom.value) {
      targetRoomId.value = activeRoom.value.id;
    } else {
      targetRoomId.value = null;
    }
  };
  const setupChatEventListeners = () => {
    {
      console.warn("[Chat] Cannot setup event listeners in server-side");
      return;
    }
  };
  return {
    connected: readonly(connected),
    socket,
    //  Return socket for checking availability
    rooms: readonly(rooms),
    activeRoom: readonly(activeRoom),
    messages: readonly(messages),
    //  UI reads only
    sortedMessages,
    //  Computed property for UI
    typingUsers: readonly(typingUsers),
    connect: connectSocket,
    disconnect: disconnectSocket,
    loadRooms,
    loadRoom,
    loadMessages,
    joinRoom,
    leaveRoom,
    sendMessage,
    markAsRead,
    startTyping,
    stopTyping,
    uploadFile,
    getRoomMessages,
    getTypingUsers,
    clearMessages,
    setActiveRoom,
    setupChatEventListeners
  };
};
const _sfc_main$7$1 = /* @__PURE__ */ defineComponent({
  __name: "ChatInput",
  __ssrInlineRender: true,
  props: {
    roomId: {},
    placeholder: {},
    uploading: { type: Boolean },
    sending: { type: Boolean },
    replyingTo: {}
  },
  emits: ["send-message", "typing", "cancel-reply"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const messageText = ref("");
    ref(null);
    ref(null);
    const previewFile = ref(null);
    const previewFileUrl = ref("");
    const error = ref("");
    ref(null);
    ref("");
    ref(0);
    const showEmojiPicker = ref(false);
    ref(null);
    const commonEmojis = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "",
      "",
      "#",
      "*",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
    const canSend = computed(() => {
      return (messageText.value.trim().length > 0 || previewFile.value !== null) && !props.uploading && !props.sending;
    });
    const formatFileSize = (bytes) => {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "border-t p-4 bg-white relative" }, _attrs))} data-v-c9b7ef97>`);
      if (__props.replyingTo) {
        _push(`<div class="mb-3 p-3 bg-gray-50 rounded-lg border-l-4 border-l-green-600 flex items-start justify-between" data-v-c9b7ef97><div class="flex-1 min-w-0" data-v-c9b7ef97><div class="text-xs text-gray-500 mb-1" data-v-c9b7ef97>  ${ssrInterpolate(__props.replyingTo.sender?.first_name)} ${ssrInterpolate(__props.replyingTo.sender?.last_name)}</div><div class="text-sm text-gray-700 truncate" data-v-c9b7ef97>${ssrInterpolate(__props.replyingTo.content || (__props.replyingTo.file_name || ""))}</div></div><button class="ml-2 text-gray-500 hover:text-gray-700 flex-shrink-0" data-v-c9b7ef97><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-c9b7ef97><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" data-v-c9b7ef97></path></svg></button></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(previewFile)) {
        _push(`<div class="mb-3 p-3 bg-gray-50 rounded-lg flex items-center justify-between" data-v-c9b7ef97><div class="flex items-center space-x-3 flex-1 min-w-0" data-v-c9b7ef97>`);
        if (unref(previewFile).type.startsWith("image/")) {
          _push(`<img${ssrRenderAttr("src", unref(previewFileUrl))} alt="Preview" class="w-16 h-16 object-cover rounded" data-v-c9b7ef97>`);
        } else {
          _push(`<svg class="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-c9b7ef97><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" data-v-c9b7ef97></path></svg>`);
        }
        _push(`<div class="flex-1 min-w-0" data-v-c9b7ef97><p class="text-sm font-medium text-gray-900 truncate" data-v-c9b7ef97>${ssrInterpolate(unref(previewFile).name)}</p><p class="text-xs text-gray-500" data-v-c9b7ef97>${ssrInterpolate(formatFileSize(unref(previewFile).size))}</p></div></div><button class="ml-2 text-red-600 hover:text-red-700" data-v-c9b7ef97><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-c9b7ef97><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" data-v-c9b7ef97></path></svg></button></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex items-center space-x-2" data-v-c9b7ef97><div class="relative" data-v-c9b7ef97><button class="p-2 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-lg transition-colors self-center"${ssrIncludeBooleanAttr(__props.uploading || __props.sending) ? " disabled" : ""} title=" emoji" data-v-c9b7ef97><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-c9b7ef97><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-c9b7ef97></path></svg></button>`);
      if (unref(showEmojiPicker)) {
        _push(`<div class="absolute bottom-full mb-2 left-0 bg-white border border-gray-200 rounded-lg shadow-xl p-3 w-64 h-64 overflow-y-auto z-[100]" data-v-c9b7ef97><div class="grid grid-cols-8 gap-1" data-v-c9b7ef97><!--[-->`);
        ssrRenderList(commonEmojis, (emoji) => {
          _push(`<button class="p-2 hover:bg-gray-100 rounded text-lg transition-colors" type="button" data-v-c9b7ef97>${ssrInterpolate(emoji)}</button>`);
        });
        _push(`<!--]--></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><button class="p-2 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-lg transition-colors self-center"${ssrIncludeBooleanAttr(__props.uploading || __props.sending) ? " disabled" : ""} title="" data-v-c9b7ef97><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-c9b7ef97><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" data-v-c9b7ef97></path></svg></button><input type="file" class="hidden" accept="image/*,application/pdf,.doc,.docx,.xls,.xls,.txt" data-v-c9b7ef97><div class="flex-1 relative" data-v-c9b7ef97><textarea${ssrRenderAttr("placeholder", __props.placeholder)}${ssrIncludeBooleanAttr(__props.uploading || __props.sending) ? " disabled" : ""} class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 resize-none" rows="1" style="${ssrRenderStyle({ "max-height": "120px", "min-height": "40px" })}" data-v-c9b7ef97>${ssrInterpolate(unref(messageText))}</textarea></div><button${ssrIncludeBooleanAttr(!unref(canSend) || __props.uploading || __props.sending) ? " disabled" : ""} class="h-[44px] w-[44px] flex items-center justify-center bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex-shrink-0" data-v-c9b7ef97>`);
      if (__props.sending) {
        _push(`<svg class="w-6 h-6 animate-spin" fill="none" viewBox="0 0 24 24" data-v-c9b7ef97><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" data-v-c9b7ef97></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" data-v-c9b7ef97></path></svg>`);
      } else {
        _push(`<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-c9b7ef97><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" data-v-c9b7ef97></path></svg>`);
      }
      _push(`</button></div>`);
      if (unref(error)) {
        _push(`<p class="mt-2 text-sm text-red-600" data-v-c9b7ef97>${ssrInterpolate(unref(error))}</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$7$1 = _sfc_main$7$1.setup;
_sfc_main$7$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/ChatInput.vue");
  return _sfc_setup$7$1 ? _sfc_setup$7$1(props, ctx) : void 0;
};
const ChatInput = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$7$1, [["__scopeId", "data-v-c9b7ef97"]]), { __name: "ChatInput" });
const _sfc_main$6$1 = /* @__PURE__ */ defineComponent({
  __name: "ChatWindow",
  __ssrInlineRender: true,
  props: {
    room: {},
    messages: {},
    loading: { type: Boolean, default: false }
  },
  emits: ["send-message", "load-more", "reply", "pin"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { user } = useAuth();
    const { getTypingUsers, startTyping, stopTyping } = useChat();
    const messagesContainer = ref(null);
    const previewImage = ref(null);
    const uploading = ref(false);
    const sending = ref(false);
    const loadingMore = ref(false);
    const hasMoreMessages = ref(true);
    const typingTimer = ref(null);
    const replyingToMessage = ref(null);
    const messageRefs = ref({});
    const currentUserId = computed(() => user.value?.id || 0);
    const otherUser = computed(() => {
      if (!props.room || !user.value) return null;
      return props.room.student_id === user.value.id ? props.room.tutor : props.room.student;
    });
    const typingUsers = computed(() => {
      if (!props.room) return [];
      return getTypingUsers(props.room.id);
    });
    const formatDateLabel = (date) => {
      const day = format$4(date, "d", { locale: th });
      const month = format$4(date, "MMM", { locale: th });
      const dayOfWeek = format$4(date, "EEE", { locale: th });
      return `${day} ${month} (${dayOfWeek}.)`;
    };
    const isSameDate = (date1, date2) => {
      try {
        const d1 = typeof date1 === "string" ? parseISO(date1) : date1;
        const d2 = typeof date2 === "string" ? parseISO(date2) : date2;
        return isSameDay(d1, d2);
      } catch {
        return false;
      }
    };
    const messagesWithDates = computed(() => {
      const result = [];
      for (let i = 0; i < props.messages.length; i++) {
        const message = props.messages[i];
        const messageDate = parseISO(message.created_at);
        const prevMessage = i > 0 ? props.messages[i - 1] : null;
        const shouldShowDate = !prevMessage || !isSameDate(message.created_at, prevMessage.created_at);
        if (shouldShowDate) {
          result.push({
            type: "date",
            dateLabel: formatDateLabel(messageDate),
            key: `date-${message.id}`
          });
        }
        result.push({
          type: "message",
          message,
          key: `message-${message.id}-${message.created_at}`
        });
      }
      return result;
    });
    const handleSendMessage = async (data) => {
      sending.value = true;
      try {
        emit("send-message", data);
        await nextTick();
        scrollToBottom();
      } finally {
        sending.value = false;
      }
    };
    const handleTyping = () => {
      if (!props.room) return;
      startTyping(props.room.id);
      if (typingTimer.value) {
        clearTimeout(typingTimer.value);
      }
      typingTimer.value = setTimeout(() => {
        if (props.room) {
          stopTyping(props.room.id);
        }
      }, 3e3);
    };
    const handleImageClick = (url) => {
      previewImage.value = url;
    };
    const handleReply = (message) => {
      replyingToMessage.value = message;
      nextTick(() => {
        const input = (void 0).querySelector('textarea[placeholder="..."]');
        if (input) {
          input.focus();
        }
      });
    };
    const handlePin = async (messageId, pin) => {
      console.log("[ChatWindow] Pin message:", messageId, pin);
      emit("pin", messageId, pin);
    };
    const handleScrollToMessage = (messageId) => {
      const messageElement = messageRefs.value[messageId] || (void 0).getElementById(`message-${messageId}`);
      if (messageElement && messagesContainer.value) {
        messageElement.scrollIntoView({ behavior: "smooth", block: "center" });
        messageElement.classList.add("bg-yellow-100", "transition-colors", "duration-300");
        setTimeout(() => {
          messageElement.classList.remove("bg-yellow-100");
        }, 2e3);
      }
    };
    const scrollToBottom = () => {
      if (messagesContainer.value) {
        messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
      }
    };
    watch$1(() => props.messages.length, () => {
      nextTick(() => {
        scrollToBottom();
      });
    });
    watch$1(() => props.room?.id, () => {
      nextTick(() => {
        scrollToBottom();
      });
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "h-full flex flex-col bg-white overflow-hidden" }, _attrs))}>`);
      if (__props.room) {
        _push(`<div class="border-b p-4 bg-gray-50 flex-shrink-0"><div class="flex items-center space-x-3"><div class="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden">`);
        if (unref(otherUser)?.avatar_url) {
          _push(`<img${ssrRenderAttr("src", unref(otherUser).avatar_url)}${ssrRenderAttr("alt", unref(otherUser).first_name)} class="w-full h-full object-cover">`);
        } else {
          _push(`<span class="text-gray-500 font-semibold">${ssrInterpolate(unref(otherUser)?.first_name?.charAt(0))}</span>`);
        }
        _push(`</div><div class="flex-1 min-w-0"><h3 class="font-semibold text-gray-900">${ssrInterpolate(unref(otherUser)?.first_name)} ${ssrInterpolate(unref(otherUser)?.last_name)}</h3><p class="text-sm text-gray-500 truncate">${ssrInterpolate(__props.room.course?.title)}</p></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex-1 overflow-y-auto p-4 space-y-1">`);
      if (unref(loadingMore)) {
        _push(`<div class="text-center py-2 text-sm text-gray-500"> ... </div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(hasMoreMessages) && !unref(loadingMore)) {
        _push(`<div class="text-center py-2"><button class="text-sm text-green-600 hover:text-green-700 font-medium">  </button></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<!--[-->`);
      ssrRenderList(unref(messagesWithDates), (item, index) => {
        _push(`<!--[-->`);
        if (item.type === "date") {
          _push(`<div class="flex items-center justify-center my-4"><div class="bg-gray-300 text-white px-4 py-1.5 rounded-lg text-sm font-medium flex items-center space-x-1"><span>${ssrInterpolate(item.dateLabel)}</span><svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></div></div>`);
        } else {
          _push(`<div${ssrRenderAttr("id", `message-${item.message.id}`)}>`);
          _push(ssrRenderComponent(ChatMessage, {
            message: item.message,
            "current-user-id": unref(currentUserId),
            onImageClick: handleImageClick,
            onReply: handleReply,
            onPin: handlePin,
            onScrollToMessage: handleScrollToMessage
          }, null, _parent));
          _push(`</div>`);
        }
        _push(`<!--]-->`);
      });
      _push(`<!--]-->`);
      if (unref(typingUsers).length > 0) {
        _push(`<div class="flex items-center space-x-2 text-gray-500 text-sm italic py-2"><div class="flex space-x-1"><div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="${ssrRenderStyle({ "animation-delay": "0ms" })}"></div><div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="${ssrRenderStyle({ "animation-delay": "150ms" })}"></div><div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="${ssrRenderStyle({ "animation-delay": "300ms" })}"></div></div><span>...</span></div>`);
      } else {
        _push(`<!---->`);
      }
      if (!__props.loading && __props.messages.length === 0) {
        _push(`<div class="text-center py-8 text-gray-500">  </div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div class="flex-shrink-0">`);
      if (__props.room) {
        _push(ssrRenderComponent(ChatInput, {
          "room-id": __props.room.id,
          placeholder: "...",
          uploading: unref(uploading),
          sending: unref(sending),
          "replying-to": unref(replyingToMessage),
          onSendMessage: handleSendMessage,
          onTyping: handleTyping,
          onCancelReply: ($event) => replyingToMessage.value = null
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (unref(previewImage)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"><img${ssrRenderAttr("src", unref(previewImage))} alt="Preview" class="max-w-full max-h-full object-contain"></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$6$1 = _sfc_main$6$1.setup;
_sfc_main$6$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/ChatWindow.vue");
  return _sfc_setup$6$1 ? _sfc_setup$6$1(props, ctx) : void 0;
};
const ChatWindow = Object.assign(_sfc_main$6$1, { __name: "ChatWindow" });
const _sfc_main$5$1 = /* @__PURE__ */ defineComponent({
  __name: "AddTagModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    roomId: {}
  },
  emits: ["close", "tag-added"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const tagName = ref("");
    const selectedColor = ref("#3B82F6");
    const loading = ref(false);
    const colors = [
      { value: "#3B82F6", name: "Blue" },
      { value: "#10B981", name: "Green" },
      { value: "#F59E0B", name: "Orange" },
      { value: "#EF4444", name: "Red" },
      { value: "#8B5CF6", name: "Purple" },
      { value: "#EC4899", name: "Pink" },
      { value: "#06B6D4", name: "Cyan" },
      { value: "#84CC16", name: "Lime" }
    ];
    watch$1(() => props.show, (isOpen) => {
      if (!isOpen) {
        tagName.value = "";
        selectedColor.value = "#3B82F6";
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 w-full max-w-md"><div class="flex items-center justify-between mb-4"><h3 class="text-lg font-semibold"></h3><button class="text-gray-500 hover:text-gray-700"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(tagName))} type="text" placeholder=" VIP, , " class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><div class="flex flex-wrap gap-2"><!--[-->`);
        ssrRenderList(colors, (color) => {
          _push(`<button class="${ssrRenderClass([
            "w-10 h-10 rounded-full border-2 transition-all",
            unref(selectedColor) === color.value ? "border-gray-800 scale-110" : "border-gray-300"
          ])}" style="${ssrRenderStyle({ backgroundColor: color.value })}"></button>`);
        });
        _push(`<!--]--></div></div><div class="flex justify-end space-x-3"><button class="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">  </button><button${ssrIncludeBooleanAttr(!unref(tagName).trim() || unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">${ssrInterpolate(unref(loading) ? "..." : "")}</button></div></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$5$1 = _sfc_main$5$1.setup;
_sfc_main$5$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/AddTagModal.vue");
  return _sfc_setup$5$1 ? _sfc_setup$5$1(props, ctx) : void 0;
};
const AddTagModal = Object.assign(_sfc_main$5$1, { __name: "ChatAddTagModal" });
const _sfc_main$4$1 = /* @__PURE__ */ defineComponent({
  __name: "AddNoteModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    roomId: {}
  },
  emits: ["close", "note-added"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const content = ref("");
    const loading = ref(false);
    watch$1(() => props.show, (isOpen) => {
      if (!isOpen) {
        content.value = "";
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 w-full max-w-2xl"><div class="flex items-center justify-between mb-4"><h3 class="text-lg font-semibold"></h3><button class="text-gray-500 hover:text-gray-700"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><textarea rows="6" placeholder="  ..." class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">${ssrInterpolate(unref(content))}</textarea><p class="text-xs text-gray-500 mt-1"></p></div><div class="flex justify-end space-x-3"><button class="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">  </button><button${ssrIncludeBooleanAttr(!unref(content).trim() || unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">${ssrInterpolate(unref(loading) ? "..." : "")}</button></div></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$4$1 = _sfc_main$4$1.setup;
_sfc_main$4$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/AddNoteModal.vue");
  return _sfc_setup$4$1 ? _sfc_setup$4$1(props, ctx) : void 0;
};
const AddNoteModal = Object.assign(_sfc_main$4$1, { __name: "ChatAddNoteModal" });
const _sfc_main$3$2 = /* @__PURE__ */ defineComponent({
  __name: "EditNoteModal",
  __ssrInlineRender: true,
  props: {
    note: {}
  },
  emits: ["close", "note-updated"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const content = ref("");
    const loading = ref(false);
    watch$1(() => props.note, (newNote) => {
      if (newNote) {
        content.value = newNote.content;
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.note) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 w-full max-w-2xl"><div class="flex items-center justify-between mb-4"><h3 class="text-lg font-semibold"></h3><button class="text-gray-500 hover:text-gray-700"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><textarea rows="6" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">${ssrInterpolate(unref(content))}</textarea></div><div class="flex justify-end space-x-3"><button class="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">  </button><button${ssrIncludeBooleanAttr(!unref(content).trim() || unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">${ssrInterpolate(unref(loading) ? "..." : "")}</button></div></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$3$2 = _sfc_main$3$2.setup;
_sfc_main$3$2.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/EditNoteModal.vue");
  return _sfc_setup$3$2 ? _sfc_setup$3$2(props, ctx) : void 0;
};
const EditNoteModal = Object.assign(_sfc_main$3$2, { __name: "ChatEditNoteModal" });
const _sfc_main$2$2 = /* @__PURE__ */ defineComponent({
  __name: "ChatRoomSidebar",
  __ssrInlineRender: true,
  props: {
    room: {}
  },
  setup(__props) {
    const props = __props;
    const { user } = useAuth();
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const tags = ref([]);
    const notes = ref([]);
    const showAddTagModal = ref(false);
    const showAddNoteModal = ref(false);
    ref(false);
    const editingNote = ref(null);
    const otherUser = computed(() => {
      if (!props.room || !user.value) return null;
      return props.room.student_id === user.value.id ? props.room.tutor : props.room.student;
    });
    watch$1(() => props.room?.id, async (roomId) => {
      if (roomId) {
        await loadTags();
        await loadNotes();
      } else {
        tags.value = [];
        notes.value = [];
      }
    }, { immediate: true });
    const loadTags = async () => {
      if (!props.room?.id) return;
      try {
        const response = await $fetch(
          `${config.public.apiBase}/chat/rooms/${props.room.id}/tags`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          tags.value = response.data;
        }
      } catch (error) {
        console.error("[ChatRoomSidebar] Error loading tags:", error);
      }
    };
    const loadNotes = async () => {
      if (!props.room?.id) return;
      try {
        const response = await $fetch(
          `${config.public.apiBase}/chat/rooms/${props.room.id}/notes`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          notes.value = response.data;
        }
      } catch (error) {
        console.error("[ChatRoomSidebar] Error loading notes:", error);
      }
    };
    const handleTagAdded = () => {
      loadTags();
    };
    const handleNoteAdded = () => {
      loadNotes();
    };
    const handleNoteUpdated = () => {
      editingNote.value = null;
      loadNotes();
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "w-80 border-l bg-white flex-shrink-0 overflow-y-auto flex flex-col h-full" }, _attrs))}>`);
      if (!__props.room) {
        _push(`<div class="flex-1 flex items-center justify-center p-4"><div class="text-center text-gray-500"><svg class="w-16 h-16 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg><p class="text-sm"></p></div></div>`);
      } else {
        _push(`<div class="flex-1 overflow-y-auto"><div class="p-4 border-b"><div class="flex flex-col items-center mb-4"><div class="w-20 h-20 rounded-full bg-gray-200 flex items-center justify-center overflow-hidden mb-3">`);
        if (unref(otherUser)?.avatar_url) {
          _push(`<img${ssrRenderAttr("src", unref(otherUser).avatar_url)}${ssrRenderAttr("alt", unref(otherUser).first_name)} class="w-full h-full object-cover">`);
        } else {
          _push(`<span class="text-gray-500 text-2xl font-semibold">${ssrInterpolate(unref(otherUser)?.first_name?.charAt(0))}</span>`);
        }
        _push(`</div><h3 class="text-lg font-semibold text-gray-900 mb-1">${ssrInterpolate(unref(otherUser)?.first_name)} ${ssrInterpolate(unref(otherUser)?.last_name)}</h3><button class="text-gray-500 hover:text-gray-700" title=""><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button></div></div><div class="p-4 border-b"><div class="flex items-center justify-between mb-3"><h4 class="text-sm font-semibold text-gray-700"></h4><button class="flex items-center space-x-1 px-3 py-1.5 bg-green-600 text-white text-sm rounded-lg hover:bg-green-700 transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div>`);
        if (unref(tags).length === 0) {
          _push(`<div class="text-sm text-gray-500 text-center py-4">  </div>`);
        } else {
          _push(`<div class="flex flex-wrap gap-2"><!--[-->`);
          ssrRenderList(unref(tags), (tag) => {
            _push(`<span style="${ssrRenderStyle({ backgroundColor: tag.color + "20", color: tag.color, borderColor: tag.color })}" class="px-3 py-1 rounded-full text-sm font-medium border">${ssrInterpolate(tag.tag_name)}</span>`);
          });
          _push(`<!--]--></div>`);
        }
        _push(`</div><div class="p-4 border-b"><div class="flex items-center justify-between mb-3"><h4 class="text-sm font-semibold text-gray-700">  <span class="text-gray-500 font-normal">(${ssrInterpolate(unref(notes).length)})</span></h4><button class="flex items-center space-x-1 px-3 py-1.5 bg-green-600 text-white text-sm rounded-lg hover:bg-green-700 transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div>`);
        if (unref(notes).length === 0) {
          _push(`<div class="text-sm text-gray-500 text-center py-4">  </div>`);
        } else {
          _push(`<div class="space-y-3"><!--[-->`);
          ssrRenderList(unref(notes), (note) => {
            _push(`<div class="bg-gray-50 rounded-lg p-3"><p class="text-sm text-gray-900 whitespace-pre-wrap">${ssrInterpolate(note.content)}</p><div class="flex items-center justify-between mt-2 text-xs text-gray-500"><span>  ${ssrInterpolate(note.creator?.first_name)} ${ssrInterpolate(note.creator?.last_name)} `);
            if (note.updated_by && note.updated_by !== note.created_by) {
              _push(`<span> ( ${ssrInterpolate(note.updater?.first_name)} ${ssrInterpolate(note.updater?.last_name)}) </span>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</span><button class="text-green-600 hover:text-green-700">  </button></div></div>`);
          });
          _push(`<!--]--></div>`);
        }
        _push(`</div></div>`);
      }
      if (__props.room) {
        _push(ssrRenderComponent(AddTagModal, {
          show: unref(showAddTagModal),
          "room-id": __props.room.id,
          onClose: ($event) => showAddTagModal.value = false,
          onTagAdded: handleTagAdded
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (__props.room) {
        _push(ssrRenderComponent(AddNoteModal, {
          show: unref(showAddNoteModal),
          "room-id": __props.room.id,
          onClose: ($event) => showAddNoteModal.value = false,
          onNoteAdded: handleNoteAdded
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (unref(editingNote)) {
        _push(ssrRenderComponent(EditNoteModal, {
          note: unref(editingNote),
          onClose: ($event) => editingNote.value = null,
          onNoteUpdated: handleNoteUpdated
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$2$2 = _sfc_main$2$2.setup;
_sfc_main$2$2.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/ChatRoomSidebar.vue");
  return _sfc_setup$2$2 ? _sfc_setup$2$2(props, ctx) : void 0;
};
const ChatRoomSidebar = Object.assign(_sfc_main$2$2, { __name: "ChatRoomSidebar" });
const _sfc_main$1$c = /* @__PURE__ */ defineComponent({
  __name: "CreateChatRoomModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean }
  },
  emits: ["close", "room-created"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const chatOptions = ref([]);
    const loading = ref(false);
    const error = ref("");
    const creating = ref(false);
    const loadChatOptions = async () => {
      loading.value = true;
      error.value = "";
      try {
        const response = await $fetch(
          `${config.public.apiBase}/learning/available-chats`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          chatOptions.value = response.data;
        }
      } catch (err) {
        console.error("[CreateChatRoomModal] Error loading options:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    watch$1(() => props.show, (isOpen) => {
      if (isOpen) {
        loadChatOptions();
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col"><div class="px-6 py-4 border-b flex items-center justify-between"><h2 class="text-xl font-semibold"></h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><div class="flex-1 overflow-y-auto p-6">`);
        if (unref(loading)) {
          _push(`<div class="text-center py-8"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
        } else if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-4">${ssrInterpolate(unref(error))}</div>`);
        } else if (unref(chatOptions).length === 0) {
          _push(`<div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg><p></p><p class="text-sm mt-2"></p></div>`);
        } else {
          _push(`<div class="space-y-3"><!--[-->`);
          ssrRenderList(unref(chatOptions), (option) => {
            _push(`<div class="${ssrRenderClass([option.chatRoomId ? "border-green-200 bg-green-50" : "border-gray-200", "border rounded-lg p-4 hover:bg-gray-50 transition-colors"])}"><div class="flex items-start space-x-4"><div class="w-20 h-20 bg-gray-200 rounded-lg flex-shrink-0 overflow-hidden">`);
            if (option.course.thumbnail) {
              _push(`<img${ssrRenderAttr("src", option.course.thumbnail)}${ssrRenderAttr("alt", option.course.title)} class="w-full h-full object-cover">`);
            } else {
              _push(`<div class="w-full h-full flex items-center justify-center text-gray-400"><svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div>`);
            }
            _push(`</div><div class="flex-1 min-w-0"><h3 class="font-semibold text-gray-900 mb-1">${ssrInterpolate(option.course.title)}</h3><p class="text-sm text-gray-600 mb-2"> : ${ssrInterpolate(option.tutor.firstName)} ${ssrInterpolate(option.tutor.lastName)}</p><div class="flex items-center justify-between">`);
            if (option.chatRoomId) {
              _push(`<span class="text-xs text-green-600 font-medium">   </span>`);
            } else {
              _push(`<span class="text-xs text-gray-500">  </span>`);
            }
            _push(`<button${ssrIncludeBooleanAttr(unref(creating)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed text-sm font-medium">${ssrInterpolate(option.chatRoomId ? "" : "")}</button></div></div></div></div>`);
          });
          _push(`<!--]--></div>`);
        }
        _push(`</div></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$c = _sfc_main$1$c.setup;
_sfc_main$1$c.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/chat/CreateChatRoomModal.vue");
  return _sfc_setup$1$c ? _sfc_setup$1$c(props, ctx) : void 0;
};
const CreateChatRoomModal = Object.assign(_sfc_main$1$c, { __name: "ChatCreateChatRoomModal" });
const _sfc_main$17 = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    useAuth();
    const {
      rooms,
      activeRoom,
      setActiveRoom,
      loadRooms,
      loadMessages,
      sendMessage,
      markAsRead,
      sortedMessages
    } = useChat();
    const loadingRooms = ref(false);
    const loadingMessages = ref(false);
    const messageOffset = ref(0);
    const hasMoreMessages = ref(true);
    const showCreateModal = ref(false);
    ref(false);
    const chatRooms = computed(() => [...rooms.value]);
    watch$1(() => activeRoom.value?.id, async (roomId) => {
      if (roomId) {
        await loadRoomMessages(roomId);
        markAsRead(roomId);
      } else {
        messageOffset.value = 0;
        hasMoreMessages.value = true;
      }
    }, { immediate: true });
    const currentMessages = sortedMessages;
    watch$1(() => currentMessages.value.length, (newLength, oldLength) => {
      console.log("[Chat]  Message count changed:", {
        oldLength,
        newLength,
        willScroll: newLength > (oldLength || 0)
      });
    });
    const loadRoomMessages = async (roomId, append = false) => {
      loadingMessages.value = true;
      try {
        const offset = append ? messageOffset.value : 0;
        const apiMessages = await loadMessages(roomId, 50, offset);
        if (!apiMessages) {
          console.error("[Chat] loadMessages returned undefined");
          return;
        }
        if (apiMessages.length < 50) {
          hasMoreMessages.value = false;
        } else {
          messageOffset.value += apiMessages.length;
          hasMoreMessages.value = true;
        }
      } catch (error) {
        console.error("[Chat] Error loading messages:", error);
      } finally {
        loadingMessages.value = false;
      }
    };
    const handleSelectRoom = async (room) => {
      console.log("[Chat]  Selecting room:", room.id);
      setActiveRoom(room);
      messageOffset.value = 0;
      hasMoreMessages.value = true;
      const route = useRoute();
      const router = useRouter();
      if (route.query.roomId !== room.id.toString()) {
        await router.replace({
          query: { ...route.query, roomId: room.id.toString() }
        });
      }
    };
    const sending = ref(false);
    const handleSendMessage = async (data) => {
      console.log("[Chat Page]  handleSendMessage called:", {
        hasActiveRoom: !!activeRoom.value,
        roomId: activeRoom.value?.id,
        content: data.content?.substring(0, 50),
        messageType: data.messageType,
        isSending: sending.value
      });
      if (!activeRoom.value) {
        console.error("[Chat Page]  No active room");
        return;
      }
      if (sending.value) {
        console.log("[Chat Page]  Already sending a message, skipping duplicate");
        return;
      }
      sending.value = true;
      console.log("[Chat Page]  Sending state set to true");
      try {
        console.log("[Chat Page]  Calling sendMessage composable...");
        await sendMessage({
          room_id: activeRoom.value.id,
          content: data.content,
          message_type: data.messageType,
          file_url: data.fileUrl,
          file_name: data.fileName,
          file_size: data.fileSize,
          file_type: data.fileType,
          reply_to_id: data.replyToId || null
        });
        console.log("[Chat Page]  sendMessage completed successfully");
        markAsRead(activeRoom.value.id);
      } catch (error) {
        console.error("[Chat Page]  Error in handleSendMessage:", {
          error: error.message,
          stack: error.stack,
          response: error.response
        });
      } finally {
        setTimeout(() => {
          sending.value = false;
          console.log("[Chat Page]  Sending state reset to false");
        }, 500);
      }
    };
    const handleLoadMore = async () => {
      if (!activeRoom.value || !hasMoreMessages.value || loadingMessages.value) return;
      await loadRoomMessages(activeRoom.value.id, true);
    };
    const handleRoomCreated = async (roomId) => {
      await loadRooms();
      const newRoom = rooms.value.find((r) => r.id === roomId);
      if (newRoom) {
        await handleSelectRoom(newRoom);
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "h-full flex overflow-hidden" }, _attrs))}><div class="w-80 border-r bg-white flex-shrink-0 overflow-y-auto">`);
      _push(ssrRenderComponent(ChatRoomList, {
        rooms: unref(chatRooms),
        "active-room": unref(activeRoom),
        loading: unref(loadingRooms),
        onSelectRoom: handleSelectRoom,
        onCreateRoom: ($event) => showCreateModal.value = true
      }, null, _parent));
      _push(`</div><div class="flex-1 flex flex-col min-w-0 overflow-hidden">`);
      if (!unref(activeRoom)) {
        _push(`<div class="flex-1 flex items-center justify-center bg-gray-50"><div class="text-center text-gray-500"><svg class="w-16 h-16 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg><p class="text-lg"></p></div></div>`);
      } else {
        _push(`<div class="flex-1 flex min-w-0 overflow-hidden">`);
        _push(ssrRenderComponent(ChatWindow, {
          class: "flex-1 min-w-0",
          room: unref(activeRoom),
          messages: unref(currentMessages),
          loading: unref(loadingMessages),
          onSendMessage: handleSendMessage,
          onLoadMore: handleLoadMore
        }, null, _parent));
        _push(ssrRenderComponent(ChatRoomSidebar, {
          class: "flex-shrink-0",
          room: unref(activeRoom)
        }, null, _parent));
        _push(`</div>`);
      }
      _push(`</div>`);
      _push(ssrRenderComponent(CreateChatRoomModal, {
        show: unref(showCreateModal),
        onClose: ($event) => showCreateModal.value = false,
        onRoomCreated: handleRoomCreated
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$17 = _sfc_main$17.setup;
_sfc_main$17.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/chat/index.vue");
  return _sfc_setup$17 ? _sfc_setup$17(props, ctx) : void 0;
};

const indexCTYKMr9P = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$17
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$16 = /* @__PURE__ */ defineComponent({
  __name: "my-courses",
  __ssrInlineRender: true,
  setup(__props) {
    const { user } = useAuth();
    const activeTab = ref("all");
    const selectedEnrollmentType = ref("all");
    const sortBy = ref("newest");
    const enrollments = ref([]);
    const loading = ref(true);
    const error = ref("");
    const isParent = computed(() => {
      return user.value?.roles?.includes("parent");
    });
    const tabs = [
      { id: "all", label: "" },
      { id: "active", label: "" },
      { id: "completed", label: "" }
    ];
    const filteredEnrollments = computed(() => {
      let filtered = [...enrollments.value];
      if (activeTab.value === "active") {
        filtered = filtered.filter((e) => e.status === "active");
      } else if (activeTab.value === "completed") {
        filtered = filtered.filter((e) => e.status === "completed");
      }
      if (selectedEnrollmentType.value !== "all") {
        filtered = filtered.filter((e) => e.enrollmentType === selectedEnrollmentType.value);
      }
      if (sortBy.value === "newest") {
        filtered.sort((a, b) => new Date(b.enrollmentDate).getTime() - new Date(a.enrollmentDate).getTime());
      } else if (sortBy.value === "oldest") {
        filtered.sort((a, b) => new Date(a.enrollmentDate).getTime() - new Date(b.enrollmentDate).getTime());
      } else if (sortBy.value === "title") {
        filtered.sort((a, b) => a.course.title.localeCompare(b.course.title, "th"));
      }
      return filtered;
    });
    const formatDate = (dateString) => {
      try {
        return format$4(new Date(dateString), "d MMMM yyyy", { locale: th });
      } catch {
        return dateString;
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><h1 class="text-3xl font-bold mb-6"></h1>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<!--[--><div class="flex items-center gap-4 mb-6 border-b border-gray-200"><!--[-->`);
        ssrRenderList(tabs, (tab) => {
          _push(`<button class="${ssrRenderClass([unref(activeTab) === tab.id ? "text-green-600 border-b-2 border-green-600" : "text-gray-600 hover:text-green-600", "px-4 py-2 font-semibold transition-colors relative"])}">${ssrInterpolate(tab.label)}</button>`);
        });
        _push(`<!--]--></div><div class="flex items-center justify-between mb-6"><div class="text-gray-600"> : <span class="font-semibold">${ssrInterpolate(unref(filteredEnrollments).length)}</span>  </div><div class="flex items-center gap-4"><select class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="all"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedEnrollmentType)) ? ssrLooseContain(unref(selectedEnrollmentType), "all") : ssrLooseEqual(unref(selectedEnrollmentType), "all")) ? " selected" : ""}></option><option value="onsite"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedEnrollmentType)) ? ssrLooseContain(unref(selectedEnrollmentType), "onsite") : ssrLooseEqual(unref(selectedEnrollmentType), "onsite")) ? " selected" : ""}></option><option value="online"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedEnrollmentType)) ? ssrLooseContain(unref(selectedEnrollmentType), "online") : ssrLooseEqual(unref(selectedEnrollmentType), "online")) ? " selected" : ""}></option></select><select class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="newest"${ssrIncludeBooleanAttr(Array.isArray(unref(sortBy)) ? ssrLooseContain(unref(sortBy), "newest") : ssrLooseEqual(unref(sortBy), "newest")) ? " selected" : ""}>-</option><option value="oldest"${ssrIncludeBooleanAttr(Array.isArray(unref(sortBy)) ? ssrLooseContain(unref(sortBy), "oldest") : ssrLooseEqual(unref(sortBy), "oldest")) ? " selected" : ""}>-</option><option value="title"${ssrIncludeBooleanAttr(Array.isArray(unref(sortBy)) ? ssrLooseContain(unref(sortBy), "title") : ssrLooseEqual(unref(sortBy), "title")) ? " selected" : ""}> (-)</option></select></div></div><div class="space-y-4"><!--[-->`);
        ssrRenderList(unref(filteredEnrollments), (enrollment) => {
          _push(`<div class="bg-white rounded-lg shadow p-6 flex gap-6 hover:shadow-md transition-shadow"><div class="w-48 h-32 bg-gray-200 rounded-lg flex-shrink-0 overflow-hidden">`);
          if (enrollment.course.thumbnail_url) {
            _push(`<img${ssrRenderAttr("src", enrollment.course.thumbnail_url)}${ssrRenderAttr("alt", enrollment.course.title)} class="w-full h-full object-cover">`);
          } else {
            _push(`<div class="w-full h-full flex items-center justify-center text-gray-400"><svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div>`);
          }
          _push(`</div><div class="flex-1"><div class="flex items-start justify-between mb-2"><div class="flex-1"><div class="flex items-center gap-2 mb-1"><span class="${ssrRenderClass([enrollment.enrollmentType === "online" ? "bg-blue-100 text-blue-800" : "bg-green-100 text-green-800", "px-2 py-1 text-xs font-semibold rounded"])}">${ssrInterpolate(enrollment.enrollmentType === "online" ? "" : "")}</span>`);
          if (enrollment.branch) {
            _push(`<span class="text-sm text-gray-500">${ssrInterpolate(enrollment.branch.name)}</span>`);
          } else {
            _push(`<!---->`);
          }
          if (enrollment.course.code) {
            _push(`<span class="text-xs text-gray-400">${ssrInterpolate(enrollment.course.code)}</span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div><h3 class="text-xl font-semibold mb-2">${ssrInterpolate(enrollment.course.title)}</h3>`);
          if (enrollment.course.description) {
            _push(`<p class="text-gray-600 text-sm mb-4 line-clamp-2">${ssrInterpolate(enrollment.course.description)}</p>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div>`);
          {
            _push(`<!---->`);
          }
          _push(`<div class="flex items-center justify-between"><div class="text-sm text-gray-500"> : ${ssrInterpolate(formatDate(enrollment.enrollmentDate))} `);
          if (enrollment.student && unref(isParent)) {
            _push(`<span class="ml-2"> (${ssrInterpolate(enrollment.student.firstName)} ${ssrInterpolate(enrollment.student.lastName)}) </span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div><div class="flex items-center gap-2">`);
          _push(ssrRenderComponent(_component_NuxtLink, {
            to: `/courses/${enrollment.course.id}`,
            class: "px-4 py-2 border border-green-600 text-green-600 rounded-lg hover:bg-green-50 transition-colors"
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  `);
              } else {
                return [
                  createTextVNode("  ")
                ];
              }
            }),
            _: 2
          }, _parent));
          if (enrollment.enrollmentType === "online") {
            _push(ssrRenderComponent(_component_NuxtLink, {
              to: `/learning/courses/${enrollment.course.id}`,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-semibold"
            }, {
              default: withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`  `);
                } else {
                  return [
                    createTextVNode("  ")
                  ];
                }
              }),
              _: 2
            }, _parent));
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div></div></div>`);
        });
        _push(`<!--]-->`);
        if (unref(filteredEnrollments).length === 0) {
          _push(`<div class="text-center py-12 bg-white rounded-lg shadow"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg><h3 class="mt-2 text-sm font-semibold text-gray-900"></h3><p class="mt-1 text-sm text-gray-500"></p><div class="mt-6">`);
          _push(ssrRenderComponent(_component_NuxtLink, {
            to: "/courses",
            class: "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700"
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  `);
              } else {
                return [
                  createTextVNode("  ")
                ];
              }
            }),
            _: 1
          }, _parent));
          _push(`</div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><!--]-->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$16 = _sfc_main$16.setup;
_sfc_main$16.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/my-courses.vue");
  return _sfc_setup$16 ? _sfc_setup$16(props, ctx) : void 0;
};

const myCoursesB847wEG = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$16
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const { user } = useAuth();
    const dashboardData = ref(null);
    const loading = ref(true);
    const error = ref(null);
    const getRoleDisplayName = (role) => {
      const roleNames = {
        system_admin: "",
        owner: "",
        admin: "Admin ",
        branch_admin: "",
        tutor: "",
        student: "",
        parent: ""
      };
      return roleNames[role || ""] || role || "";
    };
    const primaryRole = computed(() => {
      return user.value?.roles?.[0] || "";
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><h1 class="text-3xl font-bold mb-6">Dashboard</h1>`);
      if (unref(loading)) {
        _push(`<div class="flex items-center justify-center py-12"><div class="text-center"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600"> Dashboard...</p></div></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 rounded-lg p-6 mb-6"><div class="flex items-center"><svg class="w-6 h-6 text-red-600 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><div><h3 class="text-lg font-semibold text-red-800"></h3><p class="text-red-600">${ssrInterpolate(unref(error))}</p></div></div></div>`);
      } else if (unref(dashboardData)) {
        _push(`<!--[--><div class="bg-white rounded-lg shadow p-6 mb-6"><h2 class="text-xl font-semibold mb-2"> , ${ssrInterpolate(unref(user)?.first_name)} ${ssrInterpolate(unref(user)?.last_name)}! </h2><p class="text-gray-600"> : <span class="font-semibold text-green-600">${ssrInterpolate(getRoleDisplayName(unref(primaryRole)))}</span>`);
        if (unref(dashboardData).branchName) {
          _push(`<span class="ml-2 text-gray-500"> - ${ssrInterpolate(unref(dashboardData).branchName)}</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</p></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">`);
        if (unref(primaryRole) === "system_admin" || unref(primaryRole) === "owner" || unref(primaryRole) === "admin") {
          _push(`<!--[--><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.totalStudents || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-green-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.totalCourses || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-blue-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.monthlyRevenue || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-yellow-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.totalEnrollments || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-purple-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg></div></div></div>`);
          if (unref(primaryRole) === "system_admin" || unref(primaryRole) === "owner") {
            _push(`<!--[-->`);
            if (unref(dashboardData).stats.activeBranches !== void 0) {
              _push(`<div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.activeBranches || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-indigo-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path></svg></div></div></div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`<!--]-->`);
          } else {
            _push(`<!---->`);
          }
          if (unref(primaryRole) === "admin" && unref(dashboardData).stats.pendingPayments !== void 0) {
            _push(`<div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.pendingPayments || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-orange-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<!--]-->`);
        } else if (unref(primaryRole) === "branch_admin") {
          _push(`<!--[--><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.branchStudents || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-green-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.branchCourses || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-blue-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"> ()</p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.branchRevenue || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-yellow-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.branchEnrollments || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-purple-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg></div></div></div>`);
          if (unref(dashboardData).stats.pendingPayments !== void 0) {
            _push(`<div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.pendingPayments || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-orange-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(dashboardData).stats.activeTutors !== void 0) {
            _push(`<div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.activeTutors || 0).toLocaleString())}</p></div><div class="h-12 w-12 bg-teal-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-teal-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2 2v2m4 6h.01M5 20h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path></svg></div></div></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<!--]-->`);
        } else if (unref(primaryRole) === "tutor") {
          _push(`<!--[--><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.myCourses || 0).toLocaleString())}</p><p class="text-sm text-green-600 mt-1"></p></div><div class="h-12 w-12 bg-blue-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.myStudents || 0).toLocaleString())}</p><p class="text-sm text-green-600 mt-1"></p></div><div class="h-12 w-12 bg-green-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.teachingHours || 0).toLocaleString())}</p><p class="text-sm text-purple-600 mt-1"></p></div><div class="h-12 w-12 bg-purple-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.teachingHoursThisMonth || 0).toLocaleString())}</p><p class="text-sm text-blue-600 mt-1"></p></div><div class="h-12 w-12 bg-blue-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.pendingAssignments || 0).toLocaleString())}</p><p class="text-sm text-orange-600 mt-1"></p></div><div class="h-12 w-12 bg-orange-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold mt-2">${ssrInterpolate((unref(dashboardData).stats.upcomingClassesToday || 0).toLocaleString())}</p><p class="text-sm text-indigo-600 mt-1"></p></div><div class="h-12 w-12 bg-indigo-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg></div></div></div><!--]-->`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="grid grid-cols-1 lg:grid-cols-2 gap-6">`);
        if (unref(primaryRole) !== "tutor") {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="h-64 flex items-center justify-center text-gray-400"><p> ()</p></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2>`);
        if (unref(dashboardData).recentEnrollments.length === 0) {
          _push(`<div class="text-center py-8 text-gray-500"><p></p></div>`);
        } else {
          _push(`<div class="space-y-4"><!--[-->`);
          ssrRenderList(unref(dashboardData).recentEnrollments, (enrollment) => {
            _push(`<div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg"><div><p class="font-medium">${ssrInterpolate(enrollment.studentName)}</p><p class="text-sm text-gray-600">${ssrInterpolate(enrollment.courseName)}</p>`);
            if (enrollment.branchName) {
              _push(`<p class="text-xs text-gray-500 mt-1">${ssrInterpolate(enrollment.branchName)}</p>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div><div class="text-right"><p class="font-semibold text-green-600">${ssrInterpolate(enrollment.amount.toLocaleString())}</p><p class="text-xs text-gray-500">${ssrInterpolate(enrollment.date)}</p></div></div>`);
          });
          _push(`<!--]--></div>`);
        }
        _push(`</div></div><!--]-->`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$15 = _sfc_main$15.setup;
_sfc_main$15.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/index.vue");
  return _sfc_setup$15 ? _sfc_setup$15(props, ctx) : void 0;
};

const indexCb9_knGu = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$15
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$14 = /* @__PURE__ */ defineComponent({
  __name: "login",
  __ssrInlineRender: true,
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="min-h-screen flex items-center justify-center bg-gray-50"><div class="text-center"><p class="text-gray-600 mb-4">...</p><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-green-600 mx-auto"></div></div></div></div>`);
    };
  }
});
const _sfc_setup$14 = _sfc_main$14.setup;
_sfc_main$14.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/login.vue");
  return _sfc_setup$14 ? _sfc_setup$14(props, ctx) : void 0;
};

const loginDqqBgQn6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$14
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$13 = /* @__PURE__ */ defineComponent({
  __name: "AddressSelect",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    userId: {},
    loading: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    required: { type: Boolean, default: true },
    placeholder: { default: "" },
    hint: { default: "" },
    showAddButton: { type: Boolean, default: true }
  },
  emits: ["update:modelValue", "add-new"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const addresses = ref([]);
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const loadAddresses = async () => {
      if (!props.userId) {
        addresses.value = [];
        return;
      }
      try {
        const response = await $fetch(
          `${config.public.apiBase}/admin/users/${props.userId}/addresses`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          addresses.value = response.data;
        }
      } catch (err) {
        console.error("Error loading addresses:", err);
        addresses.value = [];
      }
    };
    const formatAddress = (address) => {
      const parts = [];
      if (address.recipient_name) parts.push(address.recipient_name);
      if (address.address_line1) parts.push(address.address_line1);
      if (address.district) parts.push(`.${address.district}`);
      if (address.province) parts.push(`.${address.province}`);
      if (address.postal_code) parts.push(address.postal_code);
      const addressStr = parts.join(" ");
      const typeLabel = address.address_type === "home" ? "" : address.address_type === "work" ? "" : "";
      const defaultLabel = address.is_default ? " ()" : "";
      return `${addressStr} [${typeLabel}${defaultLabel}]`;
    };
    watch$1(() => props.userId, (newUserId) => {
      if (newUserId) {
        loadAddresses();
      } else {
        addresses.value = [];
      }
    }, { immediate: true });
    const reloadAddresses = async () => {
      await loadAddresses();
    };
    __expose({
      loadAddresses,
      reloadAddresses,
      addresses: computed(() => addresses.value)
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><label class="block text-sm font-medium text-gray-700 mb-2">`);
      ssrRenderSlot(_ctx.$slots, "label", {}, () => {
        _push(` <span class="text-red-500">*</span>`);
      }, _push, _parent);
      _push(`</label><div class="relative"><select${ssrRenderAttr("value", __props.modelValue)}${ssrIncludeBooleanAttr(__props.disabled || __props.loading) ? " disabled" : ""}${ssrIncludeBooleanAttr(__props.required) ? " required" : ""} data-address-select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 disabled:bg-gray-100 disabled:cursor-not-allowed bg-white text-gray-900"><option value="">${ssrInterpolate(__props.loading ? "..." : __props.placeholder)}</option><!--[-->`);
      ssrRenderList(unref(addresses), (address) => {
        _push(`<option${ssrRenderAttr("value", address.id)}>${ssrInterpolate(formatAddress(address))}</option>`);
      });
      _push(`<!--]--></select>`);
      if (__props.showAddButton) {
        _push(`<button type="button" class="absolute right-10 top-1/2 transform -translate-y-1/2 text-green-600 hover:text-green-700" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg></button>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (__props.hint) {
        _push(`<p class="mt-1 text-sm text-gray-500">${ssrInterpolate(__props.hint)}</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$13 = _sfc_main$13.setup;
_sfc_main$13.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/AddressSelect.vue");
  return _sfc_setup$13 ? _sfc_setup$13(props, ctx) : void 0;
};
const AddressSelect = Object.assign(_sfc_main$13, { __name: "AddressSelect" });

const _sfc_main$1$b = /* @__PURE__ */ defineComponent({
  __name: "AddressForm",
  __ssrInlineRender: true,
  props: {
    address: { default: null }
  },
  emits: ["update"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const form = reactive({
      address_type: "home",
      recipient_name: "",
      phone: "",
      address_line1: "",
      address_line2: "",
      subdistrict: "",
      district: "",
      province: "",
      postal_code: "",
      country: "Thailand",
      is_default: false
    });
    const error = ref("");
    watch$1(() => props.address, (address) => {
      if (address) {
        Object.assign(form, {
          address_type: address.address_type || "home",
          recipient_name: address.recipient_name || "",
          phone: address.phone || "",
          address_line1: address.address_line1 || "",
          address_line2: address.address_line2 || "",
          subdistrict: address.subdistrict || "",
          district: address.district || "",
          province: address.province || "",
          postal_code: address.postal_code || "",
          country: address.country || "Thailand",
          is_default: address.is_default || false
        });
      } else {
        Object.assign(form, {
          address_type: "home",
          recipient_name: "",
          phone: "",
          address_line1: "",
          address_line2: "",
          subdistrict: "",
          district: "",
          province: "",
          postal_code: "",
          country: "Thailand",
          is_default: false
        });
      }
      error.value = "";
    }, { immediate: true });
    watch$1(form, (newForm) => {
      emit("update", { ...newForm });
    }, { deep: true });
    __expose({
      validate: () => {
        if (!form.recipient_name || !form.phone || !form.address_line1 || !form.province || !form.postal_code) {
          error.value = "";
          return false;
        }
        error.value = "";
        return true;
      },
      getData: () => ({ ...form })
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({
        class: "space-y-4",
        "data-address-form": ""
      }, _attrs))}><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900"><option value="home"${ssrIncludeBooleanAttr(Array.isArray(unref(form).address_type) ? ssrLooseContain(unref(form).address_type, "home") : ssrLooseEqual(unref(form).address_type, "home")) ? " selected" : ""}></option><option value="work"${ssrIncludeBooleanAttr(Array.isArray(unref(form).address_type) ? ssrLooseContain(unref(form).address_type, "work") : ssrLooseEqual(unref(form).address_type, "work")) ? " selected" : ""}></option><option value="other"${ssrIncludeBooleanAttr(Array.isArray(unref(form).address_type) ? ssrLooseContain(unref(form).address_type, "other") : ssrLooseEqual(unref(form).address_type, "other")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).recipient_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900" placeholder="- "></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).phone)} type="tel" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900" placeholder="080-123-4567"></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  1 <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).address_line1)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900" placeholder="   "></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  2 </label><input${ssrRenderAttr("value", unref(form).address_line2)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900" placeholder="  / ()"></div><div class="grid grid-cols-1 md:grid-cols-3 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"> / </label><input${ssrRenderAttr("value", unref(form).subdistrict)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> / </label><input${ssrRenderAttr("value", unref(form).district)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).province)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900"></div></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).postal_code)} type="text" required maxlength="5" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900" placeholder="10110"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).country)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900" placeholder="Thailand"></div></div><div class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_default) ? ssrLooseContain(unref(form).is_default, null) : unref(form).is_default) ? " checked" : ""} type="checkbox" id="is_default" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><label for="is_default" class="ml-2 text-sm text-gray-700">  </label></div>`);
      if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$1$b = _sfc_main$1$b.setup;
_sfc_main$1$b.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/AddressForm.vue");
  return _sfc_setup$1$b ? _sfc_setup$1$b(props, ctx) : void 0;
};
const AddressForm = Object.assign(_sfc_main$1$b, { __name: "AddressForm" });
const _sfc_main$12 = /* @__PURE__ */ defineComponent({
  __name: "EnrollmentModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    enrollment: { default: null },
    prefillCourseId: { default: void 0 },
    prefillEnrollmentType: { default: void 0 }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const config = useRuntimeConfig();
    const { accessToken, user } = useAuth();
    const form = reactive({
      student_id: 0,
      course_id: 0,
      branch_id: 0,
      enrollment_type: "onsite",
      shipping_address_id: null,
      enrollment_date: "",
      status: "pending"
    });
    const loading = ref(false);
    const loadingBranches = ref(false);
    const loadingStudents = ref(false);
    const error = ref("");
    ref([]);
    const filteredStudents = ref([]);
    const availableCourses = ref([]);
    const availableBranches = ref([]);
    const studentSearchQuery = ref("");
    const showStudentDropdown = ref(false);
    const selectedStudent = ref(null);
    const showAddressForm = ref(false);
    const newAddress = ref(null);
    const addressSelectRef = ref(null);
    const autoSelectStudent = ref(false);
    const loadCourses = async () => {
      try {
        const response = await $fetch(
          `${config.public.apiBase}/admin/courses`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            },
            params: { status: "published" }
          }
        );
        if (response.success) {
          availableCourses.value = response.data;
        }
      } catch (err) {
        console.error("Error loading courses:", err);
      }
    };
    const loadBranchesForCourse = async () => {
      if (!form.course_id) {
        availableBranches.value = [];
        form.branch_id = 0;
        return;
      }
      loadingBranches.value = true;
      try {
        const response = await $fetch(`${config.public.apiBase}/admin/courses/${form.course_id}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success && response.data.branches) {
          availableBranches.value = response.data.branches.map((b) => ({
            id: b.branch_id,
            name: b.branch_name,
            code: b.branch_code
          }));
        }
      } catch (err) {
        console.error("Error loading branches:", err);
        error.value = "";
      } finally {
        loadingBranches.value = false;
      }
    };
    watch$1(() => props.enrollment, (enrollment) => {
      if (enrollment) {
        form.student_id = enrollment.student_id;
        form.course_id = enrollment.course_id;
        form.branch_id = enrollment.branch_id || 0;
        form.enrollment_type = enrollment.enrollment_type || "onsite";
        form.shipping_address_id = enrollment.shipping_address_id || null;
        form.status = enrollment.status;
        form.enrollment_date = enrollment.enrollment_date ? new Date(enrollment.enrollment_date).toISOString().slice(0, 16) : (/* @__PURE__ */ new Date()).toISOString().slice(0, 16);
        if (enrollment.student_id) {
          fetchStudentInfo(enrollment.student_id);
        }
        loadBranchesForCourse();
      } else {
        form.student_id = 0;
        form.course_id = props.prefillCourseId || 0;
        form.branch_id = 0;
        form.enrollment_type = props.prefillEnrollmentType || "onsite";
        form.shipping_address_id = null;
        form.status = "pending";
        form.enrollment_date = (/* @__PURE__ */ new Date()).toISOString().slice(0, 16);
        availableBranches.value = [];
        selectedStudent.value = null;
        studentSearchQuery.value = "";
        if (props.prefillCourseId) {
          loadBranchesForCourse();
        }
      }
    }, { immediate: true });
    const fetchStudentInfo = async (studentId) => {
      try {
        const response = await $fetch(
          `${config.public.apiBase}/admin/users`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            },
            params: { role: "student" }
          }
        );
        if (response.success) {
          const student = response.data.find((s) => s.id === studentId);
          if (student) {
            selectedStudent.value = student;
            studentSearchQuery.value = `${student.first_name} ${student.last_name} (@${student.username})`;
          }
        }
      } catch (err) {
        console.error("Error fetching student info:", err);
      }
    };
    const checkAutoSelectStudent = async () => {
      if (!user.value || !user.value.roles) {
        autoSelectStudent.value = false;
        return;
      }
      if (user.value.roles.includes("student")) {
        autoSelectStudent.value = true;
        form.student_id = user.value.id;
        try {
          const response = await $fetch(
            `${config.public.apiBase}/admin/users`,
            {
              headers: {
                Authorization: `Bearer ${accessToken.value}`
              },
              params: { role: "student", search: user.value.username || user.value.email }
            }
          );
          if (response.success && response.data.length > 0) {
            const student = response.data.find((s) => s.id === user.value.id) || response.data[0];
            selectedStudent.value = student;
            studentSearchQuery.value = `${student.first_name} ${student.last_name} (@${student.username})`;
          }
        } catch (err) {
          console.error("Error fetching student info:", err);
        }
      } else {
        autoSelectStudent.value = false;
      }
    };
    watch$1(() => props.show, async (show) => {
      if (show) {
        await checkAutoSelectStudent();
        loadCourses();
        if (props.enrollment) {
          loadBranchesForCourse();
          if (props.enrollment.student_id) {
            fetchStudentInfo(props.enrollment.student_id);
          }
        } else {
          if (!autoSelectStudent.value) {
            studentSearchQuery.value = "";
            selectedStudent.value = null;
            filteredStudents.value = [];
          }
          if (props.prefillCourseId) {
            form.course_id = props.prefillCourseId;
            loadBranchesForCourse();
          }
          if (props.prefillEnrollmentType) {
            form.enrollment_type = props.prefillEnrollmentType;
          }
        }
      }
    }, { immediate: true });
    const addressFormRef = ref(null);
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.enrollment ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4">`);
        if (!unref(autoSelectStudent)) {
          _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><div class="relative"><input${ssrRenderAttr("value", unref(studentSearchQuery))} type="text" placeholder=" (, username, )..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900">`);
          if (unref(selectedStudent)) {
            _push(`<div class="absolute right-10 top-1/2 transform -translate-y-1/2 text-green-600"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(showStudentDropdown) && (unref(filteredStudents).length > 0 || unref(studentSearchQuery))) {
            _push(`<div class="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">`);
            if (unref(loadingStudents)) {
              _push(`<div class="px-4 py-2 text-sm text-gray-500"> ... </div>`);
            } else if (unref(filteredStudents).length === 0 && unref(studentSearchQuery)) {
              _push(`<div class="px-4 py-2 text-sm text-gray-500">  </div>`);
            } else {
              _push(`<div class="divide-y divide-gray-200"><!--[-->`);
              ssrRenderList(unref(filteredStudents), (student) => {
                _push(`<button type="button" class="${ssrRenderClass([{ "bg-green-100": unref(form).student_id === student.id }, "w-full text-left px-4 py-2 hover:bg-green-50 focus:bg-green-50 focus:outline-none"])}"><div class="font-medium text-gray-900">${ssrInterpolate(student.first_name)} ${ssrInterpolate(student.last_name)}</div><div class="text-sm text-gray-500">@${ssrInterpolate(student.username)}</div>`);
                if (student.email) {
                  _push(`<div class="text-xs text-gray-400">${ssrInterpolate(student.email)}</div>`);
                } else {
                  _push(`<!---->`);
                }
                _push(`</button>`);
              });
              _push(`<!--]--></div>`);
            }
            _push(`</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div><input${ssrRenderAttr("value", unref(form).student_id)} type="hidden" required></div>`);
        } else {
          _push(`<div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label><div class="px-4 py-2 bg-gray-50 border border-gray-300 rounded-lg"><p class="font-medium text-gray-900">${ssrInterpolate(unref(selectedStudent)?.first_name)} ${ssrInterpolate(unref(selectedStudent)?.last_name)}</p><p class="text-sm text-gray-500">@${ssrInterpolate(unref(selectedStudent)?.username)}</p></div><input${ssrRenderAttr("value", unref(form).student_id)} type="hidden" required></div>`);
        }
        _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).course_id) ? ssrLooseContain(unref(form).course_id, "") : ssrLooseEqual(unref(form).course_id, "")) ? " selected" : ""}></option><!--[-->`);
        ssrRenderList(unref(availableCourses), (course) => {
          _push(`<option${ssrRenderAttr("value", course.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).course_id) ? ssrLooseContain(unref(form).course_id, course.id) : ssrLooseEqual(unref(form).course_id, course.id)) ? " selected" : ""}>${ssrInterpolate(course.title)}</option>`);
        });
        _push(`<!--]--></select></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><div class="flex gap-6"><label class="flex items-center cursor-pointer"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).enrollment_type, "onsite")) ? " checked" : ""} type="radio" value="onsite" class="mr-2 w-4 h-4 text-green-600 focus:ring-green-500"><span class="text-gray-700"> (Onsite)</span></label><label class="flex items-center cursor-pointer"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).enrollment_type, "online")) ? " checked" : ""} type="radio" value="online" class="mr-2 w-4 h-4 text-green-600 focus:ring-green-500"><span class="text-gray-700"> (Online)</span></label></div></div>`);
        if (unref(form).enrollment_type === "onsite") {
          _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select${ssrIncludeBooleanAttr(unref(form).enrollment_type === "onsite") ? " required" : ""}${ssrIncludeBooleanAttr(!unref(form).course_id || unref(loadingBranches)) ? " disabled" : ""} class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 disabled:bg-gray-100 disabled:cursor-not-allowed bg-white text-gray-900"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).branch_id) ? ssrLooseContain(unref(form).branch_id, "") : ssrLooseEqual(unref(form).branch_id, "")) ? " selected" : ""}>${ssrInterpolate(unref(loadingBranches) ? "..." : "")}</option><!--[-->`);
          ssrRenderList(unref(availableBranches), (branch) => {
            _push(`<option${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).branch_id) ? ssrLooseContain(unref(form).branch_id, branch.id) : ssrLooseEqual(unref(form).branch_id, branch.id)) ? " selected" : ""}>${ssrInterpolate(branch.name)}</option>`);
          });
          _push(`<!--]--></select></div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(form).enrollment_type === "online" && unref(form).student_id) {
          _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label>`);
          _push(ssrRenderComponent(AddressSelect, {
            ref_key: "addressSelectRef",
            ref: addressSelectRef,
            modelValue: unref(form).shipping_address_id,
            "onUpdate:modelValue": ($event) => unref(form).shipping_address_id = $event,
            "user-id": unref(form).student_id,
            required: unref(form).enrollment_type === "online",
            placeholder: "",
            hint: "",
            onAddNew: ($event) => showAddressForm.value = true
          }, null, _parent));
          _push(`</div>`);
        } else if (unref(form).enrollment_type === "online" && !unref(form).student_id) {
          _push(`<div class="text-sm text-gray-500">  </div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900"><option value="pending"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "pending") : ssrLooseEqual(unref(form).status, "pending")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "active") : ssrLooseEqual(unref(form).status, "active")) ? " selected" : ""}></option><option value="completed"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "completed") : ssrLooseEqual(unref(form).status, "completed")) ? " selected" : ""}></option><option value="cancelled"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "cancelled") : ssrLooseEqual(unref(form).status, "cancelled")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).enrollment_date)} type="datetime-local" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900" style="${ssrRenderStyle({ "color-scheme": "light" })}"></div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(showAddressForm)) {
          _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-4"><h3 class="text-xl font-bold"></h3><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div>`);
          _push(ssrRenderComponent(AddressForm, {
            ref_key: "addressFormRef",
            ref: addressFormRef,
            address: null,
            onUpdate: ($event) => newAddress.value = $event
          }, null, _parent));
          _push(`<div class="flex justify-end space-x-3 mt-4 pt-4 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="button"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50">  </button></div></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$12 = _sfc_main$12.setup;
_sfc_main$12.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/EnrollmentModal.vue");
  return _sfc_setup$12 ? _sfc_setup$12(props, ctx) : void 0;
};
const EnrollmentModal = Object.assign(_sfc_main$12, { __name: "EnrollmentModal" });

const _sfc_main$11 = /* @__PURE__ */ defineComponent({
  __name: "[id]",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    const router = useRouter();
    useAuth();
    const courseId = computed(() => parseInt(route.params.id));
    const loading = ref(true);
    const error = ref("");
    const courseDetail = ref(null);
    const showEnrollmentModal = ref(false);
    const enrollmentType = ref("online");
    const handleEnrollmentSaved = () => {
      showEnrollmentModal.value = false;
      router.push("/my-courses");
    };
    const getTypeName = (type) => {
      const typeNames = {
        live_online: "Live Online",
        vod: "VOD",
        hybrid: "Hybrid"
      };
      return typeNames[type] || type;
    };
    const getLevelName = (level) => {
      const levelNames = {
        beginner: "",
        intermediate: "",
        advanced: ""
      };
      return levelNames[level] || level;
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_EnrollmentModal = EnrollmentModal;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50" }, _attrs))}>`);
      if (unref(loading)) {
        _push(`<div class="container mx-auto px-4 py-12"><div class="text-center"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div></div>`);
      } else if (unref(error)) {
        _push(`<div class="container mx-auto px-4 py-12"><div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg text-center">${ssrInterpolate(unref(error))}</div></div>`);
      } else if (unref(courseDetail)) {
        _push(`<div class="container mx-auto px-4 py-8"><div class="grid grid-cols-1 lg:grid-cols-3 gap-8"><div class="lg:col-span-2 space-y-6">`);
        if (unref(courseDetail).course.thumbnail_url) {
          _push(`<div class="bg-white rounded-lg shadow overflow-hidden"><img${ssrRenderAttr("src", unref(courseDetail).course.thumbnail_url)}${ssrRenderAttr("alt", unref(courseDetail).course.title)} class="w-full h-auto" style="${ssrRenderStyle({ "max-height": "500px", "object-fit": "cover" })}"></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="bg-white rounded-lg shadow p-6"><div class="mb-4"><span class="px-3 py-1 bg-green-100 text-green-800 rounded-full text-sm font-medium">${ssrInterpolate(getTypeName(unref(courseDetail).course.type))}</span></div><h1 class="text-3xl font-bold text-gray-900 mb-4">${ssrInterpolate(unref(courseDetail).course.title)}</h1>`);
        if (unref(courseDetail).course.description) {
          _push(`<div class="prose max-w-none mb-6">${unref(courseDetail).course.description ?? ""}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="grid grid-cols-2 md:grid-cols-4 gap-4 pt-6 border-t"><div><p class="text-sm text-gray-500 mb-1"></p><p class="font-semibold">${ssrInterpolate(unref(courseDetail).course.duration_hours ? `${unref(courseDetail).course.duration_hours} ` : "-")}</p></div><div><p class="text-sm text-gray-500 mb-1"></p><p class="font-semibold">${ssrInterpolate(unref(courseDetail).course.level ? getLevelName(unref(courseDetail).course.level) : "-")}</p></div><div><p class="text-sm text-gray-500 mb-1"></p><p class="font-semibold">${ssrInterpolate(getTypeName(unref(courseDetail).course.type))}</p></div><div><p class="text-sm text-gray-500 mb-1"></p><p class="font-semibold">${ssrInterpolate(unref(courseDetail).course.code || "-")}</p></div></div></div>`);
        if (unref(courseDetail).branches && unref(courseDetail).branches.length > 0) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="space-y-3"><!--[-->`);
          ssrRenderList(unref(courseDetail).branches, (branch) => {
            _push(`<div class="border border-gray-200 rounded-lg p-4"><h3 class="font-medium text-lg mb-2">${ssrInterpolate(branch.branch_name)}</h3><div class="grid grid-cols-2 gap-2 text-sm text-gray-600"><div>: <span class="font-medium">${ssrInterpolate(branch.seat_limit ? branch.seat_limit.toLocaleString() : "")}</span></div><div>: <span class="font-medium">${ssrInterpolate(branch.current_enrollments || 0)}</span></div>`);
            if (branch.available_seats !== null) {
              _push(`<div> : <span class="font-medium text-green-600">${ssrInterpolate(branch.available_seats)}</span></div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></div>`);
          });
          _push(`<!--]--></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="lg:col-span-1"><div class="bg-white rounded-lg shadow-lg sticky top-4 p-6"><div class="mb-6">`);
        if (unref(courseDetail).course.onsite_price && unref(courseDetail).course.onsite_price !== unref(courseDetail).course.online_price) {
          _push(`<div class="mb-2"><p class="text-sm text-gray-500"> (Onsite)</p><div class="flex items-baseline gap-2"><span class="text-3xl font-bold text-gray-900"> ${ssrInterpolate(unref(courseDetail).course.onsite_price.toLocaleString())}</span></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div><p class="text-sm text-gray-500 mb-1"> (Online)</p><div class="flex items-baseline gap-2">`);
        if (unref(courseDetail).course.online_price < unref(courseDetail).course.price) {
          _push(`<span class="text-sm text-gray-400 line-through"> ${ssrInterpolate(unref(courseDetail).course.price.toLocaleString())}</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<span class="text-3xl font-bold text-green-600"> ${ssrInterpolate(unref(courseDetail).course.online_price.toLocaleString())}</span></div></div></div><div class="space-y-3"><button class="w-full px-6 py-3 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 transition-colors flex items-center justify-center gap-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>  </button>`);
        if (unref(courseDetail).branches && unref(courseDetail).branches.length > 0) {
          _push(`<button class="w-full px-6 py-3 bg-white border-2 border-green-600 text-green-600 rounded-lg font-semibold hover:bg-green-50 transition-colors">  </button>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="mt-6 pt-6 border-t space-y-3"><div class="flex items-start gap-3"><svg class="w-5 h-5 text-green-600 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg><div><p class="font-medium text-sm"></p><p class="text-xs text-gray-500"></p></div></div><div class="flex items-start gap-3"><svg class="w-5 h-5 text-green-600 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg><div><p class="font-medium text-sm"></p><p class="text-xs text-gray-500"></p></div></div><div class="flex items-start gap-3"><svg class="w-5 h-5 text-green-600 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg><div><p class="font-medium text-sm"></p><p class="text-xs text-gray-500">-</p></div></div></div></div></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(showEnrollmentModal)) {
        _push(ssrRenderComponent(_component_EnrollmentModal, {
          show: unref(showEnrollmentModal),
          enrollment: null,
          "prefill-course-id": unref(courseId),
          "prefill-enrollment-type": unref(enrollmentType),
          onClose: ($event) => showEnrollmentModal.value = false,
          onSaved: handleEnrollmentSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$11 = _sfc_main$11.setup;
_sfc_main$11.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/courses/[id].vue");
  return _sfc_setup$11 ? _sfc_setup$11(props, ctx) : void 0;
};

const _id_D2Wpd0Y = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$11
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$10 = /* @__PURE__ */ defineComponent({
  __name: "register",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useRouter();
    useAuth();
    const form = reactive({
      first_name: "",
      last_name: "",
      email: "",
      phone: "",
      password: "",
      confirm_password: "",
      role: "parent",
      accept_terms: false
    });
    const loading = ref(false);
    const error = ref("");
    const showEmailForm = ref(false);
    const loginLink = computed(() => {
      const redirect = route.query.redirect;
      return redirect ? `/auth/login?redirect=${encodeURIComponent(redirect)}` : "/auth/login";
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-[calc(100vh-200px)] flex items-center justify-center py-12" }, _attrs))}><div class="max-w-md w-full mx-4"><div class="bg-white rounded-lg shadow-lg p-8"><h1 class="text-3xl font-bold text-center mb-2"></h1><p class="text-center text-gray-600 text-sm mb-8">  </p>`);
      if (!unref(showEmailForm)) {
        _push(`<div class="space-y-3 mb-6"><button${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="w-full flex items-center justify-center gap-3 px-4 py-3 border-2 border-green-600 text-green-600 rounded-lg font-semibold hover:bg-green-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path></svg><span></span></button><div class="relative my-6"><div class="absolute inset-0 flex items-center"><div class="w-full border-t border-gray-300"></div></div><div class="relative flex justify-center text-sm"><span class="px-2 bg-white text-gray-500"></span></div></div><button${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="w-full flex items-center justify-center gap-3 px-4 py-3 border-2 border-gray-300 rounded-lg font-semibold hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"><svg class="w-5 h-5" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"></path><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"></path><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"></path><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"></path></svg><span> Google</span></button><button${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="w-full flex items-center justify-center gap-3 px-4 py-3 border-2 border-gray-300 rounded-lg font-semibold hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"><svg class="w-5 h-5" fill="#1877F2" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"></path></svg><span> Facebook</span></button><button${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="w-full flex items-center justify-center gap-3 px-4 py-3 bg-[#00C300] text-white rounded-lg font-semibold hover:bg-[#00B300] transition-colors disabled:opacity-50 disabled:cursor-not-allowed"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19.365 9.863c.349 0 .63.285.63.631 0 .345-.281.63-.63.63H17.61v1.125h1.755c.349 0 .63.283.63.63 0 .344-.281.629-.63.629h-2.386c-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.346 0 .627.285.627.63 0 .349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211 0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346 0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195 0 .375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345 0 .63.285.63.63v4.771zm-5.741 0c0 .344-.282.629-.631.629-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346 0 .628.285.628.63v4.771zm-2.466.629H4.917c-.345 0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348 0 .63.285.63.63v4.141h1.756c.348 0 .629.283.629.63 0 .344-.282.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943 0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.086.766.062 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314"></path></svg><span> LINE</span></button></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(showEmailForm)) {
        _push(`<div><div class="mb-4 flex items-center justify-between"><h2 class="text-xl font-semibold"></h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-2 gap-4"><div><label for="first_name" class="block text-sm font-medium text-gray-700 mb-1">  <span class="text-red-500">*</span></label><input id="first_name"${ssrRenderAttr("value", unref(form).first_name)} type="text" required class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder=""></div><div><label for="last_name" class="block text-sm font-medium text-gray-700 mb-1">  <span class="text-red-500">*</span></label><input id="last_name"${ssrRenderAttr("value", unref(form).last_name)} type="text" required class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder=""></div></div><div><label for="email" class="block text-sm font-medium text-gray-700 mb-1">  <span class="text-red-500">*</span></label><input id="email"${ssrRenderAttr("value", unref(form).email)} type="email" required class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder="example@email.com"><p class="mt-1 text-xs text-gray-500"> username </p></div><div><label for="phone" class="block text-sm font-medium text-gray-700 mb-1">  </label><input id="phone"${ssrRenderAttr("value", unref(form).phone)} type="tel" class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder="081-234-5678"></div><div><label for="password" class="block text-sm font-medium text-gray-700 mb-1">  <span class="text-red-500">*</span></label><input id="password"${ssrRenderAttr("value", unref(form).password)} type="password" required minlength="6" class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder=""><p class="mt-1 text-xs text-gray-500"> 6 </p></div><div><label for="confirm_password" class="block text-sm font-medium text-gray-700 mb-1">  <span class="text-red-500">*</span></label><input id="confirm_password"${ssrRenderAttr("value", unref(form).confirm_password)} type="password" required class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder=""></div><div><label class="flex items-start cursor-pointer"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).role, "student")) ? " checked" : ""} type="radio" value="student" class="mt-1 mr-2 w-4 h-4 text-green-600 focus:ring-green-500"><span class="text-sm text-gray-700"><strong></strong> -  </span></label></div><div><label class="flex items-start cursor-pointer"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).role, "parent")) ? " checked" : ""} type="radio" value="parent" class="mt-1 mr-2 w-4 h-4 text-green-600 focus:ring-green-500"><span class="text-sm text-gray-700"><strong></strong> -  () </span></label></div><div class="flex items-start"><input id="terms"${ssrIncludeBooleanAttr(Array.isArray(unref(form).accept_terms) ? ssrLooseContain(unref(form).accept_terms, null) : unref(form).accept_terms) ? " checked" : ""} type="checkbox" required class="mt-1 mr-2 w-4 h-4 rounded border-gray-300 text-green-600 focus:ring-green-500"><label for="terms" class="text-sm text-gray-600">  `);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/terms",
          class: "text-green-600 hover:text-green-700"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(``);
            } else {
              return [
                createTextVNode("")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`  `);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/privacy",
          class: "text-green-600 hover:text-green-700"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(``);
            } else {
              return [
                createTextVNode("")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</label></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded text-sm">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<button type="submit"${ssrIncludeBooleanAttr(unref(loading) || !unref(form).accept_terms) ? " disabled" : ""} class="w-full py-3 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></form></div>`);
      } else {
        _push(`<!---->`);
      }
      if (!unref(showEmailForm)) {
        _push(`<div class="mt-6 text-center"><p class="text-gray-600"> ? `);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: unref(loginLink),
          class: "text-green-600 hover:text-green-700 font-semibold"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</p></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div></div>`);
    };
  }
});
const _sfc_setup$10 = _sfc_main$10.setup;
_sfc_main$10.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/auth/register.vue");
  return _sfc_setup$10 ? _sfc_setup$10(props, ctx) : void 0;
};

const registerCdyLrvRz = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$10
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    useHead({
      title: " - KDC School"
    });
    useRoute();
    const courses = ref([]);
    const loading = ref(true);
    const error = ref(null);
    const pagination = reactive({
      page: 1,
      limit: 15,
      total: 0,
      totalPages: 0
    });
    const searchQuery = ref("");
    const selectedType = ref("");
    const selectedLevel = ref("");
    const selectedBranch = ref("");
    const sortBy = ref("newest");
    const branches = ref([]);
    const loadingBranches = ref(false);
    const formatCourseForCard = (course) => {
      return {
        id: course.id,
        title: course.title,
        description: course.description,
        price: course.price,
        thumbnail: course.thumbnail_url || void 0,
        type: getTypeName(course.type),
        students: course.enrollment_count,
        rating: void 0,
        // TODO: Add rating if available
        originalPrice: void 0
        // TODO: Add original price if available
      };
    };
    const getTypeName = (type) => {
      const typeNames = {
        live_online: "Live Online",
        vod: "Video on Demand",
        hybrid: "Hybrid"
      };
      return typeNames[type] || type;
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_CourseCard = __nuxt_component_0$a;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50" }, _attrs))}><section class="bg-gradient-to-br from-green-500 to-green-700 text-white py-12"><div class="container mx-auto px-4"><h1 class="text-4xl font-bold mb-4"></h1><p class="text-lg text-green-100"></p></div></section><section class="bg-white border-b border-gray-200 sticky top-0 z-10 shadow-sm"><div class="container mx-auto px-4 py-4"><div class="flex flex-col md:flex-row gap-4"><div class="flex-1"><div class="relative"><input${ssrRenderAttr("value", unref(searchQuery))} type="text" placeholder="..." class="w-full px-4 py-2 pl-10 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><svg class="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></div></div><select class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(selectedType)) ? ssrLooseContain(unref(selectedType), "") : ssrLooseEqual(unref(selectedType), "")) ? " selected" : ""}></option><option value="live_online"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedType)) ? ssrLooseContain(unref(selectedType), "live_online") : ssrLooseEqual(unref(selectedType), "live_online")) ? " selected" : ""}>Live Online</option><option value="vod"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedType)) ? ssrLooseContain(unref(selectedType), "vod") : ssrLooseEqual(unref(selectedType), "vod")) ? " selected" : ""}>Video on Demand</option><option value="hybrid"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedType)) ? ssrLooseContain(unref(selectedType), "hybrid") : ssrLooseEqual(unref(selectedType), "hybrid")) ? " selected" : ""}>Hybrid</option></select><select class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(selectedLevel)) ? ssrLooseContain(unref(selectedLevel), "") : ssrLooseEqual(unref(selectedLevel), "")) ? " selected" : ""}></option><option value="beginner"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedLevel)) ? ssrLooseContain(unref(selectedLevel), "beginner") : ssrLooseEqual(unref(selectedLevel), "beginner")) ? " selected" : ""}>Beginner</option><option value="intermediate"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedLevel)) ? ssrLooseContain(unref(selectedLevel), "intermediate") : ssrLooseEqual(unref(selectedLevel), "intermediate")) ? " selected" : ""}>Intermediate</option><option value="advanced"${ssrIncludeBooleanAttr(Array.isArray(unref(selectedLevel)) ? ssrLooseContain(unref(selectedLevel), "advanced") : ssrLooseEqual(unref(selectedLevel), "advanced")) ? " selected" : ""}>Advanced</option></select><select class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"${ssrIncludeBooleanAttr(unref(loadingBranches)) ? " disabled" : ""}><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(selectedBranch)) ? ssrLooseContain(unref(selectedBranch), "") : ssrLooseEqual(unref(selectedBranch), "")) ? " selected" : ""}></option><!--[-->`);
      ssrRenderList(unref(branches), (branch) => {
        _push(`<option${ssrRenderAttr("value", branch.id.toString())}${ssrIncludeBooleanAttr(Array.isArray(unref(selectedBranch)) ? ssrLooseContain(unref(selectedBranch), branch.id.toString()) : ssrLooseEqual(unref(selectedBranch), branch.id.toString())) ? " selected" : ""}>${ssrInterpolate(branch.name)}</option>`);
      });
      _push(`<!--]--></select><select class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="newest"${ssrIncludeBooleanAttr(Array.isArray(unref(sortBy)) ? ssrLooseContain(unref(sortBy), "newest") : ssrLooseEqual(unref(sortBy), "newest")) ? " selected" : ""}></option><option value="popular"${ssrIncludeBooleanAttr(Array.isArray(unref(sortBy)) ? ssrLooseContain(unref(sortBy), "popular") : ssrLooseEqual(unref(sortBy), "popular")) ? " selected" : ""}></option><option value="price_asc"${ssrIncludeBooleanAttr(Array.isArray(unref(sortBy)) ? ssrLooseContain(unref(sortBy), "price_asc") : ssrLooseEqual(unref(sortBy), "price_asc")) ? " selected" : ""}>: -</option><option value="price_desc"${ssrIncludeBooleanAttr(Array.isArray(unref(sortBy)) ? ssrLooseContain(unref(sortBy), "price_desc") : ssrLooseEqual(unref(sortBy), "price_desc")) ? " selected" : ""}>: -</option></select></div></div></section>`);
      if (unref(loading)) {
        _push(`<div class="container mx-auto px-4 py-12"><div class="text-center"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div></div>`);
      } else if (unref(error)) {
        _push(`<div class="container mx-auto px-4 py-12"><div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg text-center">${ssrInterpolate(unref(error))}</div></div>`);
      } else {
        _push(`<section class="container mx-auto px-4 py-8"><div class="mb-6"><p class="text-gray-600">  <span class="font-semibold text-gray-900">${ssrInterpolate(unref(pagination).total)}</span>  </p></div>`);
        if (unref(courses).length === 0) {
          _push(`<div class="text-center py-16"><svg class="mx-auto h-16 w-16 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg><h3 class="text-xl font-semibold text-gray-900 mb-2"></h3><p class="text-gray-600"></p></div>`);
        } else {
          _push(`<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"><!--[-->`);
          ssrRenderList(unref(courses), (course) => {
            _push(ssrRenderComponent(_component_CourseCard, {
              key: course.id,
              course: formatCourseForCard(course)
            }, null, _parent));
          });
          _push(`<!--]--></div>`);
        }
        if (unref(pagination).totalPages > 1) {
          _push(`<div class="mt-8 bg-white px-4 py-3 flex items-center justify-between border-t border-gray-200 rounded-lg shadow-sm"><div class="text-sm text-gray-700">  ${ssrInterpolate((unref(pagination).page - 1) * unref(pagination).limit + 1)}  ${ssrInterpolate(Math.min(unref(pagination).page * unref(pagination).limit, unref(pagination).total))}  ${ssrInterpolate(unref(pagination).total)}  </div><div class="flex space-x-2"><button${ssrIncludeBooleanAttr(unref(pagination).page === 1) ? " disabled" : ""} class="px-4 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100 transition-colors">  </button><button${ssrIncludeBooleanAttr(unref(pagination).page >= unref(pagination).totalPages) ? " disabled" : ""} class="px-4 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100 transition-colors">  </button></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</section>`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$$ = _sfc_main$$.setup;
_sfc_main$$.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/courses/index.vue");
  return _sfc_setup$$ ? _sfc_setup$$(props, ctx) : void 0;
};

const indexBjLz_g6_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$$
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const articles = ref([]);
    const loading = ref(true);
    const error = ref(null);
    const formatDate = (date) => {
      if (!date) return "";
      return format$4(new Date(date), "dd MMMM yyyy", { locale: th });
    };
    useHead({
      title: () => " - KDC Tutor School",
      meta: [
        {
          name: "description",
          content: () => " KDC Tutor School"
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50 py-8" }, _attrs))} data-v-fe7937e4><div class="container mx-auto px-4" data-v-fe7937e4><div class="mb-8" data-v-fe7937e4><h1 class="text-4xl font-bold text-gray-900 mb-4" data-v-fe7937e4></h1><p class="text-gray-600" data-v-fe7937e4> KDC Tutor School</p></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-20" data-v-fe7937e4><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600" data-v-fe7937e4></div><p class="mt-4 text-gray-600" data-v-fe7937e4>...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6" data-v-fe7937e4>${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(articles).length > 0) {
        _push(`<div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6" data-v-fe7937e4><!--[-->`);
        ssrRenderList(unref(articles), (article) => {
          _push(`<article class="bg-white rounded-lg shadow-sm hover:shadow-lg transition-shadow overflow-hidden cursor-pointer" data-v-fe7937e4><div class="aspect-video bg-gradient-to-br from-green-400 to-green-600 flex items-center justify-center" data-v-fe7937e4><div class="text-6xl" data-v-fe7937e4>${ssrInterpolate(article.icon || "")}</div></div><div class="p-6" data-v-fe7937e4><div class="flex items-center space-x-2 mb-3" data-v-fe7937e4>`);
          if (article.category) {
            _push(`<span class="px-3 py-1 bg-green-100 text-green-800 rounded-full text-xs font-medium" data-v-fe7937e4>${ssrInterpolate(article.category)}</span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<span class="text-gray-500 text-xs" data-v-fe7937e4>${ssrInterpolate(formatDate(article.published_at || article.created_at))}</span></div><h2 class="text-xl font-bold text-gray-900 mb-2 line-clamp-2" data-v-fe7937e4>${ssrInterpolate(article.title)}</h2>`);
          if (article.excerpt) {
            _push(`<p class="text-gray-600 text-sm mb-4 line-clamp-3" data-v-fe7937e4>${ssrInterpolate(article.excerpt)}</p>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<div class="flex items-center justify-between" data-v-fe7937e4><span class="text-green-600 text-sm font-medium hover:text-green-700" data-v-fe7937e4>   </span><span class="text-gray-400 text-xs" data-v-fe7937e4>${ssrInterpolate(article.view_count)} views </span></div></div></article>`);
        });
        _push(`<!--]--></div>`);
      } else {
        _push(`<div class="bg-white rounded-lg shadow-sm p-12 text-center" data-v-fe7937e4><div class="text-6xl mb-4" data-v-fe7937e4></div><h2 class="text-2xl font-bold text-gray-900 mb-2" data-v-fe7937e4></h2><p class="text-gray-600" data-v-fe7937e4></p></div>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$_ = _sfc_main$_.setup;
_sfc_main$_.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/articles/index.vue");
  return _sfc_setup$_ ? _sfc_setup$_(props, ctx) : void 0;
};
const index = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__scopeId", "data-v-fe7937e4"]]);

const indexCLWrykF8 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "[slug]",
  __ssrInlineRender: true,
  setup(__props) {
    useRoute();
    const article = ref(null);
    const loading = ref(true);
    const error = ref("");
    const formatDate = (date) => {
      if (!date) return "";
      try {
        const d = new Date(date);
        const months = [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ];
        return `${d.getDate()} ${months[d.getMonth()]} ${d.getFullYear()}`;
      } catch {
        return "";
      }
    };
    useHead({
      title: computed(() => article.value ? article.value.title : "")
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50" }, _attrs))} data-v-eb0d7bd9><div class="container mx-auto px-4 py-12 max-w-4xl" data-v-eb0d7bd9>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12" data-v-eb0d7bd9><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600" data-v-eb0d7bd9></div><p class="mt-2 text-gray-600" data-v-eb0d7bd9>...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6" data-v-eb0d7bd9>${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(article)) {
        _push(`<article class="bg-white rounded-lg shadow-lg overflow-hidden" data-v-eb0d7bd9><div class="aspect-video bg-gradient-to-br from-green-400 to-green-600 flex items-center justify-center" data-v-eb0d7bd9><div class="text-6xl" data-v-eb0d7bd9>${ssrInterpolate(unref(article).icon || "")}</div></div><div class="p-8 border-b" data-v-eb0d7bd9><div class="flex items-center justify-between mb-4" data-v-eb0d7bd9><div class="flex items-center space-x-4" data-v-eb0d7bd9>`);
        if (unref(article).category) {
          _push(`<span class="px-3 py-1 bg-green-100 text-green-800 rounded-full text-sm font-medium" data-v-eb0d7bd9>${ssrInterpolate(unref(article).category)}</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<span class="text-gray-500 text-sm" data-v-eb0d7bd9>${ssrInterpolate(formatDate(unref(article).published_at || unref(article).created_at))}</span></div>`);
        if (unref(article).author_name) {
          _push(`<div class="text-sm text-gray-600" data-v-eb0d7bd9>  ${ssrInterpolate(unref(article).author_name)}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><h1 class="text-4xl font-bold text-gray-900 mb-4" data-v-eb0d7bd9>${ssrInterpolate(unref(article).title)}</h1>`);
        if (unref(article).excerpt) {
          _push(`<p class="text-xl text-gray-600 leading-relaxed" data-v-eb0d7bd9>${ssrInterpolate(unref(article).excerpt)}</p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="p-8 prose prose-lg max-w-none" data-v-eb0d7bd9><div data-v-eb0d7bd9>${unref(article).content ?? ""}</div></div><div class="p-8 bg-gray-50 border-t" data-v-eb0d7bd9><div class="flex items-center justify-between" data-v-eb0d7bd9>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "text-green-600 hover:text-green-700 font-semibold flex items-center"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-eb0d7bd9${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" data-v-eb0d7bd9${_scopeId}></path></svg>  `);
            } else {
              return [
                (openBlock(), createBlock("svg", {
                  class: "w-5 h-5 mr-2",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M10 19l-7-7m0 0l7-7m-7 7h18"
                  })
                ])),
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<div class="text-sm text-gray-500" data-v-eb0d7bd9>  ${ssrInterpolate(unref(article).view_count)}  </div></div></div></article>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$Z = _sfc_main$Z.setup;
_sfc_main$Z.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/articles/[slug].vue");
  return _sfc_setup$Z ? _sfc_setup$Z(props, ctx) : void 0;
};
const _slug_ = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__scopeId", "data-v-eb0d7bd9"]]);

const _slug_CfMQhSJZ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _slug_
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "payment-history",
  __ssrInlineRender: true,
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><h1 class="text-3xl font-bold mb-6"></h1><div class="bg-white rounded-lg shadow p-8 text-center"><svg class="mx-auto h-16 w-16 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><h3 class="text-lg font-semibold text-gray-900 mb-2"></h3><p class="text-gray-600"></p></div></div>`);
    };
  }
});
const _sfc_setup$Y = _sfc_main$Y.setup;
_sfc_main$Y.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/payment-history.vue");
  return _sfc_setup$Y ? _sfc_setup$Y(props, ctx) : void 0;
};

const paymentHistoryBDqgnPfV = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$Y
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    useAuth();
    const rooms = ref([]);
    const courses = ref([]);
    const loading = ref(false);
    const error = ref("");
    const searchQuery = ref("");
    const filters = reactive({
      status: "",
      courseId: null
    });
    const pagination = reactive({
      page: 1,
      limit: 50,
      total: 0,
      totalPages: 0,
      offset: 0
    });
    const getStatusText = (status) => {
      const statusMap = {
        active: "",
        archived: "",
        closed: ""
      };
      return statusMap[status] || status;
    };
    const formatDate = (dateString) => {
      if (!dateString) return "-";
      try {
        return formatDistanceToNow(new Date(dateString), {
          addSuffix: true,
          locale: th
        });
      } catch {
        return dateString;
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-4 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "active") : ssrLooseEqual(unref(filters).status, "active")) ? " selected" : ""}></option><option value="archived"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "archived") : ssrLooseEqual(unref(filters).status, "archived")) ? " selected" : ""}></option><option value="closed"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "closed") : ssrLooseEqual(unref(filters).status, "closed")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> (/)</label><input${ssrRenderAttr("value", unref(searchQuery))} type="text" placeholder="..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option${ssrRenderAttr("value", null)}${ssrIncludeBooleanAttr(Array.isArray(unref(filters).courseId) ? ssrLooseContain(unref(filters).courseId, null) : ssrLooseEqual(unref(filters).courseId, null)) ? " selected" : ""}></option><!--[-->`);
      ssrRenderList(unref(courses), (course) => {
        _push(`<option${ssrRenderAttr("value", course.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(filters).courseId) ? ssrLooseContain(unref(filters).courseId, course.id) : ssrLooseEqual(unref(filters).courseId, course.id)) ? " selected" : ""}>${ssrInterpolate(course.title)}</option>`);
      });
      _push(`<!--]--></select></div><div class="flex items-end"><button class="w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">  </button></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center text-gray-500"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<div><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">  </th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">  </th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">  </th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">  </th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">  </th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">  </th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">  </th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(rooms), (room) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900"> #${ssrInterpolate(room.id)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(room.student?.first_name)} ${ssrInterpolate(room.student?.last_name)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(room.tutor?.first_name)} ${ssrInterpolate(room.tutor?.last_name)}</div></td><td class="px-6 py-4"><div class="text-sm text-gray-900">${ssrInterpolate(room.course?.title)}</div><div class="text-xs text-gray-500">${ssrInterpolate(room.course?.code)}</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([
            "px-2 py-1 text-xs font-semibold rounded-full",
            room.status === "active" ? "bg-green-100 text-green-800" : room.status === "archived" ? "bg-yellow-100 text-yellow-800" : "bg-gray-100 text-gray-800"
          ])}">${ssrInterpolate(getStatusText(room.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(room.last_message_at || room.updated_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">`);
          _push(ssrRenderComponent(_component_NuxtLink, {
            to: `/admin/chat/${room.id}`,
            class: "text-green-600 hover:text-green-900"
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  `);
              } else {
                return [
                  createTextVNode("  ")
                ];
              }
            }),
            _: 2
          }, _parent));
          _push(`</td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
        if (unref(pagination).totalPages > 1) {
          _push(`<div class="px-6 py-4 border-t flex items-center justify-between"><div class="text-sm text-gray-700">  ${ssrInterpolate((unref(pagination).offset || 0) + 1)} - ${ssrInterpolate(Math.min((unref(pagination).offset || 0) + (unref(pagination).limit || 50), unref(pagination).total))}  ${ssrInterpolate(unref(pagination).total)}</div><div class="flex space-x-2"><button${ssrIncludeBooleanAttr(unref(pagination).page <= 1) ? " disabled" : ""} class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed">  </button><button${ssrIncludeBooleanAttr(unref(pagination).page >= unref(pagination).totalPages) ? " disabled" : ""} class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed">  </button></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$X = _sfc_main$X.setup;
_sfc_main$X.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/chat/index.vue");
  return _sfc_setup$X ? _sfc_setup$X(props, ctx) : void 0;
};

const index9b65BEUu = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$X
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "UserModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    user: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const availableRoles = [
      { value: UserRole.SYSTEM_ADMIN, label: "System Admin" },
      { value: UserRole.OWNER, label: "Owner" },
      { value: UserRole.ADMIN, label: "Admin " },
      { value: UserRole.BRANCH_ADMIN, label: "Admin " },
      { value: UserRole.TUTOR, label: "Tutor" }
    ];
    const form = reactive({
      username: "",
      email: "",
      first_name: "",
      last_name: "",
      password: "",
      phone: "",
      roles: []
    });
    const loading = ref(false);
    const error = ref("");
    watch$1(() => props.user, (user) => {
      if (user) {
        form.username = user.username;
        form.email = user.email || "";
        form.first_name = user.first_name;
        form.last_name = user.last_name;
        form.phone = user.phone || "";
        form.password = "";
        form.roles = user.roles.filter(
          (role) => availableRoles.some((r) => r.value === role)
        );
      } else {
        form.username = "";
        form.email = "";
        form.first_name = "";
        form.last_name = "";
        form.password = "";
        form.phone = "";
        form.roles = [];
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.user ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"> Username <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).username)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"${ssrIncludeBooleanAttr(!!__props.user) ? " disabled" : ""}></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Email </label><input${ssrRenderAttr("value", unref(form).email)} type="email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).first_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).last_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span>`);
        if (__props.user) {
          _push(`<span class="text-xs text-gray-500">()</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label><input${ssrRenderAttr("value", unref(form).password)} type="password"${ssrIncludeBooleanAttr(!__props.user) ? " required" : ""} class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).phone)} type="tel" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><div class="grid grid-cols-2 md:grid-cols-3 gap-3"><!--[-->`);
        ssrRenderList(availableRoles, (role) => {
          _push(`<label class="${ssrRenderClass([{ "bg-green-50 border-green-500": unref(form).roles.includes(role.value) }, "flex items-center space-x-2 p-3 border border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50"])}"><input type="checkbox"${ssrRenderAttr("value", role.value)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).roles) ? ssrLooseContain(unref(form).roles, role.value) : unref(form).roles) ? " checked" : ""} class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="text-sm font-medium">${ssrInterpolate(role.label)}</span></label>`);
        });
        _push(`<!--]--></div>`);
        if (unref(form).roles.length === 0) {
          _push(`<p class="mt-2 text-sm text-red-600">  1  </p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading) || unref(form).roles.length === 0) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$W = _sfc_main$W.setup;
_sfc_main$W.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/UserModal.vue");
  return _sfc_setup$W ? _sfc_setup$W(props, ctx) : void 0;
};
const __nuxt_component_0$9 = Object.assign(_sfc_main$W, { __name: "UserModal" });

const _sfc_main$V = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const users = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingUser = ref(null);
    const userToDelete = ref(null);
    const filters = reactive({
      search: "",
      role: "",
      status: ""
    });
    const pagination = reactive({
      page: 1,
      limit: 20,
      total: 0,
      totalPages: 0
    });
    const loadUsers = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams({
          page: pagination.page.toString(),
          limit: pagination.limit.toString()
        });
        if (filters.search) params.append("search", filters.search);
        if (filters.role) params.append("role", filters.role);
        if (filters.status) params.append("status", filters.status);
        const response = await $fetch(`${config.public.apiBase}/admin/users?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          users.value = response.data;
          Object.assign(pagination, response.pagination);
        }
      } catch (err) {
        console.error("Error loading users:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingUser.value = null;
    };
    const handleUserSaved = () => {
      closeModal();
      loadUsers();
    };
    const getRoleDisplayName = (role) => {
      const roleNames = {
        system_admin: "System Admin",
        owner: "Owner",
        admin: "Admin ",
        branch_admin: "Branch Admin",
        tutor: "",
        parent: "",
        student: ""
      };
      return roleNames[role] || role;
    };
    const getRoleBadgeClass = (role) => {
      const classes = {
        system_admin: "bg-purple-100 text-purple-800",
        owner: "bg-indigo-100 text-indigo-800",
        admin: "bg-teal-100 text-teal-800",
        branch_admin: "bg-blue-100 text-blue-800",
        tutor: "bg-green-100 text-green-800",
        parent: "bg-yellow-100 text-yellow-800",
        student: "bg-gray-100 text-gray-800"
      };
      return classes[role] || "bg-gray-100 text-gray-800";
    };
    const getStatusDisplayName = (status) => {
      const statusNames = {
        active: "",
        inactive: "",
        suspended: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        active: "bg-green-100 text-green-800",
        inactive: "bg-gray-100 text-gray-800",
        suspended: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UserModal = __nuxt_component_0$9;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-3 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=" username, email, " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "") : ssrLooseEqual(unref(filters).role, "")) ? " selected" : ""}></option><option value="system_admin"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "system_admin") : ssrLooseEqual(unref(filters).role, "system_admin")) ? " selected" : ""}>System Admin</option><option value="owner"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "owner") : ssrLooseEqual(unref(filters).role, "owner")) ? " selected" : ""}>Owner</option><option value="admin"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "admin") : ssrLooseEqual(unref(filters).role, "admin")) ? " selected" : ""}>Admin </option><option value="branch_admin"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "branch_admin") : ssrLooseEqual(unref(filters).role, "branch_admin")) ? " selected" : ""}>Branch Admin</option><option value="tutor"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "tutor") : ssrLooseEqual(unref(filters).role, "tutor")) ? " selected" : ""}>Tutor</option><option value="parent"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "parent") : ssrLooseEqual(unref(filters).role, "parent")) ? " selected" : ""}>Parent</option><option value="student"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "student") : ssrLooseEqual(unref(filters).role, "student")) ? " selected" : ""}>Student</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "active") : ssrLooseEqual(unref(filters).status, "active")) ? " selected" : ""}>Active</option><option value="inactive"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "inactive") : ssrLooseEqual(unref(filters).status, "inactive")) ? " selected" : ""}>Inactive</option><option value="suspended"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "suspended") : ssrLooseEqual(unref(filters).status, "suspended")) ? " selected" : ""}>Suspended</option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(users).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(users), (user) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div><div class="text-sm font-medium text-gray-900">${ssrInterpolate(user.first_name)} ${ssrInterpolate(user.last_name)}</div><div class="text-sm text-gray-500">${ssrInterpolate(user.username)}</div>`);
          if (user.email) {
            _push(`<div class="text-xs text-gray-400">${ssrInterpolate(user.email)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="flex flex-wrap gap-1"><!--[-->`);
          ssrRenderList(user.roles, (role) => {
            _push(`<span class="${ssrRenderClass([getRoleBadgeClass(role), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getRoleDisplayName(role))}</span>`);
          });
          _push(`<!--]--></div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(user.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusDisplayName(user.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(user.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>`);
          if (user.status === "active") {
            _push(`<button class="text-yellow-600 hover:text-yellow-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"></path></svg></button>`);
          } else {
            _push(`<button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>`);
          }
          _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      if (unref(pagination).totalPages > 1) {
        _push(`<div class="bg-gray-50 px-4 py-3 flex items-center justify-between border-t border-gray-200"><div class="text-sm text-gray-700">  ${ssrInterpolate((unref(pagination).page - 1) * unref(pagination).limit + 1)}  ${ssrInterpolate(Math.min(unref(pagination).page * unref(pagination).limit, unref(pagination).total))}  ${ssrInterpolate(unref(pagination).total)}  </div><div class="flex space-x-2"><button${ssrIncludeBooleanAttr(unref(pagination).page === 1) ? " disabled" : ""} class="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100">  </button><button${ssrIncludeBooleanAttr(unref(pagination).page >= unref(pagination).totalPages) ? " disabled" : ""} class="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100">  </button></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (unref(showCreateModal) || unref(editingUser)) {
        _push(ssrRenderComponent(_component_UserModal, {
          show: unref(showCreateModal) || !!unref(editingUser),
          user: unref(editingUser),
          onClose: closeModal,
          onSaved: handleUserSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (unref(userToDelete)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-md w-full mx-4"><h3 class="text-lg font-semibold mb-4"></h3><p class="text-gray-600 mb-6">  <strong>${ssrInterpolate(unref(userToDelete).first_name)} ${ssrInterpolate(unref(userToDelete).last_name)}</strong>? <br><span class="text-sm text-red-600"></span></p><div class="flex justify-end space-x-3"><button class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">  </button></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$V = _sfc_main$V.setup;
_sfc_main$V.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/users/index.vue");
  return _sfc_setup$V ? _sfc_setup$V(props, ctx) : void 0;
};

const indexDZHCqHn_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$V
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$U = /* @__PURE__ */ defineComponent({
  __name: "[roomId]",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useAuth();
    const roomId = computed(() => parseInt(route.params.roomId));
    const room = ref(null);
    const messages = ref([]);
    const loading = ref(true);
    const loadingMessages = ref(false);
    const error = ref("");
    const previewImage = ref(null);
    ref(0);
    const hasMoreMessages = ref(true);
    const formatTime = (dateString) => {
      try {
        return format$4(new Date(dateString), "dd/MM/yyyy HH:mm", { locale: th });
      } catch {
        return dateString;
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/admin/chat",
        class: "p-2 hover:bg-gray-100 rounded-lg"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"${_scopeId}></path></svg>`);
          } else {
            return [
              (openBlock(), createBlock("svg", {
                class: "w-6 h-6",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M10 19l-7-7m0 0l7-7m-7 7h18"
                })
              ]))
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<h1 class="text-3xl font-bold"> #${ssrInterpolate(unref(roomId))}</h1></div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(room)) {
        _push(`<div class="h-[calc(100vh-200px)] flex flex-col bg-white rounded-lg shadow"><div class="border-b p-4 bg-gray-50"><div class="grid grid-cols-1 md:grid-cols-3 gap-4"><div><p class="text-sm text-gray-500"></p><p class="font-semibold">${ssrInterpolate(unref(room).student?.first_name)} ${ssrInterpolate(unref(room).student?.last_name)}</p></div><div><p class="text-sm text-gray-500"></p><p class="font-semibold">${ssrInterpolate(unref(room).tutor?.first_name)} ${ssrInterpolate(unref(room).tutor?.last_name)}</p></div><div><p class="text-sm text-gray-500"></p><p class="font-semibold">${ssrInterpolate(unref(room).course?.title)}</p></div></div></div><div class="flex-1 overflow-y-auto p-4 space-y-1">`);
        if (unref(loadingMessages)) {
          _push(`<div class="text-center py-2 text-sm text-gray-500"> ... </div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(hasMoreMessages) && !unref(loadingMessages)) {
          _push(`<div class="text-center py-2"><button class="text-sm text-green-600 hover:text-green-700 font-medium">  </button></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<!--[-->`);
        ssrRenderList(unref(messages), (message) => {
          _push(`<div class="${ssrRenderClass([message.sender_id === unref(room).student_id ? "justify-end" : "justify-start", "flex mb-4"])}"><div class="flex space-x-2 max-w-[70%]"><div class="${ssrRenderClass([
            "rounded-lg px-4 py-2",
            message.sender_id === unref(room).student_id ? "bg-green-600 text-white" : "bg-gray-100 text-gray-900"
          ])}">`);
          if (message.message_type === "text") {
            _push(`<p class="whitespace-pre-wrap">${ssrInterpolate(message.content)}</p>`);
          } else if (message.message_type === "image" && message.file_url) {
            _push(`<img${ssrRenderAttr("src", message.file_url)} alt="Image" class="rounded-lg max-w-sm cursor-pointer">`);
          } else if (message.message_type === "file" && message.file_url) {
            _push(`<a${ssrRenderAttr("href", message.file_url)} target="_blank" class="flex items-center space-x-2 text-sm hover:underline"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg><span>${ssrInterpolate(message.file_name || "")}</span></a>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<p class="text-xs opacity-75 mt-1">${ssrInterpolate(formatTime(message.created_at))}</p></div></div></div>`);
        });
        _push(`<!--]--></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(previewImage)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"><img${ssrRenderAttr("src", unref(previewImage))} alt="Preview" class="max-w-full max-h-full object-contain"></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$U = _sfc_main$U.setup;
_sfc_main$U.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/chat/[roomId].vue");
  return _sfc_setup$U ? _sfc_setup$U(props, ctx) : void 0;
};

const _roomId_Qi9MxOXe = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$U
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$T = /* @__PURE__ */ defineComponent({
  __name: "RichTextEditor",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    entityType: {},
    entityId: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const showImageDialog = ref(false);
    const showLinkDialog = ref(false);
    const imageUrl = ref("");
    const linkUrl = ref("");
    const uploadingImage = ref(false);
    ref(null);
    useAuth();
    const editor = useEditor({
      content: props.modelValue,
      extensions: [
        StarterKit.configure({
          heading: {
            levels: [1, 2, 3]
          }
        }),
        Image.configure({
          inline: true,
          allowBase64: true
        }),
        Link.configure({
          openOnClick: false,
          HTMLAttributes: {
            target: "_blank",
            rel: "noopener noreferrer"
          }
        }),
        TextAlign.configure({
          types: ["heading", "paragraph"]
        })
        // Note: Underline extension - uncomment if package is installed
        // Underline
      ],
      onUpdate: ({ editor: editor2 }) => {
        emit("update:modelValue", editor2.getHTML());
      }
    });
    watch$1(() => props.modelValue, (value) => {
      const isSame = editor.value?.getHTML() === value;
      if (!isSame) {
        editor.value?.commands.setContent(value || "");
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "rich-text-editor" }, _attrs))}>`);
      if (unref(editor)) {
        _push(`<div class="border border-gray-300 rounded-lg overflow-hidden"><div class="border-b border-gray-300 bg-gray-50 p-2 flex flex-wrap gap-1"><button type="button" class="${ssrRenderClass([
          "p-2 rounded hover:bg-gray-200",
          unref(editor).isActive("bold") ? "bg-gray-300" : ""
        ])}" title="Bold"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 4h8a4 4 0 014 4 4 4 0 01-4 4H6z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 12h9a4 4 0 014 4 4 4 0 01-4 4H6z"></path></svg></button><button type="button" class="${ssrRenderClass([
          "p-2 rounded hover:bg-gray-200",
          unref(editor).isActive("italic") ? "bg-gray-300" : ""
        ])}" title="Italic"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg></button><div class="w-px h-6 bg-gray-300 mx-1"></div><button type="button" class="${ssrRenderClass([
          "p-2 rounded hover:bg-gray-200",
          unref(editor).isActive("heading", { level: 1 }) ? "bg-gray-300" : ""
        ])}" title="Heading 1"> H1 </button><button type="button" class="${ssrRenderClass([
          "p-2 rounded hover:bg-gray-200",
          unref(editor).isActive("heading", { level: 2 }) ? "bg-gray-300" : ""
        ])}" title="Heading 2"> H2 </button><button type="button" class="${ssrRenderClass([
          "p-2 rounded hover:bg-gray-200",
          unref(editor).isActive("heading", { level: 3 }) ? "bg-gray-300" : ""
        ])}" title="Heading 3"> H3 </button><div class="w-px h-6 bg-gray-300 mx-1"></div><button type="button" class="${ssrRenderClass([
          "p-2 rounded hover:bg-gray-200",
          unref(editor).isActive("bulletList") ? "bg-gray-300" : ""
        ])}" title="Bullet List"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 6h13M8 12h13m-13 6h13M3 6h.01M3 12h.01M3 18h.01"></path></svg></button><button type="button" class="${ssrRenderClass([
          "p-2 rounded hover:bg-gray-200",
          unref(editor).isActive("orderedList") ? "bg-gray-300" : ""
        ])}" title="Numbered List"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14"></path></svg></button><div class="w-px h-6 bg-gray-300 mx-1"></div><button type="button" class="p-2 rounded hover:bg-gray-200" title="Insert Image"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg></button><button type="button" class="${ssrRenderClass([
          "p-2 rounded hover:bg-gray-200",
          unref(editor).isActive("link") ? "bg-gray-300" : ""
        ])}" title="Insert Link"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></button></div>`);
        _push(ssrRenderComponent(unref(EditorContent), {
          editor: unref(editor),
          class: "prose max-w-none min-h-[300px] p-4 focus:outline-none"
        }, null, _parent));
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(showImageDialog)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-md w-full mx-4"><h3 class="text-lg font-semibold mb-4"></h3><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input type="file" accept="image/*" class="hidden"><div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-green-500 transition-colors cursor-pointer"><svg class="w-12 h-12 mx-auto text-gray-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg><p class="text-sm text-gray-600 mb-1"><span class="text-green-600 font-medium"></span>  </p><p class="text-xs text-gray-500">: JPG, PNG, GIF, WebP ( 5MB)</p>`);
        if (unref(uploadingImage)) {
          _push(`<div class="mt-2"><div class="inline-block animate-spin rounded-full h-5 w-5 border-b-2 border-green-600"></div><p class="text-xs text-gray-600 mt-1">...</p></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div><div class="relative"><div class="absolute inset-0 flex items-center"><div class="w-full border-t border-gray-300"></div></div><div class="relative flex justify-center text-sm"><span class="px-2 bg-white text-gray-500"></span></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> URL </label><input${ssrRenderAttr("value", unref(imageUrl))} type="text" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="https://example.com/image.jpg"></div><div class="flex justify-end space-x-2"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="button"${ssrIncludeBooleanAttr(!unref(imageUrl) || unref(uploadingImage)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">  URL </button></div></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(showLinkDialog)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-md w-full mx-4"><h3 class="text-lg font-semibold mb-4"></h3><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">URL</label><input${ssrRenderAttr("value", unref(linkUrl))} type="text" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="https://example.com"></div><div class="flex justify-end space-x-2"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="button" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">  </button></div></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$T = _sfc_main$T.setup;
_sfc_main$T.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/RichTextEditor.vue");
  return _sfc_setup$T ? _sfc_setup$T(props, ctx) : void 0;
};
const RichTextEditor = Object.assign(_sfc_main$T, { __name: "RichTextEditor" });

const _sfc_main$1$a = /* @__PURE__ */ defineComponent({
  __name: "CourseModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    course: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const form = reactive({
      title: "",
      description: "",
      thumbnail_url: "",
      type: "",
      price: 0,
      duration_hours: null,
      level: "",
      status: "draft",
      code: "",
      selectedBranches: []
    });
    const loading = ref(false);
    const loadingBranches = ref(false);
    const error = ref("");
    const branchError = ref("");
    const availableBranches = ref([]);
    const branchSeatLimits = ref({});
    const uploadingThumbnail = ref(false);
    ref(null);
    const loadBranches = async () => {
      loadingBranches.value = true;
      branchError.value = "";
      try {
        const response = await $fetch(
          `${config.public.apiBase}/admin/branches`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          availableBranches.value = response.data || [];
          console.log("[CourseModal] Loaded branches:", availableBranches.value.length);
          if (availableBranches.value.length === 0) {
            branchError.value = " ";
          }
        } else {
          branchError.value = "";
        }
      } catch (err) {
        console.error("[CourseModal] Error loading branches:", err);
        branchError.value = err.data?.message || err.message || "";
      } finally {
        loadingBranches.value = false;
      }
    };
    const getBranchSeatLimit = (branchId) => {
      return branchSeatLimits.value[branchId] ?? "";
    };
    watch$1(() => props.course, (course) => {
      if (course) {
        form.title = course.title;
        form.description = course.description || "";
        form.type = course.type;
        form.price = course.price;
        form.duration_hours = course.duration_hours || null;
        form.level = course.level || "";
        form.status = course.status;
        form.code = course.code || "";
        form.thumbnail_url = course.thumbnail_url || "";
        if (course.branches && course.branches.length > 0) {
          form.selectedBranches = course.branches.map((b) => b.branch_id);
          course.branches.forEach((b) => {
            if (b.seat_limit !== null && b.seat_limit !== void 0) {
              branchSeatLimits.value[b.branch_id] = b.seat_limit;
            }
          });
        } else {
          form.selectedBranches = [];
        }
      } else {
        form.title = "";
        form.description = "";
        form.type = "";
        form.price = 0;
        form.duration_hours = null;
        form.level = "";
        form.status = "draft";
        form.code = "";
        form.thumbnail_url = "";
        form.selectedBranches = [];
        branchSeatLimits.value = {};
      }
      error.value = "";
      branchError.value = "";
    }, { immediate: true });
    watch$1(() => props.show, (show) => {
      if (show) {
        loadBranches();
        if (!props.course) {
          branchSeatLimits.value = {};
        }
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-3xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.course ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).title)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=""></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).code)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" COURSE001"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "") : ssrLooseEqual(unref(form).type, "")) ? " selected" : ""}></option><option value="live_online"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "live_online") : ssrLooseEqual(unref(form).type, "live_online")) ? " selected" : ""}>Live Online</option><option value="vod"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "vod") : ssrLooseEqual(unref(form).type, "vod")) ? " selected" : ""}>VOD</option><option value="hybrid"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "hybrid") : ssrLooseEqual(unref(form).type, "hybrid")) ? " selected" : ""}>Hybrid</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  () <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).price)} type="number" step="0.01" min="0" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="0.00"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  () </label><input${ssrRenderAttr("value", unref(form).duration_hours)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="0"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).level) ? ssrLooseContain(unref(form).level, "") : ssrLooseEqual(unref(form).level, "")) ? " selected" : ""}></option><option value="beginner"${ssrIncludeBooleanAttr(Array.isArray(unref(form).level) ? ssrLooseContain(unref(form).level, "beginner") : ssrLooseEqual(unref(form).level, "beginner")) ? " selected" : ""}></option><option value="intermediate"${ssrIncludeBooleanAttr(Array.isArray(unref(form).level) ? ssrLooseContain(unref(form).level, "intermediate") : ssrLooseEqual(unref(form).level, "intermediate")) ? " selected" : ""}></option><option value="advanced"${ssrIncludeBooleanAttr(Array.isArray(unref(form).level) ? ssrLooseContain(unref(form).level, "advanced") : ssrLooseEqual(unref(form).level, "advanced")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="draft"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "draft") : ssrLooseEqual(unref(form).status, "draft")) ? " selected" : ""}></option><option value="published"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "published") : ssrLooseEqual(unref(form).status, "published")) ? " selected" : ""}></option><option value="archived"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "archived") : ssrLooseEqual(unref(form).status, "archived")) ? " selected" : ""}></option></select></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label>`);
        if (unref(loadingBranches)) {
          _push(`<div class="text-sm text-gray-500 py-2"> ... </div>`);
        } else if (unref(branchError)) {
          _push(`<div class="text-sm text-red-500 py-2 bg-red-50 border border-red-200 rounded p-2">${ssrInterpolate(unref(branchError))}</div>`);
        } else if (unref(availableBranches).length === 0) {
          _push(`<div class="text-sm text-yellow-600 py-2 bg-yellow-50 border border-yellow-200 rounded p-2">    </div>`);
        } else {
          _push(`<div class="space-y-2 border border-gray-300 rounded-lg p-3"><!--[-->`);
          ssrRenderList(unref(availableBranches), (branch) => {
            _push(`<div class="border-b border-gray-200 pb-3 last:border-b-0 last:pb-0"><label class="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded"><input type="checkbox"${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).selectedBranches) ? ssrLooseContain(unref(form).selectedBranches, branch.id) : unref(form).selectedBranches) ? " checked" : ""} class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><div class="flex-1"><span class="text-sm font-medium text-gray-700">${ssrInterpolate(branch.name)}</span>`);
            if (branch.code) {
              _push(`<span class="text-xs text-gray-500 ml-1">(${ssrInterpolate(branch.code)})</span>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></label>`);
            if (unref(form).selectedBranches.includes(branch.id)) {
              _push(`<div class="mt-2 ml-6"><label class="block text-xs font-medium text-gray-600 mb-1">  () </label><input type="number"${ssrRenderAttr("value", getBranchSeatLimit(branch.id))} min="1" class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" ()"><p class="text-xs text-gray-500 mt-1"></p></div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div>`);
          });
          _push(`<!--]--></div>`);
        }
        if (unref(form).selectedBranches.length === 0 && !unref(loadingBranches) && unref(availableBranches).length > 0) {
          _push(`<p class="text-xs text-red-500 mt-1">  1  </p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label><div class="space-y-3"><div class="bg-blue-50 border border-blue-200 rounded-lg p-4"><p class="text-sm font-semibold text-blue-900 mb-2"> :</p><ul class="text-sm text-blue-800 space-y-1 list-disc list-inside"><li><strong>:</strong> 1280 x 720 pixels</li><li><strong>:</strong> 16:9 ()</li><li><strong>:</strong> JPG, PNG, WebP</li><li><strong>:</strong>  2 MB ( &lt; 500 KB)</li></ul></div>`);
        if (unref(uploadingThumbnail)) {
          _push(`<div class="text-sm text-gray-600 py-2"> ... </div>`);
        } else if (unref(form).thumbnail_url) {
          _push(`<div class="space-y-3"><div class="aspect-video bg-gray-200 rounded-lg overflow-hidden max-w-2xl"><img${ssrRenderAttr("src", unref(form).thumbnail_url)} alt="Thumbnail preview" class="w-full h-full object-cover"></div><button type="button" class="px-3 py-2 text-sm text-red-600 hover:bg-red-50 rounded-lg border border-red-200">  </button></div>`);
        } else {
          _push(`<div class="border-2 border-dashed border-gray-300 rounded-lg p-4"><input type="file" accept="image/jpeg,image/png,image/webp" class="hidden"><button type="button" class="w-full px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"><svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>  </button><p class="text-xs text-gray-500 mt-2 text-center">: JPG, PNG, WebP ( 2 MB)</p></div>`);
        }
        _push(`</div></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label>`);
        _push(ssrRenderComponent(RichTextEditor, {
          modelValue: unref(form).description,
          "onUpdate:modelValue": ($event) => unref(form).description = $event,
          "entity-type": "courses",
          "entity-id": props.course?.id,
          class: "w-full"
        }, null, _parent));
        _push(`</div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$a = _sfc_main$1$a.setup;
_sfc_main$1$a.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/CourseModal.vue");
  return _sfc_setup$1$a ? _sfc_setup$1$a(props, ctx) : void 0;
};
const __nuxt_component_0$8 = Object.assign(_sfc_main$1$a, { __name: "CourseModal" });
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    useRouter();
    const courses = ref([]);
    const loading = ref(true);
    const error = ref("");
    const showCreateModal = ref(false);
    const filters = reactive({
      search: "",
      type: "",
      status: ""
    });
    const loadCourses = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = {};
        if (filters.search) params.search = filters.search;
        if (filters.type) params.type = filters.type;
        if (filters.status) params.status = filters.status;
        const response = await $fetch(`${config.public.apiBase}/admin/courses`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          },
          params
        });
        if (response.success) {
          courses.value = response.data;
        }
      } catch (err) {
        console.error("Error loading courses:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
    };
    const handleCourseSaved = async () => {
      closeModal();
      await loadCourses();
    };
    const getTypeName = (type) => {
      const typeNames = {
        live_online: "Live Online",
        vod: "VOD",
        hybrid: "Hybrid"
      };
      return typeNames[type] || type;
    };
    const getTypeBadgeClass = (type) => {
      const classes = {
        live_online: "bg-blue-100 text-blue-800",
        vod: "bg-purple-100 text-purple-800",
        hybrid: "bg-indigo-100 text-indigo-800"
      };
      return classes[type] || "bg-gray-100 text-gray-800";
    };
    const getStatusName = (status) => {
      const statusNames = {
        draft: "",
        published: "",
        archived: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        draft: "bg-gray-100 text-gray-800",
        published: "bg-green-100 text-green-800",
        archived: "bg-yellow-100 text-yellow-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getLevelName = (level) => {
      const levelNames = {
        beginner: "",
        intermediate: "",
        advanced: ""
      };
      return levelNames[level] || level;
    };
    const formatCurrency = (amount) => {
      return new Intl.NumberFormat("th-TH", {
        style: "currency",
        currency: "THB"
      }).format(amount);
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_CourseModal = __nuxt_component_0$8;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-3 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).type) ? ssrLooseContain(unref(filters).type, "") : ssrLooseEqual(unref(filters).type, "")) ? " selected" : ""}></option><option value="live_online"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).type) ? ssrLooseContain(unref(filters).type, "live_online") : ssrLooseEqual(unref(filters).type, "live_online")) ? " selected" : ""}>Live Online</option><option value="vod"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).type) ? ssrLooseContain(unref(filters).type, "vod") : ssrLooseEqual(unref(filters).type, "vod")) ? " selected" : ""}>VOD</option><option value="hybrid"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).type) ? ssrLooseContain(unref(filters).type, "hybrid") : ssrLooseEqual(unref(filters).type, "hybrid")) ? " selected" : ""}>Hybrid</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="draft"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "draft") : ssrLooseEqual(unref(filters).status, "draft")) ? " selected" : ""}></option><option value="published"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "published") : ssrLooseEqual(unref(filters).status, "published")) ? " selected" : ""}></option><option value="archived"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "archived") : ssrLooseEqual(unref(filters).status, "archived")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(courses).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(courses), (course) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 cursor-pointer"><div><div class="text-sm font-medium text-green-600 hover:text-green-700 cursor-pointer">${ssrInterpolate(course.title)}</div>`);
          if (course.code) {
            _push(`<div class="text-xs text-gray-500">: ${ssrInterpolate(course.code)}</div>`);
          } else {
            _push(`<!---->`);
          }
          if (course.description) {
            _push(`<div class="text-xs text-gray-400 mt-1 line-clamp-2">${ssrInterpolate(course.description)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getTypeBadgeClass(course.type), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getTypeName(course.type))}</span></td><td class="px-6 py-4 whitespace-nowrap"><span class="text-sm font-medium text-gray-900">${ssrInterpolate(formatCurrency(course.price))}</span></td><td class="px-6 py-4 whitespace-nowrap">`);
          if (course.level) {
            _push(`<span class="text-sm text-gray-600">${ssrInterpolate(getLevelName(course.level))}</span>`);
          } else {
            _push(`<span class="text-sm text-gray-400">-</span>`);
          }
          _push(`</td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(course.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusName(course.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(course.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>`);
          if (course.status === "published") {
            _push(`<button class="text-yellow-600 hover:text-yellow-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"></path></svg></button>`);
          } else if (course.status === "archived") {
            _push(`<button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>`);
          } else if (course.status === "draft") {
            _push(`<button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      if (unref(showCreateModal)) {
        _push(ssrRenderComponent(_component_CourseModal, {
          show: unref(showCreateModal),
          course: null,
          onClose: closeModal,
          onSaved: handleCourseSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$S = _sfc_main$S.setup;
_sfc_main$S.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/courses/index.vue");
  return _sfc_setup$S ? _sfc_setup$S(props, ctx) : void 0;
};

const indexDjC_26Kt = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$S
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "StudentModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    student: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const form = reactive({
      username: "",
      email: "",
      first_name: "",
      last_name: "",
      password: "",
      phone: ""
    });
    const loading = ref(false);
    const error = ref("");
    watch$1(() => props.student, (student) => {
      if (student) {
        form.username = student.username;
        form.email = student.email || "";
        form.first_name = student.first_name;
        form.last_name = student.last_name;
        form.phone = student.phone || "";
        form.password = "";
      } else {
        form.username = "";
        form.email = "";
        form.first_name = "";
        form.last_name = "";
        form.password = "";
        form.phone = "";
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.student ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"> Username <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).username)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"${ssrIncludeBooleanAttr(!!__props.student) ? " disabled" : ""}></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Email </label><input${ssrRenderAttr("value", unref(form).email)} type="email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).first_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).last_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span>`);
        if (__props.student) {
          _push(`<span class="text-xs text-gray-500">()</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label><input${ssrRenderAttr("value", unref(form).password)} type="password"${ssrIncludeBooleanAttr(!__props.student) ? " required" : ""} class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).phone)} type="tel" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$R = _sfc_main$R.setup;
_sfc_main$R.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/StudentModal.vue");
  return _sfc_setup$R ? _sfc_setup$R(props, ctx) : void 0;
};
const __nuxt_component_1$2 = Object.assign(_sfc_main$R, { __name: "StudentModal" });

const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    useRouter();
    const students = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingStudent = ref(null);
    const filters = reactive({
      search: "",
      status: ""
    });
    const pagination = reactive({
      page: 1,
      limit: 20,
      total: 0,
      totalPages: 0
    });
    const loadStudents = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams({
          page: pagination.page.toString(),
          limit: pagination.limit.toString()
        });
        if (filters.search) params.append("search", filters.search);
        if (filters.status) params.append("status", filters.status);
        const response = await $fetch(`${config.public.apiBase}/admin/students?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          students.value = response.data;
          Object.assign(pagination, response.pagination);
        }
      } catch (err) {
        console.error("Error loading students:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingStudent.value = null;
    };
    const handleStudentSaved = () => {
      closeModal();
      loadStudents();
    };
    const getStatusDisplayName = (status) => {
      const statusNames = {
        active: "",
        inactive: "",
        suspended: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        active: "bg-green-100 text-green-800",
        inactive: "bg-gray-100 text-gray-800",
        suspended: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getRelationshipName = (relationship) => {
      const relationshipNames = {
        father: "",
        mother: "",
        guardian: ""
      };
      return relationshipNames[relationship] || relationship;
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_StudentModal = __nuxt_component_1$2;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=" username, email, " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "active") : ssrLooseEqual(unref(filters).status, "active")) ? " selected" : ""}></option><option value="inactive"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "inactive") : ssrLooseEqual(unref(filters).status, "inactive")) ? " selected" : ""}></option><option value="suspended"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "suspended") : ssrLooseEqual(unref(filters).status, "suspended")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(students).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(students), (student) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap cursor-pointer"><div><div class="text-sm font-medium text-green-600 hover:text-green-700 cursor-pointer">${ssrInterpolate(student.first_name)} ${ssrInterpolate(student.last_name)}</div><div class="text-sm text-gray-500">${ssrInterpolate(student.username)}</div>`);
          if (student.email) {
            _push(`<div class="text-xs text-gray-400">${ssrInterpolate(student.email)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4">`);
          if (student.parents && student.parents.length > 0) {
            _push(`<div class="space-y-1"><!--[-->`);
            ssrRenderList(student.parents, (parent) => {
              _push(`<div class="text-sm"><span class="font-medium text-gray-900">${ssrInterpolate(parent.name)}</span><span class="text-gray-500 ml-2">(${ssrInterpolate(getRelationshipName(parent.relationship))})</span></div>`);
            });
            _push(`<!--]--></div>`);
          } else {
            _push(`<div class="text-sm text-gray-400"></div>`);
          }
          _push(`</td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(student.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusDisplayName(student.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(student.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>`);
          if (student.status === "active") {
            _push(`<button class="text-yellow-600 hover:text-yellow-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"></path></svg></button>`);
          } else {
            _push(`<button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>`);
          }
          _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      if (unref(pagination).totalPages > 1) {
        _push(`<div class="bg-gray-50 px-4 py-3 flex items-center justify-between border-t border-gray-200"><div class="text-sm text-gray-700">  ${ssrInterpolate((unref(pagination).page - 1) * unref(pagination).limit + 1)}  ${ssrInterpolate(Math.min(unref(pagination).page * unref(pagination).limit, unref(pagination).total))}  ${ssrInterpolate(unref(pagination).total)}  </div><div class="flex space-x-2"><button${ssrIncludeBooleanAttr(unref(pagination).page === 1) ? " disabled" : ""} class="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100">  </button><button${ssrIncludeBooleanAttr(unref(pagination).page >= unref(pagination).totalPages) ? " disabled" : ""} class="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100">  </button></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (unref(showCreateModal) || unref(editingStudent)) {
        _push(ssrRenderComponent(_component_StudentModal, {
          show: unref(showCreateModal) || !!unref(editingStudent),
          student: unref(editingStudent),
          onClose: closeModal,
          onSaved: handleStudentSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$Q = _sfc_main$Q.setup;
_sfc_main$Q.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/students/index.vue");
  return _sfc_setup$Q ? _sfc_setup$Q(props, ctx) : void 0;
};

const indexBqsX72xU = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$Q
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "forgot-password",
  __ssrInlineRender: true,
  setup(__props) {
    const form = ref({
      identifier: ""
    });
    const loading = ref(false);
    const error = ref(null);
    const success = ref(null);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-[calc(100vh-200px)] flex items-center justify-center py-12" }, _attrs))}><div class="max-w-md w-full mx-4"><div class="bg-white rounded-lg shadow-lg p-8"><h1 class="text-3xl font-bold text-center mb-2"></h1><p class="text-gray-600 text-center mb-8">   </p><form class="space-y-6"><div><label for="identifier" class="block text-sm font-medium text-gray-700 mb-2">    </label><input id="identifier"${ssrRenderAttr("value", unref(form).identifier)} type="text" required class="w-full px-4 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400" placeholder="username  email"></div>`);
      if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(success)) {
        _push(`<div class="bg-green-50 border border-green-200 text-green-700 px-4 py-3 rounded">${ssrInterpolate(unref(success))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="w-full py-2 px-4 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors font-medium">`);
      if (unref(loading)) {
        _push(`<span>...</span>`);
      } else {
        _push(`<span></span>`);
      }
      _push(`</button></form><div class="mt-6 text-center">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/auth/login",
        class: "text-sm text-green-600 hover:text-green-700"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div></div>`);
    };
  }
});
const _sfc_setup$P = _sfc_main$P.setup;
_sfc_main$P.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/auth/forgot-password.vue");
  return _sfc_setup$P ? _sfc_setup$P(props, ctx) : void 0;
};

const forgotPasswordD78DQuHr = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$P
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$O = /* @__PURE__ */ defineComponent({
  __name: "new",
  __ssrInlineRender: true,
  setup(__props) {
    useRouter();
    const error = ref(null);
    const saving = ref(false);
    const submitError = ref(null);
    const form = ref({
      slug: "",
      title: "",
      content: "",
      meta_title: "",
      meta_description: "",
      meta_keywords: "",
      is_active: true,
      display_order: 0
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/admin/content/pages",
        class: "p-2 hover:bg-gray-100 rounded-lg"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"${_scopeId}></path></svg>`);
          } else {
            return [
              (openBlock(), createBlock("svg", {
                class: "w-6 h-6",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M10 19l-7-7m0 0l7-7m-7 7h18"
                })
              ]))
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<h1 class="text-3xl font-bold"></h1></div></div>`);
      if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<form class="bg-white rounded-lg shadow p-6 space-y-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"> Slug <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).slug)} type="text" required placeholder="about, contact, help" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono"><p class="mt-1 text-sm text-gray-500">URL path  (: /about, /contact)</p></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).title)} type="text" required placeholder="" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option${ssrRenderAttr("value", true)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, true) : ssrLooseEqual(unref(form).is_active, true)) ? " selected" : ""}></option><option${ssrRenderAttr("value", false)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, false) : ssrLooseEqual(unref(form).is_active, false)) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).display_order)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label>`);
      _push(ssrRenderComponent(RichTextEditor, {
        modelValue: unref(form).content,
        "onUpdate:modelValue": ($event) => unref(form).content = $event,
        "entity-type": "content-pages",
        "entity-id": null,
        class: "w-full"
      }, null, _parent));
      _push(`</div><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"> Meta Title </label><input${ssrRenderAttr("value", unref(form).meta_title)} type="text" placeholder=" - KDC Tutor School" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><p class="mt-1 text-sm text-gray-500"> SEO ()</p></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Meta Keywords </label><input${ssrRenderAttr("value", unref(form).meta_keywords)} type="text" placeholder="keyword1, keyword2, keyword3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Meta Description </label><textarea rows="3" placeholder="  SEO" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).meta_description)}</textarea></div>`);
      if (unref(submitError)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">${ssrInterpolate(unref(submitError))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex justify-end space-x-4 pt-4 border-t">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/admin/content/pages",
        class: "px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors">`);
      if (unref(saving)) {
        _push(`<span>...</span>`);
      } else {
        _push(`<span></span>`);
      }
      _push(`</button></div></form></div>`);
    };
  }
});
const _sfc_setup$O = _sfc_main$O.setup;
_sfc_main$O.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/content/pages/new.vue");
  return _sfc_setup$O ? _sfc_setup$O(props, ctx) : void 0;
};

const newFSBUYZ_J = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$O
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "edit",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useRouter();
    useAuth();
    const courseId = computed(() => parseInt(route.params.id));
    const loading = ref(true);
    const error = ref("");
    const submitting = ref(false);
    const submitError = ref("");
    const form = reactive({
      title: "",
      description: "",
      thumbnail_url: "",
      type: "",
      price: 0,
      duration_hours: null,
      level: "",
      status: "draft",
      code: "",
      selectedBranches: []
    });
    const uploadingThumbnail = ref(false);
    ref(null);
    const availableBranches = ref([]);
    const loadingBranches = ref(false);
    const branchSeatLimits = ref({});
    const getBranchSeatLimit = (branchId) => {
      return branchSeatLimits.value[branchId] ?? "";
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4"><button class="p-2 hover:bg-gray-100 rounded-lg"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg></button><h1 class="text-3xl font-bold"></h1></div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else {
        _push(`<!--[-->`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<form class="bg-white rounded-lg shadow p-6 space-y-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).title)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=""></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).code)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" COURSE001"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "") : ssrLooseEqual(unref(form).type, "")) ? " selected" : ""}></option><option value="live_online"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "live_online") : ssrLooseEqual(unref(form).type, "live_online")) ? " selected" : ""}>Live Online</option><option value="vod"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "vod") : ssrLooseEqual(unref(form).type, "vod")) ? " selected" : ""}>VOD</option><option value="hybrid"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "hybrid") : ssrLooseEqual(unref(form).type, "hybrid")) ? " selected" : ""}>Hybrid</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  () <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).price)} type="number" step="0.01" min="0" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="0.00"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  () </label><input${ssrRenderAttr("value", unref(form).duration_hours)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="0"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).level) ? ssrLooseContain(unref(form).level, "") : ssrLooseEqual(unref(form).level, "")) ? " selected" : ""}></option><option value="beginner"${ssrIncludeBooleanAttr(Array.isArray(unref(form).level) ? ssrLooseContain(unref(form).level, "beginner") : ssrLooseEqual(unref(form).level, "beginner")) ? " selected" : ""}></option><option value="intermediate"${ssrIncludeBooleanAttr(Array.isArray(unref(form).level) ? ssrLooseContain(unref(form).level, "intermediate") : ssrLooseEqual(unref(form).level, "intermediate")) ? " selected" : ""}></option><option value="advanced"${ssrIncludeBooleanAttr(Array.isArray(unref(form).level) ? ssrLooseContain(unref(form).level, "advanced") : ssrLooseEqual(unref(form).level, "advanced")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="draft"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "draft") : ssrLooseEqual(unref(form).status, "draft")) ? " selected" : ""}></option><option value="published"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "published") : ssrLooseEqual(unref(form).status, "published")) ? " selected" : ""}></option><option value="archived"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "archived") : ssrLooseEqual(unref(form).status, "archived")) ? " selected" : ""}></option></select></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label>`);
        if (unref(loadingBranches)) {
          _push(`<div class="text-sm text-gray-500 py-2"> ... </div>`);
        } else if (unref(availableBranches).length === 0) {
          _push(`<div class="text-sm text-yellow-600 py-2 bg-yellow-50 border border-yellow-200 rounded p-2">    </div>`);
        } else {
          _push(`<div class="space-y-2 border border-gray-300 rounded-lg p-3"><!--[-->`);
          ssrRenderList(unref(availableBranches), (branch) => {
            _push(`<div class="border-b border-gray-200 pb-3 last:border-b-0 last:pb-0"><label class="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded"><input type="checkbox"${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).selectedBranches) ? ssrLooseContain(unref(form).selectedBranches, branch.id) : unref(form).selectedBranches) ? " checked" : ""} class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><div class="flex-1"><span class="text-sm font-medium text-gray-700">${ssrInterpolate(branch.name)}</span>`);
            if (branch.code) {
              _push(`<span class="text-xs text-gray-500 ml-1">(${ssrInterpolate(branch.code)})</span>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></label>`);
            if (unref(form).selectedBranches.includes(branch.id)) {
              _push(`<div class="mt-2 ml-6"><label class="block text-xs font-medium text-gray-600 mb-1">  () </label><input type="number"${ssrRenderAttr("value", getBranchSeatLimit(branch.id))} min="1" class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" ()"><p class="text-xs text-gray-500 mt-1"></p></div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div>`);
          });
          _push(`<!--]--></div>`);
        }
        if (unref(form).selectedBranches.length === 0 && !unref(loadingBranches) && unref(availableBranches).length > 0) {
          _push(`<p class="text-xs text-red-500 mt-1">  1  </p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-3"><p class="text-sm font-semibold text-blue-900 mb-2"> :</p><ul class="text-sm text-blue-800 space-y-1 list-disc list-inside"><li><strong>:</strong> 1280 x 720 pixels</li><li><strong>:</strong> 16:9 ()</li><li><strong>:</strong> JPG, PNG, WebP</li><li><strong>:</strong>  2 MB ( &lt; 500 KB)</li></ul></div><div class="space-y-3">`);
        if (unref(uploadingThumbnail)) {
          _push(`<div class="text-sm text-gray-600 py-2"> ... </div>`);
        } else if (unref(form).thumbnail_url) {
          _push(`<div class="space-y-3"><p class="text-sm text-gray-600"> ( 16:9):</p><div class="aspect-video bg-gray-200 rounded-lg overflow-hidden max-w-2xl"><img${ssrRenderAttr("src", unref(form).thumbnail_url)} alt="Thumbnail preview" class="w-full h-full object-cover"></div><button type="button" class="px-3 py-2 text-sm text-red-600 hover:bg-red-50 rounded-lg border border-red-200">  </button></div>`);
        } else {
          _push(`<div class="border-2 border-dashed border-gray-300 rounded-lg p-4"><input type="file" accept="image/jpeg,image/png,image/webp" class="hidden"><button type="button" class="w-full px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"><svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>  </button><p class="text-xs text-gray-500 mt-2 text-center">: JPG, PNG, WebP ( 2 MB)</p></div>`);
        }
        _push(`</div>`);
        if (unref(submitError) && (unref(submitError).includes("") || unref(submitError).includes(""))) {
          _push(`<p class="mt-2 text-sm text-red-600">${ssrInterpolate(unref(submitError))}</p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label>`);
        _push(ssrRenderComponent(RichTextEditor, {
          modelValue: unref(form).description,
          "onUpdate:modelValue": ($event) => unref(form).description = $event,
          "entity-type": "courses",
          "entity-id": unref(courseId),
          class: "w-full"
        }, null, _parent));
        _push(`</div></div>`);
        if (unref(submitError)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(submitError))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(submitting)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(submitting)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form><!--]-->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$N = _sfc_main$N.setup;
_sfc_main$N.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/courses/[id]/edit.vue");
  return _sfc_setup$N ? _sfc_setup$N(props, ctx) : void 0;
};

const editKCC45fLa = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$N
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    useRouter();
    const enrollments = ref([]);
    const availableCourses = ref([]);
    const availableBranches = ref([]);
    const loading = ref(true);
    const error = ref("");
    const showCreateModal = ref(false);
    const filters = reactive({
      search: "",
      status: "",
      course_id: "",
      branch_id: ""
    });
    const loadEnrollments = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = {};
        if (filters.search) params.search = filters.search;
        if (filters.status) params.status = filters.status;
        if (filters.course_id) params.course_id = filters.course_id;
        if (filters.branch_id) params.branch_id = filters.branch_id;
        const response = await $fetch(`${config.public.apiBase}/admin/enrollments`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          },
          params
        });
        if (response.success) {
          enrollments.value = response.data;
        }
      } catch (err) {
        console.error("Error loading enrollments:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
    };
    const handleEnrollmentSaved = async () => {
      closeModal();
      await loadEnrollments();
    };
    const getStatusName = (status) => {
      const statusNames = {
        pending: "",
        active: "",
        completed: "",
        cancelled: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        pending: "bg-yellow-100 text-yellow-800",
        active: "bg-green-100 text-green-800",
        completed: "bg-blue-100 text-blue-800",
        cancelled: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-4 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="pending"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "pending") : ssrLooseEqual(unref(filters).status, "pending")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "active") : ssrLooseEqual(unref(filters).status, "active")) ? " selected" : ""}></option><option value="completed"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "completed") : ssrLooseEqual(unref(filters).status, "completed")) ? " selected" : ""}></option><option value="cancelled"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "cancelled") : ssrLooseEqual(unref(filters).status, "cancelled")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).course_id) ? ssrLooseContain(unref(filters).course_id, "") : ssrLooseEqual(unref(filters).course_id, "")) ? " selected" : ""}></option><!--[-->`);
      ssrRenderList(unref(availableCourses), (course) => {
        _push(`<option${ssrRenderAttr("value", course.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(filters).course_id) ? ssrLooseContain(unref(filters).course_id, course.id) : ssrLooseEqual(unref(filters).course_id, course.id)) ? " selected" : ""}>${ssrInterpolate(course.title)}</option>`);
      });
      _push(`<!--]--></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).branch_id) ? ssrLooseContain(unref(filters).branch_id, "") : ssrLooseEqual(unref(filters).branch_id, "")) ? " selected" : ""}></option><!--[-->`);
      ssrRenderList(unref(availableBranches), (branch) => {
        _push(`<option${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(filters).branch_id) ? ssrLooseContain(unref(filters).branch_id, branch.id) : ssrLooseEqual(unref(filters).branch_id, branch.id)) ? " selected" : ""}>${ssrInterpolate(branch.name)}</option>`);
      });
      _push(`<!--]--></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(enrollments).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">/</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(enrollments), (enrollment) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 cursor-pointer"><div><div class="text-sm font-medium text-green-600 hover:text-green-700 cursor-pointer">${ssrInterpolate(enrollment.student_first_name)} ${ssrInterpolate(enrollment.student_last_name)}</div><div class="text-xs text-gray-500">@${ssrInterpolate(enrollment.student_username)}</div>`);
          if (enrollment.student_email) {
            _push(`<div class="text-xs text-gray-400">${ssrInterpolate(enrollment.student_email)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4"><div><div class="text-sm font-medium text-gray-900">${ssrInterpolate(enrollment.course_title)}</div>`);
          if (enrollment.course_code) {
            _push(`<div class="text-xs text-gray-500">: ${ssrInterpolate(enrollment.course_code)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([enrollment.enrollment_type === "online" ? "bg-blue-100 text-blue-800" : "bg-green-100 text-green-800", "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(enrollment.enrollment_type === "online" ? "" : "")}</span></td><td class="px-6 py-4 whitespace-nowrap">`);
          if (enrollment.enrollment_type === "onsite") {
            _push(`<div class="text-sm text-gray-900"><div>${ssrInterpolate(enrollment.branch_name || "-")}</div>`);
            if (enrollment.branch_code) {
              _push(`<div class="text-xs text-gray-500">${ssrInterpolate(enrollment.branch_code)}</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div>`);
          } else {
            _push(`<div class="text-sm text-gray-500 italic">  </div>`);
          }
          _push(`</td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(enrollment.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusName(enrollment.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(enrollment.enrollment_date || enrollment.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>`);
          if (enrollment.status === "pending") {
            _push(`<button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>`);
          } else if (enrollment.status === "active") {
            _push(`<button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      if (unref(showCreateModal)) {
        _push(ssrRenderComponent(EnrollmentModal, {
          show: unref(showCreateModal),
          enrollment: null,
          onClose: closeModal,
          onSaved: handleEnrollmentSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$M = _sfc_main$M.setup;
_sfc_main$M.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/enrollments/index.vue");
  return _sfc_setup$M ? _sfc_setup$M(props, ctx) : void 0;
};

const indexD7Kkgqct = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$M
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useRouter();
    const { user } = useAuth();
    parseInt(route.params.id);
    const loading = ref(true);
    const error = ref("");
    const courseDetail = ref(null);
    const canEdit = computed(() => {
      if (!user.value || !user.value.roles) return false;
      const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
      return user.value.roles.some((role) => allowedRoles.includes(role));
    });
    const getTypeName = (type) => {
      const typeNames = {
        live_online: "Live Online",
        vod: "VOD",
        hybrid: "Hybrid"
      };
      return typeNames[type] || type;
    };
    const getTypeBadgeClass = (type) => {
      const classes = {
        live_online: "bg-blue-100 text-blue-800",
        vod: "bg-purple-100 text-purple-800",
        hybrid: "bg-indigo-100 text-indigo-800"
      };
      return classes[type] || "bg-gray-100 text-gray-800";
    };
    const getStatusName = (status) => {
      const statusNames = {
        draft: "",
        published: "",
        archived: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        draft: "bg-gray-100 text-gray-800",
        published: "bg-green-100 text-green-800",
        archived: "bg-yellow-100 text-yellow-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getLevelName = (level) => {
      const levelNames = {
        beginner: "",
        intermediate: "",
        advanced: ""
      };
      return levelNames[level] || level;
    };
    const getEnrollmentStatusName = (status) => {
      const statusNames = {
        active: "",
        completed: "",
        cancelled: ""
      };
      return statusNames[status] || status;
    };
    const getEnrollmentStatusBadgeClass = (status) => {
      const classes = {
        active: "bg-green-100 text-green-800",
        completed: "bg-blue-100 text-blue-800",
        cancelled: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const formatCurrency = (amount) => {
      return new Intl.NumberFormat("th-TH", {
        style: "currency",
        currency: "THB"
      }).format(amount);
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4"><button class="p-2 hover:bg-gray-100 rounded-lg"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg></button><h1 class="text-3xl font-bold"></h1></div><div class="flex items-center space-x-3">`);
      if (unref(canEdit)) {
        _push(`<button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg><span></span></button>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(courseDetail)) {
        _push(`<div class="space-y-6">`);
        if (unref(courseDetail).course.thumbnail_url) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="flex justify-center"><img${ssrRenderAttr("src", unref(courseDetail).course.thumbnail_url)}${ssrRenderAttr("alt", unref(courseDetail).course.title)} class="max-w-full h-auto rounded-lg shadow-md" style="${ssrRenderStyle({ "max-height": "400px" })}"></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between mb-6"><h2 class="text-xl font-semibold"></h2><span class="${ssrRenderClass([getStatusBadgeClass(unref(courseDetail).course.status), "px-3 py-1 text-sm font-medium rounded"])}">${ssrInterpolate(getStatusName(unref(courseDetail).course.status))}</span></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-lg font-medium text-gray-900">${ssrInterpolate(unref(courseDetail).course.title)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(courseDetail).course.code || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><span class="${ssrRenderClass([getTypeBadgeClass(unref(courseDetail).course.type), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getTypeName(unref(courseDetail).course.type))}</span></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-lg font-medium text-gray-900">${ssrInterpolate(formatCurrency(unref(courseDetail).course.price))}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(courseDetail).course.duration_hours ? `${unref(courseDetail).course.duration_hours} ` : "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(courseDetail).course.level ? getLevelName(unref(courseDetail).course.level) : "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(formatDate(unref(courseDetail).course.created_at))}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(formatDate(unref(courseDetail).course.updated_at))}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(courseDetail).course.created_by_name ? `${unref(courseDetail).course.created_by_name} ${unref(courseDetail).course.created_by_last_name || ""}` : "-")}</p></div>`);
        if (unref(courseDetail).course.description) {
          _push(`<div class="md:col-span-2 lg:col-span-3"><label class="block text-sm font-medium text-gray-500 mb-1"></label><div class="text-gray-900 prose max-w-none">${unref(courseDetail).course.description ?? ""}</div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div>`);
        if (unref(courseDetail).branches && unref(courseDetail).branches.length > 0) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"> (${ssrInterpolate(unref(courseDetail).branches.length)})</h2><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><!--[-->`);
          ssrRenderList(unref(courseDetail).branches, (branch) => {
            _push(`<div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50"><div class="flex items-start justify-between"><div class="flex-1"><h3 class="text-lg font-medium text-gray-900">${ssrInterpolate(branch.branch_name)}</h3>`);
            if (branch.branch_code) {
              _push(`<p class="text-sm text-gray-500 mt-1">: ${ssrInterpolate(branch.branch_code)}</p>`);
            } else {
              _push(`<!---->`);
            }
            _push(`<div class="mt-3 space-y-1"><div class="flex items-center justify-between text-sm"><span class="text-gray-600">:</span><span class="font-medium text-gray-900">${ssrInterpolate(branch.seat_limit ? branch.seat_limit.toLocaleString() : "")}</span></div><div class="flex items-center justify-between text-sm"><span class="text-gray-600">:</span><span class="font-medium text-gray-900">${ssrInterpolate(branch.current_enrollments || 0)}</span></div><div class="flex items-center justify-between text-sm"><span class="text-gray-600">:</span><span class="${ssrRenderClass([branch.is_available ? "bg-green-100 text-green-800" : "bg-red-100 text-red-800", "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(branch.is_available ? "" : "")}</span></div></div></div></div></div>`);
          });
          _push(`<!--]--></div></div>`);
        } else {
          _push(`<div class="bg-white rounded-lg shadow p-6"><div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path></svg><p></p></div></div>`);
        }
        if (unref(courseDetail).enrollments && unref(courseDetail).enrollments.length > 0) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"> (${ssrInterpolate(unref(courseDetail).enrollments.length)})</h2><div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
          ssrRenderList(unref(courseDetail).enrollments, (enrollment) => {
            _push(`<tr class="hover:bg-gray-50"><td class="px-4 py-3"><div><div class="text-sm font-medium text-green-600 hover:text-green-700 cursor-pointer">${ssrInterpolate(enrollment.student.first_name)} ${ssrInterpolate(enrollment.student.last_name)}</div><div class="text-xs text-gray-500">${ssrInterpolate(enrollment.student.username)}</div></div></td><td class="px-4 py-3 text-sm text-gray-900">${ssrInterpolate(enrollment.branch.name)}</td><td class="px-4 py-3"><span class="${ssrRenderClass([getEnrollmentStatusBadgeClass(enrollment.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getEnrollmentStatusName(enrollment.status))}</span></td><td class="px-4 py-3 text-sm text-gray-500">${ssrInterpolate(formatDate(enrollment.enrolled_at))}</td><td class="px-4 py-3 text-right">`);
            _push(ssrRenderComponent(_component_NuxtLink, {
              to: `/admin/enrollments/${enrollment.id}`,
              class: "text-green-600 hover:text-green-700 text-sm font-medium"
            }, {
              default: withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`  `);
                } else {
                  return [
                    createTextVNode("  ")
                  ];
                }
              }),
              _: 2
            }, _parent));
            _push(`</td></tr>`);
          });
          _push(`<!--]--></tbody></table></div></div>`);
        } else {
          _push(`<div class="bg-white rounded-lg shadow p-6"><div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><p></p></div></div>`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$L = _sfc_main$L.setup;
_sfc_main$L.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/courses/[id]/index.vue");
  return _sfc_setup$L ? _sfc_setup$L(props, ctx) : void 0;
};

const indexFJv__duR = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$L
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "edit",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useRouter();
    useAuth();
    parseInt(route.params.id);
    const loading = ref(true);
    const error = ref("");
    const student = ref(null);
    const parents = ref([]);
    const submitting = ref(false);
    const submitError = ref("");
    const showAddParentModal = ref(false);
    const parentSearch = ref("");
    const parentSearchResults = ref([]);
    const selectedParentToAdd = ref(null);
    const parentRelationship = ref("guardian");
    const addingParent = ref(false);
    const addParentError = ref("");
    const parentToEdit = ref(null);
    const editingParent = ref(false);
    const editParentError = ref("");
    const editParentForm = reactive({
      first_name: "",
      last_name: "",
      email: "",
      phone: "",
      relationship: "guardian"
    });
    const form = reactive({
      username: "",
      email: "",
      first_name: "",
      last_name: "",
      phone: "",
      status: "active"
    });
    const getRelationshipName = (relationship) => {
      const relationshipNames = {
        father: "",
        mother: "",
        guardian: "",
        other: ""
      };
      return relationshipNames[relationship] || relationship;
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4"><button class="p-2 hover:bg-gray-100 rounded-lg"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg></button><h1 class="text-3xl font-bold"></h1></div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(student)) {
        _push(`<div class="space-y-6"><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-6"></h2><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"> Username <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).username)} type="text" required disabled class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-gray-100 cursor-not-allowed"><p class="mt-1 text-xs text-gray-500"> Username </p></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Email </label><input${ssrRenderAttr("value", unref(form).email)} type="email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).first_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).last_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).phone)} type="tel" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "active") : ssrLooseEqual(unref(form).status, "active")) ? " selected" : ""}></option><option value="inactive"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "inactive") : ssrLooseEqual(unref(form).status, "inactive")) ? " selected" : ""}></option><option value="suspended"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "suspended") : ssrLooseEqual(unref(form).status, "suspended")) ? " selected" : ""}></option></select></div></div>`);
        if (unref(submitError)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(submitError))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(submitting)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(submitting)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between mb-6"><h2 class="text-xl font-semibold"></h2><button class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div>`);
        if (unref(parents) && unref(parents).length > 0) {
          _push(`<div class="space-y-4"><!--[-->`);
          ssrRenderList(unref(parents), (parent) => {
            _push(`<div class="border border-gray-200 rounded-lg p-4"><div class="flex items-center justify-between"><div class="flex-1"><div class="flex items-center space-x-3 mb-2"><h3 class="text-lg font-medium text-gray-900">${ssrInterpolate(parent.first_name)} ${ssrInterpolate(parent.last_name)}</h3><span class="px-2 py-1 text-xs font-medium rounded bg-blue-100 text-blue-800">${ssrInterpolate(getRelationshipName(parent.relationship))}</span></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm"><div><span class="text-gray-500">Email:</span><span class="ml-2 text-gray-900">${ssrInterpolate(parent.email || "-")}</span></div><div><span class="text-gray-500">:</span><span class="ml-2 text-gray-900">${ssrInterpolate(parent.phone || "-")}</span></div></div></div><div class="flex items-center space-x-2"><button class="px-3 py-2 text-green-600 hover:bg-green-50 rounded-lg transition-colors" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button></div></div></div>`);
          });
          _push(`<!--]--></div>`);
        } else {
          _push(`<div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><p class="mt-2"></p></div>`);
        }
        _push(`</div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(showAddParentModal)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-md w-full mx-4"><h3 class="text-lg font-semibold mb-4"></h3><form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  (Username  Email) </label><input${ssrRenderAttr("value", unref(parentSearch))} type="text" placeholder=" username  email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">`);
        if (unref(parentSearchResults).length > 0) {
          _push(`<div class="mt-2 max-h-40 overflow-y-auto border border-gray-200 rounded-lg"><!--[-->`);
          ssrRenderList(unref(parentSearchResults), (user) => {
            _push(`<button type="button" class="w-full text-left px-4 py-2 hover:bg-gray-100 border-b border-gray-100 last:border-b-0"><div class="font-medium">${ssrInterpolate(user.first_name)} ${ssrInterpolate(user.last_name)}</div><div class="text-sm text-gray-500">${ssrInterpolate(user.username)} - ${ssrInterpolate(user.email || "-")}</div></button>`);
          });
          _push(`<!--]--></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
        if (unref(selectedParentToAdd)) {
          _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="father"${ssrIncludeBooleanAttr(Array.isArray(unref(parentRelationship)) ? ssrLooseContain(unref(parentRelationship), "father") : ssrLooseEqual(unref(parentRelationship), "father")) ? " selected" : ""}></option><option value="mother"${ssrIncludeBooleanAttr(Array.isArray(unref(parentRelationship)) ? ssrLooseContain(unref(parentRelationship), "mother") : ssrLooseEqual(unref(parentRelationship), "mother")) ? " selected" : ""}></option><option value="guardian"${ssrIncludeBooleanAttr(Array.isArray(unref(parentRelationship)) ? ssrLooseContain(unref(parentRelationship), "guardian") : ssrLooseEqual(unref(parentRelationship), "guardian")) ? " selected" : ""}></option><option value="other"${ssrIncludeBooleanAttr(Array.isArray(unref(parentRelationship)) ? ssrLooseContain(unref(parentRelationship), "other") : ssrLooseEqual(unref(parentRelationship), "other")) ? " selected" : ""}></option></select></div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(addParentError)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(addParentError))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(!unref(selectedParentToAdd) || unref(addingParent)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(addingParent)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(parentToEdit)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-md w-full mx-4"><h3 class="text-lg font-semibold mb-4"></h3><form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(editParentForm).first_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(editParentForm).last_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Email </label><input${ssrRenderAttr("value", unref(editParentForm).email)} type="email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(editParentForm).phone)} type="tel" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="father"${ssrIncludeBooleanAttr(Array.isArray(unref(editParentForm).relationship) ? ssrLooseContain(unref(editParentForm).relationship, "father") : ssrLooseEqual(unref(editParentForm).relationship, "father")) ? " selected" : ""}></option><option value="mother"${ssrIncludeBooleanAttr(Array.isArray(unref(editParentForm).relationship) ? ssrLooseContain(unref(editParentForm).relationship, "mother") : ssrLooseEqual(unref(editParentForm).relationship, "mother")) ? " selected" : ""}></option><option value="guardian"${ssrIncludeBooleanAttr(Array.isArray(unref(editParentForm).relationship) ? ssrLooseContain(unref(editParentForm).relationship, "guardian") : ssrLooseEqual(unref(editParentForm).relationship, "guardian")) ? " selected" : ""}></option><option value="other"${ssrIncludeBooleanAttr(Array.isArray(unref(editParentForm).relationship) ? ssrLooseContain(unref(editParentForm).relationship, "other") : ssrLooseEqual(unref(editParentForm).relationship, "other")) ? " selected" : ""}></option></select></div>`);
        if (unref(editParentError)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(editParentError))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(editingParent)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(editingParent)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$K = _sfc_main$K.setup;
_sfc_main$K.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/students/[id]/edit.vue");
  return _sfc_setup$K ? _sfc_setup$K(props, ctx) : void 0;
};

const editC6V17F6j = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$K
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "[provider]",
  __ssrInlineRender: true,
  async setup(__props) {
    let __temp, __restore;
    const route = useRoute();
    useRouter();
    useAuth();
    const { getRedirectPathByRole } = ([__temp, __restore] = withAsyncContext(() => Promise.resolve().then(function () { return authCOdMvhp6; })), __temp = await __temp, __restore(), __temp);
    route.params.provider;
    const loading = ref(true);
    const error = ref("");
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen flex items-center justify-center bg-gray-50" }, _attrs))}><div class="text-center">`);
      if (unref(loading)) {
        _push(`<div class="space-y-4"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="space-y-4"><div class="text-red-600 text-xl"></div><p class="text-gray-600">${ssrInterpolate(unref(error))}</p>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/auth/login",
          class: "text-green-600 hover:text-green-700"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$J = _sfc_main$J.setup;
_sfc_main$J.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/auth/callback/[provider].vue");
  return _sfc_setup$J ? _sfc_setup$J(props, ctx) : void 0;
};

const _provider_KjhVxuSc = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$J
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const pages = ref([]);
    const loading = ref(true);
    const error = ref(null);
    const filters = ref({
      search: "",
      status: ""
    });
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy HH:mm", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/admin/content/pages/new",
        class: "px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"${_scopeId}></path></svg><span${_scopeId}></span>`);
          } else {
            return [
              (openBlock(), createBlock("svg", {
                class: "w-5 h-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M12 4v16m8-8H4"
                })
              ])),
              createVNode("span", null, "")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", slug" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "active") : ssrLooseEqual(unref(filters).status, "active")) ? " selected" : ""}></option><option value="inactive"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "inactive") : ssrLooseEqual(unref(filters).status, "inactive")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(pages).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Slug</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(pages), (page) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(page.title)}</div></td><td class="px-6 py-4"><div class="text-sm text-gray-600 font-mono">/${ssrInterpolate(page.slug)}</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([{
            "bg-green-100 text-green-800": page.is_active,
            "bg-gray-100 text-gray-800": !page.is_active
          }, "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(page.is_active ? "" : "")}</span></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(page.display_order)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-600">${ssrInterpolate(formatDate(page.updated_at))}</div></td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><a${ssrRenderAttr("href", `/${page.slug}`)} target="_blank" class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg></a>`);
          _push(ssrRenderComponent(_component_NuxtLink, {
            to: `/admin/content/pages/${page.id}/edit`,
            class: "text-blue-600 hover:text-blue-900",
            title: ""
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"${_scopeId}></path></svg>`);
              } else {
                return [
                  (openBlock(), createBlock("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                    })
                  ]))
                ];
              }
            }),
            _: 2
          }, _parent));
          _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$I = _sfc_main$I.setup;
_sfc_main$I.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/content/pages/index.vue");
  return _sfc_setup$I ? _sfc_setup$I(props, ctx) : void 0;
};

const indexCSgfzyoj = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$I
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useRouter();
    const config = useRuntimeConfig();
    const { accessToken, user } = useAuth();
    const studentId = parseInt(route.params.id);
    const loading = ref(true);
    const error = ref("");
    const studentDetail = ref(null);
    const learningProgress = ref([]);
    const payments = ref([]);
    const loadingPayments = ref(false);
    const showEditStudentModal = ref(false);
    const editingStudent = ref(null);
    const showAddParentModal = ref(false);
    const parentSearch = ref("");
    const parentSearchResults = ref([]);
    const selectedParentToAdd = ref(null);
    const parentRelationship = ref("guardian");
    const addingParent = ref(false);
    const addParentError = ref("");
    const parentToEdit = ref(null);
    const editingParent = ref(false);
    const editParentError = ref("");
    const editParentForm = reactive({
      first_name: "",
      last_name: "",
      email: "",
      phone: "",
      relationship: "guardian"
    });
    const canEdit = computed(() => {
      if (!user.value || !user.value.roles) return false;
      const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
      return user.value.roles.some((role) => allowedRoles.includes(role));
    });
    const canViewPayments = computed(() => {
      if (!user.value || !user.value.roles) return false;
      const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
      return user.value.roles.some((role) => allowedRoles.includes(role));
    });
    const loadStudentDetail = async () => {
      loading.value = true;
      error.value = "";
      try {
        const response = await $fetch(`${config.public.apiBase}/admin/students/${studentId}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          studentDetail.value = response.data;
          await Promise.all([
            loadLearningProgress(),
            ...canViewPayments.value ? [loadPayments()] : []
          ]);
        }
      } catch (err) {
        console.error("Error loading student detail:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const loadLearningProgress = async () => {
    };
    const loadPayments = async () => {
      if (!canViewPayments.value) return;
      loadingPayments.value = true;
      try {
        const response = await $fetch(`${config.public.apiBase}/admin/students/${studentId}/payments`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          payments.value = response.data;
        }
      } catch (err) {
        console.error("Error loading payments:", err);
        payments.value = [];
      } finally {
        loadingPayments.value = false;
      }
    };
    const closeEditStudentModal = () => {
      showEditStudentModal.value = false;
      editingStudent.value = null;
    };
    const handleStudentSaved = async () => {
      closeEditStudentModal();
      await loadStudentDetail();
    };
    const getStatusDisplayName = (status) => {
      const statusNames = {
        active: "",
        inactive: "",
        suspended: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        active: "bg-green-100 text-green-800",
        inactive: "bg-gray-100 text-gray-800",
        suspended: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getRelationshipName = (relationship) => {
      const relationshipNames = {
        father: "",
        mother: "",
        guardian: "",
        other: ""
      };
      return relationshipNames[relationship] || relationship;
    };
    const getEnrollmentStatusName = (status) => {
      const statusNames = {
        pending: "",
        active: "",
        completed: "",
        cancelled: ""
      };
      return statusNames[status] || status;
    };
    const getPaymentStatusName = (status) => {
      const statusNames = {
        pending: "",
        paid: "",
        failed: "",
        refunded: ""
      };
      return statusNames[status] || status;
    };
    const getPaymentStatusBadgeClass = (status) => {
      const classes = {
        pending: "bg-yellow-100 text-yellow-800",
        paid: "bg-green-100 text-green-800",
        failed: "bg-red-100 text-red-800",
        refunded: "bg-gray-100 text-gray-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy HH:mm", { locale: th });
    };
    const formatCurrency = (amount) => {
      return new Intl.NumberFormat("th-TH", {
        style: "currency",
        currency: "THB"
      }).format(amount);
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      const _component_StudentModal = __nuxt_component_1$2;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4"><button class="p-2 hover:bg-gray-100 rounded-lg"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg></button><h1 class="text-3xl font-bold"></h1></div><div class="flex items-center space-x-3">`);
      if (unref(canEdit)) {
        _push(`<button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg><span></span></button>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(studentDetail)) {
        _push(`<div class="space-y-6"><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between mb-6"><h2 class="text-xl font-semibold"></h2><span class="${ssrRenderClass([getStatusBadgeClass(unref(studentDetail).student.status), "px-3 py-1 text-sm font-medium rounded"])}">${ssrInterpolate(getStatusDisplayName(unref(studentDetail).student.status))}</span></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"><div><label class="block text-sm font-medium text-gray-500 mb-1">-</label><p class="text-lg font-medium text-gray-900">${ssrInterpolate(unref(studentDetail).student.first_name)} ${ssrInterpolate(unref(studentDetail).student.last_name)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1">Username</label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.username)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1">Email</label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.email || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.phone || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(formatDate(unref(studentDetail).student.created_at))}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(formatDate(unref(studentDetail).student.updated_at))}</p></div></div></div><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between mb-4"><h2 class="text-xl font-semibold"></h2>`);
        if (unref(canEdit)) {
          _push(`<button class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
        if (unref(studentDetail).parents && unref(studentDetail).parents.length > 0) {
          _push(`<div class="space-y-4"><!--[-->`);
          ssrRenderList(unref(studentDetail).parents, (parent) => {
            _push(`<div class="border border-gray-200 rounded-lg p-4"><div class="flex items-center justify-between mb-3"><div class="flex items-center space-x-3"><h3 class="text-lg font-medium text-gray-900">${ssrInterpolate(parent.first_name)} ${ssrInterpolate(parent.last_name)}</h3><span class="px-2 py-1 text-xs font-medium rounded bg-blue-100 text-blue-800">${ssrInterpolate(getRelationshipName(parent.relationship))}</span></div>`);
            if (unref(canEdit)) {
              _push(`<div class="flex items-center space-x-2"><button class="px-3 py-2 text-green-600 hover:bg-green-50 rounded-lg transition-colors" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button></div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-500 mb-1">Username</label><p class="text-gray-900">${ssrInterpolate(parent.username)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1">Email</label><p class="text-gray-900">${ssrInterpolate(parent.email || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(parent.phone || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><span class="${ssrRenderClass([getStatusBadgeClass(parent.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusDisplayName(parent.status))}</span></div></div></div>`);
          });
          _push(`<!--]--></div>`);
        } else {
          _push(`<div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><p class="mt-2"></p></div>`);
        }
        _push(`</div><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2>`);
        if (unref(studentDetail).enrollments && unref(studentDetail).enrollments.length > 0) {
          _push(`<div class="space-y-4"><!--[-->`);
          ssrRenderList(unref(studentDetail).enrollments, (enrollment) => {
            _push(`<div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors"><div class="flex items-start justify-between"><div class="flex-1"><div class="flex items-center space-x-3 mb-2"><h3 class="text-lg font-medium text-gray-900">${ssrInterpolate(enrollment.course.title)}</h3><span class="${ssrRenderClass([enrollment.status === "active" ? "bg-green-100 text-green-800" : "bg-gray-100 text-gray-800", "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getEnrollmentStatusName(enrollment.status))}</span></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm"><div><span class="text-gray-500">:</span><span class="ml-2 text-gray-900">${ssrInterpolate(enrollment.course.code)}</span></div><div><span class="text-gray-500">:</span><span class="ml-2 text-gray-900">${ssrInterpolate(enrollment.branch.name)}</span></div><div><span class="text-gray-500">:</span><span class="ml-2 text-gray-900">${ssrInterpolate(formatDate(enrollment.enrolled_at))}</span></div></div></div>`);
            _push(ssrRenderComponent(_component_NuxtLink, {
              to: `/admin/enrollments/${enrollment.id}`,
              class: "ml-4 px-4 py-2 text-sm bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, {
              default: withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`  `);
                } else {
                  return [
                    createTextVNode("  ")
                  ];
                }
              }),
              _: 2
            }, _parent));
            _push(`</div></div>`);
          });
          _push(`<!--]--></div>`);
        } else {
          _push(`<div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg><p class="mt-2"></p></div>`);
        }
        _push(`</div>`);
        if (unref(learningProgress) && unref(learningProgress).length > 0) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="space-y-4"><!--[-->`);
          ssrRenderList(unref(learningProgress), (progress) => {
            _push(`<div class="border border-gray-200 rounded-lg p-4"><div class="flex items-center justify-between mb-2"><h3 class="font-medium text-gray-900">${ssrInterpolate(progress.course_title)}</h3><span class="text-sm text-gray-500">${ssrInterpolate(progress.completion_percentage)}%</span></div><div class="w-full bg-gray-200 rounded-full h-2"><div class="bg-green-600 h-2 rounded-full transition-all" style="${ssrRenderStyle({ width: `${progress.completion_percentage}%` })}"></div></div><div class="mt-2 text-sm text-gray-600">  ${ssrInterpolate(progress.completed_sessions)} / ${ssrInterpolate(progress.total_sessions)}  </div></div>`);
          });
          _push(`<!--]--></div></div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(canViewPayments)) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2>`);
          if (unref(loadingPayments)) {
            _push(`<div class="text-center py-8"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
          } else if (unref(payments) && unref(payments).length > 0) {
            _push(`<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
            ssrRenderList(unref(payments), (payment) => {
              _push(`<tr class="hover:bg-gray-50"><td class="px-4 py-3 text-sm text-gray-900">${ssrInterpolate(payment.payment_date ? formatDate(payment.payment_date) : formatDate(payment.created_at))}</td><td class="px-4 py-3 text-sm font-medium text-gray-900">${ssrInterpolate(formatCurrency(payment.amount))}</td><td class="px-4 py-3 text-sm text-gray-900">${ssrInterpolate(payment.payment_method_name)}</td><td class="px-4 py-3 text-sm text-gray-900">`);
              if (payment.enrollment) {
                _push(`<span class="font-medium text-green-600">${ssrInterpolate(payment.enrollment.course.code)}</span>`);
              } else {
                _push(`<span class="text-gray-400">-</span>`);
              }
              _push(`</td><td class="px-4 py-3 text-sm text-gray-900">`);
              if (payment.enrollment) {
                _push(`<span class="font-medium">${ssrInterpolate(payment.enrollment.branch.name)}</span>`);
              } else {
                _push(`<span class="text-gray-400">-</span>`);
              }
              _push(`</td><td class="px-4 py-3 text-sm"><span class="${ssrRenderClass([getPaymentStatusBadgeClass(payment.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getPaymentStatusName(payment.status))}</span></td></tr>`);
            });
            _push(`<!--]--></tbody></table></div>`);
          } else {
            _push(`<div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><p class="mt-2"></p></div>`);
          }
          _push(`</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(showAddParentModal)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 max-h-[90vh] overflow-y-auto"><h3 class="text-lg font-semibold mb-4"></h3><form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  (Username  Email) </label><input${ssrRenderAttr("value", unref(parentSearch))} type="text" placeholder=" username  email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">`);
        if (unref(parentSearchResults).length > 0) {
          _push(`<div class="mt-2 max-h-40 overflow-y-auto border border-gray-200 rounded-lg"><!--[-->`);
          ssrRenderList(unref(parentSearchResults), (user2) => {
            _push(`<button type="button" class="w-full text-left px-4 py-2 hover:bg-gray-100 border-b border-gray-100 last:border-b-0"><div class="font-medium">${ssrInterpolate(user2.first_name)} ${ssrInterpolate(user2.last_name)}</div><div class="text-sm text-gray-500">${ssrInterpolate(user2.username)} - ${ssrInterpolate(user2.email || "-")}</div></button>`);
          });
          _push(`<!--]--></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
        if (unref(selectedParentToAdd)) {
          _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="father"${ssrIncludeBooleanAttr(Array.isArray(unref(parentRelationship)) ? ssrLooseContain(unref(parentRelationship), "father") : ssrLooseEqual(unref(parentRelationship), "father")) ? " selected" : ""}></option><option value="mother"${ssrIncludeBooleanAttr(Array.isArray(unref(parentRelationship)) ? ssrLooseContain(unref(parentRelationship), "mother") : ssrLooseEqual(unref(parentRelationship), "mother")) ? " selected" : ""}></option><option value="guardian"${ssrIncludeBooleanAttr(Array.isArray(unref(parentRelationship)) ? ssrLooseContain(unref(parentRelationship), "guardian") : ssrLooseEqual(unref(parentRelationship), "guardian")) ? " selected" : ""}></option><option value="other"${ssrIncludeBooleanAttr(Array.isArray(unref(parentRelationship)) ? ssrLooseContain(unref(parentRelationship), "other") : ssrLooseEqual(unref(parentRelationship), "other")) ? " selected" : ""}></option></select></div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(addParentError)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(addParentError))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(!unref(selectedParentToAdd) || unref(addingParent)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(addingParent)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(parentToEdit)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 max-h-[90vh] overflow-y-auto"><h3 class="text-lg font-semibold mb-4"></h3><form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(editParentForm).first_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(editParentForm).last_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Email </label><input${ssrRenderAttr("value", unref(editParentForm).email)} type="email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(editParentForm).phone)} type="tel" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="father"${ssrIncludeBooleanAttr(Array.isArray(unref(editParentForm).relationship) ? ssrLooseContain(unref(editParentForm).relationship, "father") : ssrLooseEqual(unref(editParentForm).relationship, "father")) ? " selected" : ""}></option><option value="mother"${ssrIncludeBooleanAttr(Array.isArray(unref(editParentForm).relationship) ? ssrLooseContain(unref(editParentForm).relationship, "mother") : ssrLooseEqual(unref(editParentForm).relationship, "mother")) ? " selected" : ""}></option><option value="guardian"${ssrIncludeBooleanAttr(Array.isArray(unref(editParentForm).relationship) ? ssrLooseContain(unref(editParentForm).relationship, "guardian") : ssrLooseEqual(unref(editParentForm).relationship, "guardian")) ? " selected" : ""}></option><option value="other"${ssrIncludeBooleanAttr(Array.isArray(unref(editParentForm).relationship) ? ssrLooseContain(unref(editParentForm).relationship, "other") : ssrLooseEqual(unref(editParentForm).relationship, "other")) ? " selected" : ""}></option></select></div>`);
        if (unref(editParentError)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(editParentError))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(editingParent)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(editingParent)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(showEditStudentModal)) {
        _push(ssrRenderComponent(_component_StudentModal, {
          show: unref(showEditStudentModal),
          student: unref(editingStudent),
          onClose: closeEditStudentModal,
          onSaved: handleStudentSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$H = _sfc_main$H.setup;
_sfc_main$H.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/students/[id]/index.vue");
  return _sfc_setup$H ? _sfc_setup$H(props, ctx) : void 0;
};

const indexCScfA6Bq = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$H
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    useAuth();
    useRouter();
    const courses = ref([]);
    const loading = ref(true);
    const error = ref("");
    const filters = reactive({
      search: "",
      type: "",
      status: ""
    });
    const getTypeName = (type) => {
      const typeNames = {
        live_online: "Live Online",
        vod: "VOD",
        hybrid: "Hybrid"
      };
      return typeNames[type] || type;
    };
    const getTypeBadgeClass = (type) => {
      const classes = {
        live_online: "bg-blue-100 text-blue-800",
        vod: "bg-purple-100 text-purple-800",
        hybrid: "bg-indigo-100 text-indigo-800"
      };
      return classes[type] || "bg-gray-100 text-gray-800";
    };
    const getStatusName = (status) => {
      const statusNames = {
        draft: "",
        published: "",
        archived: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        draft: "bg-gray-100 text-gray-800",
        published: "bg-green-100 text-green-800",
        archived: "bg-yellow-100 text-yellow-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getLevelName = (level) => {
      const levelNames = {
        beginner: "",
        intermediate: "",
        advanced: ""
      };
      return levelNames[level] || level;
    };
    const formatCurrency = (amount) => {
      return new Intl.NumberFormat("th-TH", {
        style: "currency",
        currency: "THB"
      }).format(amount);
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div><h1 class="text-3xl font-bold"></h1><p class="text-gray-600 mt-1"></p></div></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-3 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).type) ? ssrLooseContain(unref(filters).type, "") : ssrLooseEqual(unref(filters).type, "")) ? " selected" : ""}></option><option value="live_online"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).type) ? ssrLooseContain(unref(filters).type, "live_online") : ssrLooseEqual(unref(filters).type, "live_online")) ? " selected" : ""}>Live Online</option><option value="vod"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).type) ? ssrLooseContain(unref(filters).type, "vod") : ssrLooseEqual(unref(filters).type, "vod")) ? " selected" : ""}>VOD</option><option value="hybrid"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).type) ? ssrLooseContain(unref(filters).type, "hybrid") : ssrLooseEqual(unref(filters).type, "hybrid")) ? " selected" : ""}>Hybrid</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="draft"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "draft") : ssrLooseEqual(unref(filters).status, "draft")) ? " selected" : ""}></option><option value="published"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "published") : ssrLooseEqual(unref(filters).status, "published")) ? " selected" : ""}></option><option value="archived"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "archived") : ssrLooseEqual(unref(filters).status, "archived")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(courses).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg><p class="mt-4 text-lg font-medium"></p><p class="mt-1 text-sm"></p></div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(courses), (course) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 cursor-pointer"><div><div class="text-sm font-medium text-green-600 hover:text-green-700 cursor-pointer">${ssrInterpolate(course.title)}</div>`);
          if (course.code) {
            _push(`<div class="text-xs text-gray-500">: ${ssrInterpolate(course.code)}</div>`);
          } else {
            _push(`<!---->`);
          }
          if (course.description) {
            _push(`<div class="text-xs text-gray-400 mt-1 line-clamp-2">${ssrInterpolate(course.description)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getTypeBadgeClass(course.type), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getTypeName(course.type))}</span></td><td class="px-6 py-4 whitespace-nowrap"><span class="text-sm font-medium text-gray-900">${ssrInterpolate(formatCurrency(course.price))}</span></td><td class="px-6 py-4 whitespace-nowrap">`);
          if (course.level) {
            _push(`<span class="text-sm text-gray-600">${ssrInterpolate(getLevelName(course.level))}</span>`);
          } else {
            _push(`<span class="text-sm text-gray-400">-</span>`);
          }
          _push(`</td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(course.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusName(course.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(course.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2">`);
          _push(ssrRenderComponent(_component_NuxtLink, {
            to: `/admin/courses/${course.id}`,
            class: "text-blue-600 hover:text-blue-900",
            title: ""
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"${_scopeId}></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"${_scopeId}></path></svg>`);
              } else {
                return [
                  (openBlock(), createBlock("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                    }),
                    createVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                    })
                  ]))
                ];
              }
            }),
            _: 2
          }, _parent));
          _push(`</div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$G = _sfc_main$G.setup;
_sfc_main$G.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/tutor/courses/index.vue");
  return _sfc_setup$G ? _sfc_setup$G(props, ctx) : void 0;
};

const indexD0CwM0km = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$G
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "[id]",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useAuth();
    parseInt(route.params.id);
    const loading = ref(true);
    const error = ref("");
    const studentDetail = ref(null);
    const getStatusDisplayName = (status) => {
      const statusNames = {
        active: "",
        inactive: "",
        suspended: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        active: "bg-green-100 text-green-800",
        inactive: "bg-gray-100 text-gray-800",
        suspended: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getRelationshipName = (relationship) => {
      const relationshipNames = {
        father: "",
        mother: "",
        guardian: "",
        other: ""
      };
      return relationshipNames[relationship] || relationship;
    };
    const getEnrollmentStatusName = (status) => {
      const statusNames = {
        pending: "",
        active: "",
        completed: "",
        cancelled: ""
      };
      return statusNames[status] || status;
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy HH:mm", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4"><button class="p-2 hover:bg-gray-100 rounded-lg"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg></button><h1 class="text-3xl font-bold"></h1></div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(studentDetail)) {
        _push(`<div class="space-y-6"><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between mb-6"><h2 class="text-xl font-semibold"></h2><span class="${ssrRenderClass([getStatusBadgeClass(unref(studentDetail).student.status), "px-3 py-1 text-sm font-medium rounded"])}">${ssrInterpolate(getStatusDisplayName(unref(studentDetail).student.status))}</span></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"><div><label class="block text-sm font-medium text-gray-500 mb-1">-</label><p class="text-lg font-medium text-gray-900">${ssrInterpolate(unref(studentDetail).student.first_name)} ${ssrInterpolate(unref(studentDetail).student.last_name)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1">Username</label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.username)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1">Email</label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.email || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.phone || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(formatDate(unref(studentDetail).student.created_at))}</p></div></div></div><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2>`);
        if (unref(studentDetail).parents && unref(studentDetail).parents.length > 0) {
          _push(`<div class="space-y-4"><!--[-->`);
          ssrRenderList(unref(studentDetail).parents, (parent) => {
            _push(`<div class="border border-gray-200 rounded-lg p-4"><div class="flex items-center justify-between mb-3"><h3 class="text-lg font-medium text-gray-900">${ssrInterpolate(parent.first_name)} ${ssrInterpolate(parent.last_name)}</h3><span class="px-2 py-1 text-xs font-medium rounded bg-blue-100 text-blue-800">${ssrInterpolate(getRelationshipName(parent.relationship))}</span></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-500 mb-1">Email</label><p class="text-gray-900">${ssrInterpolate(parent.email || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(parent.phone || "-")}</p></div></div></div>`);
          });
          _push(`<!--]--></div>`);
        } else {
          _push(`<div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><p class="mt-2"></p></div>`);
        }
        _push(`</div><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2>`);
        if (unref(studentDetail).enrollments && unref(studentDetail).enrollments.length > 0) {
          _push(`<div class="space-y-4"><!--[-->`);
          ssrRenderList(unref(studentDetail).enrollments, (enrollment) => {
            _push(`<div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors"><div class="flex items-start justify-between"><div class="flex-1"><div class="flex items-center space-x-3 mb-2"><h3 class="text-lg font-medium text-gray-900">${ssrInterpolate(enrollment.course.title)}</h3><span class="${ssrRenderClass([enrollment.status === "active" ? "bg-green-100 text-green-800" : "bg-gray-100 text-gray-800", "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getEnrollmentStatusName(enrollment.status))}</span></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm"><div><span class="text-gray-500">:</span><span class="ml-2 text-gray-900">${ssrInterpolate(enrollment.course.code)}</span></div><div><span class="text-gray-500">:</span><span class="ml-2 text-gray-900">${ssrInterpolate(enrollment.branch.name)}</span></div><div><span class="text-gray-500">:</span><span class="ml-2 text-gray-900">${ssrInterpolate(formatDate(enrollment.enrolled_at))}</span></div></div></div></div></div>`);
          });
          _push(`<!--]--></div>`);
        } else {
          _push(`<div class="text-center py-8 text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg><p class="mt-2"></p></div>`);
        }
        _push(`</div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$F = _sfc_main$F.setup;
_sfc_main$F.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/tutor/students/[id].vue");
  return _sfc_setup$F ? _sfc_setup$F(props, ctx) : void 0;
};

const _id_BkoAM4Py = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$F
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "SMTPTab",
  __ssrInlineRender: true,
  setup(__props) {
    useAuth();
    const form = reactive({
      host: "",
      port: 587,
      secure: false,
      username: "",
      password: "",
      from_email: "",
      from_name: "",
      enabled: false
    });
    const loading = ref(false);
    const error = ref("");
    const success = ref("");
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "bg-white rounded-lg shadow p-6" }, _attrs))}><div class="mb-6"><h2 class="text-2xl font-bold mb-2"> SMTP</h2><p class="text-gray-600"> SMTP Server</p></div><form class="space-y-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"> SMTP Host <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).host)} type="text" required placeholder="smtp.gmail.com" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> SMTP Port <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).port)} type="number" required min="1" max="65535" placeholder="587" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Username <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).username)} type="text" required placeholder="your-email@gmail.com" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Password <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).password)} type="password" required placeholder="" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  (From Email) <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).from_email)} type="email" required placeholder="noreply@example.com" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  (From Name) <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).from_name)} type="text" required placeholder="Tutor School" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div class="space-y-4"><div class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).secure) ? ssrLooseContain(unref(form).secure, null) : unref(form).secure) ? " checked" : ""} type="checkbox" id="secure" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><label for="secure" class="ml-2 text-sm font-medium text-gray-700">  SSL/TLS (Secure) </label></div><div class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).enabled) ? ssrLooseContain(unref(form).enabled, null) : unref(form).enabled) ? " checked" : ""} type="checkbox" id="enabled" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><label for="enabled" class="ml-2 text-sm font-medium text-gray-700">  </label></div></div>`);
      if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(success)) {
        _push(`<div class="bg-green-50 border border-green-200 text-green-700 px-4 py-3 rounded">${ssrInterpolate(unref(success))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex justify-end"><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
      if (unref(loading)) {
        _push(`<span>...</span>`);
      } else {
        _push(`<span></span>`);
      }
      _push(`</button></div></form></div>`);
    };
  }
});
const _sfc_setup$E = _sfc_main$E.setup;
_sfc_main$E.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/email/components/SMTPTab.vue");
  return _sfc_setup$E ? _sfc_setup$E(props, ctx) : void 0;
};

const SMTPTabBmssJ9_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$E
}, Symbol.toStringTag, { value: 'Module' }));

const placeholderExample = "<p> {{first_name}},</p>";
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "TemplateModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    template: {},
    mode: { default: "view" }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const mode = ref(props.mode);
    const form = reactive({
      name: "",
      subject: "",
      body: ""
    });
    const loading = ref(false);
    const error = ref("");
    const formatVariable = (variable) => {
      return `{{${variable}}}`;
    };
    watch$1(() => props.template, (template) => {
      if (template) {
        form.name = template.name;
        form.subject = template.subject;
        form.body = template.body;
      }
      error.value = "";
      mode.value = props.mode;
    }, { immediate: true });
    watch$1(() => props.mode, (newMode) => {
      mode.value = newMode;
    });
    const previewBody = computed(() => {
      let preview = form.body || props.template.body;
      props.template.variables.forEach((variable) => {
        const sampleData = {
          first_name: "",
          last_name: "",
          email: "example@email.com",
          student_name: " ",
          course_name: " .3",
          enrollment_date: "1  2567",
          reset_link: "https://example.com/reset-password"
        };
        const regex = new RegExp(`{{\\s*${variable}\\s*}}`, "g");
        preview = preview.replace(regex, sampleData[variable] || `[${variable}]`);
      });
      return preview;
    });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(unref(mode) === "view" ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div>`);
        if (unref(mode) === "view") {
          _push(`<div><div class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><div class="px-4 py-2 bg-gray-50 border border-gray-200 rounded-lg">${ssrInterpolate(__props.template.name)}</div></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><div class="px-4 py-2 bg-gray-50 border border-gray-200 rounded-lg">${ssrInterpolate(__props.template.code)}</div></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><div class="px-4 py-2 bg-gray-50 border border-gray-200 rounded-lg">${ssrInterpolate(__props.template.subject)}</div></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><div class="flex flex-wrap gap-2"><!--[-->`);
          ssrRenderList(__props.template.variables, (variable) => {
            _push(`<span class="px-3 py-1 text-sm font-medium bg-blue-100 text-blue-800 rounded">${ssrInterpolate(formatVariable(variable))}</span>`);
          });
          _push(`<!--]--></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> (HTML)</label><div class="px-4 py-3 bg-gray-50 border border-gray-200 rounded-lg min-h-[200px] overflow-auto"><div>${__props.template.body ?? ""}</div></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><div class="px-4 py-3 bg-white border-2 border-gray-300 rounded-lg min-h-[200px]"><div>${unref(previewBody) ?? ""}</div></div></div></div><div class="flex justify-end space-x-3 pt-6 mt-6 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="button" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">  </button></div></div>`);
        } else {
          _push(`<form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", __props.template.code)} type="text" disabled class="w-full px-4 py-2 bg-gray-100 border border-gray-300 rounded-lg cursor-not-allowed"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).subject)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  (HTML) <span class="text-red-500">*</span></label><textarea rows="10" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm"${ssrRenderAttr("placeholder", placeholderExample)}>${ssrInterpolate(unref(form).body)}</textarea><p class="mt-1 text-xs text-gray-500"> {{variable_name}}</p></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><div class="px-4 py-3 bg-white border-2 border-gray-300 rounded-lg min-h-[200px]"><div>${unref(previewBody) ?? ""}</div></div></div>`);
          if (unref(error)) {
            _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
          if (unref(loading)) {
            _push(`<span>...</span>`);
          } else {
            _push(`<span></span>`);
          }
          _push(`</button></div></form>`);
        }
        _push(`</div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$D = _sfc_main$D.setup;
_sfc_main$D.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/email/components/TemplateModal.vue");
  return _sfc_setup$D ? _sfc_setup$D(props, ctx) : void 0;
};

const TemplateModalGRTNwPnN = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$D
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "TemplatesTab",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const templates = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showModal = ref(false);
    const selectedTemplate = ref(null);
    const modalMode = ref("view");
    const loadTemplates = async () => {
      loading.value = true;
      error.value = "";
      try {
        const response = await $fetch(`${config.public.apiBase}/admin/settings/email/templates`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          templates.value = response.data;
        }
      } catch (err) {
        console.error("Error loading templates:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showModal.value = false;
      selectedTemplate.value = null;
    };
    const handleTemplateSaved = () => {
      closeModal();
      loadTemplates();
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "bg-white rounded-lg shadow" }, _attrs))}><div class="p-6 border-b border-gray-200"><h2 class="text-2xl font-bold mb-2"></h2><p class="text-gray-600"></p></div>`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded m-6">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<div>`);
        if (unref(templates).length === 0) {
          _push(`<div class="p-8 text-center text-gray-500">  </div>`);
        } else {
          _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
          ssrRenderList(unref(templates), (template) => {
            _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(template.name)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-500">${ssrInterpolate(template.code)}</div></td><td class="px-6 py-4"><div class="text-sm text-gray-900 max-w-xs truncate">${ssrInterpolate(template.subject)}</div></td><td class="px-6 py-4"><div class="flex flex-wrap gap-1"><!--[-->`);
            ssrRenderList(template.variables, (variable) => {
              _push(`<span class="px-2 py-1 text-xs font-medium bg-blue-100 text-blue-800 rounded">${ssrInterpolate(variable)}</span>`);
            });
            _push(`<!--]--></div></td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg></button><button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button></div></td></tr>`);
          });
          _push(`<!--]--></tbody></table>`);
        }
        _push(`</div>`);
      }
      if (unref(showModal) && unref(selectedTemplate)) {
        _push(ssrRenderComponent(_sfc_main$D, {
          show: unref(showModal),
          template: unref(selectedTemplate),
          mode: unref(modalMode),
          onClose: closeModal,
          onSaved: handleTemplateSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$C = _sfc_main$C.setup;
_sfc_main$C.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/email/components/TemplatesTab.vue");
  return _sfc_setup$C ? _sfc_setup$C(props, ctx) : void 0;
};

const TemplatesTabBpOw2Zp = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$C
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const activeTab = ref("smtp");
    const tabs = [
      { id: "smtp", label: " SMTP" },
      { id: "templates", label: "Template" }
    ];
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="mb-6"><h1 class="text-3xl font-bold"></h1><p class="mt-2 text-gray-600"></p></div><div class="flex items-center gap-4 mb-6 border-b border-gray-200"><!--[-->`);
      ssrRenderList(tabs, (tab) => {
        _push(`<button class="${ssrRenderClass([unref(activeTab) === tab.id ? "text-green-600 border-b-2 border-green-600" : "text-gray-600 hover:text-green-600", "px-4 py-2 font-semibold transition-colors relative"])}">${ssrInterpolate(tab.label)}</button>`);
      });
      _push(`<!--]--></div><div>`);
      if (unref(activeTab) === "smtp") {
        _push(ssrRenderComponent(_sfc_main$E, null, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (unref(activeTab) === "templates") {
        _push(ssrRenderComponent(_sfc_main$C, null, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$B = _sfc_main$B.setup;
_sfc_main$B.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/email/index.vue");
  return _sfc_setup$B ? _sfc_setup$B(props, ctx) : void 0;
};

const indexBfoDd_bx = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$B
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$9 = /* @__PURE__ */ defineComponent({
  __name: "RoleModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    role: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const form = reactive({
      name: "",
      description: ""
    });
    const loading = ref(false);
    const error = ref("");
    watch$1(() => props.role, (role) => {
      if (role) {
        form.name = role.name;
        form.description = role.description || "";
      } else {
        form.name = "";
        form.description = "";
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.role ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required${ssrIncludeBooleanAttr(!!__props.role) ? " disabled" : ""} class="${ssrRenderClass(["w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500", { "bg-gray-100 cursor-not-allowed": __props.role }])}">`);
        if (__props.role) {
          _push(`<p class="mt-1 text-xs text-gray-500"></p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).description)}</textarea></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$9 = _sfc_main$1$9.setup;
_sfc_main$1$9.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/RoleModal.vue");
  return _sfc_setup$1$9 ? _sfc_setup$1$9(props, ctx) : void 0;
};
const __nuxt_component_0$7 = Object.assign(_sfc_main$1$9, { __name: "RoleModal" });
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const roles = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingRole = ref(null);
    const filters = reactive({
      search: ""
    });
    const systemRoles = ["system_admin", "owner", "admin", "branch_admin", "tutor", "parent", "student"];
    const isSystemRole = (roleName) => {
      return systemRoles.includes(roleName);
    };
    const loadRoles = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams();
        if (filters.search) params.append("search", filters.search);
        const response = await $fetch(`${config.public.apiBase}/admin/settings/roles?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          roles.value = response.data;
        }
      } catch (err) {
        console.error("Error loading roles:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingRole.value = null;
    };
    const handleRoleSaved = () => {
      closeModal();
      loadRoles();
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_RoleModal = __nuxt_component_0$7;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(roles).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(roles), (role) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(role.name)}</div></td><td class="px-6 py-4"><div class="text-sm text-gray-500 max-w-xs truncate">${ssrInterpolate(role.description || "-")}</div></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(role.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""${ssrIncludeBooleanAttr(isSystemRole(role.name)) ? " disabled" : ""}><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="${ssrRenderClass([{ "opacity-50 cursor-not-allowed": isSystemRole(role.name) }, "w-5 h-5"])}"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>`);
          if (!isSystemRole(role.name)) {
            _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      if (unref(showCreateModal) || unref(editingRole)) {
        _push(ssrRenderComponent(_component_RoleModal, {
          show: unref(showCreateModal) || !!unref(editingRole),
          role: unref(editingRole),
          onClose: closeModal,
          onSaved: handleRoleSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$A = _sfc_main$A.setup;
_sfc_main$A.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/roles/index.vue");
  return _sfc_setup$A ? _sfc_setup$A(props, ctx) : void 0;
};

const indexCvk7ldB7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$A
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const users = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingUser = ref(null);
    const filters = reactive({
      search: "",
      role: "",
      status: ""
    });
    const pagination = reactive({
      page: 1,
      limit: 20,
      total: 0,
      totalPages: 0
    });
    const loadUsers = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams({
          page: pagination.page.toString(),
          limit: pagination.limit.toString()
        });
        if (filters.search) params.append("search", filters.search);
        if (filters.role) params.append("role", filters.role);
        if (filters.status) params.append("status", filters.status);
        const response = await $fetch(`${config.public.apiBase}/admin/users?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          users.value = response.data.filter((user) => {
            const hasValidRoles = user.roles.some(
              (role) => ["system_admin", "owner", "admin", "branch_admin", "tutor"].includes(role)
            );
            return hasValidRoles;
          });
          Object.assign(pagination, response.pagination);
        }
      } catch (err) {
        console.error("Error loading users:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingUser.value = null;
    };
    const handleUserSaved = () => {
      closeModal();
      loadUsers();
    };
    const getStatusDisplayName = (status) => {
      const statusNames = {
        active: "",
        inactive: "",
        suspended: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        active: "bg-green-100 text-green-800",
        inactive: "bg-gray-100 text-gray-800",
        suspended: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getRoleDisplayName = (role) => {
      const roleNames = {
        system_admin: "System Admin",
        owner: "Owner",
        admin: "Admin ",
        branch_admin: "Admin ",
        tutor: "Tutor",
        parent: "Parent",
        student: "Student"
      };
      return roleNames[role] || role;
    };
    const getRoleBadgeClass = (role) => {
      const classes = {
        system_admin: "bg-purple-100 text-purple-800",
        owner: "bg-red-100 text-red-800",
        admin: "bg-blue-100 text-blue-800",
        branch_admin: "bg-indigo-100 text-indigo-800",
        tutor: "bg-yellow-100 text-yellow-800",
        parent: "bg-green-100 text-green-800",
        student: "bg-gray-100 text-gray-800"
      };
      return classes[role] || "bg-gray-100 text-gray-800";
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UserModal = __nuxt_component_0$9;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-3 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=" username, email, " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "") : ssrLooseEqual(unref(filters).role, "")) ? " selected" : ""}></option><option value="system_admin"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "system_admin") : ssrLooseEqual(unref(filters).role, "system_admin")) ? " selected" : ""}>System Admin</option><option value="owner"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "owner") : ssrLooseEqual(unref(filters).role, "owner")) ? " selected" : ""}>Owner</option><option value="admin"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "admin") : ssrLooseEqual(unref(filters).role, "admin")) ? " selected" : ""}>Admin </option><option value="branch_admin"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "branch_admin") : ssrLooseEqual(unref(filters).role, "branch_admin")) ? " selected" : ""}>Admin </option><option value="tutor"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).role) ? ssrLooseContain(unref(filters).role, "tutor") : ssrLooseEqual(unref(filters).role, "tutor")) ? " selected" : ""}>Tutor</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "active") : ssrLooseEqual(unref(filters).status, "active")) ? " selected" : ""}></option><option value="inactive"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "inactive") : ssrLooseEqual(unref(filters).status, "inactive")) ? " selected" : ""}></option><option value="suspended"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "suspended") : ssrLooseEqual(unref(filters).status, "suspended")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(users).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(users), (user) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div><div class="text-sm font-medium text-gray-900">${ssrInterpolate(user.first_name)} ${ssrInterpolate(user.last_name)}</div><div class="text-sm text-gray-500">${ssrInterpolate(user.username)}</div>`);
          if (user.email) {
            _push(`<div class="text-xs text-gray-400">${ssrInterpolate(user.email)}</div>`);
          } else {
            _push(`<!---->`);
          }
          if (user.phone) {
            _push(`<div class="text-xs text-gray-400">${ssrInterpolate(user.phone)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4"><div class="flex flex-wrap gap-1"><!--[-->`);
          ssrRenderList(user.roles, (role) => {
            _push(`<span class="${ssrRenderClass([getRoleBadgeClass(role), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getRoleDisplayName(role))}</span>`);
          });
          _push(`<!--]--></div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(user.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusDisplayName(user.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(user.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>`);
          if (user.status === "active") {
            _push(`<button class="text-yellow-600 hover:text-yellow-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"></path></svg></button>`);
          } else {
            _push(`<button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>`);
          }
          _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      if (unref(pagination).totalPages > 1) {
        _push(`<div class="bg-gray-50 px-4 py-3 flex items-center justify-between border-t border-gray-200"><div class="text-sm text-gray-700">  ${ssrInterpolate((unref(pagination).page - 1) * unref(pagination).limit + 1)}  ${ssrInterpolate(Math.min(unref(pagination).page * unref(pagination).limit, unref(pagination).total))}  ${ssrInterpolate(unref(pagination).total)}  </div><div class="flex space-x-2"><button${ssrIncludeBooleanAttr(unref(pagination).page === 1) ? " disabled" : ""} class="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100">  </button><button${ssrIncludeBooleanAttr(unref(pagination).page >= unref(pagination).totalPages) ? " disabled" : ""} class="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100">  </button></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (unref(showCreateModal) || unref(editingUser)) {
        _push(ssrRenderComponent(_component_UserModal, {
          show: unref(showCreateModal) || !!unref(editingUser),
          user: unref(editingUser),
          onClose: closeModal,
          onSaved: handleUserSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$z = _sfc_main$z.setup;
_sfc_main$z.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/users/index.vue");
  return _sfc_setup$z ? _sfc_setup$z(props, ctx) : void 0;
};

const indexC6_laMk5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$z
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$3$1 = /* @__PURE__ */ defineComponent({
  __name: "EventModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    event: {},
    initialDate: {}
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const config = useRuntimeConfig();
    const { accessToken, user } = useAuth();
    const saving = ref(false);
    const availableBranches = ref([]);
    const form = reactive({
      title: "",
      description: "",
      startDate: "",
      startTime: "",
      endDate: "",
      endTime: "",
      is_all_day: false,
      location: "",
      event_type: "personal",
      color: "#3B82F6",
      reminder_minutes: null,
      is_shared: false,
      shared_scope: "public",
      shared_branch_id: null
    });
    const colorOptions = [
      { value: "#3B82F6", class: "blue-500", label: "" },
      { value: "#10B981", class: "green-500", label: "" },
      { value: "#F59E0B", class: "yellow-500", label: "" },
      { value: "#EF4444", class: "red-500", label: "" },
      { value: "#8B5CF6", class: "purple-500", label: "" },
      { value: "#EC4899", class: "pink-500", label: "" }
    ];
    const userRoles = computed(() => user.value?.roles || []);
    const isSystemAdmin = computed(() => userRoles.value.includes(UserRole.SYSTEM_ADMIN) || userRoles.value.includes(UserRole.OWNER));
    const isAdmin = computed(() => userRoles.value.includes(UserRole.ADMIN));
    const isBranchAdmin = computed(() => userRoles.value.includes(UserRole.BRANCH_ADMIN));
    const isTutor = computed(() => userRoles.value.includes(UserRole.TUTOR));
    const isStudent = computed(() => userRoles.value.includes(UserRole.STUDENT));
    const isParent = computed(() => userRoles.value.includes(UserRole.PARENT));
    const canCreateHoliday = computed(() => isSystemAdmin.value || isAdmin.value || isBranchAdmin.value);
    const canCreateAnnouncement = computed(() => isSystemAdmin.value || isAdmin.value || isBranchAdmin.value);
    const canShareToAdmins = computed(() => isSystemAdmin.value || isAdmin.value);
    const canShareToBranchAdmins = computed(() => isSystemAdmin.value || isAdmin.value || isBranchAdmin.value);
    const canShareToTutors = computed(() => isSystemAdmin.value || isAdmin.value || isBranchAdmin.value || isTutor.value);
    const canShareToStudents = computed(() => isSystemAdmin.value || isAdmin.value || isBranchAdmin.value || isTutor.value || isStudent.value);
    const canShareToBranchStudents = computed(() => isSystemAdmin.value || isAdmin.value || isBranchAdmin.value || isTutor.value);
    const canShareToParents = computed(() => isSystemAdmin.value || isAdmin.value || isBranchAdmin.value || isTutor.value || isParent.value);
    const canShareToBranchParents = computed(() => isSystemAdmin.value || isAdmin.value || isBranchAdmin.value || isTutor.value);
    const loadBranches = async () => {
      try {
        const response = await $fetch(`${config.public.apiBase}/admin/branches`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          availableBranches.value = response.data.filter((b) => b.code !== null);
        }
      } catch (error) {
        console.error("Error loading branches:", error);
      }
    };
    const initializeForm = () => {
      if (props.event) {
        const startDate = new Date(props.event.start_datetime);
        const endDate = new Date(props.event.end_datetime);
        form.title = props.event.title;
        form.description = props.event.description || "";
        form.startDate = formatDateInput(startDate);
        form.startTime = formatTimeInput(startDate);
        form.endDate = formatDateInput(endDate);
        form.endTime = formatTimeInput(endDate);
        form.is_all_day = props.event.is_all_day;
        form.location = props.event.location || "";
        form.event_type = props.event.event_type;
        form.color = props.event.color;
        form.reminder_minutes = props.event.reminder_minutes;
        form.is_shared = props.event.is_shared;
        form.shared_scope = props.event.shared_scope;
        form.shared_branch_id = props.event.shared_branch_id;
      } else {
        const baseDate = props.initialDate || /* @__PURE__ */ new Date();
        form.startDate = formatDateInput(baseDate);
        form.startTime = formatTimeInput(baseDate);
        form.endDate = formatDateInput(baseDate);
        form.endTime = formatTimeInput(new Date(baseDate.getTime() + 60 * 60 * 1e3));
        form.is_all_day = false;
        form.is_shared = false;
        form.shared_scope = "public";
        form.shared_branch_id = null;
      }
    };
    const formatDateInput = (date) => {
      return date.toISOString().split("T")[0];
    };
    const formatTimeInput = (date) => {
      return date.toTimeString().slice(0, 5);
    };
    watch$1(() => props.show, (newVal) => {
      if (newVal) {
        initializeForm();
        if (canShareToBranchAdmins.value || canShareToTutors.value || canShareToBranchStudents.value || canShareToBranchParents.value) {
          loadBranches();
        }
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.event ? " Event" : " Event")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  Event <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).title)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" , "></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="">${ssrInterpolate(unref(form).description)}</textarea></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).startDate)} type="date" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">`);
        if (!unref(form).is_all_day) {
          _push(`<input${ssrRenderAttr("value", unref(form).startTime)} type="time" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 mt-2">`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).endDate)} type="date" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">`);
        if (!unref(form).is_all_day) {
          _push(`<input${ssrRenderAttr("value", unref(form).endTime)} type="time" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 mt-2">`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div><div><label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_all_day) ? ssrLooseContain(unref(form).is_all_day, null) : unref(form).is_all_day) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="text-sm font-medium text-gray-700"></span></label></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).location)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" , Zoom Meeting"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  Event </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="personal"${ssrIncludeBooleanAttr(Array.isArray(unref(form).event_type) ? ssrLooseContain(unref(form).event_type, "personal") : ssrLooseEqual(unref(form).event_type, "personal")) ? " selected" : ""}></option><option value="meeting"${ssrIncludeBooleanAttr(Array.isArray(unref(form).event_type) ? ssrLooseContain(unref(form).event_type, "meeting") : ssrLooseEqual(unref(form).event_type, "meeting")) ? " selected" : ""}></option><option value="holiday"${ssrIncludeBooleanAttr(!unref(canCreateHoliday)) ? " disabled" : ""}${ssrIncludeBooleanAttr(Array.isArray(unref(form).event_type) ? ssrLooseContain(unref(form).event_type, "holiday") : ssrLooseEqual(unref(form).event_type, "holiday")) ? " selected" : ""}></option><option value="announcement"${ssrIncludeBooleanAttr(!unref(canCreateAnnouncement)) ? " disabled" : ""}${ssrIncludeBooleanAttr(Array.isArray(unref(form).event_type) ? ssrLooseContain(unref(form).event_type, "announcement") : ssrLooseEqual(unref(form).event_type, "announcement")) ? " selected" : ""}></option><option value="other"${ssrIncludeBooleanAttr(Array.isArray(unref(form).event_type) ? ssrLooseContain(unref(form).event_type, "other") : ssrLooseEqual(unref(form).event_type, "other")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  Event </label><div class="flex items-center space-x-2"><!--[-->`);
        ssrRenderList(colorOptions, (colorOption) => {
          _push(`<button type="button" class="${ssrRenderClass([[
            unref(form).color === colorOption.value ? "border-gray-800 scale-110" : "border-gray-300",
            `bg-${colorOption.class}`
          ], "w-10 h-10 rounded-lg border-2 transition-all"])}" style="${ssrRenderStyle({ backgroundColor: colorOption.value })}"></button>`);
        });
        _push(`<!--]--></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option${ssrRenderAttr("value", null)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, null) : ssrLooseEqual(unref(form).reminder_minutes, null)) ? " selected" : ""}></option><option${ssrRenderAttr("value", 15)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 15) : ssrLooseEqual(unref(form).reminder_minutes, 15)) ? " selected" : ""}>15 </option><option${ssrRenderAttr("value", 30)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 30) : ssrLooseEqual(unref(form).reminder_minutes, 30)) ? " selected" : ""}>30 </option><option${ssrRenderAttr("value", 60)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 60) : ssrLooseEqual(unref(form).reminder_minutes, 60)) ? " selected" : ""}>1 </option><option${ssrRenderAttr("value", 1440)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 1440) : ssrLooseEqual(unref(form).reminder_minutes, 1440)) ? " selected" : ""}>1 </option><option${ssrRenderAttr("value", 2880)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 2880) : ssrLooseEqual(unref(form).reminder_minutes, 2880)) ? " selected" : ""}>2 </option></select></div><div class="border-t pt-4"><label class="flex items-center space-x-2 mb-4"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_shared) ? ssrLooseContain(unref(form).is_shared, null) : unref(form).is_shared) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="text-sm font-medium text-gray-700"> Event</span></label>`);
        if (unref(form).is_shared) {
          _push(`<div class="space-y-3 pl-6 border-l-2 border-gray-200"><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><div class="space-y-2"><label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).shared_scope, "public")) ? " checked" : ""} type="radio" value="public" class="w-4 h-4 text-green-600 border-gray-300 focus:ring-green-500"><span class="text-sm text-gray-700"> (Public)</span></label>`);
          if (unref(canShareToAdmins)) {
            _push(`<label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).shared_scope, "admins")) ? " checked" : ""} type="radio" value="admins" class="w-4 h-4 text-green-600 border-gray-300 focus:ring-green-500"><span class="text-sm text-gray-700"> (Admins)</span></label>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(canShareToBranchAdmins)) {
            _push(`<label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).shared_scope, "branch_admins")) ? " checked" : ""} type="radio" value="branch_admins" class="w-4 h-4 text-green-600 border-gray-300 focus:ring-green-500"><span class="text-sm text-gray-700"> (Branch Admins)</span></label>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(form).shared_scope === "branch_admins" && unref(availableBranches).length > 0) {
            _push(`<div class="ml-6 mt-2"><select class="w-full px-3 py-1 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option${ssrRenderAttr("value", null)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).shared_branch_id) ? ssrLooseContain(unref(form).shared_branch_id, null) : ssrLooseEqual(unref(form).shared_branch_id, null)) ? " selected" : ""}></option><!--[-->`);
            ssrRenderList(unref(availableBranches), (branch) => {
              _push(`<option${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).shared_branch_id) ? ssrLooseContain(unref(form).shared_branch_id, branch.id) : ssrLooseEqual(unref(form).shared_branch_id, branch.id)) ? " selected" : ""}>${ssrInterpolate(branch.name)}</option>`);
            });
            _push(`<!--]--></select></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(canShareToTutors)) {
            _push(`<label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).shared_scope, "tutors")) ? " checked" : ""} type="radio" value="tutors" class="w-4 h-4 text-green-600 border-gray-300 focus:ring-green-500"><span class="text-sm text-gray-700"> (Tutors)</span></label>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(form).shared_scope === "tutors" && unref(availableBranches).length > 0) {
            _push(`<div class="ml-6 mt-2"><select class="w-full px-3 py-1 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option${ssrRenderAttr("value", null)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).shared_branch_id) ? ssrLooseContain(unref(form).shared_branch_id, null) : ssrLooseEqual(unref(form).shared_branch_id, null)) ? " selected" : ""}></option><!--[-->`);
            ssrRenderList(unref(availableBranches), (branch) => {
              _push(`<option${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).shared_branch_id) ? ssrLooseContain(unref(form).shared_branch_id, branch.id) : ssrLooseEqual(unref(form).shared_branch_id, branch.id)) ? " selected" : ""}>${ssrInterpolate(branch.name)}</option>`);
            });
            _push(`<!--]--></select></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(canShareToStudents)) {
            _push(`<label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).shared_scope, "students")) ? " checked" : ""} type="radio" value="students" class="w-4 h-4 text-green-600 border-gray-300 focus:ring-green-500"><span class="text-sm text-gray-700"> (Students)</span></label>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(canShareToBranchStudents)) {
            _push(`<label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).shared_scope, "branch_students")) ? " checked" : ""} type="radio" value="branch_students" class="w-4 h-4 text-green-600 border-gray-300 focus:ring-green-500"><span class="text-sm text-gray-700"> (Branch Students)</span></label>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(form).shared_scope === "branch_students" && unref(availableBranches).length > 0) {
            _push(`<div class="ml-6 mt-2"><select required class="w-full px-3 py-1 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).shared_branch_id) ? ssrLooseContain(unref(form).shared_branch_id, "") : ssrLooseEqual(unref(form).shared_branch_id, "")) ? " selected" : ""}></option><!--[-->`);
            ssrRenderList(unref(availableBranches), (branch) => {
              _push(`<option${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).shared_branch_id) ? ssrLooseContain(unref(form).shared_branch_id, branch.id) : ssrLooseEqual(unref(form).shared_branch_id, branch.id)) ? " selected" : ""}>${ssrInterpolate(branch.name)}</option>`);
            });
            _push(`<!--]--></select></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(canShareToParents)) {
            _push(`<label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).shared_scope, "parents")) ? " checked" : ""} type="radio" value="parents" class="w-4 h-4 text-green-600 border-gray-300 focus:ring-green-500"><span class="text-sm text-gray-700"> (Parents)</span></label>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(canShareToBranchParents)) {
            _push(`<label class="flex items-center space-x-2"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).shared_scope, "branch_parents")) ? " checked" : ""} type="radio" value="branch_parents" class="w-4 h-4 text-green-600 border-gray-300 focus:ring-green-500"><span class="text-sm text-gray-700"> (Branch Parents)</span></label>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(form).shared_scope === "branch_parents" && unref(availableBranches).length > 0) {
            _push(`<div class="ml-6 mt-2"><select required class="w-full px-3 py-1 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).shared_branch_id) ? ssrLooseContain(unref(form).shared_branch_id, "") : ssrLooseEqual(unref(form).shared_branch_id, "")) ? " selected" : ""}></option><!--[-->`);
            ssrRenderList(unref(availableBranches), (branch) => {
              _push(`<option${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).shared_branch_id) ? ssrLooseContain(unref(form).shared_branch_id, branch.id) : ssrLooseEqual(unref(form).shared_branch_id, branch.id)) ? " selected" : ""}>${ssrInterpolate(branch.name)}</option>`);
            });
            _push(`<!--]--></select></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="flex items-center justify-end space-x-4 pt-4 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 text-gray-700">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(saving)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$3$1 = _sfc_main$3$1.setup;
_sfc_main$3$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/EventModal.vue");
  return _sfc_setup$3$1 ? _sfc_setup$3$1(props, ctx) : void 0;
};
const __nuxt_component_0$6 = Object.assign(_sfc_main$3$1, { __name: "EventModal" });
const _sfc_main$2$1 = /* @__PURE__ */ defineComponent({
  __name: "TaskModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    task: {},
    initialDate: {}
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      title: "",
      description: "",
      start_date: "",
      due_date: "",
      priority: "medium",
      status: "not_started",
      color: "#10B981",
      category: ""
    });
    const colorOptions = [
      { value: "#10B981", class: "green-500", label: "" },
      { value: "#3B82F6", class: "blue-500", label: "" },
      { value: "#F59E0B", class: "yellow-500", label: "" },
      { value: "#EF4444", class: "red-500", label: "" },
      { value: "#8B5CF6", class: "purple-500", label: "" },
      { value: "#EC4899", class: "pink-500", label: "" }
    ];
    const formatDateInput = (date) => {
      if (!date) return "";
      const d = typeof date === "string" ? new Date(date) : date;
      return d.toISOString().split("T")[0];
    };
    const initializeForm = () => {
      if (props.task) {
        form.title = props.task.title;
        form.description = props.task.description || "";
        form.start_date = formatDateInput(props.task.start_date);
        form.due_date = formatDateInput(props.task.due_date);
        form.priority = props.task.priority;
        form.status = props.task.status;
        form.color = props.task.color;
        form.category = props.task.category || "";
      } else {
        form.title = "";
        form.description = "";
        if (props.initialDate) {
          form.start_date = formatDateInput(props.initialDate);
          form.due_date = formatDateInput(props.initialDate);
        } else {
          form.start_date = "";
          form.due_date = "";
        }
        form.priority = "medium";
        form.status = "not_started";
        form.color = "#10B981";
        form.category = "";
      }
    };
    watch$1(() => props.show, (newVal) => {
      if (newVal) {
        initializeForm();
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.task ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).title)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" , "></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="">${ssrInterpolate(unref(form).description)}</textarea></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).start_date)} type="date" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).due_date)} type="date" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="low"${ssrIncludeBooleanAttr(Array.isArray(unref(form).priority) ? ssrLooseContain(unref(form).priority, "low") : ssrLooseEqual(unref(form).priority, "low")) ? " selected" : ""}></option><option value="medium"${ssrIncludeBooleanAttr(Array.isArray(unref(form).priority) ? ssrLooseContain(unref(form).priority, "medium") : ssrLooseEqual(unref(form).priority, "medium")) ? " selected" : ""}></option><option value="high"${ssrIncludeBooleanAttr(Array.isArray(unref(form).priority) ? ssrLooseContain(unref(form).priority, "high") : ssrLooseEqual(unref(form).priority, "high")) ? " selected" : ""}></option><option value="urgent"${ssrIncludeBooleanAttr(Array.isArray(unref(form).priority) ? ssrLooseContain(unref(form).priority, "urgent") : ssrLooseEqual(unref(form).priority, "urgent")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="not_started"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "not_started") : ssrLooseEqual(unref(form).status, "not_started")) ? " selected" : ""}></option><option value="in_progress"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "in_progress") : ssrLooseEqual(unref(form).status, "in_progress")) ? " selected" : ""}></option><option value="completed"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "completed") : ssrLooseEqual(unref(form).status, "completed")) ? " selected" : ""}></option><option value="cancelled"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "cancelled") : ssrLooseEqual(unref(form).status, "cancelled")) ? " selected" : ""}></option></select></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).category)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" , , "></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><div class="flex items-center space-x-2"><!--[-->`);
        ssrRenderList(colorOptions, (colorOption) => {
          _push(`<button type="button" class="${ssrRenderClass([[
            unref(form).color === colorOption.value ? "border-gray-800 scale-110" : "border-gray-300",
            `bg-${colorOption.class}`
          ], "w-10 h-10 rounded-lg border-2 transition-all"])}" style="${ssrRenderStyle({ backgroundColor: colorOption.value })}"></button>`);
        });
        _push(`<!--]--></div></div><div class="flex items-center justify-end space-x-4 pt-4 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 text-gray-700">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(saving)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$2$1 = _sfc_main$2$1.setup;
_sfc_main$2$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/TaskModal.vue");
  return _sfc_setup$2$1 ? _sfc_setup$2$1(props, ctx) : void 0;
};
const __nuxt_component_1$1 = Object.assign(_sfc_main$2$1, { __name: "TaskModal" });
const _sfc_main$1$8 = /* @__PURE__ */ defineComponent({
  __name: "AppointmentModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    appointment: {}
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      title: "",
      description: "",
      startDate: "",
      startTime: "",
      endDate: "",
      endTime: "",
      appointment_type: "student",
      location: "",
      meeting_link: "",
      status: "scheduled",
      color: "#3B82F6",
      reminder_minutes: null,
      participant_user_ids_input: "",
      participant_user_ids: []
    });
    const colorOptions = [
      { value: "#3B82F6", class: "blue-500", label: "" },
      { value: "#10B981", class: "green-500", label: "" },
      { value: "#F59E0B", class: "yellow-500", label: "" },
      { value: "#EF4444", class: "red-500", label: "" },
      { value: "#8B5CF6", class: "purple-500", label: "" },
      { value: "#EC4899", class: "pink-500", label: "" }
    ];
    const formatDateInput = (date) => {
      const d = typeof date === "string" ? new Date(date) : date;
      return d.toISOString().split("T")[0];
    };
    const formatTimeInput = (date) => {
      const d = typeof date === "string" ? new Date(date) : date;
      return d.toTimeString().slice(0, 5);
    };
    const initializeForm = () => {
      if (props.appointment) {
        const startDate = new Date(props.appointment.start_datetime);
        const endDate = new Date(props.appointment.end_datetime);
        form.title = props.appointment.title;
        form.description = props.appointment.description || "";
        form.startDate = formatDateInput(startDate);
        form.startTime = formatTimeInput(startDate);
        form.endDate = formatDateInput(endDate);
        form.endTime = formatTimeInput(endDate);
        form.appointment_type = props.appointment.appointment_type;
        form.location = props.appointment.location || "";
        form.meeting_link = props.appointment.meeting_link || "";
        form.status = props.appointment.status;
        form.color = props.appointment.color;
        form.reminder_minutes = props.appointment.reminder_minutes;
        form.participant_user_ids = props.appointment.participants?.map((p) => p.user_id) || [];
        form.participant_user_ids_input = form.participant_user_ids.join(",");
      } else {
        const baseDate = props.initialDate || /* @__PURE__ */ new Date();
        form.startDate = formatDateInput(baseDate);
        form.startTime = formatTimeInput(baseDate);
        form.endDate = formatDateInput(baseDate);
        form.endTime = formatTimeInput(new Date(baseDate.getTime() + 60 * 60 * 1e3));
        form.appointment_type = "student";
        form.status = "scheduled";
        form.participant_user_ids = [];
        form.participant_user_ids_input = "";
      }
    };
    watch$1(() => props.show, (newVal) => {
      if (newVal) {
        initializeForm();
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.appointment ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).title)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" , "></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="">${ssrInterpolate(unref(form).description)}</textarea></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).startDate)} type="date" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><input${ssrRenderAttr("value", unref(form).startTime)} type="time" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 mt-2"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).endDate)} type="date" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><input${ssrRenderAttr("value", unref(form).endTime)} type="time" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 mt-2"></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="student"${ssrIncludeBooleanAttr(Array.isArray(unref(form).appointment_type) ? ssrLooseContain(unref(form).appointment_type, "student") : ssrLooseEqual(unref(form).appointment_type, "student")) ? " selected" : ""}></option><option value="meeting"${ssrIncludeBooleanAttr(Array.isArray(unref(form).appointment_type) ? ssrLooseContain(unref(form).appointment_type, "meeting") : ssrLooseEqual(unref(form).appointment_type, "meeting")) ? " selected" : ""}></option><option value="parent"${ssrIncludeBooleanAttr(Array.isArray(unref(form).appointment_type) ? ssrLooseContain(unref(form).appointment_type, "parent") : ssrLooseEqual(unref(form).appointment_type, "parent")) ? " selected" : ""}></option><option value="staff"${ssrIncludeBooleanAttr(Array.isArray(unref(form).appointment_type) ? ssrLooseContain(unref(form).appointment_type, "staff") : ssrLooseEqual(unref(form).appointment_type, "staff")) ? " selected" : ""}></option><option value="other"${ssrIncludeBooleanAttr(Array.isArray(unref(form).appointment_type) ? ssrLooseContain(unref(form).appointment_type, "other") : ssrLooseEqual(unref(form).appointment_type, "other")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).location)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" , Zoom Meeting"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).meeting_link)} type="url" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="https://zoom.us/j/..."></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="scheduled"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "scheduled") : ssrLooseEqual(unref(form).status, "scheduled")) ? " selected" : ""}></option><option value="confirmed"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "confirmed") : ssrLooseEqual(unref(form).status, "confirmed")) ? " selected" : ""}></option><option value="cancelled"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "cancelled") : ssrLooseEqual(unref(form).status, "cancelled")) ? " selected" : ""}></option><option value="completed"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "completed") : ssrLooseEqual(unref(form).status, "completed")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><div class="flex items-center space-x-2"><!--[-->`);
        ssrRenderList(colorOptions, (colorOption) => {
          _push(`<button type="button" class="${ssrRenderClass([[
            unref(form).color === colorOption.value ? "border-gray-800 scale-110" : "border-gray-300",
            `bg-${colorOption.class}`
          ], "w-10 h-10 rounded-lg border-2 transition-all"])}" style="${ssrRenderStyle({ backgroundColor: colorOption.value })}"></button>`);
        });
        _push(`<!--]--></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option${ssrRenderAttr("value", null)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, null) : ssrLooseEqual(unref(form).reminder_minutes, null)) ? " selected" : ""}></option><option${ssrRenderAttr("value", 15)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 15) : ssrLooseEqual(unref(form).reminder_minutes, 15)) ? " selected" : ""}>15 </option><option${ssrRenderAttr("value", 30)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 30) : ssrLooseEqual(unref(form).reminder_minutes, 30)) ? " selected" : ""}>30 </option><option${ssrRenderAttr("value", 60)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 60) : ssrLooseEqual(unref(form).reminder_minutes, 60)) ? " selected" : ""}>1 </option><option${ssrRenderAttr("value", 1440)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).reminder_minutes) ? ssrLooseContain(unref(form).reminder_minutes, 1440) : ssrLooseEqual(unref(form).reminder_minutes, 1440)) ? " selected" : ""}>1 </option></select></div><div class="border-t pt-4"><label class="block text-sm font-medium text-gray-700 mb-2">  (User IDs -  comma) </label><input${ssrRenderAttr("value", unref(form).participant_user_ids_input)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" 1,2,3 (User IDs)"><p class="text-xs text-gray-500 mt-1"> User IDs  comma ()</p></div><div class="flex items-center justify-end space-x-4 pt-4 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 text-gray-700">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(saving)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$8 = _sfc_main$1$8.setup;
_sfc_main$1$8.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/AppointmentModal.vue");
  return _sfc_setup$1$8 ? _sfc_setup$1$8(props, ctx) : void 0;
};
const __nuxt_component_2 = Object.assign(_sfc_main$1$8, { __name: "AppointmentModal" });
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const schedules = ref([]);
    const events = ref([]);
    const tasks = ref([]);
    const appointments = ref([]);
    const courses = ref([]);
    const loading = ref(true);
    const error = ref("");
    const viewMode = ref("month");
    const dateRange = ref("month");
    const customStartDate = ref("");
    const customEndDate = ref("");
    const currentWeekStart = ref(startOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 }));
    const currentDay = ref(/* @__PURE__ */ new Date());
    const currentMonth = ref(startOfMonth(/* @__PURE__ */ new Date()));
    ref(null);
    const showViewMenu = ref(false);
    const showCreateMenu = ref(false);
    const showDateMenu = ref({});
    const showEventModal = ref(false);
    const showTaskModal = ref(false);
    const showAppointmentModal = ref(false);
    const selectedEvent = ref(null);
    const selectedTask = ref(null);
    const selectedAppointment = ref(null);
    const selectedDateForCreate = ref(null);
    const viewModes = [
      { value: "day", label: "", shortcut: "D" },
      { value: "week", label: "", shortcut: "W" },
      { value: "month", label: "", shortcut: "M" },
      { value: "agenda", label: "", shortcut: "A" },
      { value: "4days", label: "4 ", shortcut: "X" }
    ];
    const filters = reactive({
      status: "",
      courseId: ""
    });
    const currentViewLabel = computed(() => {
      const view = viewModes.find((v) => v.value === viewMode.value);
      return view?.label || "";
    });
    const isCalendarView = computed(() => {
      return ["day", "week", "month", "4days"].includes(viewMode.value);
    });
    const currentPeriodLabel = computed(() => {
      if (viewMode.value === "day") {
        return format$4(currentDay.value, "dd MMMM yyyy", { locale: th });
      } else if (viewMode.value === "week") {
        return formatWeekRange(currentWeekStart.value);
      } else if (viewMode.value === "month") {
        return format$4(currentMonth.value, "MMMM yyyy", { locale: th });
      } else if (viewMode.value === "4days") {
        const endDate = addDays(currentDay.value, 3);
        return `${format$4(currentDay.value, "dd MMM", { locale: th })} - ${format$4(endDate, "dd MMM yyyy", { locale: th })}`;
      }
      return "";
    });
    const fourDays = computed(() => {
      const days = [];
      const dayNames = ["", "", "", ""];
      for (let i = 0; i < 4; i++) {
        const date = addDays(currentDay.value, i);
        days.push({
          key: i,
          label: dayNames[i] || format$4(date, "EEEE", { locale: th }),
          date
        });
      }
      return days;
    });
    const monthDays = computed(() => {
      const start = startOfWeek(startOfMonth(currentMonth.value), { weekStartsOn: 1 });
      const end = endOfWeek(endOfMonth(currentMonth.value), { weekStartsOn: 1 });
      const days = eachDayOfInterval({ start, end });
      return days.map((date, index) => ({
        key: index,
        date
      }));
    });
    const todayCount = computed(() => {
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      return schedules.value.filter(
        (s) => s.start_datetime.startsWith(today) && s.status !== "cancelled"
      ).length;
    });
    const weekCount = computed(() => {
      const weekStart = startOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 });
      const weekEnd = endOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 });
      return schedules.value.filter((s) => {
        const scheduleDate = parseISO(s.start_datetime);
        return scheduleDate >= weekStart && scheduleDate <= weekEnd && s.status !== "cancelled";
      }).length;
    });
    const ongoingCount = computed(() => {
      return schedules.value.filter((s) => s.status === "ongoing").length;
    });
    const completedCount = computed(() => {
      return schedules.value.filter((s) => s.status === "completed").length;
    });
    const weekDays = computed(() => {
      const days = [];
      for (let i = 0; i < 7; i++) {
        const date = addDays(currentWeekStart.value, i);
        const dayNames = ["", "", "", "", "", "", ""];
        days.push({
          key: i,
          label: dayNames[i],
          date
        });
      }
      return days;
    });
    const loadEvents = async () => {
      try {
        const params = {};
        if (viewMode.value === "day") {
          params.start_date = format$4(currentDay.value, "yyyy-MM-dd");
          params.end_date = format$4(currentDay.value, "yyyy-MM-dd");
        } else if (viewMode.value === "week") {
          const weekEnd = endOfWeek(currentWeekStart.value, { weekStartsOn: 1 });
          params.start_date = format$4(currentWeekStart.value, "yyyy-MM-dd");
          params.end_date = format$4(weekEnd, "yyyy-MM-dd");
        } else if (viewMode.value === "month") {
          const monthStart = startOfMonth(currentMonth.value);
          const monthEnd = endOfMonth(currentMonth.value);
          params.start_date = format$4(monthStart, "yyyy-MM-dd");
          params.end_date = format$4(monthEnd, "yyyy-MM-dd");
        } else if (viewMode.value === "4days") {
          const endDate = addDays(currentDay.value, 3);
          params.start_date = format$4(currentDay.value, "yyyy-MM-dd");
          params.end_date = format$4(endDate, "yyyy-MM-dd");
        } else if (viewMode.value === "agenda") {
          const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          params.start_date = today;
        } else {
          if (dateRange.value === "today") {
            const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
            params.start_date = today;
            params.end_date = today;
          } else if (dateRange.value === "week") {
            const weekStart = startOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 });
            const weekEnd = endOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 });
            params.start_date = format$4(weekStart, "yyyy-MM-dd");
            params.end_date = format$4(weekEnd, "yyyy-MM-dd");
          } else if (dateRange.value === "month") {
            const now = /* @__PURE__ */ new Date();
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            params.start_date = format$4(monthStart, "yyyy-MM-dd");
            params.end_date = format$4(monthEnd, "yyyy-MM-dd");
          } else if (dateRange.value === "upcoming") {
            const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
            params.start_date = today;
          } else if (dateRange.value === "custom") {
            if (customStartDate.value) params.start_date = customStartDate.value;
            if (customEndDate.value) params.end_date = customEndDate.value;
          }
        }
        params.include_shared = "true";
        const response = await $fetch(`${config.public.apiBase}/calendar/events`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          },
          params
        });
        if (response.success) {
          events.value = response.data;
        }
      } catch (err) {
        console.error("Error loading events:", err);
      }
    };
    const loadTasks = async () => {
      try {
        const params = {};
        if (viewMode.value === "day") {
          params.start_date = format$4(currentDay.value, "yyyy-MM-dd");
          params.end_date = format$4(currentDay.value, "yyyy-MM-dd");
        } else if (viewMode.value === "week") {
          const weekEnd = endOfWeek(currentWeekStart.value, { weekStartsOn: 1 });
          params.start_date = format$4(currentWeekStart.value, "yyyy-MM-dd");
          params.end_date = format$4(weekEnd, "yyyy-MM-dd");
        } else if (viewMode.value === "month") {
          const monthStart = startOfMonth(currentMonth.value);
          const monthEnd = endOfMonth(currentMonth.value);
          params.start_date = format$4(monthStart, "yyyy-MM-dd");
          params.end_date = format$4(monthEnd, "yyyy-MM-dd");
        } else if (viewMode.value === "4days") {
          const endDate = addDays(currentDay.value, 3);
          params.start_date = format$4(currentDay.value, "yyyy-MM-dd");
          params.end_date = format$4(endDate, "yyyy-MM-dd");
        } else if (viewMode.value === "agenda") {
          const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          params.start_date = today;
        } else {
          if (dateRange.value === "today") {
            const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
            params.start_date = today;
            params.end_date = today;
          } else if (dateRange.value === "week") {
            const weekStart = startOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 });
            const weekEnd = endOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 });
            params.start_date = format$4(weekStart, "yyyy-MM-dd");
            params.end_date = format$4(weekEnd, "yyyy-MM-dd");
          } else if (dateRange.value === "month") {
            const now = /* @__PURE__ */ new Date();
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            params.start_date = format$4(monthStart, "yyyy-MM-dd");
            params.end_date = format$4(monthEnd, "yyyy-MM-dd");
          } else if (dateRange.value === "upcoming") {
            const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
            params.start_date = today;
          } else if (dateRange.value === "custom") {
            if (customStartDate.value) params.start_date = customStartDate.value;
            if (customEndDate.value) params.end_date = customEndDate.value;
          }
        }
        params.include_shared = "true";
        const response = await $fetch(`${config.public.apiBase}/calendar/tasks`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          },
          params
        });
        if (response.success) {
          tasks.value = response.data;
        }
      } catch (err) {
        console.error("Error loading tasks:", err);
      }
    };
    const loadAppointments = async () => {
      try {
        const params = {};
        if (viewMode.value === "day") {
          params.start_date = format$4(currentDay.value, "yyyy-MM-dd");
          params.end_date = format$4(currentDay.value, "yyyy-MM-dd");
        } else if (viewMode.value === "week") {
          const weekEnd = endOfWeek(currentWeekStart.value, { weekStartsOn: 1 });
          params.start_date = format$4(currentWeekStart.value, "yyyy-MM-dd");
          params.end_date = format$4(weekEnd, "yyyy-MM-dd");
        } else if (viewMode.value === "month") {
          const monthStart = startOfMonth(currentMonth.value);
          const monthEnd = endOfMonth(currentMonth.value);
          params.start_date = format$4(monthStart, "yyyy-MM-dd");
          params.end_date = format$4(monthEnd, "yyyy-MM-dd");
        } else if (viewMode.value === "4days") {
          const endDate = addDays(currentDay.value, 3);
          params.start_date = format$4(currentDay.value, "yyyy-MM-dd");
          params.end_date = format$4(endDate, "yyyy-MM-dd");
        } else if (viewMode.value === "agenda") {
          const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          params.start_date = today;
        } else {
          if (dateRange.value === "today") {
            const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
            params.start_date = today;
            params.end_date = today;
          } else if (dateRange.value === "week") {
            const weekStart = startOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 });
            const weekEnd = endOfWeek(/* @__PURE__ */ new Date(), { weekStartsOn: 1 });
            params.start_date = format$4(weekStart, "yyyy-MM-dd");
            params.end_date = format$4(weekEnd, "yyyy-MM-dd");
          } else if (dateRange.value === "month") {
            const now = /* @__PURE__ */ new Date();
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            params.start_date = format$4(monthStart, "yyyy-MM-dd");
            params.end_date = format$4(monthEnd, "yyyy-MM-dd");
          } else if (dateRange.value === "upcoming") {
            const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
            params.start_date = today;
          } else if (dateRange.value === "custom") {
            if (customStartDate.value) params.start_date = customStartDate.value;
            if (customEndDate.value) params.end_date = customEndDate.value;
          }
        }
        const response = await $fetch(`${config.public.apiBase}/calendar/appointments`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          },
          params
        });
        if (response.success) {
          appointments.value = response.data;
        }
      } catch (err) {
        console.error("Error loading appointments:", err);
      }
    };
    const getSchedulesForDay = (date) => {
      return schedules.value.filter((schedule) => {
        const scheduleDate = parseISO(schedule.start_datetime);
        return isSameDay(scheduleDate, date);
      });
    };
    const getEventsForDay = (date) => {
      return events.value.filter((event) => {
        const eventDate = parseISO(event.start_datetime);
        return isSameDay(eventDate, date);
      });
    };
    const getTasksForDay = (date) => {
      return tasks.value.filter((task) => {
        if (task.due_date) {
          const taskDate = parseISO(task.due_date);
          return isSameDay(taskDate, date);
        } else if (task.start_date) {
          const taskDate = parseISO(task.start_date);
          return isSameDay(taskDate, date);
        }
        return false;
      });
    };
    const getAppointmentsForDay = (date) => {
      return appointments.value.filter((appointment) => {
        const appointmentDate = parseISO(appointment.start_datetime);
        return isSameDay(appointmentDate, date);
      });
    };
    const handleEventSaved = () => {
      loadEvents();
      showEventModal.value = false;
      selectedEvent.value = null;
    };
    const handleTaskSaved = () => {
      loadTasks();
      showTaskModal.value = false;
      selectedTask.value = null;
    };
    const handleAppointmentSaved = () => {
      loadAppointments();
      showAppointmentModal.value = false;
      selectedAppointment.value = null;
    };
    const isToday$1 = (date) => {
      return isToday(date);
    };
    const formatWeekRange = (weekStart) => {
      const weekEnd = endOfWeek(weekStart, { weekStartsOn: 1 });
      return `${format$4(weekStart, "dd MMM yyyy", { locale: th })} - ${format$4(weekEnd, "dd MMM yyyy", { locale: th })}`;
    };
    const formatDay = (date) => {
      return format$4(date, "d", { locale: th });
    };
    const formatDateTime = (dateTime) => {
      return format$4(parseISO(dateTime), "dd MMM yyyy", { locale: th });
    };
    const formatTime = (dateTime) => {
      return format$4(parseISO(dateTime), "HH:mm", { locale: th });
    };
    const formatTimeRange = (start, end) => {
      return `${format$4(parseISO(start), "HH:mm")} - ${format$4(parseISO(end), "HH:mm")}`;
    };
    const getStatusName = (status) => {
      const statusNames = {
        scheduled: "",
        ongoing: "",
        completed: "",
        cancelled: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        scheduled: "bg-blue-100 text-blue-800",
        ongoing: "bg-orange-100 text-orange-800",
        completed: "bg-green-100 text-green-800",
        cancelled: "bg-gray-100 text-gray-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getSessionTypeName = (type) => {
      const typeNames = {
        live: "Live",
        vod: "VOD"
      };
      return typeNames[type] || type;
    };
    const getSessionTypeBadgeClass = (type) => {
      const classes = {
        live: "bg-red-100 text-red-800",
        vod: "bg-purple-100 text-purple-800"
      };
      return classes[type] || "bg-gray-100 text-gray-800";
    };
    const getScheduleCardClass = (schedule) => {
      if (schedule.status === "completed") return "bg-green-100 text-green-800 border border-green-200";
      if (schedule.status === "ongoing") return "bg-orange-100 text-orange-800 border border-orange-200";
      if (schedule.status === "cancelled") return "bg-gray-100 text-gray-600 border border-gray-200";
      return "bg-blue-100 text-blue-800 border border-blue-200";
    };
    const getScheduleBorderClass = (status) => {
      if (status === "completed") return "border-green-500 bg-green-50";
      if (status === "ongoing") return "border-orange-500 bg-orange-50";
      if (status === "cancelled") return "border-gray-400 bg-gray-50";
      return "border-blue-500 bg-blue-50";
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_EventModal = __nuxt_component_0$6;
      const _component_TaskModal = __nuxt_component_1$1;
      const _component_AppointmentModal = __nuxt_component_2;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div><h1 class="text-3xl font-bold"></h1><p class="text-gray-600 mt-1"></p></div><div class="flex items-center space-x-4"><div class="relative"><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>`);
      if (unref(showCreateMenu)) {
        _push(`<div class="absolute left-0 mt-2 w-48 bg-gray-800 rounded-lg shadow-lg border border-gray-700 py-1 z-50"><button class="w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><span></span></button><button class="w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path></svg><span></span></button><button class="w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span></span></button></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div class="relative"><button class="px-4 py-2 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 flex items-center space-x-2 text-gray-700"><span>${ssrInterpolate(unref(currentViewLabel))}</span><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>`);
      if (unref(showViewMenu)) {
        _push(`<div class="absolute right-0 mt-2 w-48 bg-gray-800 rounded-lg shadow-lg z-50"><div class="py-1"><!--[-->`);
        ssrRenderList(viewModes, (view) => {
          _push(`<button class="${ssrRenderClass([{ "bg-gray-700": unref(viewMode) === view.value }, "w-full px-4 py-2 text-left text-white hover:bg-gray-700 flex items-center justify-between"])}"><span>${ssrInterpolate(view.label)}</span><span class="text-gray-400 text-sm">${ssrInterpolate(view.shortcut)}</span></button>`);
        });
        _push(`<!--]--></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (unref(isCalendarView)) {
        _push(`<div class="flex items-center space-x-2"><button class="p-2 border border-gray-300 rounded-lg hover:bg-gray-50"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg></button><button class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 text-sm">  </button><button class="p-2 border border-gray-300 rounded-lg hover:bg-gray-50"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(isCalendarView)) {
        _push(`<div class="text-lg font-semibold text-gray-700">${ssrInterpolate(unref(currentPeriodLabel))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div><div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6"><div class="bg-white rounded-lg shadow p-4"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold text-gray-900">${ssrInterpolate(unref(todayCount))}</p></div><div class="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-4"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold text-gray-900">${ssrInterpolate(unref(weekCount))}</p></div><div class="w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-4"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold text-orange-600">${ssrInterpolate(unref(ongoingCount))}</p></div><div class="w-12 h-12 bg-orange-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div><div class="bg-white rounded-lg shadow p-4"><div class="flex items-center justify-between"><div><p class="text-sm text-gray-600"></p><p class="text-2xl font-bold text-green-600">${ssrInterpolate(unref(completedCount))}</p></div><div class="w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center"><svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></div></div></div></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-4 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="today"${ssrIncludeBooleanAttr(Array.isArray(unref(dateRange)) ? ssrLooseContain(unref(dateRange), "today") : ssrLooseEqual(unref(dateRange), "today")) ? " selected" : ""}></option><option value="week"${ssrIncludeBooleanAttr(Array.isArray(unref(dateRange)) ? ssrLooseContain(unref(dateRange), "week") : ssrLooseEqual(unref(dateRange), "week")) ? " selected" : ""}></option><option value="month"${ssrIncludeBooleanAttr(Array.isArray(unref(dateRange)) ? ssrLooseContain(unref(dateRange), "month") : ssrLooseEqual(unref(dateRange), "month")) ? " selected" : ""}></option><option value="upcoming"${ssrIncludeBooleanAttr(Array.isArray(unref(dateRange)) ? ssrLooseContain(unref(dateRange), "upcoming") : ssrLooseEqual(unref(dateRange), "upcoming")) ? " selected" : ""}></option><option value="all"${ssrIncludeBooleanAttr(Array.isArray(unref(dateRange)) ? ssrLooseContain(unref(dateRange), "all") : ssrLooseEqual(unref(dateRange), "all")) ? " selected" : ""}></option><option value="custom"${ssrIncludeBooleanAttr(Array.isArray(unref(dateRange)) ? ssrLooseContain(unref(dateRange), "custom") : ssrLooseEqual(unref(dateRange), "custom")) ? " selected" : ""}></option></select></div>`);
      if (unref(dateRange) === "custom") {
        _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(customStartDate))} type="date" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(dateRange) === "custom") {
        _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(customEndDate))} type="date" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="scheduled"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "scheduled") : ssrLooseEqual(unref(filters).status, "scheduled")) ? " selected" : ""}></option><option value="ongoing"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "ongoing") : ssrLooseEqual(unref(filters).status, "ongoing")) ? " selected" : ""}></option><option value="completed"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "completed") : ssrLooseEqual(unref(filters).status, "completed")) ? " selected" : ""}></option><option value="cancelled"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "cancelled") : ssrLooseEqual(unref(filters).status, "cancelled")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).courseId) ? ssrLooseContain(unref(filters).courseId, "") : ssrLooseEqual(unref(filters).courseId, "")) ? " selected" : ""}></option><!--[-->`);
      ssrRenderList(unref(courses), (course) => {
        _push(`<option${ssrRenderAttr("value", course.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(filters).courseId) ? ssrLooseContain(unref(filters).courseId, course.id) : ssrLooseEqual(unref(filters).courseId, course.id)) ? " selected" : ""}>${ssrInterpolate(course.title)}</option>`);
      });
      _push(`<!--]--></select></div></div></div>`);
      if (unref(viewMode) === "day") {
        _push(`<div class="bg-white rounded-lg shadow p-6">`);
        if (unref(loading)) {
          _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
        } else if (unref(error)) {
          _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<div><div class="space-y-4"><!--[-->`);
          ssrRenderList(getEventsForDay(unref(currentDay)), (event) => {
            _push(`<div class="border-l-4 p-4 rounded-r-lg cursor-pointer hover:shadow-md transition-shadow" style="${ssrRenderStyle({ borderColor: event.color })}"><div class="flex items-start justify-between"><div class="flex-1"><div class="flex items-center space-x-2 mb-2"><span class="text-lg font-semibold text-gray-900">${ssrInterpolate(event.title)}</span><span class="px-2 py-1 text-xs font-medium rounded bg-gray-100 text-gray-700"> Event </span>`);
            if (event.is_shared) {
              _push(`<span class="px-2 py-1 text-xs font-medium rounded bg-blue-100 text-blue-700">  </span>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div><div class="text-sm text-gray-600 mb-2">`);
            if (event.location) {
              _push(`<div>: ${ssrInterpolate(event.location)}</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`<div>: ${ssrInterpolate(formatTimeRange(event.start_datetime, event.end_datetime))}</div>`);
            if (event.description) {
              _push(`<div class="mt-1 text-gray-500">${ssrInterpolate(event.description)}</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></div></div></div>`);
          });
          _push(`<!--]--><!--[-->`);
          ssrRenderList(getTasksForDay(unref(currentDay)), (task) => {
            _push(`<div class="border-l-4 p-4 rounded-r-lg cursor-pointer hover:shadow-md transition-shadow" style="${ssrRenderStyle({ borderColor: task.color })}"><div class="flex items-start justify-between"><div class="flex-1"><div class="flex items-center space-x-2 mb-2"><svg class="${ssrRenderClass([task.status === "completed" ? "text-green-600" : "text-gray-400", "w-5 h-5"])}" fill="none" stroke="currentColor" viewBox="0 0 24 24">`);
            if (task.status === "completed") {
              _push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>`);
            } else {
              _push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>`);
            }
            _push(`</svg><span class="${ssrRenderClass([task.status === "completed" ? "line-through opacity-60" : "", "text-lg font-semibold text-gray-900"])}">${ssrInterpolate(task.title)}</span><span class="px-2 py-1 text-xs font-medium rounded bg-green-100 text-green-700">  </span>`);
            if (task.status === "completed") {
              _push(`<span class="px-2 py-1 text-xs font-medium rounded bg-gray-100 text-gray-700">  </span>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div><div class="text-sm text-gray-600 mb-2">`);
            if (task.due_date) {
              _push(`<div>: ${ssrInterpolate(formatDateTime(task.due_date))}</div>`);
            } else {
              _push(`<!---->`);
            }
            if (task.priority) {
              _push(`<div class="capitalize">: ${ssrInterpolate(task.priority)}</div>`);
            } else {
              _push(`<!---->`);
            }
            if (task.description) {
              _push(`<div class="mt-1 text-gray-500">${ssrInterpolate(task.description)}</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></div></div></div>`);
          });
          _push(`<!--]--><!--[-->`);
          ssrRenderList(getAppointmentsForDay(unref(currentDay)), (appointment) => {
            _push(`<div class="border-l-4 p-4 rounded-r-lg cursor-pointer hover:shadow-md transition-shadow" style="${ssrRenderStyle({ borderColor: appointment.color })}"><div class="flex items-start justify-between"><div class="flex-1"><div class="flex items-center space-x-2 mb-2"><span class="text-lg font-semibold text-gray-900">${ssrInterpolate(appointment.title)}</span><span class="px-2 py-1 text-xs font-medium rounded bg-blue-100 text-blue-700">  </span>`);
            if (appointment.status === "confirmed") {
              _push(`<span class="px-2 py-1 text-xs font-medium rounded bg-green-100 text-green-700">  </span>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div><div class="text-sm text-gray-600 mb-2">`);
            if (appointment.location) {
              _push(`<div>: ${ssrInterpolate(appointment.location)}</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`<div>: ${ssrInterpolate(formatTimeRange(appointment.start_datetime, appointment.end_datetime))}</div>`);
            if (appointment.participants && appointment.participants.length > 0) {
              _push(`<div> : ${ssrInterpolate(appointment.participants.length)}  </div>`);
            } else {
              _push(`<!---->`);
            }
            if (appointment.description) {
              _push(`<div class="mt-1 text-gray-500">${ssrInterpolate(appointment.description)}</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></div></div></div>`);
          });
          _push(`<!--]--><!--[-->`);
          ssrRenderList(getSchedulesForDay(unref(currentDay)), (schedule) => {
            _push(`<div class="${ssrRenderClass([getScheduleBorderClass(schedule.status), "border-l-4 p-4 rounded-r-lg"])}"><div class="flex items-start justify-between"><div class="flex-1"><div class="flex items-center space-x-2 mb-2"><span class="text-lg font-semibold text-gray-900">${ssrInterpolate(schedule.course.title)}</span><span class="${ssrRenderClass([getStatusBadgeClass(schedule.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusName(schedule.status))}</span><span class="${ssrRenderClass([getSessionTypeBadgeClass(schedule.session_type), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getSessionTypeName(schedule.session_type))}</span></div><div class="text-sm text-gray-600 mb-2"><div>: ${ssrInterpolate(schedule.branch.name)}</div><div>: ${ssrInterpolate(formatTimeRange(schedule.start_datetime, schedule.end_datetime))}</div></div></div><div class="flex items-center space-x-2">`);
            if (schedule.session_type === "live" && schedule.meeting_link) {
              _push(`<a${ssrRenderAttr("href", schedule.meeting_link)} target="_blank" rel="noopener noreferrer" class="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm">  </a>`);
            } else if (schedule.session_type === "vod" && schedule.video_url) {
              _push(`<a${ssrRenderAttr("href", schedule.video_url)} target="_blank" rel="noopener noreferrer" class="px-3 py-1 bg-purple-600 text-white rounded hover:bg-purple-700 text-sm">  </a>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></div></div>`);
          });
          _push(`<!--]-->`);
          if (getSchedulesForDay(unref(currentDay)).length === 0 && getEventsForDay(unref(currentDay)).length === 0 && getTasksForDay(unref(currentDay)).length === 0 && getAppointmentsForDay(unref(currentDay)).length === 0) {
            _push(`<div class="text-center py-12 text-gray-500">  </div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div>`);
        }
        _push(`</div>`);
      } else if (unref(viewMode) === "week") {
        _push(`<div class="bg-white rounded-lg shadow p-6">`);
        if (unref(loading)) {
          _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
        } else if (unref(error)) {
          _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<div><div class="grid grid-cols-7 gap-2"><!--[-->`);
          ssrRenderList(unref(weekDays), (day) => {
            _push(`<div class="text-center font-semibold text-gray-700 py-2 border-b"><div class="text-sm">${ssrInterpolate(day.label)}</div></div>`);
          });
          _push(`<!--]--><!--[-->`);
          ssrRenderList(unref(weekDays), (day) => {
            _push(`<div class="${ssrRenderClass([{
              "bg-blue-50": isToday$1(day.date),
              "bg-gray-50": day.date < new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0))
            }, "min-h-32 border border-gray-200 rounded-lg p-2 relative group"])}"><div class="flex items-center justify-between mb-2"><div class="text-xs font-medium text-gray-600">${ssrInterpolate(formatDay(day.date))}</div><div class="relative"><button class="opacity-0 group-hover:opacity-100 p-1 rounded hover:bg-gray-200 transition-opacity"${ssrRenderAttr("title", `${unref(format$4)(day.date, " dd MMM yyyy", { locale: unref(th) })}`)}><svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"></path></svg></button>`);
            if (unref(showDateMenu)[day.key]) {
              _push(`<div class="absolute right-0 mt-1 w-48 bg-gray-800 rounded-lg shadow-lg border border-gray-700 py-1 z-50"><button class="w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><span></span></button><button class="w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path></svg><span></span></button><button class="w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span></span></button></div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></div><div class="space-y-1"><!--[-->`);
            ssrRenderList(getEventsForDay(day.date), (event) => {
              _push(`<div class="text-xs p-1 rounded cursor-pointer truncate" style="${ssrRenderStyle({ backgroundColor: event.color + "20", borderLeft: `3px solid ${event.color}` })}"><div class="font-medium truncate text-gray-900">${ssrInterpolate(event.title)}</div><div class="text-xs opacity-75 text-gray-600">${ssrInterpolate(formatTime(event.start_datetime))}</div></div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getTasksForDay(day.date), (task) => {
              _push(`<div class="text-xs p-1 rounded cursor-pointer truncate flex items-center space-x-1" style="${ssrRenderStyle({ backgroundColor: task.color + "20", borderLeft: `2px solid ${task.color}` })}"><svg class="${ssrRenderClass([task.status === "completed" ? "text-green-600" : "text-gray-400", "w-3 h-3 flex-shrink-0"])}" fill="none" stroke="currentColor" viewBox="0 0 24 24">`);
              if (task.status === "completed") {
                _push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>`);
              } else {
                _push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>`);
              }
              _push(`</svg><div class="${ssrRenderClass([task.status === "completed" ? "line-through opacity-60" : "", "font-medium truncate text-gray-900"])}">${ssrInterpolate(task.title)}</div></div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getAppointmentsForDay(day.date), (appointment) => {
              _push(`<div class="text-xs p-1 rounded cursor-pointer truncate" style="${ssrRenderStyle({ backgroundColor: appointment.color + "20", borderLeft: `3px solid ${appointment.color}` })}"><div class="font-medium truncate text-gray-900">${ssrInterpolate(appointment.title)}</div><div class="text-xs opacity-75 text-gray-600">${ssrInterpolate(formatTime(appointment.start_datetime))}</div></div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getSchedulesForDay(day.date), (schedule) => {
              _push(`<div class="${ssrRenderClass([getScheduleCardClass(schedule), "text-xs p-1 rounded cursor-pointer"])}"><div class="font-medium truncate">${ssrInterpolate(schedule.course.title)}</div><div class="text-xs opacity-75">${ssrInterpolate(formatTime(schedule.start_datetime))}</div></div>`);
            });
            _push(`<!--]--></div></div>`);
          });
          _push(`<!--]--></div></div>`);
        }
        _push(`</div>`);
      } else if (unref(viewMode) === "month") {
        _push(`<div class="bg-white rounded-lg shadow p-6">`);
        if (unref(loading)) {
          _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
        } else if (unref(error)) {
          _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<div><div class="grid grid-cols-7 gap-1 mb-2"><!--[-->`);
          ssrRenderList(unref(weekDays), (day) => {
            _push(`<div class="text-center font-semibold text-gray-700 py-2"><div class="text-sm">${ssrInterpolate(day.label)}</div></div>`);
          });
          _push(`<!--]--></div><div class="grid grid-cols-7 gap-1"><!--[-->`);
          ssrRenderList(unref(monthDays), (day) => {
            _push(`<div class="${ssrRenderClass([{
              "bg-blue-50": isToday$1(day.date),
              "bg-gray-50": !unref(isSameMonth)(day.date, unref(currentMonth))
            }, "min-h-24 border border-gray-200 rounded p-1"])}"><div class="text-xs font-medium text-gray-600 mb-1">${ssrInterpolate(formatDay(day.date))}</div><div class="space-y-0.5"><!--[-->`);
            ssrRenderList(getEventsForDay(day.date), (event) => {
              _push(`<div class="text-xs p-0.5 rounded truncate cursor-pointer" style="${ssrRenderStyle({ backgroundColor: event.color + "20", borderLeft: `2px solid ${event.color}` })}"${ssrRenderAttr("title", event.title)}>${ssrInterpolate(formatTime(event.start_datetime))} ${ssrInterpolate(event.title)}</div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getTasksForDay(day.date), (task) => {
              _push(`<div class="text-xs p-0.5 rounded truncate cursor-pointer flex items-center space-x-1" style="${ssrRenderStyle({ backgroundColor: task.color + "20", borderLeft: `2px solid ${task.color}` })}"${ssrRenderAttr("title", task.title)}><span class="${ssrRenderClass(task.status === "completed" ? "line-through opacity-60" : "")}">${ssrInterpolate(task.title)}</span></div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getAppointmentsForDay(day.date), (appointment) => {
              _push(`<div class="text-xs p-0.5 rounded truncate cursor-pointer" style="${ssrRenderStyle({ backgroundColor: appointment.color + "20", borderLeft: `2px solid ${appointment.color}` })}"${ssrRenderAttr("title", appointment.title)}>${ssrInterpolate(formatTime(appointment.start_datetime))} ${ssrInterpolate(appointment.title)}</div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getSchedulesForDay(day.date), (schedule) => {
              _push(`<div class="${ssrRenderClass([getScheduleCardClass(schedule), "text-xs p-1 rounded truncate cursor-pointer"])}"${ssrRenderAttr("title", schedule.course.title)}>${ssrInterpolate(formatTime(schedule.start_datetime))} ${ssrInterpolate(schedule.course.title)}</div>`);
            });
            _push(`<!--]--></div></div>`);
          });
          _push(`<!--]--></div></div>`);
        }
        _push(`</div>`);
      } else if (unref(viewMode) === "4days") {
        _push(`<div class="bg-white rounded-lg shadow p-6">`);
        if (unref(loading)) {
          _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
        } else if (unref(error)) {
          _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<div><div class="grid grid-cols-4 gap-4"><!--[-->`);
          ssrRenderList(unref(fourDays), (day) => {
            _push(`<div class="${ssrRenderClass([{
              "bg-blue-50": isToday$1(day.date)
            }, "border border-gray-200 rounded-lg p-4"])}"><div class="font-semibold text-gray-700 mb-3"><div class="text-sm">${ssrInterpolate(day.label)}</div><div class="text-xs text-gray-500">${ssrInterpolate(formatDay(day.date))}</div></div><div class="space-y-2"><!--[-->`);
            ssrRenderList(getEventsForDay(day.date), (event) => {
              _push(`<div class="text-xs p-2 rounded cursor-pointer" style="${ssrRenderStyle({ backgroundColor: event.color + "20", borderLeft: `3px solid ${event.color}` })}"><div class="font-medium truncate text-gray-900">${ssrInterpolate(event.title)}</div><div class="text-xs opacity-75 text-gray-600">${ssrInterpolate(formatTimeRange(event.start_datetime, event.end_datetime))}</div></div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getTasksForDay(day.date), (task) => {
              _push(`<div class="text-xs p-2 rounded cursor-pointer flex items-center space-x-1" style="${ssrRenderStyle({ backgroundColor: task.color + "20", borderLeft: `3px solid ${task.color}` })}"><svg class="${ssrRenderClass([task.status === "completed" ? "text-green-600" : "text-gray-400", "w-3 h-3 flex-shrink-0"])}" fill="none" stroke="currentColor" viewBox="0 0 24 24">`);
              if (task.status === "completed") {
                _push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>`);
              } else {
                _push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>`);
              }
              _push(`</svg><div class="${ssrRenderClass([task.status === "completed" ? "line-through opacity-60" : "", "font-medium truncate text-gray-900"])}">${ssrInterpolate(task.title)}</div></div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getAppointmentsForDay(day.date), (appointment) => {
              _push(`<div class="text-xs p-2 rounded cursor-pointer" style="${ssrRenderStyle({ backgroundColor: appointment.color + "20", borderLeft: `3px solid ${appointment.color}` })}"><div class="font-medium truncate text-gray-900">${ssrInterpolate(appointment.title)}</div><div class="text-xs opacity-75 text-gray-600">${ssrInterpolate(formatTimeRange(appointment.start_datetime, appointment.end_datetime))}</div></div>`);
            });
            _push(`<!--]--><!--[-->`);
            ssrRenderList(getSchedulesForDay(day.date), (schedule) => {
              _push(`<div class="${ssrRenderClass([getScheduleCardClass(schedule), "text-xs p-2 rounded cursor-pointer"])}"><div class="font-medium truncate">${ssrInterpolate(schedule.course.title)}</div><div class="text-xs opacity-75">${ssrInterpolate(formatTimeRange(schedule.start_datetime, schedule.end_datetime))}</div></div>`);
            });
            _push(`<!--]-->`);
            if (getSchedulesForDay(day.date).length === 0 && getEventsForDay(day.date).length === 0 && getTasksForDay(day.date).length === 0 && getAppointmentsForDay(day.date).length === 0) {
              _push(`<div class="text-xs text-gray-400 text-center py-4">  </div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div></div>`);
          });
          _push(`<!--]--></div></div>`);
        }
        _push(`</div>`);
      } else if (unref(viewMode) === "agenda") {
        _push(`<div class="bg-white rounded-lg shadow overflow-hidden">`);
        if (unref(loading)) {
          _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
        } else if (unref(error)) {
          _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded m-4">${ssrInterpolate(unref(error))}</div>`);
        } else if (unref(schedules).length === 0 && unref(events).length === 0 && unref(tasks).length === 0 && unref(appointments).length === 0) {
          _push(`<div class="p-8 text-center text-gray-500"><svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><p class="mt-4 text-lg font-medium"></p><p class="mt-1 text-sm">, ,  </p></div>`);
        } else {
          _push(`<div class="space-y-4">`);
          if (unref(events).length > 0) {
            _push(`<div><h3 class="px-6 py-3 text-lg font-semibold text-gray-900 border-b">Events</h3><div class="divide-y divide-gray-200"><!--[-->`);
            ssrRenderList(unref(events), (event) => {
              _push(`<div class="px-6 py-4 hover:bg-gray-50 cursor-pointer"><div class="flex items-center justify-between"><div class="flex-1"><div class="flex items-center space-x-2"><div class="w-4 h-4 rounded" style="${ssrRenderStyle({ backgroundColor: event.color })}"></div><div class="text-sm font-medium text-gray-900">${ssrInterpolate(event.title)}</div>`);
              if (event.is_shared) {
                _push(`<span class="px-2 py-1 text-xs font-medium rounded bg-blue-100 text-blue-700">  </span>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</div><div class="mt-1 text-sm text-gray-500">${ssrInterpolate(formatDateTime(event.start_datetime))} `);
              if (event.location) {
                _push(`<span class="ml-2"> ${ssrInterpolate(event.location)}</span>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</div>`);
              if (event.description) {
                _push(`<div class="mt-1 text-sm text-gray-600">${ssrInterpolate(event.description)}</div>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</div></div></div>`);
            });
            _push(`<!--]--></div></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(tasks).length > 0) {
            _push(`<div><h3 class="px-6 py-3 text-lg font-semibold text-gray-900 border-b"></h3><div class="divide-y divide-gray-200"><!--[-->`);
            ssrRenderList(unref(tasks), (task) => {
              _push(`<div class="px-6 py-4 hover:bg-gray-50 cursor-pointer"><div class="flex items-center justify-between"><div class="flex-1"><div class="flex items-center space-x-2"><svg class="${ssrRenderClass([task.status === "completed" ? "text-green-600" : "text-gray-400", "w-4 h-4"])}" fill="none" stroke="currentColor" viewBox="0 0 24 24">`);
              if (task.status === "completed") {
                _push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>`);
              } else {
                _push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>`);
              }
              _push(`</svg><div class="${ssrRenderClass([task.status === "completed" ? "line-through opacity-60" : "", "text-sm font-medium text-gray-900"])}">${ssrInterpolate(task.title)}</div></div><div class="mt-1 text-sm text-gray-500">`);
              if (task.due_date) {
                _push(`<span>${ssrInterpolate(formatDateTime(task.due_date))}</span>`);
              } else {
                _push(`<!---->`);
              }
              if (task.priority) {
                _push(`<span class="ml-2 capitalize"> ${ssrInterpolate(task.priority)}</span>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</div>`);
              if (task.description) {
                _push(`<div class="mt-1 text-sm text-gray-600">${ssrInterpolate(task.description)}</div>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</div></div></div>`);
            });
            _push(`<!--]--></div></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(appointments).length > 0) {
            _push(`<div><h3 class="px-6 py-3 text-lg font-semibold text-gray-900 border-b"></h3><div class="divide-y divide-gray-200"><!--[-->`);
            ssrRenderList(unref(appointments), (appointment) => {
              _push(`<div class="px-6 py-4 hover:bg-gray-50 cursor-pointer"><div class="flex items-center justify-between"><div class="flex-1"><div class="flex items-center space-x-2"><div class="w-4 h-4 rounded" style="${ssrRenderStyle({ backgroundColor: appointment.color })}"></div><div class="text-sm font-medium text-gray-900">${ssrInterpolate(appointment.title)}</div>`);
              if (appointment.status === "confirmed") {
                _push(`<span class="px-2 py-1 text-xs font-medium rounded bg-green-100 text-green-700">  </span>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</div><div class="mt-1 text-sm text-gray-500">${ssrInterpolate(formatDateTime(appointment.start_datetime))} `);
              if (appointment.location) {
                _push(`<span class="ml-2"> ${ssrInterpolate(appointment.location)}</span>`);
              } else {
                _push(`<!---->`);
              }
              if (appointment.participants && appointment.participants.length > 0) {
                _push(`<span class="ml-2"> ${ssrInterpolate(appointment.participants.length)} </span>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</div>`);
              if (appointment.description) {
                _push(`<div class="mt-1 text-sm text-gray-600">${ssrInterpolate(appointment.description)}</div>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</div></div></div>`);
            });
            _push(`<!--]--></div></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(schedules).length > 0) {
            _push(`<div><h3 class="px-6 py-3 text-lg font-semibold text-gray-900 border-b"></h3><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
            ssrRenderList(unref(schedules), (schedule) => {
              _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(formatDateTime(schedule.start_datetime))}</div><div class="text-xs text-gray-500">${ssrInterpolate(formatTimeRange(schedule.start_datetime, schedule.end_datetime))}</div></td><td class="px-6 py-4"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(schedule.course.title)}</div>`);
              if (schedule.course.code) {
                _push(`<div class="text-xs text-gray-500">${ssrInterpolate(schedule.course.code)}</div>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(schedule.branch.name)}</div>`);
              if (schedule.branch.code) {
                _push(`<div class="text-xs text-gray-500">${ssrInterpolate(schedule.branch.code)}</div>`);
              } else {
                _push(`<!---->`);
              }
              _push(`</td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getSessionTypeBadgeClass(schedule.session_type), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getSessionTypeName(schedule.session_type))}</span></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(schedule.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusName(schedule.status))}</span></td><td class="px-6 py-4 whitespace-nowrap">`);
              if (schedule.session_type === "live" && schedule.meeting_link) {
                _push(`<div class="flex items-center space-x-2"><a${ssrRenderAttr("href", schedule.meeting_link)} target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:text-blue-800 text-sm flex items-center"><svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg>  </a></div>`);
              } else if (schedule.session_type === "vod" && schedule.video_url) {
                _push(`<div class="flex items-center space-x-2"><a${ssrRenderAttr("href", schedule.video_url)} target="_blank" rel="noopener noreferrer" class="text-purple-600 hover:text-purple-800 text-sm flex items-center"><svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>  </a></div>`);
              } else {
                _push(`<span class="text-xs text-gray-400">-</span>`);
              }
              _push(`</td></tr>`);
            });
            _push(`<!--]--></tbody></table></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div>`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(ssrRenderComponent(_component_EventModal, {
        show: unref(showEventModal),
        event: unref(selectedEvent),
        "initial-date": unref(selectedDateForCreate),
        onClose: ($event) => {
          showEventModal.value = false;
          selectedEvent.value = null;
          selectedDateForCreate.value = null;
        },
        onSaved: handleEventSaved
      }, null, _parent));
      _push(ssrRenderComponent(_component_TaskModal, {
        show: unref(showTaskModal),
        task: unref(selectedTask),
        "initial-date": unref(selectedDateForCreate),
        onClose: ($event) => {
          showTaskModal.value = false;
          selectedTask.value = null;
          selectedDateForCreate.value = null;
        },
        onSaved: handleTaskSaved
      }, null, _parent));
      _push(ssrRenderComponent(_component_AppointmentModal, {
        show: unref(showAppointmentModal),
        appointment: unref(selectedAppointment),
        "initial-date": unref(selectedDateForCreate),
        onClose: ($event) => {
          showAppointmentModal.value = false;
          selectedAppointment.value = null;
          selectedDateForCreate.value = null;
        },
        onSaved: handleAppointmentSaved
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$y = _sfc_main$y.setup;
_sfc_main$y.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/tutor/schedule/index.vue");
  return _sfc_setup$y ? _sfc_setup$y(props, ctx) : void 0;
};

const indexXfjEsN76 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$y
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    useAuth();
    const students = ref([]);
    const loading = ref(false);
    const error = ref("");
    const selectedStudent = ref(null);
    const studentDetail = ref(null);
    const loadingDetail = ref(false);
    const filters = reactive({
      search: "",
      status: ""
    });
    const pagination = reactive({
      page: 1,
      limit: 20,
      total: 0,
      totalPages: 0
    });
    const getStatusDisplayName = (status) => {
      const statusNames = {
        active: "",
        inactive: "",
        suspended: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        active: "bg-green-100 text-green-800",
        inactive: "bg-gray-100 text-gray-800",
        suspended: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getRelationshipName = (relationship) => {
      const relationshipNames = {
        father: "",
        mother: "",
        guardian: ""
      };
      return relationshipNames[relationship] || relationship;
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=" username, email, " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "active") : ssrLooseEqual(unref(filters).status, "active")) ? " selected" : ""}></option><option value="inactive"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "inactive") : ssrLooseEqual(unref(filters).status, "inactive")) ? " selected" : ""}></option><option value="suspended"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "suspended") : ssrLooseEqual(unref(filters).status, "suspended")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(students).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(students), (student) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div><div class="text-sm font-medium text-gray-900">${ssrInterpolate(student.first_name)} ${ssrInterpolate(student.last_name)}</div><div class="text-sm text-gray-500">${ssrInterpolate(student.username)}</div>`);
          if (student.email) {
            _push(`<div class="text-xs text-gray-400">${ssrInterpolate(student.email)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4">`);
          if (student.parents && student.parents.length > 0) {
            _push(`<div class="space-y-1"><!--[-->`);
            ssrRenderList(student.parents, (parent) => {
              _push(`<div class="text-sm"><span class="font-medium text-gray-900">${ssrInterpolate(parent.name)}</span><span class="text-gray-500 ml-2">(${ssrInterpolate(getRelationshipName(parent.relationship))})</span></div>`);
            });
            _push(`<!--]--></div>`);
          } else {
            _push(`<div class="text-sm text-gray-400"></div>`);
          }
          _push(`</td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(student.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusDisplayName(student.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(student.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2">`);
          _push(ssrRenderComponent(_component_NuxtLink, {
            to: `/admin/tutor/students/${student.id}`,
            class: "text-blue-600 hover:text-blue-900",
            title: ""
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"${_scopeId}></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"${_scopeId}></path></svg>`);
              } else {
                return [
                  (openBlock(), createBlock("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                    }),
                    createVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                    })
                  ]))
                ];
              }
            }),
            _: 2
          }, _parent));
          _push(`</div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      if (unref(pagination).totalPages > 1) {
        _push(`<div class="bg-gray-50 px-4 py-3 flex items-center justify-between border-t border-gray-200"><div class="text-sm text-gray-700">  ${ssrInterpolate((unref(pagination).page - 1) * unref(pagination).limit + 1)}  ${ssrInterpolate(Math.min(unref(pagination).page * unref(pagination).limit, unref(pagination).total))}  ${ssrInterpolate(unref(pagination).total)}  </div><div class="flex space-x-2"><button${ssrIncludeBooleanAttr(unref(pagination).page === 1) ? " disabled" : ""} class="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100">  </button><button${ssrIncludeBooleanAttr(unref(pagination).page >= unref(pagination).totalPages) ? " disabled" : ""} class="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-100">  </button></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (unref(selectedStudent)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold"></h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div>`);
        if (unref(loadingDetail)) {
          _push(`<div class="text-center py-8"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
        } else if (unref(studentDetail)) {
          _push(`<div class="space-y-6"><div class="bg-gray-50 rounded-lg p-4"><h3 class="text-lg font-semibold mb-4"></h3><div class="grid grid-cols-2 gap-4"><div><label class="text-sm font-medium text-gray-500">-</label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.first_name)} ${ssrInterpolate(unref(studentDetail).student.last_name)}</p></div><div><label class="text-sm font-medium text-gray-500">Username</label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.username)}</p></div><div><label class="text-sm font-medium text-gray-500">Email</label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.email || "-")}</p></div><div><label class="text-sm font-medium text-gray-500"></label><p class="text-gray-900">${ssrInterpolate(unref(studentDetail).student.phone || "-")}</p></div><div><label class="text-sm font-medium text-gray-500"></label><span class="${ssrRenderClass([getStatusBadgeClass(unref(studentDetail).student.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusDisplayName(unref(studentDetail).student.status))}</span></div></div></div><div class="bg-gray-50 rounded-lg p-4"><h3 class="text-lg font-semibold mb-4"></h3>`);
          if (unref(studentDetail).parents && unref(studentDetail).parents.length > 0) {
            _push(`<div class="space-y-3"><!--[-->`);
            ssrRenderList(unref(studentDetail).parents, (parent) => {
              _push(`<div class="bg-white rounded-lg p-4 border border-gray-200"><div class="grid grid-cols-2 gap-4"><div><label class="text-sm font-medium text-gray-500">-</label><p class="text-gray-900">${ssrInterpolate(parent.first_name)} ${ssrInterpolate(parent.last_name)}</p></div><div><label class="text-sm font-medium text-gray-500"></label><p class="text-gray-900">${ssrInterpolate(getRelationshipName(parent.relationship))}</p></div><div><label class="text-sm font-medium text-gray-500">Email</label><p class="text-gray-900">${ssrInterpolate(parent.email || "-")}</p></div><div><label class="text-sm font-medium text-gray-500"></label><p class="text-gray-900">${ssrInterpolate(parent.phone || "-")}</p></div></div></div>`);
            });
            _push(`<!--]--></div>`);
          } else {
            _push(`<div class="text-gray-500 text-center py-4">  </div>`);
          }
          _push(`</div><div class="bg-gray-50 rounded-lg p-4"><h3 class="text-lg font-semibold mb-4"></h3>`);
          if (unref(studentDetail).enrollments && unref(studentDetail).enrollments.length > 0) {
            _push(`<div class="space-y-2"><!--[-->`);
            ssrRenderList(unref(studentDetail).enrollments, (enrollment) => {
              _push(`<div class="bg-white rounded-lg p-3 border border-gray-200"><div class="flex items-center justify-between"><div><p class="font-medium text-gray-900">${ssrInterpolate(enrollment.course.title)}</p><p class="text-sm text-gray-500">${ssrInterpolate(enrollment.branch.name)} - ${ssrInterpolate(enrollment.course.code)}</p></div><div class="text-right"><span class="${ssrRenderClass([enrollment.status === "active" ? "bg-green-100 text-green-800" : "bg-gray-100 text-gray-800", "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(enrollment.status === "active" ? "" : enrollment.status)}</span><p class="text-xs text-gray-500 mt-1">${ssrInterpolate(formatDate(enrollment.enrolled_at))}</p></div></div></div>`);
            });
            _push(`<!--]--></div>`);
          } else {
            _push(`<div class="text-gray-500 text-center py-4">  </div>`);
          }
          _push(`</div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end mt-6"><button class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$x = _sfc_main$x.setup;
_sfc_main$x.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/tutor/students/index.vue");
  return _sfc_setup$x ? _sfc_setup$x(props, ctx) : void 0;
};

const indexCfAkTeA8 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$x
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "edit",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useRouter();
    useAuth();
    computed(() => parseInt(route.params.id));
    const loading = ref(true);
    const error = ref("");
    const submitting = ref(false);
    const submitError = ref("");
    const form = reactive({
      student_id: 0,
      course_id: 0,
      branch_id: 0,
      enrollment_type: "onsite",
      shipping_address_id: null,
      enrollment_date: "",
      status: "pending"
    });
    const availableStudents = ref([]);
    const availableCourses = ref([]);
    const availableBranches = ref([]);
    const loadingStudents = ref(false);
    const loadingCourses = ref(false);
    const loadingBranches = ref(false);
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4"><button class="p-2 hover:bg-gray-100 rounded-lg"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg></button><h1 class="text-3xl font-bold"></h1></div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else {
        _push(`<!--[-->`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<form class="bg-white rounded-lg shadow p-6 space-y-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required${ssrIncludeBooleanAttr(unref(loadingStudents)) ? " disabled" : ""} class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 disabled:bg-gray-100 disabled:cursor-not-allowed"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).student_id) ? ssrLooseContain(unref(form).student_id, "") : ssrLooseEqual(unref(form).student_id, "")) ? " selected" : ""}>${ssrInterpolate(unref(loadingStudents) ? "..." : "")}</option><!--[-->`);
        ssrRenderList(unref(availableStudents), (student) => {
          _push(`<option${ssrRenderAttr("value", student.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).student_id) ? ssrLooseContain(unref(form).student_id, student.id) : ssrLooseEqual(unref(form).student_id, student.id)) ? " selected" : ""}>${ssrInterpolate(student.first_name)} ${ssrInterpolate(student.last_name)} (@${ssrInterpolate(student.username)}) </option>`);
        });
        _push(`<!--]--></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required${ssrIncludeBooleanAttr(unref(loadingCourses)) ? " disabled" : ""} class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 disabled:bg-gray-100 disabled:cursor-not-allowed"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).course_id) ? ssrLooseContain(unref(form).course_id, "") : ssrLooseEqual(unref(form).course_id, "")) ? " selected" : ""}>${ssrInterpolate(unref(loadingCourses) ? "..." : "")}</option><!--[-->`);
        ssrRenderList(unref(availableCourses), (course) => {
          _push(`<option${ssrRenderAttr("value", course.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).course_id) ? ssrLooseContain(unref(form).course_id, course.id) : ssrLooseEqual(unref(form).course_id, course.id)) ? " selected" : ""}>${ssrInterpolate(course.title)}</option>`);
        });
        _push(`<!--]--></select></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><div class="flex gap-6"><label class="flex items-center cursor-pointer"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).enrollment_type, "onsite")) ? " checked" : ""} type="radio" value="onsite" class="mr-2 w-4 h-4 text-green-600 focus:ring-green-500"><span class="text-gray-700"> (Onsite)</span></label><label class="flex items-center cursor-pointer"><input${ssrIncludeBooleanAttr(ssrLooseEqual(unref(form).enrollment_type, "online")) ? " checked" : ""} type="radio" value="online" class="mr-2 w-4 h-4 text-green-600 focus:ring-green-500"><span class="text-gray-700"> (Online)</span></label></div></div>`);
        if (unref(form).enrollment_type === "onsite") {
          _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select${ssrIncludeBooleanAttr(unref(form).enrollment_type === "onsite") ? " required" : ""}${ssrIncludeBooleanAttr(!unref(form).course_id || unref(loadingBranches)) ? " disabled" : ""} class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 disabled:bg-gray-100 disabled:cursor-not-allowed bg-white text-gray-900"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(form).branch_id) ? ssrLooseContain(unref(form).branch_id, "") : ssrLooseEqual(unref(form).branch_id, "")) ? " selected" : ""}>${ssrInterpolate(unref(loadingBranches) ? "..." : "")}</option><!--[-->`);
          ssrRenderList(unref(availableBranches), (branch) => {
            _push(`<option${ssrRenderAttr("value", branch.id)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).branch_id) ? ssrLooseContain(unref(form).branch_id, branch.id) : ssrLooseEqual(unref(form).branch_id, branch.id)) ? " selected" : ""}>${ssrInterpolate(branch.name)}</option>`);
          });
          _push(`<!--]--></select></div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(form).enrollment_type === "online" && unref(form).student_id) {
          _push(`<div>`);
          _push(ssrRenderComponent(AddressSelect, {
            modelValue: unref(form).shipping_address_id,
            "onUpdate:modelValue": ($event) => unref(form).shipping_address_id = $event,
            "user-id": unref(form).student_id,
            required: unref(form).enrollment_type === "online",
            placeholder: "",
            hint: ""
          }, null, _parent));
          _push(`</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="pending"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "pending") : ssrLooseEqual(unref(form).status, "pending")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "active") : ssrLooseEqual(unref(form).status, "active")) ? " selected" : ""}></option><option value="completed"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "completed") : ssrLooseEqual(unref(form).status, "completed")) ? " selected" : ""}></option><option value="cancelled"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "cancelled") : ssrLooseEqual(unref(form).status, "cancelled")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).enrollment_date)} type="datetime-local" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-white text-gray-900" style="${ssrRenderStyle({ "color-scheme": "light" })}"></div></div>`);
        if (unref(submitError)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(submitError))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(submitting)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(submitting)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form><!--]-->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$w = _sfc_main$w.setup;
_sfc_main$w.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/enrollments/[id]/edit.vue");
  return _sfc_setup$w ? _sfc_setup$w(props, ctx) : void 0;
};

const editT7KjozcG = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$w
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "GeneralTab",
  __ssrInlineRender: true,
  props: {
    settings: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      app_name: "",
      app_version: "",
      logo_url: "",
      favicon_url: "",
      contact_email: "",
      contact_phone: "",
      address: ""
    });
    watch$1(() => props.settings, (newSettings) => {
      if (newSettings && newSettings.length > 0) {
        newSettings.forEach((setting) => {
          const key = setting.key;
          if (key in form) {
            form[key] = setting.value || "";
          }
        });
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><input${ssrRenderAttr("value", unref(form).app_name)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><input${ssrRenderAttr("value", unref(form).app_version)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required></div><div><label class="block text-sm font-medium text-gray-700 mb-1"> URL  </label><input${ssrRenderAttr("value", unref(form).logo_url)} type="url" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-1"> URL Favicon </label><input${ssrRenderAttr("value", unref(form).favicon_url)} type="url" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><input${ssrRenderAttr("value", unref(form).contact_email)} type="email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><input${ssrRenderAttr("value", unref(form).contact_phone)} type="tel" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).address)}</textarea></div><div class="flex justify-end pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center">`);
      if (unref(saving)) {
        _push(`<span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`  </button></div></form></div></div>`);
    };
  }
});
const _sfc_setup$v = _sfc_main$v.setup;
_sfc_main$v.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/components/GeneralTab.vue");
  return _sfc_setup$v ? _sfc_setup$v(props, ctx) : void 0;
};

const GeneralTabCHRudM28 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$v
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "TimezoneTab",
  __ssrInlineRender: true,
  props: {
    settings: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      timezone: "Asia/Bangkok",
      date_format: "DD/MM/YYYY",
      time_format: "24-hour"
    });
    watch$1(() => props.settings, (newSettings) => {
      if (newSettings && newSettings.length > 0) {
        newSettings.forEach((setting) => {
          const key = setting.key;
          if (key in form) {
            form[key] = setting.value || form[key];
          }
        });
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1"> Timezone </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><option value="Asia/Bangkok"${ssrIncludeBooleanAttr(Array.isArray(unref(form).timezone) ? ssrLooseContain(unref(form).timezone, "Asia/Bangkok") : ssrLooseEqual(unref(form).timezone, "Asia/Bangkok")) ? " selected" : ""}>Asia/Bangkok (+07:00)</option><option value="UTC"${ssrIncludeBooleanAttr(Array.isArray(unref(form).timezone) ? ssrLooseContain(unref(form).timezone, "UTC") : ssrLooseEqual(unref(form).timezone, "UTC")) ? " selected" : ""}>UTC (+00:00)</option><option value="Asia/Jakarta"${ssrIncludeBooleanAttr(Array.isArray(unref(form).timezone) ? ssrLooseContain(unref(form).timezone, "Asia/Jakarta") : ssrLooseEqual(unref(form).timezone, "Asia/Jakarta")) ? " selected" : ""}>Asia/Jakarta (+07:00)</option><option value="Asia/Singapore"${ssrIncludeBooleanAttr(Array.isArray(unref(form).timezone) ? ssrLooseContain(unref(form).timezone, "Asia/Singapore") : ssrLooseEqual(unref(form).timezone, "Asia/Singapore")) ? " selected" : ""}>Asia/Singapore (+08:00)</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><option value="DD/MM/YYYY"${ssrIncludeBooleanAttr(Array.isArray(unref(form).date_format) ? ssrLooseContain(unref(form).date_format, "DD/MM/YYYY") : ssrLooseEqual(unref(form).date_format, "DD/MM/YYYY")) ? " selected" : ""}>DD/MM/YYYY</option><option value="YYYY-MM-DD"${ssrIncludeBooleanAttr(Array.isArray(unref(form).date_format) ? ssrLooseContain(unref(form).date_format, "YYYY-MM-DD") : ssrLooseEqual(unref(form).date_format, "YYYY-MM-DD")) ? " selected" : ""}>YYYY-MM-DD</option><option value="MM/DD/YYYY"${ssrIncludeBooleanAttr(Array.isArray(unref(form).date_format) ? ssrLooseContain(unref(form).date_format, "MM/DD/YYYY") : ssrLooseEqual(unref(form).date_format, "MM/DD/YYYY")) ? " selected" : ""}>MM/DD/YYYY</option><option value="DD MMM YYYY"${ssrIncludeBooleanAttr(Array.isArray(unref(form).date_format) ? ssrLooseContain(unref(form).date_format, "DD MMM YYYY") : ssrLooseEqual(unref(form).date_format, "DD MMM YYYY")) ? " selected" : ""}>DD MMM YYYY</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><option value="24-hour"${ssrIncludeBooleanAttr(Array.isArray(unref(form).time_format) ? ssrLooseContain(unref(form).time_format, "24-hour") : ssrLooseEqual(unref(form).time_format, "24-hour")) ? " selected" : ""}>24-hour (00:00 - 23:59)</option><option value="12-hour"${ssrIncludeBooleanAttr(Array.isArray(unref(form).time_format) ? ssrLooseContain(unref(form).time_format, "12-hour") : ssrLooseEqual(unref(form).time_format, "12-hour")) ? " selected" : ""}>12-hour (AM/PM)</option></select></div></div><div class="flex justify-end pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center">`);
      if (unref(saving)) {
        _push(`<span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`  </button></div></form></div></div>`);
    };
  }
});
const _sfc_setup$u = _sfc_main$u.setup;
_sfc_main$u.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/components/TimezoneTab.vue");
  return _sfc_setup$u ? _sfc_setup$u(props, ctx) : void 0;
};

const TimezoneTabDw893pUd = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$u
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "MaintenanceTab",
  __ssrInlineRender: true,
  props: {
    settings: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      maintenance_mode: false,
      maintenance_message: "",
      maintenance_allowed_ips: []
    });
    const allowedIPsString = computed({
      get: () => form.maintenance_allowed_ips.join(", "),
      set: (value) => {
        form.maintenance_allowed_ips = value.split(",").map((ip) => ip.trim()).filter((ip) => ip.length > 0);
      }
    });
    watch$1(() => props.settings, (newSettings) => {
      if (newSettings && newSettings.length > 0) {
        newSettings.forEach((setting) => {
          if (setting.key === "maintenance_mode") {
            form.maintenance_mode = setting.value || false;
          } else if (setting.key === "maintenance_message") {
            form.maintenance_message = setting.value || "";
          } else if (setting.key === "maintenance_allowed_ips") {
            form.maintenance_allowed_ips = Array.isArray(setting.value) ? setting.value : [];
          }
        });
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"> Maintenance Mode</h2><form class="space-y-4"><div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg"><div><label class="block text-sm font-medium text-gray-700">  Maintenance Mode </label><p class="text-sm text-gray-500 mt-1">   Maintenance  </p></div><label class="relative inline-flex items-center cursor-pointer"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).maintenance_mode) ? ssrLooseContain(unref(form).maintenance_mode, null) : unref(form).maintenance_mode) ? " checked" : ""} type="checkbox" class="sr-only peer"><div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[&#39;&#39;] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div></label></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  Maintenance </label><textarea rows="4" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder=" ">${ssrInterpolate(unref(form).maintenance_message)}</textarea></div><div><label class="block text-sm font-medium text-gray-700 mb-1"> IP  Maintenance ( comma) </label><input${ssrRenderAttr("value", unref(allowedIPsString))} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="127.0.0.1, 192.168.1.1"><p class="mt-1 text-sm text-gray-500"> IP  Maintenance Mode </p></div><div class="flex justify-end pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center">`);
      if (unref(saving)) {
        _push(`<span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`  </button></div></form></div></div>`);
    };
  }
});
const _sfc_setup$t = _sfc_main$t.setup;
_sfc_main$t.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/components/MaintenanceTab.vue");
  return _sfc_setup$t ? _sfc_setup$t(props, ctx) : void 0;
};

const MaintenanceTabDm9kgHWA = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$t
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "SecurityTab",
  __ssrInlineRender: true,
  props: {
    settings: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      session_timeout: 120,
      password_min_length: 8,
      password_require_uppercase: false,
      password_require_lowercase: false,
      password_require_number: false,
      password_require_special: false,
      login_attempts_limit: 5,
      login_lockout_duration: 15,
      two_factor_auth_enabled: false
    });
    watch$1(() => props.settings, (newSettings) => {
      if (newSettings && newSettings.length > 0) {
        newSettings.forEach((setting) => {
          const key = setting.key;
          if (key in form) {
            if (typeof form[key] === "number") {
              form[key] = Number(setting.value) || form[key];
            } else if (typeof form[key] === "boolean") {
              form[key] = setting.value || false;
            } else {
              form[key] = setting.value || form[key];
            }
          }
        });
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><form class="space-y-6"><div class="border-b border-gray-200 pb-4"><h3 class="text-lg font-medium mb-4">Session Settings</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1"> Session Timeout () </label><input${ssrRenderAttr("value", unref(form).session_timeout)} type="number" min="5" max="480" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><p class="mt-1 text-sm text-gray-500"> session</p></div></div></div><div class="border-b border-gray-200 pb-4"><h3 class="text-lg font-medium mb-4">Password Policy</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><input${ssrRenderAttr("value", unref(form).password_min_length)} type="number" min="6" max="32" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required></div></div><div class="mt-4 space-y-2"><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).password_require_uppercase) ? ssrLooseContain(unref(form).password_require_uppercase, null) : unref(form).password_require_uppercase) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).password_require_lowercase) ? ssrLooseContain(unref(form).password_require_lowercase, null) : unref(form).password_require_lowercase) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).password_require_number) ? ssrLooseContain(unref(form).password_require_number, null) : unref(form).password_require_number) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).password_require_special) ? ssrLooseContain(unref(form).password_require_special, null) : unref(form).password_require_special) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"> (!@#$%^&amp;*)</span></label></div></div><div class="border-b border-gray-200 pb-4"><h3 class="text-lg font-medium mb-4">Login Security</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1">  login  </label><input${ssrRenderAttr("value", unref(form).login_attempts_limit)} type="number" min="3" max="10" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  lock () </label><input${ssrRenderAttr("value", unref(form).login_lockout_duration)} type="number" min="5" max="60" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required></div></div></div><div><h3 class="text-lg font-medium mb-4">Two-Factor Authentication</h3><div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg"><div><label class="block text-sm font-medium text-gray-700">  2FA  admin </label><p class="text-sm text-gray-500 mt-1">  2  admin </p></div><label class="relative inline-flex items-center cursor-pointer"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).two_factor_auth_enabled) ? ssrLooseContain(unref(form).two_factor_auth_enabled, null) : unref(form).two_factor_auth_enabled) ? " checked" : ""} type="checkbox" class="sr-only peer"><div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[&#39;&#39;] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div></label></div></div><div class="flex justify-end pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center">`);
      if (unref(saving)) {
        _push(`<span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`  </button></div></form></div></div>`);
    };
  }
});
const _sfc_setup$s = _sfc_main$s.setup;
_sfc_main$s.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/components/SecurityTab.vue");
  return _sfc_setup$s ? _sfc_setup$s(props, ctx) : void 0;
};

const SecurityTabDDNotXn0 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$s
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "FileUploadTab",
  __ssrInlineRender: true,
  props: {
    settings: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      max_file_size: 10,
      allowed_file_types: "jpg,jpeg,png,gif,pdf,doc,docx,xls,xlsx",
      storage_type: "local"
    });
    watch$1(() => props.settings, (newSettings) => {
      if (newSettings && newSettings.length > 0) {
        newSettings.forEach((setting) => {
          const key = setting.key;
          if (key in form) {
            if (typeof form[key] === "number") {
              form[key] = Number(setting.value) || form[key];
            } else {
              form[key] = setting.value || form[key];
            }
          }
        });
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1">  (MB) </label><input${ssrRenderAttr("value", unref(form).max_file_size)} type="number" min="1" max="100" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  Storage </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><option value="local"${ssrIncludeBooleanAttr(Array.isArray(unref(form).storage_type) ? ssrLooseContain(unref(form).storage_type, "local") : ssrLooseEqual(unref(form).storage_type, "local")) ? " selected" : ""}>Local Storage</option><option value="s3"${ssrIncludeBooleanAttr(Array.isArray(unref(form).storage_type) ? ssrLooseContain(unref(form).storage_type, "s3") : ssrLooseEqual(unref(form).storage_type, "s3")) ? " selected" : ""}>Amazon S3</option></select></div></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  ( comma) </label><input${ssrRenderAttr("value", unref(form).allowed_file_types)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="jpg,jpeg,png,gif,pdf,doc,docx" required><p class="mt-1 text-sm text-gray-500"> : jpg, jpeg, png, gif, pdf, doc, docx, xls, xlsx </p></div><div class="flex justify-end pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center">`);
      if (unref(saving)) {
        _push(`<span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`  </button></div></form></div></div>`);
    };
  }
});
const _sfc_setup$r = _sfc_main$r.setup;
_sfc_main$r.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/components/FileUploadTab.vue");
  return _sfc_setup$r ? _sfc_setup$r(props, ctx) : void 0;
};

const FileUploadTabCW3cNCWa = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$r
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "NotificationTab",
  __ssrInlineRender: true,
  props: {
    settings: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      email_notifications_enabled: true,
      sms_notifications_enabled: false,
      course_reminder_before_minutes: 60,
      payment_reminder_before_days: 3
    });
    watch$1(() => props.settings, (newSettings) => {
      if (newSettings && newSettings.length > 0) {
        newSettings.forEach((setting) => {
          const key = setting.key;
          if (key in form) {
            if (typeof form[key] === "number") {
              form[key] = Number(setting.value) || form[key];
            } else if (typeof form[key] === "boolean") {
              form[key] = setting.value || false;
            } else {
              form[key] = setting.value || form[key];
            }
          }
        });
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><form class="space-y-6"><div class="border-b border-gray-200 pb-4"><h3 class="text-lg font-medium mb-4"></h3><div class="space-y-4"><div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg"><div><label class="block text-sm font-medium text-gray-700">  </label><p class="text-sm text-gray-500 mt-1">  </p></div><label class="relative inline-flex items-center cursor-pointer"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).email_notifications_enabled) ? ssrLooseContain(unref(form).email_notifications_enabled, null) : unref(form).email_notifications_enabled) ? " checked" : ""} type="checkbox" class="sr-only peer"><div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[&#39;&#39;] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div></label></div><div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg"><div><label class="block text-sm font-medium text-gray-700"> SMS </label><p class="text-sm text-gray-500 mt-1">  SMS </p></div><label class="relative inline-flex items-center cursor-pointer"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).sms_notifications_enabled) ? ssrLooseContain(unref(form).sms_notifications_enabled, null) : unref(form).sms_notifications_enabled) ? " checked" : ""} type="checkbox" class="sr-only peer"><div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[&#39;&#39;] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div></label></div></div></div><div><h3 class="text-lg font-medium mb-4"></h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1">  () </label><input${ssrRenderAttr("value", unref(form).course_reminder_before_minutes)} type="number" min="5" max="1440" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><p class="mt-1 text-sm text-gray-500"></p></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  () </label><input${ssrRenderAttr("value", unref(form).payment_reminder_before_days)} type="number" min="1" max="30" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><p class="mt-1 text-sm text-gray-500"></p></div></div></div><div class="flex justify-end pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center">`);
      if (unref(saving)) {
        _push(`<span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`  </button></div></form></div></div>`);
    };
  }
});
const _sfc_setup$q = _sfc_main$q.setup;
_sfc_main$q.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/components/NotificationTab.vue");
  return _sfc_setup$q ? _sfc_setup$q(props, ctx) : void 0;
};

const NotificationTabCXea2PWy = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$q
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "LanguageTab",
  __ssrInlineRender: true,
  props: {
    settings: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      default_language: "th",
      supported_languages: "th,en"
    });
    watch$1(() => props.settings, (newSettings) => {
      if (newSettings && newSettings.length > 0) {
        newSettings.forEach((setting) => {
          const key = setting.key;
          if (key in form) {
            form[key] = setting.value || form[key];
          }
        });
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><option value="th"${ssrIncludeBooleanAttr(Array.isArray(unref(form).default_language) ? ssrLooseContain(unref(form).default_language, "th") : ssrLooseEqual(unref(form).default_language, "th")) ? " selected" : ""}> (Thai)</option><option value="en"${ssrIncludeBooleanAttr(Array.isArray(unref(form).default_language) ? ssrLooseContain(unref(form).default_language, "en") : ssrLooseEqual(unref(form).default_language, "en")) ? " selected" : ""}>English</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-1">  ( comma) </label><input${ssrRenderAttr("value", unref(form).supported_languages)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="th,en" required><p class="mt-1 text-sm text-gray-500"> : th,en (, ) </p></div></div><div class="flex justify-end pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center">`);
      if (unref(saving)) {
        _push(`<span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`  </button></div></form></div></div>`);
    };
  }
});
const _sfc_setup$p = _sfc_main$p.setup;
_sfc_main$p.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/components/LanguageTab.vue");
  return _sfc_setup$p ? _sfc_setup$p(props, ctx) : void 0;
};

const LanguageTabDbPMqoWD = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$p
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "DisplayTab",
  __ssrInlineRender: true,
  props: {
    settings: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const form = reactive({
      items_per_page: 20,
      theme_mode: "light",
      primary_color: "#10b981",
      secondary_color: "#2563eb"
    });
    watch$1(() => props.settings, (newSettings) => {
      if (newSettings && newSettings.length > 0) {
        newSettings.forEach((setting) => {
          const key = setting.key;
          if (key in form) {
            if (typeof form[key] === "number") {
              form[key] = Number(setting.value) || form[key];
            } else {
              form[key] = setting.value || form[key];
            }
          }
        });
      }
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><form class="space-y-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><option${ssrRenderAttr("value", 10)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).items_per_page) ? ssrLooseContain(unref(form).items_per_page, 10) : ssrLooseEqual(unref(form).items_per_page, 10)) ? " selected" : ""}>10</option><option${ssrRenderAttr("value", 20)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).items_per_page) ? ssrLooseContain(unref(form).items_per_page, 20) : ssrLooseEqual(unref(form).items_per_page, 20)) ? " selected" : ""}>20</option><option${ssrRenderAttr("value", 50)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).items_per_page) ? ssrLooseContain(unref(form).items_per_page, 50) : ssrLooseEqual(unref(form).items_per_page, 50)) ? " selected" : ""}>50</option><option${ssrRenderAttr("value", 100)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).items_per_page) ? ssrLooseContain(unref(form).items_per_page, 100) : ssrLooseEqual(unref(form).items_per_page, 100)) ? " selected" : ""}>100</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-1"> Theme Mode </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" required><option value="light"${ssrIncludeBooleanAttr(Array.isArray(unref(form).theme_mode) ? ssrLooseContain(unref(form).theme_mode, "light") : ssrLooseEqual(unref(form).theme_mode, "light")) ? " selected" : ""}>Light</option><option value="dark"${ssrIncludeBooleanAttr(Array.isArray(unref(form).theme_mode) ? ssrLooseContain(unref(form).theme_mode, "dark") : ssrLooseEqual(unref(form).theme_mode, "dark")) ? " selected" : ""}>Dark</option><option value="auto"${ssrIncludeBooleanAttr(Array.isArray(unref(form).theme_mode) ? ssrLooseContain(unref(form).theme_mode, "auto") : ssrLooseEqual(unref(form).theme_mode, "auto")) ? " selected" : ""}>Auto ()</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-1"> Primary Color (Hex) </label><div class="flex items-center gap-2"><input${ssrRenderAttr("value", unref(form).primary_color)} type="color" class="w-16 h-10 border border-gray-300 rounded cursor-pointer"><input${ssrRenderAttr("value", unref(form).primary_color)} type="text" pattern="^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm" placeholder="#10b981"></div></div><div><label class="block text-sm font-medium text-gray-700 mb-1"> Secondary Color (Hex) </label><div class="flex items-center gap-2"><input${ssrRenderAttr("value", unref(form).secondary_color)} type="color" class="w-16 h-10 border border-gray-300 rounded cursor-pointer"><input${ssrRenderAttr("value", unref(form).secondary_color)} type="text" pattern="^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm" placeholder="#2563eb"></div></div></div><div class="flex justify-end pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center">`);
      if (unref(saving)) {
        _push(`<span class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`  </button></div></form></div></div>`);
    };
  }
});
const _sfc_setup$o = _sfc_main$o.setup;
_sfc_main$o.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/components/DisplayTab.vue");
  return _sfc_setup$o ? _sfc_setup$o(props, ctx) : void 0;
};

const DisplayTabCsMJSnCo = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$o
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const { accessToken } = useAuth();
    const activeTab = ref("general");
    const loading = ref(true);
    const error = ref(null);
    const settings = ref({});
    const tabs = [
      { id: "general", label: "" },
      { id: "timezone", label: "" },
      { id: "maintenance", label: "" },
      { id: "security", label: "" },
      { id: "file_upload", label: "" },
      { id: "notification", label: "" },
      { id: "language", label: "" },
      { id: "display", label: "" }
    ];
    const loadSettings = async () => {
      try {
        loading.value = true;
        error.value = null;
        const response = await $fetch(
          "/api/admin/settings/system",
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          settings.value = response.data;
        } else {
          error.value = "";
        }
      } catch (err) {
        console.error("Error loading system settings:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const handleSaved = () => {
      loadSettings();
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="mb-6"><h1 class="text-3xl font-bold"></h1><p class="mt-2 text-gray-600"></p></div>`);
      if (unref(loading)) {
        _push(`<div class="flex items-center justify-center py-12"><div class="text-center"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto"></div><p class="mt-4 text-gray-600">...</p></div></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 rounded-lg p-4"><div class="flex items-center">`);
        _push(ssrRenderComponent(unref(ExclamationTriangleIcon), { class: "h-5 w-5 text-red-600 mr-2" }, null, _parent));
        _push(`<p class="text-red-800">${ssrInterpolate(unref(error))}</p></div></div>`);
      } else {
        _push(`<div><div class="flex items-center gap-4 mb-6 border-b border-gray-200"><!--[-->`);
        ssrRenderList(tabs, (tab) => {
          _push(`<button class="${ssrRenderClass([unref(activeTab) === tab.id ? "text-green-600 border-b-2 border-green-600" : "text-gray-600 hover:text-green-600", "px-4 py-2 font-semibold transition-colors relative"])}">${ssrInterpolate(tab.label)}</button>`);
        });
        _push(`<!--]--></div><div>`);
        if (unref(activeTab) === "general") {
          _push(ssrRenderComponent(_sfc_main$v, {
            settings: unref(settings).general || [],
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "timezone") {
          _push(ssrRenderComponent(_sfc_main$u, {
            settings: unref(settings).timezone || [],
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "maintenance") {
          _push(ssrRenderComponent(_sfc_main$t, {
            settings: unref(settings).maintenance || [],
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "security") {
          _push(ssrRenderComponent(_sfc_main$s, {
            settings: unref(settings).security || [],
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "file_upload") {
          _push(ssrRenderComponent(_sfc_main$r, {
            settings: unref(settings).file_upload || [],
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "notification") {
          _push(ssrRenderComponent(_sfc_main$q, {
            settings: unref(settings).notification || [],
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "language") {
          _push(ssrRenderComponent(_sfc_main$p, {
            settings: unref(settings).language || [],
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "display") {
          _push(ssrRenderComponent(_sfc_main$o, {
            settings: unref(settings).display || [],
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div>`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$n = _sfc_main$n.setup;
_sfc_main$n.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/system/index.vue");
  return _sfc_setup$n ? _sfc_setup$n(props, ctx) : void 0;
};

const indexDgxVJ48 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$n
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$7 = /* @__PURE__ */ defineComponent({
  __name: "ArticleModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    article: {}
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const loading = ref(false);
    const uploadingThumbnail = ref(false);
    ref(null);
    const uploadError = ref("");
    const form = reactive({
      title: "",
      excerpt: "",
      content: "",
      category: "",
      icon: "",
      featured_image_url: "",
      status: "draft",
      is_featured: false,
      display_order: 0
    });
    watch$1(() => props.show, (newVal) => {
      if (newVal) {
        if (props.article) {
          form.title = props.article.title || "";
          form.excerpt = props.article.excerpt || "";
          form.content = props.article.content || "";
          form.category = props.article.category || "";
          form.icon = props.article.icon || "";
          form.featured_image_url = props.article.featured_image_url || "";
          form.status = props.article.status;
          form.is_featured = props.article.is_featured || false;
          form.display_order = props.article.display_order || 0;
        } else {
          resetForm();
        }
      }
    });
    const resetForm = () => {
      form.title = "";
      form.excerpt = "";
      form.content = "";
      form.category = "";
      form.icon = "";
      form.featured_image_url = "";
      form.status = "draft";
      form.is_featured = false;
      form.display_order = 0;
      uploadError.value = "";
    };
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.article ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).title)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).category)} type="text" placeholder=" , " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Icon (Emoji) </label><input${ssrRenderAttr("value", unref(form).icon)} type="text" placeholder=" , " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="draft"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "draft") : ssrLooseEqual(unref(form).status, "draft")) ? " selected" : ""}></option><option value="published"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "published") : ssrLooseEqual(unref(form).status, "published")) ? " selected" : ""}></option><option value="archived"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "archived") : ssrLooseEqual(unref(form).status, "archived")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).display_order)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_featured) ? ssrLooseContain(unref(form).is_featured, null) : unref(form).is_featured) ? " checked" : ""} type="checkbox" class="h-4 w-4 text-green-600 focus:ring-green-500 border-gray-300 rounded"><label class="ml-2 block text-sm text-gray-700">  </label></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  (Excerpt) </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).excerpt)}</textarea></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label><div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-3"><p class="text-sm font-semibold text-blue-900 mb-2"> :</p><ul class="text-sm text-blue-800 space-y-1 list-disc list-inside"><li><strong>:</strong> 1280 x 720 pixels</li><li><strong>:</strong> 16:9 ()</li><li><strong>:</strong> JPG, PNG, WebP</li><li><strong>:</strong>  2 MB ( &lt; 500 KB)</li></ul></div><div class="space-y-3">`);
        if (unref(uploadingThumbnail)) {
          _push(`<div class="text-sm text-gray-600 py-2"> ... </div>`);
        } else if (unref(form).featured_image_url) {
          _push(`<div class="space-y-3"><p class="text-sm text-gray-600"> ( 16:9):</p><div class="aspect-video bg-gray-200 rounded-lg overflow-hidden max-w-2xl"><img${ssrRenderAttr("src", unref(form).featured_image_url)} alt="Featured image preview" class="w-full h-full object-cover"></div><button type="button" class="px-3 py-2 text-sm text-red-600 hover:bg-red-50 rounded-lg border border-red-200">  </button></div>`);
        } else {
          _push(`<div class="border-2 border-dashed border-gray-300 rounded-lg p-4"><input type="file" accept="image/jpeg,image/png,image/webp" class="hidden"><button type="button" class="w-full px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"><svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>  </button><p class="text-xs text-gray-500 mt-2 text-center">: JPG, PNG, WebP ( 2 MB)</p></div>`);
        }
        _push(`</div>`);
        if (unref(uploadError)) {
          _push(`<p class="mt-2 text-sm text-red-600">${ssrInterpolate(unref(uploadError))}</p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label>`);
        _push(ssrRenderComponent(RichTextEditor, {
          modelValue: unref(form).content,
          "onUpdate:modelValue": ($event) => unref(form).content = $event,
          "entity-type": "articles",
          "entity-id": props.article?.id,
          class: "w-full"
        }, null, _parent));
        _push(`</div><div class="flex justify-end space-x-4 pt-4 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">${ssrInterpolate(unref(loading) ? "..." : "")}</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$7 = _sfc_main$1$7.setup;
_sfc_main$1$7.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ArticleModal.vue");
  return _sfc_setup$1$7 ? _sfc_setup$1$7(props, ctx) : void 0;
};
const __nuxt_component_0$5 = Object.assign(_sfc_main$1$7, { __name: "ArticleModal" });
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const articles = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingArticle = ref(null);
    const filters = reactive({
      search: "",
      category: "",
      status: ""
    });
    const loadArticles = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams();
        if (filters.search) params.append("search", filters.search);
        if (filters.category) params.append("category", filters.category);
        if (filters.status) params.append("status", filters.status);
        const response = await $fetch(`${config.public.apiBase}/admin/articles?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          articles.value = response.data;
        }
      } catch (err) {
        console.error("Error loading articles:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const getStatusName = (status) => {
      const statusNames = {
        draft: "",
        published: "",
        archived: ""
      };
      return statusNames[status] || status;
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingArticle.value = null;
    };
    const handleArticleSaved = () => {
      closeModal();
      loadArticles();
    };
    useConfirm();
    return (_ctx, _push, _parent, _attrs) => {
      const _component_ArticleModal = __nuxt_component_0$5;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-3 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).category)} type="text" placeholder="" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="draft"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "draft") : ssrLooseEqual(unref(filters).status, "draft")) ? " selected" : ""}></option><option value="published"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "published") : ssrLooseEqual(unref(filters).status, "published")) ? " selected" : ""}></option><option value="archived"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "archived") : ssrLooseEqual(unref(filters).status, "archived")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(articles).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(articles), (article) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4"><div class="flex items-center space-x-3">`);
          if (article.icon) {
            _push(`<div class="text-2xl">${ssrInterpolate(article.icon)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<div><div class="text-sm font-medium text-gray-900">${ssrInterpolate(article.title)}</div>`);
          if (article.excerpt) {
            _push(`<div class="text-xs text-gray-500 mt-1 line-clamp-1">${ssrInterpolate(article.excerpt)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(article.category || "-")}</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([{
            "bg-yellow-100 text-yellow-800": article.status === "draft",
            "bg-green-100 text-green-800": article.status === "published",
            "bg-gray-100 text-gray-800": article.status === "archived"
          }, "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusName(article.status))}</span></td><td class="px-6 py-4 whitespace-nowrap">`);
          if (article.is_featured) {
            _push(`<span class="px-2 py-1 text-xs font-medium bg-blue-100 text-blue-800 rounded">  </span>`);
          } else {
            _push(`<span class="text-gray-400">-</span>`);
          }
          _push(`</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button><button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      _push(ssrRenderComponent(_component_ArticleModal, {
        show: unref(showCreateModal) || unref(editingArticle) !== null,
        article: unref(editingArticle),
        onClose: closeModal,
        onSaved: handleArticleSaved
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$m = _sfc_main$m.setup;
_sfc_main$m.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/content/articles/index.vue");
  return _sfc_setup$m ? _sfc_setup$m(props, ctx) : void 0;
};

const indexIrFooeij = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$m
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useRouter();
    const { user } = useAuth();
    computed(() => parseInt(route.params.id));
    const loading = ref(true);
    const error = ref("");
    const enrollmentDetail = ref(null);
    const canEdit = computed(() => {
      if (!user.value || !user.value.roles) return false;
      const allowedRoles = ["system_admin", "owner", "admin", "branch_admin"];
      return user.value.roles.some((role) => allowedRoles.includes(role));
    });
    const getStatusName = (status) => {
      const statusNames = {
        pending: "",
        active: "",
        completed: "",
        cancelled: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        pending: "bg-yellow-100 text-yellow-800",
        active: "bg-green-100 text-green-800",
        completed: "bg-blue-100 text-blue-800",
        cancelled: "bg-red-100 text-red-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const getTypeName = (type) => {
      const typeNames = {
        live_online: "Live Online",
        vod: "VOD",
        hybrid: "Hybrid"
      };
      return typeNames[type] || type;
    };
    const getTypeBadgeClass = (type) => {
      const classes = {
        live_online: "bg-blue-100 text-blue-800",
        vod: "bg-purple-100 text-purple-800",
        hybrid: "bg-indigo-100 text-indigo-800"
      };
      return classes[type] || "bg-gray-100 text-gray-800";
    };
    const getLevelName = (level) => {
      const levelNames = {
        beginner: "",
        intermediate: "",
        advanced: ""
      };
      return levelNames[level] || level;
    };
    const getPaymentStatusName = (status) => {
      const statusNames = {
        pending: "",
        paid: "",
        failed: "",
        refunded: ""
      };
      return statusNames[status] || status;
    };
    const getPaymentStatusBadgeClass = (status) => {
      const classes = {
        pending: "bg-yellow-100 text-yellow-800",
        paid: "bg-green-100 text-green-800",
        failed: "bg-red-100 text-red-800",
        refunded: "bg-gray-100 text-gray-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const formatCurrency = (amount) => {
      return new Intl.NumberFormat("th-TH", {
        style: "currency",
        currency: "THB"
      }).format(amount);
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy HH:mm", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4"><button class="p-2 hover:bg-gray-100 rounded-lg"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg></button><h1 class="text-3xl font-bold"></h1></div><div class="flex items-center space-x-3">`);
      if (unref(canEdit)) {
        _push(`<button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg><span></span></button>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(enrollmentDetail)) {
        _push(`<div class="space-y-6"><div class="bg-white rounded-lg shadow p-6"><div class="flex items-center justify-between mb-4"><h2 class="text-xl font-semibold"></h2><span class="${ssrRenderClass([getStatusBadgeClass(unref(enrollmentDetail).enrollment.status), "px-3 py-1 text-sm font-medium rounded"])}">${ssrInterpolate(getStatusName(unref(enrollmentDetail).enrollment.status))}</span></div><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><span class="${ssrRenderClass([unref(enrollmentDetail).enrollment.enrollment_type === "online" ? "bg-blue-100 text-blue-800" : "bg-green-100 text-green-800", "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(unref(enrollmentDetail).enrollment.enrollment_type === "online" ? "" : "")}</span></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(formatDate(unref(enrollmentDetail).enrollment.enrollment_date || unref(enrollmentDetail).enrollment.created_at))}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(formatDate(unref(enrollmentDetail).enrollment.updated_at))}</p></div></div></div><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-500 mb-1">-</label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).student.first_name)} ${ssrInterpolate(unref(enrollmentDetail).student.last_name)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1">Username</label><p class="text-gray-900">@${ssrInterpolate(unref(enrollmentDetail).student.username)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).student.email || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).student.phone || "-")}</p></div></div></div><div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-500 mb-1"></label>`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: `/admin/courses/${unref(enrollmentDetail).course.id}`,
          class: "text-green-600 hover:text-green-700"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<p class="text-lg font-medium"${_scopeId}>${ssrInterpolate(unref(enrollmentDetail).course.title)}</p>`);
            } else {
              return [
                createVNode("p", { class: "text-lg font-medium" }, toDisplayString(unref(enrollmentDetail).course.title), 1)
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).course.code || "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><span class="${ssrRenderClass([getTypeBadgeClass(unref(enrollmentDetail).course.type), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getTypeName(unref(enrollmentDetail).course.type))}</span></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-lg font-medium text-gray-900">${ssrInterpolate(formatCurrency(unref(enrollmentDetail).course.price))}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).course.duration_hours ? `${unref(enrollmentDetail).course.duration_hours} ` : "-")}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).course.level ? getLevelName(unref(enrollmentDetail).course.level) : "-")}</p></div>`);
        if (unref(enrollmentDetail).course.description) {
          _push(`<div class="md:col-span-2"><label class="block text-sm font-medium text-gray-500 mb-1"></label><div class="text-gray-900 prose max-w-none">${unref(enrollmentDetail).course.description ?? ""}</div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div>`);
        if (unref(enrollmentDetail).enrollment.enrollment_type === "onsite" && unref(enrollmentDetail).branch) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).branch.name)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).branch.code || "-")}</p></div>`);
          if (unref(enrollmentDetail).branch.address) {
            _push(`<div class="md:col-span-2"><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).branch.address)}</p></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(enrollmentDetail).branch.phone) {
            _push(`<div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).branch.phone)}</p></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(enrollmentDetail).branch.email) {
            _push(`<div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).branch.email)}</p></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(enrollmentDetail).enrollment.enrollment_type === "online" && unref(enrollmentDetail).shipping_address) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).shipping_address.recipient_name)}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).shipping_address.phone)}</p></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).shipping_address.address_line1)} `);
          if (unref(enrollmentDetail).shipping_address.address_line2) {
            _push(`<span>, ${ssrInterpolate(unref(enrollmentDetail).shipping_address.address_line2)}</span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</p><p class="text-gray-900">`);
          if (unref(enrollmentDetail).shipping_address.subdistrict) {
            _push(`<span>${ssrInterpolate(unref(enrollmentDetail).shipping_address.subdistrict)}</span>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(enrollmentDetail).shipping_address.district) {
            _push(`<span>.${ssrInterpolate(unref(enrollmentDetail).shipping_address.district)}</span>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(enrollmentDetail).shipping_address.province) {
            _push(`<span>.${ssrInterpolate(unref(enrollmentDetail).shipping_address.province)}</span>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(enrollmentDetail).shipping_address.postal_code) {
            _push(`<span>${ssrInterpolate(unref(enrollmentDetail).shipping_address.postal_code)}</span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).shipping_address.address_type === "home" ? "" : unref(enrollmentDetail).shipping_address.address_type === "work" ? "" : "")} `);
          if (unref(enrollmentDetail).shipping_address.is_default) {
            _push(`<span class="ml-2 px-2 py-1 bg-green-100 text-green-800 rounded text-xs"></span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</p></div></div></div>`);
        } else {
          _push(`<!---->`);
        }
        if (unref(enrollmentDetail).payment) {
          _push(`<div class="bg-white rounded-lg shadow p-6"><h2 class="text-xl font-semibold mb-4"></h2><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-lg font-medium text-gray-900">${ssrInterpolate(formatCurrency(unref(enrollmentDetail).payment.amount))}</p></div><div><label class="block text-sm font-medium text-gray-500 mb-1"></label><span class="${ssrRenderClass([getPaymentStatusBadgeClass(unref(enrollmentDetail).payment.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getPaymentStatusName(unref(enrollmentDetail).payment.status))}</span></div>`);
          if (unref(enrollmentDetail).payment.payment_method) {
            _push(`<div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).payment.payment_method)}</p></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(enrollmentDetail).payment.transaction_id) {
            _push(`<div><label class="block text-sm font-medium text-gray-500 mb-1">Transaction ID</label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).payment.transaction_id)}</p></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(enrollmentDetail).payment.invoice_number) {
            _push(`<div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(unref(enrollmentDetail).payment.invoice_number)}</p></div>`);
          } else {
            _push(`<!---->`);
          }
          if (unref(enrollmentDetail).payment.paid_at) {
            _push(`<div><label class="block text-sm font-medium text-gray-500 mb-1"></label><p class="text-gray-900">${ssrInterpolate(formatDate(unref(enrollmentDetail).payment.paid_at))}</p></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$l = _sfc_main$l.setup;
_sfc_main$l.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/enrollments/[id]/index.vue");
  return _sfc_setup$l ? _sfc_setup$l(props, ctx) : void 0;
};

const indexDkMwtOCR = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$l
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "edit",
  __ssrInlineRender: true,
  setup(__props) {
    const route = useRoute();
    useRouter();
    const pageId = computed(() => route.params.id === "new" ? null : parseInt(route.params.id));
    const page = ref(null);
    const loading = ref(true);
    const error = ref(null);
    const saving = ref(false);
    const submitError = ref(null);
    const form = ref({
      slug: "",
      title: "",
      content: "",
      meta_title: "",
      meta_description: "",
      meta_keywords: "",
      is_active: true,
      display_order: 0
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div class="flex items-center space-x-4">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/admin/content/pages",
        class: "p-2 hover:bg-gray-100 rounded-lg"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"${_scopeId}></path></svg>`);
          } else {
            return [
              (openBlock(), createBlock("svg", {
                class: "w-6 h-6",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M10 19l-7-7m0 0l7-7m-7 7h18"
                })
              ]))
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<h1 class="text-3xl font-bold">${ssrInterpolate(unref(page) ? "" : "")}</h1></div></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div><p class="mt-4 text-gray-600">...</p></div>`);
      } else {
        _push(`<!--[-->`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-6">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<form class="bg-white rounded-lg shadow p-6 space-y-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"> Slug <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).slug)} type="text" required placeholder="about, contact, help" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono"><p class="mt-1 text-sm text-gray-500">URL path  (: /about, /contact)</p></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).title)} type="text" required placeholder="" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option${ssrRenderAttr("value", true)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, true) : ssrLooseEqual(unref(form).is_active, true)) ? " selected" : ""}></option><option${ssrRenderAttr("value", false)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, false) : ssrLooseEqual(unref(form).is_active, false)) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).display_order)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label>`);
        _push(ssrRenderComponent(RichTextEditor, {
          modelValue: unref(form).content,
          "onUpdate:modelValue": ($event) => unref(form).content = $event,
          "entity-type": "content-pages",
          "entity-id": unref(pageId) || void 0,
          class: "w-full"
        }, null, _parent));
        _push(`</div><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"> Meta Title </label><input${ssrRenderAttr("value", unref(form).meta_title)} type="text" placeholder=" - KDC Tutor School" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><p class="mt-1 text-sm text-gray-500"> SEO ()</p></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Meta Keywords </label><input${ssrRenderAttr("value", unref(form).meta_keywords)} type="text" placeholder="keyword1, keyword2, keyword3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Meta Description </label><textarea rows="3" placeholder="  SEO" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).meta_description)}</textarea></div>`);
        if (unref(submitError)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">${ssrInterpolate(unref(submitError))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-4 pt-4 border-t">`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/admin/content/pages",
          class: "px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors">`);
        if (unref(saving)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form><!--]-->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$k = _sfc_main$k.setup;
_sfc_main$k.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/content/pages/[id]/edit.vue");
  return _sfc_setup$k ? _sfc_setup$k(props, ctx) : void 0;
};

const editDnflIVDD = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$k
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$6 = /* @__PURE__ */ defineComponent({
  __name: "BranchModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    branch: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const form = reactive({
      name: "",
      code: "",
      address: "",
      phone: "",
      email: "",
      status: "active"
    });
    const loading = ref(false);
    const error = ref("");
    watch$1(() => props.branch, (branch) => {
      if (branch) {
        form.name = branch.name;
        form.code = branch.code;
        form.address = branch.address || "";
        form.phone = branch.phone || "";
        form.email = branch.email || "";
        form.status = branch.status;
      } else {
        form.name = "";
        form.code = "";
        form.address = "";
        form.phone = "";
        form.email = "";
        form.status = "active";
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.branch ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).code)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).address)}</textarea></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).phone)} type="tel" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).email)} type="email" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "active") : ssrLooseEqual(unref(form).status, "active")) ? " selected" : ""}></option><option value="inactive"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "inactive") : ssrLooseEqual(unref(form).status, "inactive")) ? " selected" : ""}></option></select></div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$6 = _sfc_main$1$6.setup;
_sfc_main$1$6.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/BranchModal.vue");
  return _sfc_setup$1$6 ? _sfc_setup$1$6(props, ctx) : void 0;
};
const __nuxt_component_0$4 = Object.assign(_sfc_main$1$6, { __name: "BranchModal" });
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const branches = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingBranch = ref(null);
    const filters = reactive({
      search: "",
      status: ""
    });
    const loadBranches = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams();
        if (filters.search) params.append("search", filters.search);
        if (filters.status) params.append("status", filters.status);
        const response = await $fetch(`${config.public.apiBase}/admin/settings/branches?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          branches.value = response.data;
        }
      } catch (err) {
        console.error("Error loading branches:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingBranch.value = null;
    };
    const handleBranchSaved = () => {
      closeModal();
      loadBranches();
    };
    const getStatusName = (status) => {
      const statusNames = {
        active: "",
        inactive: ""
      };
      return statusNames[status] || status;
    };
    const getStatusBadgeClass = (status) => {
      const classes = {
        active: "bg-green-100 text-green-800",
        inactive: "bg-gray-100 text-gray-800"
      };
      return classes[status] || "bg-gray-100 text-gray-800";
    };
    const formatDate = (date) => {
      return format$4(new Date(date), "dd MMM yyyy", { locale: th });
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_BranchModal = __nuxt_component_0$4;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", , " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="active"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "active") : ssrLooseEqual(unref(filters).status, "active")) ? " selected" : ""}></option><option value="inactive"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "inactive") : ssrLooseEqual(unref(filters).status, "inactive")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(branches).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(branches), (branch) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div><div class="text-sm font-medium text-gray-900">${ssrInterpolate(branch.name)}</div><div class="text-sm text-gray-500">: ${ssrInterpolate(branch.code)}</div></div></td><td class="px-6 py-4"><div class="text-sm text-gray-900">${ssrInterpolate(branch.address || "-")}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">`);
          if (branch.phone) {
            _push(`<div>${ssrInterpolate(branch.phone)}</div>`);
          } else {
            _push(`<!---->`);
          }
          if (branch.email) {
            _push(`<div class="text-gray-500">${ssrInterpolate(branch.email)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([getStatusBadgeClass(branch.status), "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusName(branch.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(formatDate(branch.created_at))}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>`);
          if (branch.status === "active") {
            _push(`<button class="text-yellow-600 hover:text-yellow-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"></path></svg></button>`);
          } else {
            _push(`<button class="text-green-600 hover:text-green-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></button>`);
          }
          _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      if (unref(showCreateModal) || unref(editingBranch)) {
        _push(ssrRenderComponent(_component_BranchModal, {
          show: unref(showCreateModal) || !!unref(editingBranch),
          branch: unref(editingBranch),
          onClose: closeModal,
          onSaved: handleBranchSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$j = _sfc_main$j.setup;
_sfc_main$j.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/branches/index.vue");
  return _sfc_setup$j ? _sfc_setup$j(props, ctx) : void 0;
};

const indexCvVx2A2E = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$j
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$5 = /* @__PURE__ */ defineComponent({
  __name: "SubjectModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    subject: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const form = reactive({
      code: "",
      name: "",
      short_name: "",
      description: "",
      icon: ""
    });
    const loading = ref(false);
    const error = ref("");
    watch$1(() => props.subject, (subject) => {
      if (subject) {
        form.code = subject.code;
        form.name = subject.name;
        form.short_name = subject.short_name || "";
        form.description = subject.description || "";
        form.icon = subject.icon || "";
      } else {
        form.code = "";
        form.name = "";
        form.short_name = "";
        form.description = "";
        form.icon = "";
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.subject ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).code)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).short_name)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  (Icon) </label><input${ssrRenderAttr("value", unref(form).icon)} type="text" placeholder=": book, calculator" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).description)}</textarea></div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$5 = _sfc_main$1$5.setup;
_sfc_main$1$5.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/SubjectModal.vue");
  return _sfc_setup$1$5 ? _sfc_setup$1$5(props, ctx) : void 0;
};
const __nuxt_component_0$3 = Object.assign(_sfc_main$1$5, { __name: "SubjectModal" });
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const subjects = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingSubject = ref(null);
    const filters = reactive({
      search: ""
    });
    const loadSubjects = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams();
        if (filters.search) params.append("search", filters.search);
        const response = await $fetch(`${config.public.apiBase}/admin/settings/subjects?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          subjects.value = response.data;
        }
      } catch (err) {
        console.error("Error loading subjects:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingSubject.value = null;
    };
    const handleSubjectSaved = () => {
      closeModal();
      loadSubjects();
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_SubjectModal = __nuxt_component_0$3;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", , " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(subjects).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(subjects), (subject) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(subject.code)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(subject.name)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-500">${ssrInterpolate(subject.short_name || "-")}</div></td><td class="px-6 py-4"><div class="text-sm text-gray-500 max-w-xs truncate">${ssrInterpolate(subject.description || "-")}</div></td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button><button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      if (unref(showCreateModal) || unref(editingSubject)) {
        _push(ssrRenderComponent(_component_SubjectModal, {
          show: unref(showCreateModal) || !!unref(editingSubject),
          subject: unref(editingSubject),
          onClose: closeModal,
          onSaved: handleSubjectSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$i = _sfc_main$i.setup;
_sfc_main$i.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/subjects/index.vue");
  return _sfc_setup$i ? _sfc_setup$i(props, ctx) : void 0;
};

const indexDVcRUuY6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$i
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$4 = /* @__PURE__ */ defineComponent({
  __name: "InclusionModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    inclusion: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const form = reactive({
      code: "",
      name: "",
      description: "",
      icon: ""
    });
    const loading = ref(false);
    const error = ref("");
    watch$1(() => props.inclusion, (inclusion) => {
      if (inclusion) {
        form.code = inclusion.code;
        form.name = inclusion.name;
        form.description = inclusion.description || "";
        form.icon = inclusion.icon || "";
      } else {
        form.code = "";
        form.name = "";
        form.description = "";
        form.icon = "";
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.inclusion ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).code)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  (Icon) </label><input${ssrRenderAttr("value", unref(form).icon)} type="text" placeholder=": book, gift" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).description)}</textarea></div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$4 = _sfc_main$1$4.setup;
_sfc_main$1$4.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/InclusionModal.vue");
  return _sfc_setup$1$4 ? _sfc_setup$1$4(props, ctx) : void 0;
};
const __nuxt_component_0$2 = Object.assign(_sfc_main$1$4, { __name: "InclusionModal" });
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const inclusions = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingInclusion = ref(null);
    const filters = reactive({
      search: ""
    });
    const loadInclusions = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams();
        if (filters.search) params.append("search", filters.search);
        const response = await $fetch(`${config.public.apiBase}/admin/settings/inclusions?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          inclusions.value = response.data;
        }
      } catch (err) {
        console.error("Error loading inclusions:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingInclusion.value = null;
    };
    const handleInclusionSaved = () => {
      closeModal();
      loadInclusions();
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_InclusionModal = __nuxt_component_0$2;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", , " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(inclusions).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(inclusions), (inclusion) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(inclusion.code)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(inclusion.name)}</div></td><td class="px-6 py-4"><div class="text-sm text-gray-500 max-w-xs truncate">${ssrInterpolate(inclusion.description || "-")}</div></td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button><button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      if (unref(showCreateModal) || unref(editingInclusion)) {
        _push(ssrRenderComponent(_component_InclusionModal, {
          show: unref(showCreateModal) || !!unref(editingInclusion),
          inclusion: unref(editingInclusion),
          onClose: closeModal,
          onSaved: handleInclusionSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$h = _sfc_main$h.setup;
_sfc_main$h.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/inclusions/index.vue");
  return _sfc_setup$h ? _sfc_setup$h(props, ctx) : void 0;
};

const indexDh96TKdI = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$h
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$3 = /* @__PURE__ */ defineComponent({
  __name: "TestimonialModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    testimonial: {}
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const loading = ref(false);
    const uploadingAvatar = ref(false);
    ref(null);
    const uploadError = ref("");
    const form = reactive({
      name: "",
      role: "",
      comment: "",
      rating: 5,
      avatar_url: "",
      status: "pending",
      display_order: 0
    });
    watch$1(() => props.show, (newVal) => {
      if (newVal) {
        if (props.testimonial) {
          form.name = props.testimonial.name || "";
          form.role = props.testimonial.role || "";
          form.comment = props.testimonial.comment || "";
          form.rating = props.testimonial.rating || 5;
          form.avatar_url = props.testimonial.avatar_url || "";
          form.status = props.testimonial.status;
          form.display_order = props.testimonial.display_order || 0;
        } else {
          resetForm();
        }
      }
    });
    const resetForm = () => {
      form.name = "";
      form.role = "";
      form.comment = "";
      form.rating = 5;
      form.avatar_url = "";
      form.status = "pending";
      form.display_order = 0;
      uploadError.value = "";
    };
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.testimonial ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> / <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).role)} type="text" required placeholder=" ,  .3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option${ssrRenderAttr("value", 1)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).rating) ? ssrLooseContain(unref(form).rating, 1) : ssrLooseEqual(unref(form).rating, 1)) ? " selected" : ""}>1 </option><option${ssrRenderAttr("value", 2)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).rating) ? ssrLooseContain(unref(form).rating, 2) : ssrLooseEqual(unref(form).rating, 2)) ? " selected" : ""}>2 </option><option${ssrRenderAttr("value", 3)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).rating) ? ssrLooseContain(unref(form).rating, 3) : ssrLooseEqual(unref(form).rating, 3)) ? " selected" : ""}>3 </option><option${ssrRenderAttr("value", 4)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).rating) ? ssrLooseContain(unref(form).rating, 4) : ssrLooseEqual(unref(form).rating, 4)) ? " selected" : ""}>4 </option><option${ssrRenderAttr("value", 5)}${ssrIncludeBooleanAttr(Array.isArray(unref(form).rating) ? ssrLooseContain(unref(form).rating, 5) : ssrLooseEqual(unref(form).rating, 5)) ? " selected" : ""}>5 </option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="pending"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "pending") : ssrLooseEqual(unref(form).status, "pending")) ? " selected" : ""}></option><option value="approved"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "approved") : ssrLooseEqual(unref(form).status, "approved")) ? " selected" : ""}></option><option value="rejected"${ssrIncludeBooleanAttr(Array.isArray(unref(form).status) ? ssrLooseContain(unref(form).status, "rejected") : ssrLooseEqual(unref(form).status, "rejected")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).display_order)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  (Avatar) </label><div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3"><p class="text-sm font-semibold text-blue-900 mb-1"> :</p><ul class="text-xs text-blue-800 space-y-1 list-disc list-inside"><li><strong>:</strong> 400 x 400 pixels</li><li><strong>:</strong> 1:1 ()</li><li><strong>:</strong> JPG, PNG, WebP</li><li><strong>:</strong>  1 MB</li></ul></div><div class="space-y-3">`);
        if (unref(uploadingAvatar)) {
          _push(`<div class="text-sm text-gray-600 py-2"> ... </div>`);
        } else if (unref(form).avatar_url) {
          _push(`<div class="space-y-3"><p class="text-sm text-gray-600">:</p><div class="w-32 h-32 bg-gray-200 rounded-full overflow-hidden border-2 border-gray-300"><img${ssrRenderAttr("src", unref(form).avatar_url)} alt="Avatar preview" class="w-full h-full object-cover"></div><button type="button" class="px-3 py-2 text-sm text-red-600 hover:bg-red-50 rounded-lg border border-red-200">  </button></div>`);
        } else {
          _push(`<div class="border-2 border-dashed border-gray-300 rounded-lg p-4"><input type="file" accept="image/jpeg,image/png,image/webp" class="hidden"><button type="button" class="w-full px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"><svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>  Avatar </button><p class="text-xs text-gray-500 mt-2 text-center">: JPG, PNG, WebP ( 1 MB)</p></div>`);
        }
        _push(`</div>`);
        if (unref(uploadError)) {
          _push(`<p class="mt-2 text-sm text-red-600">${ssrInterpolate(unref(uploadError))}</p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><textarea rows="5" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).comment)}</textarea></div></div><div class="flex justify-end space-x-4 pt-4 border-t"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">${ssrInterpolate(unref(loading) ? "..." : "")}</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$3 = _sfc_main$1$3.setup;
_sfc_main$1$3.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/TestimonialModal.vue");
  return _sfc_setup$1$3 ? _sfc_setup$1$3(props, ctx) : void 0;
};
const __nuxt_component_0$1 = Object.assign(_sfc_main$1$3, { __name: "TestimonialModal" });
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const testimonials = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingTestimonial = ref(null);
    const filters = reactive({
      search: "",
      status: ""
    });
    const loadTestimonials = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams();
        if (filters.search) params.append("search", filters.search);
        if (filters.status) params.append("status", filters.status);
        const response = await $fetch(`${config.public.apiBase}/admin/testimonials?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          testimonials.value = response.data;
        }
      } catch (err) {
        console.error("Error loading testimonials:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const getStatusName = (status) => {
      const statusNames = {
        pending: "",
        approved: "",
        rejected: ""
      };
      return statusNames[status] || status;
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingTestimonial.value = null;
    };
    const handleTestimonialSaved = () => {
      closeModal();
      loadTestimonials();
    };
    useConfirm();
    return (_ctx, _push, _parent, _attrs) => {
      const _component_TestimonialModal = __nuxt_component_0$1;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", , " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "") : ssrLooseEqual(unref(filters).status, "")) ? " selected" : ""}></option><option value="pending"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "pending") : ssrLooseEqual(unref(filters).status, "pending")) ? " selected" : ""}></option><option value="approved"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "approved") : ssrLooseEqual(unref(filters).status, "approved")) ? " selected" : ""}></option><option value="rejected"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).status) ? ssrLooseContain(unref(filters).status, "rejected") : ssrLooseEqual(unref(filters).status, "rejected")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(testimonials).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(testimonials), (testimonial) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="flex items-center">`);
          if (testimonial.avatar_url) {
            _push(`<div class="h-10 w-10 rounded-full bg-gray-200 mr-3 overflow-hidden"><img${ssrRenderAttr("src", testimonial.avatar_url)}${ssrRenderAttr("alt", testimonial.name)} class="h-full w-full object-cover"></div>`);
          } else {
            _push(`<div class="h-10 w-10 rounded-full bg-green-500 flex items-center justify-center text-white font-semibold mr-3">${ssrInterpolate(testimonial.name[0])}</div>`);
          }
          _push(`<div class="text-sm font-medium text-gray-900">${ssrInterpolate(testimonial.name)}</div></div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(testimonial.role)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="flex items-center gap-1"><!--[-->`);
          ssrRenderList(5, (i) => {
            _push(`<svg class="${ssrRenderClass([i <= testimonial.rating ? "text-yellow-400" : "text-gray-300", "w-4 h-4"])}" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>`);
          });
          _push(`<!--]--></div></td><td class="px-6 py-4"><div class="text-sm text-gray-900 line-clamp-2">${ssrInterpolate(testimonial.comment)}</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([{
            "bg-yellow-100 text-yellow-800": testimonial.status === "pending",
            "bg-green-100 text-green-800": testimonial.status === "approved",
            "bg-red-100 text-red-800": testimonial.status === "rejected"
          }, "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getStatusName(testimonial.status))}</span></td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button><button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      _push(ssrRenderComponent(_component_TestimonialModal, {
        show: unref(showCreateModal) || unref(editingTestimonial) !== null,
        testimonial: unref(editingTestimonial),
        onClose: closeModal,
        onSaved: handleTestimonialSaved
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$g = _sfc_main$g.setup;
_sfc_main$g.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/content/testimonials/index.vue");
  return _sfc_setup$g ? _sfc_setup$g(props, ctx) : void 0;
};

const indexFkEPeqsA = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$g
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$2 = /* @__PURE__ */ defineComponent({
  __name: "GradeLevelModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    gradeLevel: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const form = reactive({
      code: "",
      name: "",
      level_type: "elementary",
      grade_number: 1,
      display_order: 0
    });
    const loading = ref(false);
    const error = ref("");
    watch$1(() => props.gradeLevel, (gradeLevel) => {
      if (gradeLevel) {
        form.code = gradeLevel.code;
        form.name = gradeLevel.name;
        form.level_type = gradeLevel.level_type;
        form.grade_number = gradeLevel.grade_number;
        form.display_order = gradeLevel.display_order;
      } else {
        form.code = "";
        form.name = "";
        form.level_type = "elementary";
        form.grade_number = 1;
        form.display_order = 0;
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.gradeLevel ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).code)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="elementary"${ssrIncludeBooleanAttr(Array.isArray(unref(form).level_type) ? ssrLooseContain(unref(form).level_type, "elementary") : ssrLooseEqual(unref(form).level_type, "elementary")) ? " selected" : ""}></option><option value="secondary"${ssrIncludeBooleanAttr(Array.isArray(unref(form).level_type) ? ssrLooseContain(unref(form).level_type, "secondary") : ssrLooseEqual(unref(form).level_type, "secondary")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).grade_number)} type="number" min="1" max="6" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).display_order)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$2 = _sfc_main$1$2.setup;
_sfc_main$1$2.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/GradeLevelModal.vue");
  return _sfc_setup$1$2 ? _sfc_setup$1$2(props, ctx) : void 0;
};
const __nuxt_component_0 = Object.assign(_sfc_main$1$2, { __name: "GradeLevelModal" });
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const config = useRuntimeConfig();
    const { accessToken } = useAuth();
    const gradeLevels = ref([]);
    const loading = ref(false);
    const error = ref("");
    const showCreateModal = ref(false);
    const editingGradeLevel = ref(null);
    const filters = reactive({
      search: "",
      level_type: ""
    });
    const loadGradeLevels = async () => {
      loading.value = true;
      error.value = "";
      try {
        const params = new URLSearchParams();
        if (filters.search) params.append("search", filters.search);
        if (filters.level_type) params.append("level_type", filters.level_type);
        const response = await $fetch(`${config.public.apiBase}/admin/settings/grade-levels?${params.toString()}`, {
          headers: {
            Authorization: `Bearer ${accessToken.value}`
          }
        });
        if (response.success) {
          gradeLevels.value = response.data;
        }
      } catch (err) {
        console.error("Error loading grade levels:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      showCreateModal.value = false;
      editingGradeLevel.value = null;
    };
    const handleGradeLevelSaved = () => {
      closeModal();
      loadGradeLevels();
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_GradeLevelModal = __nuxt_component_0;
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><h1 class="text-3xl font-bold"></h1><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow p-4 mb-6"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><input${ssrRenderAttr("value", unref(filters).search)} type="text" placeholder=", " class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"></label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(unref(filters).level_type) ? ssrLooseContain(unref(filters).level_type, "") : ssrLooseEqual(unref(filters).level_type, "")) ? " selected" : ""}></option><option value="elementary"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).level_type) ? ssrLooseContain(unref(filters).level_type, "elementary") : ssrLooseEqual(unref(filters).level_type, "elementary")) ? " selected" : ""}></option><option value="secondary"${ssrIncludeBooleanAttr(Array.isArray(unref(filters).level_type) ? ssrLooseContain(unref(filters).level_type, "secondary") : ssrLooseEqual(unref(filters).level_type, "secondary")) ? " selected" : ""}></option></select></div></div></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(gradeLevels).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(gradeLevels), (gradeLevel) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(gradeLevel.code)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm text-gray-900">${ssrInterpolate(gradeLevel.name)}</div></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([gradeLevel.level_type === "elementary" ? "bg-blue-100 text-blue-800" : "bg-purple-100 text-purple-800", "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(gradeLevel.level_type === "elementary" ? "" : "")}</span></td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${ssrInterpolate(gradeLevel.display_order || 0)}</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button><button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      if (unref(showCreateModal) || unref(editingGradeLevel)) {
        _push(ssrRenderComponent(_component_GradeLevelModal, {
          show: unref(showCreateModal) || !!unref(editingGradeLevel),
          "grade-level": unref(editingGradeLevel),
          onClose: closeModal,
          onSaved: handleGradeLevelSaved
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$f = _sfc_main$f.setup;
_sfc_main$f.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/grade-levels/index.vue");
  return _sfc_setup$f ? _sfc_setup$f(props, ctx) : void 0;
};

const indexDXtBDEsv = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$f
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "PaymentMethodModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    method: { default: null }
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const loading = ref(false);
    const error = ref("");
    const form = reactive({
      code: "",
      name: "",
      name_en: "",
      type: "bank_transfer",
      description: "",
      icon: "",
      is_active: true,
      is_default: false,
      display_order: 0
    });
    watch$1(() => props.method, (method) => {
      if (method) {
        form.code = method.code || "";
        form.name = method.name || "";
        form.name_en = method.name_en || "";
        form.type = method.type || "bank_transfer";
        form.description = method.description || "";
        form.icon = method.icon || "";
        form.is_active = method.is_active !== void 0 ? method.is_active : true;
        form.is_default = method.is_default !== void 0 ? method.is_default : false;
        form.display_order = method.display_order || 0;
      } else {
        form.code = "";
        form.name = "";
        form.name_en = "";
        form.type = "bank_transfer";
        form.description = "";
        form.icon = "";
        form.is_active = true;
        form.is_default = false;
        form.display_order = 0;
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.method ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  (Code) <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).code)} type="text" required${ssrIncludeBooleanAttr(!!__props.method) ? " disabled" : ""} pattern="[a-z0-9_]+" placeholder="bank_transfer" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 disabled:bg-gray-100"><p class="mt-1 text-xs text-gray-500">,   _ </p></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><select required${ssrIncludeBooleanAttr(!!__props.method) ? " disabled" : ""} class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 disabled:bg-gray-100"><option value="bank_transfer"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "bank_transfer") : ssrLooseEqual(unref(form).type, "bank_transfer")) ? " selected" : ""}></option><option value="payment_gateway"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "payment_gateway") : ssrLooseEqual(unref(form).type, "payment_gateway")) ? " selected" : ""}>Payment Gateway</option><option value="other"${ssrIncludeBooleanAttr(Array.isArray(unref(form).type) ? ssrLooseContain(unref(form).type, "other") : ssrLooseEqual(unref(form).type, "other")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  () <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  () </label><input${ssrRenderAttr("value", unref(form).name_en)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="2" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).description)}</textarea></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Icon URL </label><input${ssrRenderAttr("value", unref(form).icon)} type="url" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).display_order)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2 flex items-center space-x-4"><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, null) : unref(form).is_active) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_default) ? ssrLooseContain(unref(form).is_default, null) : unref(form).is_default) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label></div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$e = _sfc_main$e.setup;
_sfc_main$e.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/PaymentMethodModal.vue");
  return _sfc_setup$e ? _sfc_setup$e(props, ctx) : void 0;
};

const PaymentMethodModalBnfeOhC_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$e
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "PaymentMethodBasicInfo",
  __ssrInlineRender: true,
  props: {
    method: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const error = ref("");
    const form = reactive({
      name: "",
      name_en: "",
      description: "",
      icon: "",
      is_active: true,
      is_default: false,
      display_order: 0
    });
    watch$1(() => props.method, (method) => {
      if (method) {
        form.name = method.name || "";
        form.name_en = method.name_en || "";
        form.description = method.description || "";
        form.icon = method.icon || "";
        form.is_active = method.is_active !== void 0 ? method.is_active : true;
        form.is_default = method.is_default !== void 0 ? method.is_default : false;
        form.display_order = method.display_order || 0;
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  () <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  () </label><input${ssrRenderAttr("value", unref(form).name_en)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2">  </label><textarea rows="2" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">${ssrInterpolate(unref(form).description)}</textarea></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Icon URL </label><input${ssrRenderAttr("value", unref(form).icon)} type="url" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).display_order)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2 flex items-center space-x-4"><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, null) : unref(form).is_active) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_default) ? ssrLooseContain(unref(form).is_default, null) : unref(form).is_default) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label></div></div>`);
      if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex justify-end space-x-3 pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
      if (unref(saving)) {
        _push(`<span>...</span>`);
      } else {
        _push(`<span></span>`);
      }
      _push(`</button></div></form></div>`);
    };
  }
});
const _sfc_setup$d = _sfc_main$d.setup;
_sfc_main$d.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/PaymentMethodBasicInfo.vue");
  return _sfc_setup$d ? _sfc_setup$d(props, ctx) : void 0;
};

const PaymentMethodBasicInfoDluNVwrX = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$d
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "BankAccountModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    account: { default: null },
    paymentMethodId: {}
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const loading = ref(false);
    const error = ref("");
    const form = reactive({
      bank_name: "",
      account_name: "",
      account_number: "",
      account_type: "savings",
      branch_name: "",
      qr_code_url: "",
      is_active: true,
      is_default: false,
      display_order: 0
    });
    watch$1(() => props.account, (account) => {
      if (account) {
        form.bank_name = account.bank_name || "";
        form.account_name = account.account_name || "";
        form.account_number = account.account_number || "";
        form.account_type = account.account_type || "savings";
        form.branch_name = account.branch_name || "";
        form.qr_code_url = account.qr_code_url || "";
        form.is_active = account.is_active !== void 0 ? account.is_active : true;
        form.is_default = account.is_default !== void 0 ? account.is_default : false;
        form.display_order = account.display_order || 0;
      } else {
        form.bank_name = "";
        form.account_name = "";
        form.account_number = "";
        form.account_type = "savings";
        form.branch_name = "";
        form.qr_code_url = "";
        form.is_active = true;
        form.is_default = false;
        form.display_order = 0;
      }
      error.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">${ssrInterpolate(__props.account ? "" : "")}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).bank_name)} type="text" required placeholder="" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).account_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).account_number)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><select class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"><option value="savings"${ssrIncludeBooleanAttr(Array.isArray(unref(form).account_type) ? ssrLooseContain(unref(form).account_type, "savings") : ssrLooseEqual(unref(form).account_type, "savings")) ? " selected" : ""}></option><option value="current"${ssrIncludeBooleanAttr(Array.isArray(unref(form).account_type) ? ssrLooseContain(unref(form).account_type, "current") : ssrLooseEqual(unref(form).account_type, "current")) ? " selected" : ""}></option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).branch_name)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> QR Code URL </label><input${ssrRenderAttr("value", unref(form).qr_code_url)} type="url" placeholder="https://example.com/qr-code.png" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2">  </label><input${ssrRenderAttr("value", unref(form).display_order)} type="number" min="0" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div class="md:col-span-2 flex items-center space-x-4"><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, null) : unref(form).is_active) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_default) ? ssrLooseContain(unref(form).is_default, null) : unref(form).is_default) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label></div></div>`);
        if (unref(error)) {
          _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<div class="flex justify-end space-x-3 pt-4"><button type="button" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100">  </button><button type="submit"${ssrIncludeBooleanAttr(unref(loading)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
        if (unref(loading)) {
          _push(`<span>...</span>`);
        } else {
          _push(`<span></span>`);
        }
        _push(`</button></div></form></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$c = _sfc_main$c.setup;
_sfc_main$c.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/BankAccountModal.vue");
  return _sfc_setup$c ? _sfc_setup$c(props, ctx) : void 0;
};

const BankAccountModalTDo4EpJK = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$c
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "BankAccountsSection",
  __ssrInlineRender: true,
  props: {
    paymentMethodId: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { accessToken } = useAuth();
    useConfirm();
    const loading = ref(false);
    const error = ref(null);
    const accounts = ref([]);
    const showCreateModal = ref(false);
    const editingAccount = ref(null);
    const loadAccounts = async () => {
      try {
        loading.value = true;
        error.value = null;
        const response = await $fetch(
          `/api/admin/settings/payment-methods/${props.paymentMethodId}/bank-accounts`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          accounts.value = response.data;
        } else {
          error.value = "";
        }
      } catch (err) {
        console.error("Error loading bank accounts:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeModal = () => {
      editingAccount.value = null;
      showCreateModal.value = false;
    };
    const handleSaved = () => {
      closeModal();
      loadAccounts();
      emit("saved");
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}><div class="flex items-center justify-between"><h3 class="text-lg font-semibold"></h3><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm">  </button></div>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-8"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(accounts).length === 0) {
        _push(`<div class="text-center py-8 text-gray-500">  </div>`);
      } else {
        _push(`<div class="grid grid-cols-1 md:grid-cols-2 gap-4"><!--[-->`);
        ssrRenderList(unref(accounts), (account) => {
          _push(`<div class="${ssrRenderClass([{ "border-green-500 bg-green-50": account.is_default }, "border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow"])}"><div class="flex items-start justify-between"><div class="flex-1"><div class="flex items-center gap-2 mb-2"><h4 class="font-semibold text-lg">${ssrInterpolate(account.bank_name)}</h4>`);
          if (account.is_default) {
            _push(`<span class="px-2 py-1 text-xs font-medium bg-yellow-100 text-yellow-800 rounded">  </span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div><div class="text-sm text-gray-600 space-y-1"><p><span class="font-medium">:</span> ${ssrInterpolate(account.account_name)}</p><p><span class="font-medium">:</span> ${ssrInterpolate(account.account_number)}</p>`);
          if (account.branch_name) {
            _push(`<p><span class="font-medium">:</span> ${ssrInterpolate(account.branch_name)}</p>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<p><span class="font-medium">:</span> ${ssrInterpolate(account.account_type === "savings" ? "" : "")}</p></div>`);
          if (account.qr_code_url) {
            _push(`<div class="mt-3"><img${ssrRenderAttr("src", account.qr_code_url)} alt="QR Code" class="w-32 h-32 object-contain border border-gray-200 rounded"></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div><div class="flex flex-col gap-2 ml-4"><button class="text-blue-600 hover:text-blue-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>`);
          if (!account.is_default) {
            _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div></div>`);
        });
        _push(`<!--]--></div>`);
      }
      _push(ssrRenderComponent(_sfc_main$c, {
        show: unref(showCreateModal) || !!unref(editingAccount),
        account: unref(editingAccount),
        "payment-method-id": __props.paymentMethodId,
        onClose: closeModal,
        onSaved: handleSaved
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$b = _sfc_main$b.setup;
_sfc_main$b.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/BankAccountsSection.vue");
  return _sfc_setup$b ? _sfc_setup$b(props, ctx) : void 0;
};

const BankAccountsSectionDvbJydEj = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$b
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "StripeConfig",
  __ssrInlineRender: true,
  props: {
    gatewayConfig: {},
    paymentMethodId: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const saveError = ref("");
    const form = reactive({
      gateway_code: "stripe",
      gateway_name: "Stripe",
      api_key: "",
      api_secret: "",
      webhook_secret: "",
      is_test_mode: true,
      is_active: false
    });
    watch$1(() => props.gatewayConfig, (config) => {
      if (config) {
        form.gateway_code = config.gateway_code || "stripe";
        form.gateway_name = config.gateway_name || "Stripe";
        form.api_key = config.api_key || "";
        form.is_test_mode = config.is_test_mode !== void 0 ? config.is_test_mode : true;
        form.is_active = config.is_active !== void 0 ? config.is_active : false;
      } else {
        form.gateway_code = "stripe";
        form.gateway_name = "Stripe";
        form.api_key = "";
        form.api_secret = "";
        form.webhook_secret = "";
        form.is_test_mode = true;
        form.is_active = false;
      }
      saveError.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "bg-white rounded-lg shadow p-6" }, _attrs))}><h3 class="text-lg font-semibold mb-4"> Stripe</h3><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2"> Gateway Name </label><input${ssrRenderAttr("value", unref(form).gateway_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Publishable Key (API Key) <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).api_key)} type="text" required placeholder="pk_test_..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Secret Key (API Secret) <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).api_secret)} type="password" required placeholder="sk_test_..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm">`);
      if (__props.gatewayConfig?.api_secret) {
        _push(`<p class="mt-1 text-xs text-gray-500"> : ${ssrInterpolate(__props.gatewayConfig.api_secret)} () </p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Webhook Secret </label><input${ssrRenderAttr("value", unref(form).webhook_secret)} type="password" placeholder="whsec_..." class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm">`);
      if (__props.gatewayConfig?.webhook_secret) {
        _push(`<p class="mt-1 text-xs text-gray-500"> : ${ssrInterpolate(__props.gatewayConfig.webhook_secret)} () </p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div><div class="flex items-center space-x-4"><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_test_mode) ? ssrLooseContain(unref(form).is_test_mode, null) : unref(form).is_test_mode) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700">Test Mode ()</span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, null) : unref(form).is_active) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label></div>`);
      if (unref(saveError)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(saveError))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex justify-end space-x-3 pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
      if (unref(saving)) {
        _push(`<span>...</span>`);
      } else {
        _push(`<span></span>`);
      }
      _push(`</button></div></form></div>`);
    };
  }
});
const _sfc_setup$a = _sfc_main$a.setup;
_sfc_main$a.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/gateway/StripeConfig.vue");
  return _sfc_setup$a ? _sfc_setup$a(props, ctx) : void 0;
};

const StripeConfig8Ff2Qb4D = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$a
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "KsherConfig",
  __ssrInlineRender: true,
  props: {
    gatewayConfig: {},
    paymentMethodId: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const saveError = ref("");
    const form = reactive({
      gateway_code: "ksher",
      gateway_name: "Ksher Thailand",
      merchant_id: "",
      api_key: "",
      api_secret: "",
      webhook_secret: "",
      endpoint_url: "",
      is_test_mode: true,
      is_active: false
    });
    watch$1(() => props.gatewayConfig, (config) => {
      if (config) {
        form.gateway_code = config.gateway_code || "ksher";
        form.gateway_name = config.gateway_name || "Ksher Thailand";
        form.merchant_id = config.merchant_id || "";
        form.api_key = config.api_key || "";
        form.endpoint_url = config.endpoint_url || "";
        form.is_test_mode = config.is_test_mode !== void 0 ? config.is_test_mode : true;
        form.is_active = config.is_active !== void 0 ? config.is_active : false;
      } else {
        form.gateway_code = "ksher";
        form.gateway_name = "Ksher Thailand";
        form.merchant_id = "";
        form.api_key = "";
        form.api_secret = "";
        form.webhook_secret = "";
        form.endpoint_url = "";
        form.is_test_mode = true;
        form.is_active = false;
      }
      saveError.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "bg-white rounded-lg shadow p-6" }, _attrs))}><h3 class="text-lg font-semibold mb-4"> Ksher Thailand</h3><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="md:col-span-2"><label class="block text-sm font-medium text-gray-700 mb-2"> Gateway Name </label><input${ssrRenderAttr("value", unref(form).gateway_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Merchant ID <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).merchant_id)} type="text" required placeholder="Your Merchant ID" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> API Key <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).api_key)} type="text" required placeholder="Your API Key" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> API Secret <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).api_secret)} type="password" required placeholder="Your API Secret" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm">`);
      if (__props.gatewayConfig?.api_secret) {
        _push(`<p class="mt-1 text-xs text-gray-500"> : ${ssrInterpolate(__props.gatewayConfig.api_secret)} () </p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Webhook Secret </label><input${ssrRenderAttr("value", unref(form).webhook_secret)} type="password" placeholder="Your Webhook Secret" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm">`);
      if (__props.gatewayConfig?.webhook_secret) {
        _push(`<p class="mt-1 text-xs text-gray-500"> : ${ssrInterpolate(__props.gatewayConfig.webhook_secret)} () </p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Endpoint URL </label><input${ssrRenderAttr("value", unref(form).endpoint_url)} type="url" placeholder="https://api.ksher.com" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div class="flex items-center space-x-4"><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_test_mode) ? ssrLooseContain(unref(form).is_test_mode, null) : unref(form).is_test_mode) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700">Test Mode ( Sandbox)</span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, null) : unref(form).is_active) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label></div>`);
      if (unref(saveError)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(saveError))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex justify-end space-x-3 pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
      if (unref(saving)) {
        _push(`<span>...</span>`);
      } else {
        _push(`<span></span>`);
      }
      _push(`</button></div></form></div>`);
    };
  }
});
const _sfc_setup$9 = _sfc_main$9.setup;
_sfc_main$9.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/gateway/KsherConfig.vue");
  return _sfc_setup$9 ? _sfc_setup$9(props, ctx) : void 0;
};

const KsherConfigCzUwN_np = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$9
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "GenericGatewayConfig",
  __ssrInlineRender: true,
  props: {
    gatewayConfig: {},
    paymentMethodId: {},
    gatewayCode: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    useAuth();
    const saving = ref(false);
    const saveError = ref("");
    const form = reactive({
      gateway_code: "",
      gateway_name: "",
      api_key: "",
      api_secret: "",
      merchant_id: "",
      webhook_secret: "",
      endpoint_url: "",
      is_test_mode: true,
      is_active: false
    });
    watch$1(() => [props.gatewayConfig, props.gatewayCode], ([config, code]) => {
      if (config) {
        form.gateway_code = config.gateway_code || code || "";
        form.gateway_name = config.gateway_name || "";
        form.api_key = config.api_key || "";
        form.merchant_id = config.merchant_id || "";
        form.endpoint_url = config.endpoint_url || "";
        form.is_test_mode = config.is_test_mode !== void 0 ? config.is_test_mode : true;
        form.is_active = config.is_active !== void 0 ? config.is_active : false;
      } else {
        form.gateway_code = code || "";
        form.gateway_name = "";
        form.api_key = "";
        form.api_secret = "";
        form.merchant_id = "";
        form.webhook_secret = "";
        form.endpoint_url = "";
        form.is_test_mode = true;
        form.is_active = false;
      }
      saveError.value = "";
    }, { immediate: true });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "bg-white rounded-lg shadow p-6" }, _attrs))}><h3 class="text-lg font-semibold mb-4"> Gateway</h3><form class="space-y-4"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-2"> Gateway Code <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).gateway_code)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Gateway Name <span class="text-red-500">*</span></label><input${ssrRenderAttr("value", unref(form).gateway_name)} type="text" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> API Key </label><input${ssrRenderAttr("value", unref(form).api_key)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> API Secret </label><input${ssrRenderAttr("value", unref(form).api_secret)} type="password" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm">`);
      if (__props.gatewayConfig?.api_secret) {
        _push(`<p class="mt-1 text-xs text-gray-500"> : ${ssrInterpolate(__props.gatewayConfig.api_secret)} () </p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Merchant ID </label><input${ssrRenderAttr("value", unref(form).merchant_id)} type="text" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Webhook Secret </label><input${ssrRenderAttr("value", unref(form).webhook_secret)} type="password" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 font-mono text-sm"></div><div><label class="block text-sm font-medium text-gray-700 mb-2"> Endpoint URL </label><input${ssrRenderAttr("value", unref(form).endpoint_url)} type="url" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500"></div></div><div class="flex items-center space-x-4"><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_test_mode) ? ssrLooseContain(unref(form).is_test_mode, null) : unref(form).is_test_mode) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700">Test Mode</span></label><label class="flex items-center"><input${ssrIncludeBooleanAttr(Array.isArray(unref(form).is_active) ? ssrLooseContain(unref(form).is_active, null) : unref(form).is_active) ? " checked" : ""} type="checkbox" class="w-4 h-4 text-green-600 border-gray-300 rounded focus:ring-green-500"><span class="ml-2 text-sm text-gray-700"></span></label></div>`);
      if (unref(saveError)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(saveError))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex justify-end space-x-3 pt-4"><button type="submit"${ssrIncludeBooleanAttr(unref(saving)) ? " disabled" : ""} class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">`);
      if (unref(saving)) {
        _push(`<span>...</span>`);
      } else {
        _push(`<span></span>`);
      }
      _push(`</button></div></form></div>`);
    };
  }
});
const _sfc_setup$8 = _sfc_main$8.setup;
_sfc_main$8.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/gateway/GenericGatewayConfig.vue");
  return _sfc_setup$8 ? _sfc_setup$8(props, ctx) : void 0;
};

const GenericGatewayConfigCywwJcQF = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$8
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "GatewayConfigSection",
  __ssrInlineRender: true,
  props: {
    paymentMethodId: {},
    gatewayCode: {}
  },
  emits: ["saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { accessToken } = useAuth();
    const loading = ref(false);
    const error = ref(null);
    const gatewayConfig = ref(null);
    const loadGatewayConfig = async () => {
      try {
        loading.value = true;
        error.value = null;
        const response = await $fetch(
          `/api/admin/settings/payment-methods/${props.paymentMethodId}/gateway`,
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          gatewayConfig.value = response.data;
        } else {
          error.value = " Gateway ";
        }
      } catch (err) {
        console.error("Error loading gateway config:", err);
        error.value = err.data?.message || " Gateway";
      } finally {
        loading.value = false;
      }
    };
    const handleSaved = () => {
      loadGatewayConfig();
      emit("saved");
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "space-y-6" }, _attrs))}>`);
      if (unref(loading)) {
        _push(`<div class="text-center py-8"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else {
        _push(`<div>`);
        if (__props.gatewayCode === "stripe") {
          _push(ssrRenderComponent(_sfc_main$a, {
            "gateway-config": unref(gatewayConfig),
            "payment-method-id": __props.paymentMethodId,
            onSaved: handleSaved
          }, null, _parent));
        } else if (__props.gatewayCode === "ksher") {
          _push(ssrRenderComponent(_sfc_main$9, {
            "gateway-config": unref(gatewayConfig),
            "payment-method-id": __props.paymentMethodId,
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(ssrRenderComponent(_sfc_main$8, {
            "gateway-config": unref(gatewayConfig),
            "payment-method-id": __props.paymentMethodId,
            "gateway-code": __props.gatewayCode,
            onSaved: handleSaved
          }, null, _parent));
        }
        _push(`</div>`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$7 = _sfc_main$7.setup;
_sfc_main$7.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/GatewayConfigSection.vue");
  return _sfc_setup$7 ? _sfc_setup$7(props, ctx) : void 0;
};

const GatewayConfigSectionDQwVCOTd = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$7
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "PaymentMethodDetailModal",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    method: {}
  },
  emits: ["close", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const activeTab = ref("basic");
    const tabs = computed(() => {
      const baseTabs = [
        { id: "basic", label: "" }
      ];
      if (props.method?.type === "bank_transfer") {
        baseTabs.push({ id: "bank_accounts", label: "" });
      } else if (props.method?.type === "payment_gateway") {
        baseTabs.push({ id: "gateway", label: " Gateway" });
      }
      return baseTabs;
    });
    const handleSaved = () => {
      emit("saved");
    };
    return (_ctx, _push, _parent, _attrs) => {
      if (__props.show && __props.method) {
        _push(`<div${ssrRenderAttrs(mergeProps({ class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" }, _attrs))}><div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto"><div class="flex items-center justify-between mb-6"><h2 class="text-2xl font-bold">: ${ssrInterpolate(__props.method.name)}</h2><button class="text-gray-400 hover:text-gray-600"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><div class="flex items-center gap-4 mb-6 border-b border-gray-200"><!--[-->`);
        ssrRenderList(unref(tabs), (tab) => {
          _push(`<button class="${ssrRenderClass([unref(activeTab) === tab.id ? "text-green-600 border-b-2 border-green-600" : "text-gray-600 hover:text-green-600", "px-4 py-2 font-semibold transition-colors relative"])}">${ssrInterpolate(tab.label)}</button>`);
        });
        _push(`<!--]--></div><div>`);
        if (unref(activeTab) === "basic") {
          _push(ssrRenderComponent(_sfc_main$d, {
            method: __props.method,
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "bank_accounts" && __props.method.type === "bank_transfer") {
          _push(ssrRenderComponent(_sfc_main$b, {
            "payment-method-id": __props.method.id,
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        if (unref(activeTab) === "gateway" && __props.method.type === "payment_gateway") {
          _push(ssrRenderComponent(_sfc_main$7, {
            "payment-method-id": __props.method.id,
            "gateway-code": __props.method.code,
            onSaved: handleSaved
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$6 = _sfc_main$6.setup;
_sfc_main$6.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/components/PaymentMethodDetailModal.vue");
  return _sfc_setup$6 ? _sfc_setup$6(props, ctx) : void 0;
};

const PaymentMethodDetailModalBI2Ymto6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$6
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    const { accessToken } = useAuth();
    useConfirm();
    const loading = ref(false);
    const error = ref(null);
    const paymentMethods = ref([]);
    const showCreateModal = ref(false);
    const showDetailModal = ref(false);
    const editingMethod = ref(null);
    const selectedMethod = ref(null);
    const loadPaymentMethods = async () => {
      try {
        loading.value = true;
        error.value = null;
        const response = await $fetch(
          "/api/admin/settings/payment-methods",
          {
            headers: {
              Authorization: `Bearer ${accessToken.value}`
            }
          }
        );
        if (response.success) {
          paymentMethods.value = response.data;
        } else {
          error.value = "";
        }
      } catch (err) {
        console.error("Error loading payment methods:", err);
        error.value = err.data?.message || "";
      } finally {
        loading.value = false;
      }
    };
    const closeDetailModal = () => {
      selectedMethod.value = null;
      showDetailModal.value = false;
    };
    const closeModal = () => {
      editingMethod.value = null;
      showCreateModal.value = false;
    };
    const handleSaved = () => {
      closeModal();
      closeDetailModal();
      loadPaymentMethods();
    };
    const getTypeName = (type) => {
      const types = {
        bank_transfer: "",
        payment_gateway: "Payment Gateway",
        other: ""
      };
      return types[type] || type;
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}><div class="flex items-center justify-between mb-6"><div><h1 class="text-3xl font-bold"></h1><p class="mt-2 text-gray-600">  </p></div><button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg><span></span></button></div><div class="bg-white rounded-lg shadow overflow-hidden">`);
      if (unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-green-600"></div><p class="mt-2 text-gray-600">...</p></div>`);
      } else if (unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 text-red-700 rounded">${ssrInterpolate(unref(error))}</div>`);
      } else if (unref(paymentMethods).length === 0) {
        _push(`<div class="p-8 text-center text-gray-500">  </div>`);
      } else {
        _push(`<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th><th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><!--[-->`);
        ssrRenderList(unref(paymentMethods), (method) => {
          _push(`<tr class="hover:bg-gray-50"><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(method.code)}</div></td><td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-gray-900">${ssrInterpolate(method.name)}</div>`);
          if (method.description) {
            _push(`<div class="text-sm text-gray-500">${ssrInterpolate(method.description)}</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([{
            "bg-blue-100 text-blue-800": method.type === "bank_transfer",
            "bg-purple-100 text-purple-800": method.type === "payment_gateway",
            "bg-gray-100 text-gray-800": method.type === "other"
          }, "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(getTypeName(method.type))}</span></td><td class="px-6 py-4 whitespace-nowrap"><span class="${ssrRenderClass([method.is_active ? "bg-green-100 text-green-800" : "bg-gray-100 text-gray-800", "px-2 py-1 text-xs font-medium rounded"])}">${ssrInterpolate(method.is_active ? "" : "")}</span></td><td class="px-6 py-4 whitespace-nowrap">`);
          if (method.is_default) {
            _push(`<span class="px-2 py-1 text-xs font-medium bg-yellow-100 text-yellow-800 rounded">  </span>`);
          } else {
            _push(`<span class="text-gray-400">-</span>`);
          }
          _push(`</td><td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium"><div class="flex items-center justify-end space-x-2"><button class="text-green-600 hover:text-green-900" title="/"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg></button><button class="text-blue-600 hover:text-blue-900"${ssrRenderAttr("title", method.is_active ? "" : "")}>`);
          if (method.is_active) {
            _push(`<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"></path></svg>`);
          } else {
            _push(`<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`);
          }
          _push(`</button>`);
          if (!method.is_default) {
            _push(`<button class="text-red-600 hover:text-red-900" title=""><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></td></tr>`);
        });
        _push(`<!--]--></tbody></table>`);
      }
      _push(`</div>`);
      _push(ssrRenderComponent(_sfc_main$e, {
        show: unref(showCreateModal),
        method: unref(editingMethod),
        onClose: closeModal,
        onSaved: handleSaved
      }, null, _parent));
      _push(ssrRenderComponent(_sfc_main$6, {
        show: unref(showDetailModal),
        method: unref(selectedMethod),
        onClose: closeDetailModal,
        onSaved: handleSaved
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$5 = _sfc_main$5.setup;
_sfc_main$5.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/settings/payment-methods/index.vue");
  return _sfc_setup$5 ? _sfc_setup$5(props, ctx) : void 0;
};

const index6MOfGLUy = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$5
}, Symbol.toStringTag, { value: 'Module' }));

const admin = defineNuxtRouteMiddleware(async (to, from) => {
  let __temp, __restore;
  const { isAuthenticated, fetchUser, hasAnyRole } = useAuth();
  if (!isAuthenticated.value) {
    [__temp, __restore] = executeAsync(() => fetchUser()), await __temp, __restore();
    [__temp, __restore] = executeAsync(() => new Promise((resolve) => setTimeout(resolve, 100))), await __temp, __restore();
  }
  if (!isAuthenticated.value) {
    return navigateTo(`/auth/login?redirect=${encodeURIComponent(to.fullPath)}`);
  }
  const { UserRole } = ([__temp, __restore] = executeAsync(() => Promise.resolve().then(function () { return user_types; })), __temp = await __temp, __restore(), __temp);
  const adminRoles = [
    UserRole.SYSTEM_ADMIN,
    UserRole.OWNER,
    UserRole.ADMIN,
    // Admin 
    UserRole.BRANCH_ADMIN,
    UserRole.TUTOR
    // Tutors also use admin layout
  ];
  if (!hasAnyRole(adminRoles)) {
    throw createError({
      statusCode: 403,
      message: "Access denied. Admin role required."
    });
  }
});

const adminCTEb7jtN = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: admin
}, Symbol.toStringTag, { value: 'Module' }));

const auth = defineNuxtRouteMiddleware(async (to, from) => {
  let __temp, __restore;
  const { isAuthenticated, fetchUser } = useAuth();
  if (!isAuthenticated.value) {
    [__temp, __restore] = executeAsync(() => fetchUser()), await __temp, __restore();
  }
  if (!isAuthenticated.value) {
    return navigateTo(`/auth/login?redirect=${encodeURIComponent(to.fullPath)}`);
  }
});

const authDbjuH_U_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: auth
}, Symbol.toStringTag, { value: 'Module' }));

function getRedirectPathByRole(user, redirect) {
  if (redirect) {
    return redirect;
  }
  if (!user || !user.roles || user.roles.length === 0) {
    return "/my-courses";
  }
  if (user.roles.includes(UserRole.SYSTEM_ADMIN) || user.roles.includes(UserRole.OWNER) || user.roles.includes(UserRole.ADMIN) || user.roles.includes(UserRole.BRANCH_ADMIN) || user.roles.includes(UserRole.TUTOR)) {
    return "/admin";
  }
  return "/my-courses";
}
function isAdmin(user) {
  if (!user || !user.roles) return false;
  const adminRoles = [
    UserRole.SYSTEM_ADMIN,
    UserRole.OWNER,
    UserRole.ADMIN,
    UserRole.BRANCH_ADMIN
  ];
  return user.roles.some(
    (role) => adminRoles.includes(role)
  );
}
function isStudentOrParent(user) {
  if (!user || !user.roles) return false;
  const studentRoles = [UserRole.STUDENT, UserRole.PARENT];
  return user.roles.some(
    (role) => studentRoles.includes(role)
  );
}

const authCOdMvhp6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  getRedirectPathByRole: getRedirectPathByRole,
  isAdmin: isAdmin,
  isStudentOrParent: isStudentOrParent
}, Symbol.toStringTag, { value: 'Module' }));

const guest = defineNuxtRouteMiddleware(async (to, from) => {
  let __temp, __restore;
  const { isAuthenticated, fetchUser, user } = useAuth();
  if (!isAuthenticated.value) {
    [__temp, __restore] = executeAsync(() => fetchUser()), await __temp, __restore();
  }
  if (isAuthenticated.value) {
    const redirect = to.query.redirect;
    const redirectPath = getRedirectPathByRole(user.value, redirect);
    return navigateTo(redirectPath);
  }
});

const guestCZSH4cDN = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: guest
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$1 = /* @__PURE__ */ defineComponent({
  __name: "MenuIcon",
  __ssrInlineRender: true,
  props: {
    icon: { default: null },
    class: { default: "w-5 h-5" }
  },
  setup(__props) {
    const props = __props;
    const iconMap = {
      HomeIcon,
      UsersIcon,
      UserGroupIcon,
      UserIcon,
      UserCircleIcon,
      ShieldCheckIcon,
      BuildingOfficeIcon,
      BuildingIcon: BuildingOfficeIcon,
      BookOpenIcon,
      BookIcon: BookOpenIcon,
      ClipboardDocumentCheckIcon,
      ClipboardIcon: ClipboardDocumentCheckIcon,
      CurrencyDollarIcon,
      CurrencyIcon: CurrencyDollarIcon,
      TagIcon,
      ChartBarIcon,
      ChartIcon: ChartBarIcon,
      CogIcon,
      EnvelopeIcon,
      Cog6ToothIcon,
      AcademicCapIcon,
      CalendarIcon,
      MegaphoneIcon,
      ChatBubbleLeftRightIcon,
      NewspaperIcon
    };
    const iconComponent = computed(() => {
      if (!props.icon) return null;
      return iconMap[props.icon] || null;
    });
    const iconClass = computed(() => props.class);
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderVNode(_push, createVNode(resolveDynamicComponent(unref(iconComponent)), mergeProps({ class: unref(iconClass) }, _attrs), null), _parent);
    };
  }
});
const _sfc_setup$1$1 = _sfc_main$1$1.setup;
_sfc_main$1$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/MenuIcon.vue");
  return _sfc_setup$1$1 ? _sfc_setup$1$1(props, ctx) : void 0;
};
const __nuxt_component_1 = Object.assign(_sfc_main$1$1, { __name: "MenuIcon" });
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "admin",
  __ssrInlineRender: true,
  setup(__props) {
    const { user } = useAuth();
    const route = useRoute();
    const sidebarOpen = ref(false);
    const showUserMenu = ref(false);
    const menus = ref([]);
    const loadingMenus = ref(true);
    const menuError = ref(null);
    const expandedMenus = ref({});
    const { unreadCount } = useUnreadMessages();
    const isActive = (href) => {
      if (!href || href === "#") return false;
      if (href === "/admin") {
        return route.path === "/admin";
      }
      return route.path.startsWith(href);
    };
    const isMenuActive = (menu) => {
      if (menu.href && isActive(menu.href)) {
        return true;
      }
      if (menu.children && menu.children.length > 0) {
        return menu.children.some((child) => child.href && isActive(child.href));
      }
      return false;
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      const _component_MenuIcon = __nuxt_component_1;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50" }, _attrs))}><aside class="${ssrRenderClass([
        "fixed inset-y-0 left-0 z-50 w-64 bg-white border-r border-gray-200 transition-transform duration-300 ease-in-out",
        unref(sidebarOpen) ? "translate-x-0" : "-translate-x-full lg:translate-x-0"
      ])}"><div class="flex flex-col h-full"><div class="flex items-center justify-between h-16 px-4 border-b border-gray-200">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/admin",
        class: "flex items-center space-x-2"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<span class="text-xl font-bold text-green-600"${_scopeId}>KDC Admin</span>`);
          } else {
            return [
              createVNode("span", { class: "text-xl font-bold text-green-600" }, "KDC Admin")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<button class="lg:hidden p-2 rounded-lg hover:bg-gray-100"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div><nav class="flex-1 overflow-y-auto py-4 scrollbar-light"><div class="px-3 space-y-1"><!--[-->`);
      ssrRenderList(unref(menus), (menu) => {
        _push(`<!--[-->`);
        if (menu.children && menu.children.length > 0) {
          _push(`<div><button class="${ssrRenderClass([isMenuActive(menu) ? "bg-green-50 text-green-700" : "text-gray-700 hover:bg-gray-100", "w-full flex items-center justify-between px-3 py-2 rounded-lg text-sm font-medium transition-colors"])}"><div class="flex items-center space-x-3">`);
          if (menu.icon) {
            _push(ssrRenderComponent(_component_MenuIcon, {
              icon: menu.icon,
              class: "w-5 h-5"
            }, null, _parent));
          } else {
            _push(`<!---->`);
          }
          _push(`<span>${ssrInterpolate(menu.name)}</span></div><svg class="${ssrRenderClass([{ "rotate-90": unref(expandedMenus)[menu.code] }, "w-4 h-4 transition-transform"])}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button><div class="ml-4 mt-1 space-y-1 border-l-2 border-gray-200 pl-2" style="${ssrRenderStyle(unref(expandedMenus)[menu.code] ? null : { display: "none" })}"><!--[-->`);
          ssrRenderList(menu.children, (child) => {
            _push(ssrRenderComponent(_component_NuxtLink, {
              key: child.code,
              to: child.href || "#",
              class: ["flex items-center space-x-3 px-3 py-2 rounded-lg text-sm font-medium transition-colors", isActive(child.href || "") ? "bg-green-50 text-green-700" : "text-gray-600 hover:bg-gray-100"]
            }, {
              default: withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  if (child.icon) {
                    _push2(ssrRenderComponent(_component_MenuIcon, {
                      icon: child.icon,
                      class: "w-4 h-4"
                    }, null, _parent2, _scopeId));
                  } else {
                    _push2(`<!---->`);
                  }
                  _push2(`<span${_scopeId}>${ssrInterpolate(child.name)}</span>`);
                } else {
                  return [
                    child.icon ? (openBlock(), createBlock(_component_MenuIcon, {
                      key: 0,
                      icon: child.icon,
                      class: "w-4 h-4"
                    }, null, 8, ["icon"])) : createCommentVNode("", true),
                    createVNode("span", null, toDisplayString(child.name), 1)
                  ];
                }
              }),
              _: 2
            }, _parent));
          });
          _push(`<!--]--></div></div>`);
        } else {
          _push(ssrRenderComponent(_component_NuxtLink, {
            to: menu.href || "#",
            class: ["flex items-center justify-between px-3 py-2 rounded-lg text-sm font-medium transition-colors", isActive(menu.href || "") ? "bg-green-50 text-green-700" : "text-gray-700 hover:bg-gray-100"]
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`<div class="flex items-center space-x-3"${_scopeId}>`);
                if (menu.icon) {
                  _push2(ssrRenderComponent(_component_MenuIcon, {
                    icon: menu.icon,
                    class: "w-5 h-5"
                  }, null, _parent2, _scopeId));
                } else {
                  _push2(`<!---->`);
                }
                _push2(`<span${_scopeId}>${ssrInterpolate(menu.name)}</span></div>`);
                if (menu.code === "CHAT" && unref(unreadCount) > 0) {
                  _push2(`<span class="flex items-center justify-center min-w-[20px] h-5 px-1.5 text-xs font-semibold text-white bg-red-500 rounded-full"${_scopeId}>${ssrInterpolate(unref(unreadCount) > 99 ? "99+" : unref(unreadCount))}</span>`);
                } else {
                  _push2(`<!---->`);
                }
              } else {
                return [
                  createVNode("div", { class: "flex items-center space-x-3" }, [
                    menu.icon ? (openBlock(), createBlock(_component_MenuIcon, {
                      key: 0,
                      icon: menu.icon,
                      class: "w-5 h-5"
                    }, null, 8, ["icon"])) : createCommentVNode("", true),
                    createVNode("span", null, toDisplayString(menu.name), 1)
                  ]),
                  menu.code === "CHAT" && unref(unreadCount) > 0 ? (openBlock(), createBlock("span", {
                    key: 0,
                    class: "flex items-center justify-center min-w-[20px] h-5 px-1.5 text-xs font-semibold text-white bg-red-500 rounded-full"
                  }, toDisplayString(unref(unreadCount) > 99 ? "99+" : unref(unreadCount)), 1)) : createCommentVNode("", true)
                ];
              }
            }),
            _: 2
          }, _parent));
        }
        _push(`<!--]-->`);
      });
      _push(`<!--]-->`);
      if (unref(loadingMenus)) {
        _push(`<div class="px-3 py-2 text-sm text-gray-500"> ... </div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(menuError)) {
        _push(`<div class="px-3 py-2 text-sm text-red-500">${ssrInterpolate(unref(menuError))}</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></nav><div class="p-4 border-t border-gray-200"><div class="flex items-center space-x-3"><div class="h-10 w-10 rounded-full bg-green-500 flex items-center justify-center text-white font-semibold">${ssrInterpolate(unref(user)?.first_name?.[0] || "A")}</div><div class="flex-1 min-w-0"><p class="text-sm font-medium text-gray-900 truncate">${ssrInterpolate(unref(user)?.first_name)} ${ssrInterpolate(unref(user)?.last_name)}</p><p class="text-xs text-gray-500 truncate">${ssrInterpolate(unref(user)?.email)}</p></div></div></div></div></aside>`);
      if (unref(sidebarOpen)) {
        _push(`<div class="fixed inset-0 bg-black bg-opacity-50 z-40 lg:hidden"></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="lg:pl-64"><header class="sticky top-0 z-30 bg-white border-b border-gray-200"><div class="flex items-center justify-between h-16 px-4"><button class="lg:hidden p-2 rounded-lg hover:bg-gray-100"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button><div class="flex-1 flex items-center justify-end space-x-4"><div class="hidden md:block relative"><input type="text" placeholder="..." class="pl-10 pr-4 py-2 w-64 border border-gray-300 rounded-lg bg-white text-gray-900 focus:outline-none focus:ring-2 focus:ring-green-500"><svg class="absolute left-3 top-2.5 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></div><button class="relative p-2 text-gray-700 hover:bg-gray-100 rounded-lg"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path></svg><span class="absolute top-1 right-1 block h-2 w-2 rounded-full bg-red-500"></span></button><div class="relative"><button class="flex items-center space-x-2 p-2 rounded-lg hover:bg-gray-100"><div class="h-8 w-8 rounded-full bg-green-500 flex items-center justify-center text-white font-semibold">${ssrInterpolate(unref(user)?.first_name?.[0] || "A")}</div></button>`);
      if (unref(showUserMenu)) {
        _push(`<div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border border-gray-200 py-2 z-50">`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/admin/profile",
          class: "block px-4 py-2 text-sm text-green-600 hover:bg-gray-100 hover:text-green-700",
          onClick: ($event) => showUserMenu.value = false
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/",
          class: "block px-4 py-2 text-sm text-green-600 hover:bg-gray-100 hover:text-green-700",
          onClick: ($event) => showUserMenu.value = false
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<hr class="my-2 border-gray-200"><button class="block w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-gray-100">  </button></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div></div></header><main class="p-6">`);
      ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</main><footer class="bg-white border-t border-gray-200 py-6 mt-auto"><div class="container mx-auto px-4"><div class="flex items-center justify-center"><p class="text-sm text-gray-600">  2024 KDC Tutor School.  </p></div></div></footer></div></div>`);
    };
  }
});
const _sfc_setup$4 = _sfc_main$4.setup;
_sfc_main$4.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("layouts/admin.vue");
  return _sfc_setup$4 ? _sfc_setup$4(props, ctx) : void 0;
};

const adminC7VZ2CY_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$4
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "chat",
  __ssrInlineRender: true,
  setup(__props) {
    const { user, hasAnyRole } = useAuth();
    const showUserMenu = ref(false);
    const backUrl = computed(() => {
      if (hasAnyRole(["tutor", "system_admin", "owner", "admin", "branch_admin"])) {
        return "/admin";
      }
      return "/my-courses";
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50" }, _attrs))}><header class="bg-white border-b border-gray-200 shadow-sm sticky top-0 z-50"><div class="container mx-auto px-4"><div class="flex items-center justify-between h-16"><div class="flex items-center space-x-4">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: unref(backUrl),
        class: "flex items-center space-x-2 text-gray-700 hover:text-green-600 transition-colors",
        title: unref(backUrl) === "/admin" ? " Admin Dashboard" : ""
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"${_scopeId}></path></svg><span class="font-medium"${_scopeId}></span>`);
          } else {
            return [
              (openBlock(), createBlock("svg", {
                class: "w-5 h-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M10 19l-7-7m0 0l7-7m-7 7h18"
                })
              ])),
              createVNode("span", { class: "font-medium" }, "")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: unref(backUrl),
        class: "text-xl font-bold text-green-600"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(` KDC School `);
          } else {
            return [
              createTextVNode(" KDC School ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div><div class="flex items-center space-x-4">`);
      if (unref(backUrl) === "/my-courses") {
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/my-courses",
          class: "text-gray-700 hover:text-green-600 font-medium"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/admin",
          class: "text-gray-700 hover:text-green-600 font-medium"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(` Dashboard `);
            } else {
              return [
                createTextVNode(" Dashboard ")
              ];
            }
          }),
          _: 1
        }, _parent));
      }
      _push(`<div class="relative"><button class="flex items-center space-x-2 p-2 rounded-lg hover:bg-gray-100"><div class="h-8 w-8 rounded-full bg-green-500 flex items-center justify-center text-white font-semibold">${ssrInterpolate(unref(user)?.first_name?.[0] || "U")}</div><span class="hidden md:block text-gray-700">${ssrInterpolate(unref(user)?.first_name)} ${ssrInterpolate(unref(user)?.last_name)}</span></button>`);
      if (unref(showUserMenu)) {
        _push(`<div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border border-gray-200 py-2 z-50">`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/profile",
          class: "block px-4 py-2 text-gray-700 hover:bg-gray-100",
          onClick: ($event) => showUserMenu.value = false
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<button class="block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">  </button></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div></div></div></header><main class="h-[calc(100vh-4rem)] overflow-hidden">`);
      ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</main></div>`);
    };
  }
});
const _sfc_setup$3 = _sfc_main$3.setup;
_sfc_main$3.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("layouts/chat.vue");
  return _sfc_setup$3 ? _sfc_setup$3(props, ctx) : void 0;
};

const chatDEZCJvs0 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$3
}, Symbol.toStringTag, { value: 'Module' }));

const translations = {
  th: {
    app: { name: "KDC Tutor School" },
    nav: { courses: "", login: "", register: "", dashboard: "" },
    home: {
      hero: {
        title: " ",
        subtitle: " Live e-Learning  Video on Demand",
        viewCourses: "",
        register: ""
      },
      features: {
        title: "",
        live: "Live e-Learning",
        liveDesc: "",
        vod: "Video on Demand",
        vodDesc: " 24 ",
        materials: "",
        materialsDesc: " Kerry Express"
      }
    },
    error: { goHome: "" },
    footer: { allRightsReserved: "" }
  },
  en: {
    app: { name: "KDC Tutor School" },
    nav: { courses: "Courses", login: "Login", register: "Register", dashboard: "Dashboard" },
    home: {
      hero: {
        title: "Learn Online Anytime, Anywhere",
        subtitle: "With Live e-Learning and Video on Demand",
        viewCourses: "View All Courses",
        register: "Register"
      },
      features: {
        title: "Why Choose Us",
        live: "Live e-Learning",
        liveDesc: "Learn live online with teachers",
        vod: "Video on Demand",
        vodDesc: "Watch recordings for 24 hours",
        materials: "Material Delivery",
        materialsDesc: "Materials delivered via Kerry Express"
      }
    },
    error: { goHome: "Go Home" },
    footer: { allRightsReserved: "All Rights Reserved" }
  }
};
const useI18n = () => {
  const locale = useState("i18n.locale", () => "th");
  const t = (key, params) => {
    const keys = key.split(".");
    let value = translations[locale.value] || translations.th;
    for (const k of keys) {
      value = value?.[k];
      if (value === void 0) {
        console.warn(`Translation key "${key}" not found for locale "${locale.value}"`);
        return key;
      }
    }
    if (typeof value !== "string") {
      return key;
    }
    if (params) {
      return Object.entries(params).reduce(
        (str, [param, val]) => str.replace(`{${param}}`, val),
        value
      );
    }
    return value;
  };
  const setLocale = (newLocale) => {
    if (translations[newLocale]) {
      locale.value = newLocale;
    }
  };
  return {
    locale: readonly(locale),
    t,
    setLocale
  };
};
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "default",
  __ssrInlineRender: true,
  setup(__props) {
    const { locale, t } = useI18n();
    const currentLocale = computed(() => locale.value);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50" }, _attrs))}><header class="bg-white shadow-sm"><nav class="container mx-auto px-4 py-4"><div class="flex items-center justify-between">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/",
        class: "text-2xl font-bold text-primary-blue"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`${ssrInterpolate(unref(t)("app.name"))}`);
          } else {
            return [
              createTextVNode(toDisplayString(unref(t)("app.name")), 1)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<div class="flex items-center gap-4">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/courses",
        class: "text-gray-700 hover:text-primary-blue"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`${ssrInterpolate(unref(t)("nav.courses"))}`);
          } else {
            return [
              createTextVNode(toDisplayString(unref(t)("nav.courses")), 1)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/auth/login",
        class: "text-gray-700 hover:text-primary-blue"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`${ssrInterpolate(unref(t)("nav.login"))}`);
          } else {
            return [
              createTextVNode(toDisplayString(unref(t)("nav.login")), 1)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<button class="px-3 py-1 text-sm bg-gray-100 rounded hover:bg-gray-200">${ssrInterpolate(unref(currentLocale) === "th" ? "EN" : "TH")}</button></div></div></nav></header><main>`);
      ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</main><footer class="bg-gray-800 text-white mt-auto py-8"><div class="container mx-auto px-4 text-center"><p> 2024 KDC Tutor School. ${ssrInterpolate(unref(t)("footer.allRightsReserved"))}</p></div></footer></div>`);
    };
  }
});
const _sfc_setup$2 = _sfc_main$2.setup;
_sfc_main$2.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("layouts/default.vue");
  return _sfc_setup$2 ? _sfc_setup$2(props, ctx) : void 0;
};

const defaultDK77MwgI = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$2
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "homepage",
  __ssrInlineRender: true,
  setup(__props) {
    const { isAuthenticated, user } = useAuth();
    const showUserMenu = ref(false);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-white" }, _attrs))}><header class="sticky top-0 z-50 bg-white border-b border-gray-200 shadow-sm"><nav class="container mx-auto px-4"><div class="flex items-center justify-between h-16">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/",
        class: "flex items-center space-x-2"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<span class="text-2xl font-bold text-green-600"${_scopeId}>KDC School</span>`);
          } else {
            return [
              createVNode("span", { class: "text-2xl font-bold text-green-600" }, "KDC School")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<div class="hidden md:flex items-center space-x-6">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/courses",
        class: "text-gray-700 hover:text-green-600 transition-colors"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/courses?level=elementary",
        class: "text-gray-700 hover:text-green-600 transition-colors"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/courses?level=secondary",
        class: "text-gray-700 hover:text-green-600 transition-colors"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/about",
        class: "text-gray-700 hover:text-green-600 transition-colors"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  `);
          } else {
            return [
              createTextVNode("  ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div><div class="flex items-center space-x-4"><div class="hidden md:block relative"><input type="text" placeholder="" class="pl-10 pr-4 py-2 w-64 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-gray-900 placeholder-gray-400"><svg class="absolute left-3 top-2.5 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></div>`);
      if (unref(isAuthenticated)) {
        _push(`<!--[-->`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/my-courses",
          class: "text-gray-700 hover:text-green-600 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<button class="relative p-2 text-gray-700 hover:text-green-600"><svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path></svg><span class="absolute top-0 right-0 block h-2 w-2 rounded-full bg-red-500"></span></button><div class="relative"><button class="flex items-center space-x-2 p-2 rounded-lg hover:bg-gray-100"><div class="h-8 w-8 rounded-full bg-green-500 flex items-center justify-center text-white font-semibold">${ssrInterpolate(unref(user)?.first_name?.[0] || "U")}</div></button>`);
        if (unref(showUserMenu)) {
          _push(`<div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border border-gray-200 py-2">`);
          _push(ssrRenderComponent(_component_NuxtLink, {
            to: "/profile",
            class: "block px-4 py-2 text-gray-700 hover:bg-gray-100",
            onClick: ($event) => showUserMenu.value = false
          }, {
            default: withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  `);
              } else {
                return [
                  createTextVNode("  ")
                ];
              }
            }),
            _: 1
          }, _parent));
          _push(`<button class="block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">  </button></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><!--]-->`);
      } else {
        _push(`<!--[-->`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/auth/login",
          class: "px-4 py-2 text-gray-700 hover:text-green-600 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/auth/register",
          class: "px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<!--]-->`);
      }
      _push(`</div></div></nav></header><main>`);
      ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</main><footer class="bg-gray-900 text-white py-12 mt-20"><div class="container mx-auto px-4"><div class="grid md:grid-cols-4 gap-8"><div><h3 class="text-xl font-bold mb-4">KDC School</h3><p class="text-gray-400">   </p></div><div><h4 class="font-semibold mb-4"></h4><ul class="space-y-2 text-gray-400"><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/about",
        class: "hover:text-white"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(``);
          } else {
            return [
              createTextVNode("")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/contact",
        class: "hover:text-white"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(``);
          } else {
            return [
              createTextVNode("")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/careers",
        class: "hover:text-white"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(``);
          } else {
            return [
              createTextVNode("")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li></ul></div><div><h4 class="font-semibold mb-4"></h4><ul class="space-y-2 text-gray-400"><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/help",
        class: "hover:text-white"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(``);
          } else {
            return [
              createTextVNode("")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/support",
        class: "hover:text-white"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(``);
          } else {
            return [
              createTextVNode("")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li></ul></div><div><h4 class="font-semibold mb-4"></h4><div class="flex space-x-4"><a href="#" class="text-gray-400 hover:text-white">Facebook</a><a href="#" class="text-gray-400 hover:text-white">Line</a><a href="#" class="text-gray-400 hover:text-white">YouTube</a></div></div></div><div class="border-t border-gray-800 mt-8 pt-8 text-center text-gray-400"><p> 2024 KDC School. </p></div></div></footer></div>`);
    };
  }
});
const _sfc_setup$1 = _sfc_main$1.setup;
_sfc_main$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("layouts/homepage.vue");
  return _sfc_setup$1 ? _sfc_setup$1(props, ctx) : void 0;
};

const homepageBUzDIIY1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$1
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "student",
  __ssrInlineRender: true,
  setup(__props) {
    const { user } = useAuth();
    const { unreadCount } = useUnreadMessages();
    const showUserMenu = ref(false);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$b;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "min-h-screen bg-gray-50" }, _attrs))}><header class="bg-white border-b border-gray-200 shadow-sm sticky top-0 z-50"><div class="container mx-auto px-4"><div class="flex items-center justify-between h-16">`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/",
        class: "text-xl font-bold text-green-600"
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(` KDC School `);
          } else {
            return [
              createTextVNode(" KDC School ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<div class="flex items-center space-x-4"><button class="relative p-2 text-gray-700 hover:text-green-600"><svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path></svg><span class="absolute top-1 right-1 block h-2 w-2 rounded-full bg-red-500"></span></button><div class="relative"><button class="flex items-center space-x-2 p-2 rounded-lg hover:bg-gray-100"><div class="h-8 w-8 rounded-full bg-green-500 flex items-center justify-center text-white font-semibold">${ssrInterpolate(unref(user)?.first_name?.[0] || "U")}</div><span class="hidden md:block text-gray-700">${ssrInterpolate(unref(user)?.first_name)} ${ssrInterpolate(unref(user)?.last_name)}</span></button>`);
      if (unref(showUserMenu)) {
        _push(`<div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border border-gray-200 py-2">`);
        _push(ssrRenderComponent(_component_NuxtLink, {
          to: "/profile",
          class: "block px-4 py-2 text-gray-700 hover:bg-gray-100",
          onClick: ($event) => showUserMenu.value = false
        }, {
          default: withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  `);
            } else {
              return [
                createTextVNode("  ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<button class="block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">  </button></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div></div></div></header><div class="flex"><aside class="w-64 bg-white border-r border-gray-200 min-h-[calc(100vh-4rem)] sticky top-16"><nav class="p-4"><div class="mb-6"><h2 class="text-sm font-semibold text-gray-500 uppercase mb-2"></h2><ul class="space-y-1"><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/my-courses",
        class: ["flex items-center space-x-3 px-3 py-2 rounded-lg transition-colors", _ctx.$route.path === "/my-courses" ? "bg-green-50 text-green-700" : "text-gray-700 hover:bg-gray-100"]
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"${_scopeId}></path></svg><span${_scopeId}></span>`);
          } else {
            return [
              (openBlock(), createBlock("svg", {
                class: "h-5 w-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                })
              ])),
              createVNode("span", null, "")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/chat",
        class: ["flex items-center justify-between px-3 py-2 rounded-lg transition-colors", _ctx.$route.path.startsWith("/chat") ? "bg-green-50 text-green-700" : "text-gray-700 hover:bg-gray-100"]
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="flex items-center space-x-3"${_scopeId}><svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"${_scopeId}></path></svg><span${_scopeId}></span></div>`);
            if (unref(unreadCount) > 0) {
              _push2(`<span class="flex items-center justify-center min-w-[20px] h-5 px-1.5 text-xs font-semibold text-white bg-red-500 rounded-full"${_scopeId}>${ssrInterpolate(unref(unreadCount) > 99 ? "99+" : unref(unreadCount))}</span>`);
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              createVNode("div", { class: "flex items-center space-x-3" }, [
                (openBlock(), createBlock("svg", {
                  class: "h-5 w-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"
                  })
                ])),
                createVNode("span", null, "")
              ]),
              unref(unreadCount) > 0 ? (openBlock(), createBlock("span", {
                key: 0,
                class: "flex items-center justify-center min-w-[20px] h-5 px-1.5 text-xs font-semibold text-white bg-red-500 rounded-full"
              }, toDisplayString(unref(unreadCount) > 99 ? "99+" : unref(unreadCount)), 1)) : createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li></ul></div><div><h2 class="text-sm font-semibold text-gray-500 uppercase mb-2"></h2><ul class="space-y-1"><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/profile",
        class: ["flex items-center space-x-3 px-3 py-2 rounded-lg transition-colors", _ctx.$route.path === "/profile" ? "bg-green-50 text-green-700" : "text-gray-700 hover:bg-gray-100"]
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"${_scopeId}></path></svg><span${_scopeId}></span>`);
          } else {
            return [
              (openBlock(), createBlock("svg", {
                class: "h-5 w-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"
                })
              ])),
              createVNode("span", null, "")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li><li>`);
      _push(ssrRenderComponent(_component_NuxtLink, {
        to: "/payment-history",
        class: ["flex items-center space-x-3 px-3 py-2 rounded-lg transition-colors", _ctx.$route.path === "/payment-history" ? "bg-green-50 text-green-700" : "text-gray-700 hover:bg-gray-100"]
      }, {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"${_scopeId}></path></svg><span${_scopeId}></span>`);
          } else {
            return [
              (openBlock(), createBlock("svg", {
                class: "h-5 w-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                })
              ])),
              createVNode("span", null, "")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</li></ul></div></nav></aside><main class="flex-1 p-6">`);
      ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</main></div></div>`);
    };
  }
});
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("layouts/student.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};

const studentCM_re3zP = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main
}, Symbol.toStringTag, { value: 'Module' }));

const help_vue_vue_type_style_index_0_scoped_bedacc18_lang = ".prose[data-v-bedacc18]{color:#374151;line-height:1.75}.prose h1[data-v-bedacc18]{font-size:2.25em;font-weight:700;margin-bottom:.8888889em;margin-top:0}.prose h2[data-v-bedacc18]{font-size:1.5em;font-weight:600;margin-bottom:1em;margin-top:2em}.prose p[data-v-bedacc18]{margin-bottom:1.25em;margin-top:1.25em}.prose a[data-v-bedacc18]{color:#059669;text-decoration:underline}.prose a[data-v-bedacc18]:hover{color:#047857}.prose strong[data-v-bedacc18]{font-weight:600}.prose ol[data-v-bedacc18],.prose ul[data-v-bedacc18]{margin-bottom:1.25em;margin-top:1.25em;padding-left:1.625em}.prose li[data-v-bedacc18]{margin-bottom:.5em;margin-top:.5em}";

const helpStyles_BcLrZ3bp = [
  help_vue_vue_type_style_index_0_scoped_bedacc18_lang
];

const helpStyles_BcLrZ3bp$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: helpStyles_BcLrZ3bp
}, Symbol.toStringTag, { value: 'Module' }));

const careers_vue_vue_type_style_index_0_scoped_c92df7ab_lang = ".prose[data-v-c92df7ab]{color:#374151;line-height:1.75}.prose h1[data-v-c92df7ab]{font-size:2.25em;font-weight:700;margin-bottom:.8888889em;margin-top:0}.prose h2[data-v-c92df7ab]{font-size:1.5em;font-weight:600;margin-bottom:1em;margin-top:2em}.prose p[data-v-c92df7ab]{margin-bottom:1.25em;margin-top:1.25em}.prose a[data-v-c92df7ab]{color:#059669;text-decoration:underline}.prose a[data-v-c92df7ab]:hover{color:#047857}.prose strong[data-v-c92df7ab]{font-weight:600}.prose ol[data-v-c92df7ab],.prose ul[data-v-c92df7ab]{margin-bottom:1.25em;margin-top:1.25em;padding-left:1.625em}.prose li[data-v-c92df7ab]{margin-bottom:.5em;margin-top:.5em}";

const careersStyles_CgGOGSI = [
  careers_vue_vue_type_style_index_0_scoped_c92df7ab_lang
];

const careersStyles_CgGOGSI$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: careersStyles_CgGOGSI
}, Symbol.toStringTag, { value: 'Module' }));

const about_vue_vue_type_style_index_0_scoped_fd54481d_lang = ".prose[data-v-fd54481d]{color:#374151;line-height:1.75}.prose h1[data-v-fd54481d]{font-size:2.25em;font-weight:700;margin-bottom:.8888889em;margin-top:0}.prose h2[data-v-fd54481d]{font-size:1.5em;font-weight:600;margin-bottom:1em;margin-top:2em}.prose p[data-v-fd54481d]{margin-bottom:1.25em;margin-top:1.25em}.prose a[data-v-fd54481d]{color:#059669;text-decoration:underline}.prose a[data-v-fd54481d]:hover{color:#047857}.prose strong[data-v-fd54481d]{font-weight:600}.prose ol[data-v-fd54481d],.prose ul[data-v-fd54481d]{margin-bottom:1.25em;margin-top:1.25em;padding-left:1.625em}.prose li[data-v-fd54481d]{margin-bottom:.5em;margin-top:.5em}";

const aboutStyles_DL8U3_Ex = [
  about_vue_vue_type_style_index_0_scoped_fd54481d_lang
];

const aboutStyles_DL8U3_Ex$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: aboutStyles_DL8U3_Ex
}, Symbol.toStringTag, { value: 'Module' }));

const support_vue_vue_type_style_index_0_scoped_5dfe78b0_lang = ".prose[data-v-5dfe78b0]{color:#374151;line-height:1.75}.prose h1[data-v-5dfe78b0]{font-size:2.25em;font-weight:700;margin-bottom:.8888889em;margin-top:0}.prose h2[data-v-5dfe78b0]{font-size:1.5em;font-weight:600;margin-bottom:1em;margin-top:2em}.prose p[data-v-5dfe78b0]{margin-bottom:1.25em;margin-top:1.25em}.prose a[data-v-5dfe78b0]{color:#059669;text-decoration:underline}.prose a[data-v-5dfe78b0]:hover{color:#047857}.prose strong[data-v-5dfe78b0]{font-weight:600}.prose ol[data-v-5dfe78b0],.prose ul[data-v-5dfe78b0]{margin-bottom:1.25em;margin-top:1.25em;padding-left:1.625em}.prose li[data-v-5dfe78b0]{margin-bottom:.5em;margin-top:.5em}";

const supportStyles_CkYFZ4n = [
  support_vue_vue_type_style_index_0_scoped_5dfe78b0_lang
];

const supportStyles_CkYFZ4n$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: supportStyles_CkYFZ4n
}, Symbol.toStringTag, { value: 'Module' }));

const contact_vue_vue_type_style_index_0_scoped_db1b781d_lang = ".prose[data-v-db1b781d]{color:#374151;line-height:1.75}.prose h1[data-v-db1b781d]{font-size:2.25em;font-weight:700;margin-bottom:.8888889em;margin-top:0}.prose h2[data-v-db1b781d]{font-size:1.5em;font-weight:600;margin-bottom:1em;margin-top:2em}.prose p[data-v-db1b781d]{margin-bottom:1.25em;margin-top:1.25em}.prose a[data-v-db1b781d]{color:#059669;text-decoration:underline}.prose a[data-v-db1b781d]:hover{color:#047857}.prose strong[data-v-db1b781d]{font-weight:600}.prose ol[data-v-db1b781d],.prose ul[data-v-db1b781d]{margin-bottom:1.25em;margin-top:1.25em;padding-left:1.625em}.prose li[data-v-db1b781d]{margin-bottom:.5em;margin-top:.5em}";

const contactStyles_DlMtaC4v = [
  contact_vue_vue_type_style_index_0_scoped_db1b781d_lang
];

const contactStyles_DlMtaC4v$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: contactStyles_DlMtaC4v
}, Symbol.toStringTag, { value: 'Module' }));

const index_vue_vue_type_style_index_0_scoped_fe7937e4_lang = ".line-clamp-2[data-v-fe7937e4]{-webkit-line-clamp:2}.line-clamp-2[data-v-fe7937e4],.line-clamp-3[data-v-fe7937e4]{display:-webkit-box;-webkit-box-orient:vertical;overflow:hidden}.line-clamp-3[data-v-fe7937e4]{-webkit-line-clamp:3}";

const indexStyles_DUruTEgV = [
  index_vue_vue_type_style_index_0_scoped_fe7937e4_lang
];

const indexStyles_DUruTEgV$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: indexStyles_DUruTEgV
}, Symbol.toStringTag, { value: 'Module' }));

const _slug__vue_vue_type_style_index_0_scoped_eb0d7bd9_lang = "[data-v-eb0d7bd9] .prose h2{font-size:1.5rem;font-weight:700;line-height:2rem;margin-bottom:1rem;margin-top:2rem;--tw-text-opacity:1;color:rgb(17 24 39/var(--tw-text-opacity,1))}[data-v-eb0d7bd9] .prose h3{font-size:1.25rem;font-weight:600;line-height:1.75rem;margin-bottom:.75rem;margin-top:1.5rem;--tw-text-opacity:1;color:rgb(31 41 55/var(--tw-text-opacity,1))}[data-v-eb0d7bd9] .prose p{line-height:1.625;margin-bottom:1rem;--tw-text-opacity:1;color:rgb(55 65 81/var(--tw-text-opacity,1))}[data-v-eb0d7bd9] .prose ul{list-style-position:inside;list-style-type:disc;margin-bottom:1rem}[data-v-eb0d7bd9] .prose ul>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-bottom:calc(.5rem*var(--tw-space-y-reverse));margin-top:calc(.5rem*(1 - var(--tw-space-y-reverse)))}[data-v-eb0d7bd9] .prose ol{list-style-position:inside;list-style-type:decimal;margin-bottom:1rem}[data-v-eb0d7bd9] .prose ol>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-bottom:calc(.5rem*var(--tw-space-y-reverse));margin-top:calc(.5rem*(1 - var(--tw-space-y-reverse)))}[data-v-eb0d7bd9] .prose li{--tw-text-opacity:1;color:rgb(55 65 81/var(--tw-text-opacity,1))}[data-v-eb0d7bd9] .prose strong{font-weight:600;--tw-text-opacity:1;color:rgb(17 24 39/var(--tw-text-opacity,1))}";

const _slug_Styles_BI_vgQG4 = [
  _slug__vue_vue_type_style_index_0_scoped_eb0d7bd9_lang
];

const _slug_Styles_BI_vgQG4$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _slug_Styles_BI_vgQG4
}, Symbol.toStringTag, { value: 'Module' }));

const RichTextEditor_vue_vue_type_style_index_0_lang = ".rich-text-editor .ProseMirror{min-height:300px;outline:none}.rich-text-editor .ProseMirror p{margin-bottom:1rem}.rich-text-editor .ProseMirror img{border-radius:.5rem;height:auto;margin:1rem 0;max-width:100%}.rich-text-editor .ProseMirror h1{font-size:2em;font-weight:700;margin-bottom:.5rem;margin-top:1rem}.rich-text-editor .ProseMirror h2{font-size:1.5em;font-weight:700;margin-bottom:.5rem;margin-top:1rem}.rich-text-editor .ProseMirror h3{font-size:1.25em;font-weight:700;margin-bottom:.5rem;margin-top:1rem}.rich-text-editor .ProseMirror ol,.rich-text-editor .ProseMirror ul{margin-bottom:1rem;padding-left:1.5rem}.rich-text-editor .ProseMirror ul{list-style-type:disc}.rich-text-editor .ProseMirror ol{list-style-type:decimal}.rich-text-editor .ProseMirror a{color:#059669;text-decoration:underline}.rich-text-editor .ProseMirror a:hover{color:#047857}";

const RichTextEditorStyles_CpqYpIg_ = [
  RichTextEditor_vue_vue_type_style_index_0_lang
];

const RichTextEditorStyles_CpqYpIg_$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: RichTextEditorStyles_CpqYpIg_
}, Symbol.toStringTag, { value: 'Module' }));

const TokenExpirationDialog_vue_vue_type_style_index_0_scoped_99d8e1cf_lang = ".modal-enter-active[data-v-99d8e1cf],.modal-leave-active[data-v-99d8e1cf]{transition:opacity .3s ease}.modal-enter-active .bg-white[data-v-99d8e1cf],.modal-leave-active .bg-white[data-v-99d8e1cf]{transition:transform .3s ease}.modal-enter-from[data-v-99d8e1cf],.modal-leave-to[data-v-99d8e1cf]{opacity:0}.modal-enter-from .bg-white[data-v-99d8e1cf],.modal-leave-to .bg-white[data-v-99d8e1cf]{transform:scale(.95)}";

const TokenExpirationDialogStyles_BXl98F4N = [
  TokenExpirationDialog_vue_vue_type_style_index_0_scoped_99d8e1cf_lang
];

const TokenExpirationDialogStyles_BXl98F4N$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: TokenExpirationDialogStyles_BXl98F4N
}, Symbol.toStringTag, { value: 'Module' }));

const ConfirmModal_vue_vue_type_style_index_0_scoped_701507a9_lang = ".modal-enter-active[data-v-701507a9],.modal-leave-active[data-v-701507a9]{transition:opacity .3s ease}.modal-enter-active .bg-white[data-v-701507a9],.modal-leave-active .bg-white[data-v-701507a9]{transition:transform .3s ease}.modal-enter-from[data-v-701507a9],.modal-leave-to[data-v-701507a9]{opacity:0}.modal-enter-from .bg-white[data-v-701507a9],.modal-leave-to .bg-white[data-v-701507a9]{transform:scale(.95)}";

const ConfirmModalStyles_BGWJYiPN = [
  ConfirmModal_vue_vue_type_style_index_0_scoped_701507a9_lang
];

const ConfirmModalStyles_BGWJYiPN$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: ConfirmModalStyles_BGWJYiPN
}, Symbol.toStringTag, { value: 'Module' }));

const ChatInput_vue_vue_type_style_index_0_scoped_c9b7ef97_lang = ".fade-enter-active[data-v-c9b7ef97],.fade-leave-active[data-v-c9b7ef97]{transition:opacity .2s}.fade-enter-from[data-v-c9b7ef97],.fade-leave-to[data-v-c9b7ef97]{opacity:0}";

const ChatInputStyles_CiuAWLX = [
  ChatInput_vue_vue_type_style_index_0_scoped_c9b7ef97_lang
];

const ChatInputStyles_CiuAWLX$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: ChatInputStyles_CiuAWLX
}, Symbol.toStringTag, { value: 'Module' }));

export { nodeServer as default };
//# sourceMappingURL=index.mjs.map
